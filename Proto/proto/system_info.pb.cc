// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info.proto

#include "system_info.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
namespace system_info {
PROTOBUF_CONSTEXPR Computer::Computer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workgroup_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uptime_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ComputerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComputerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComputerDefaultTypeInternal() {}
  union {
    Computer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComputerDefaultTypeInternal _Computer_default_instance_;
PROTOBUF_CONSTEXPR OperatingSystem::OperatingSystem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.arch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.install_date_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperatingSystemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperatingSystemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperatingSystemDefaultTypeInternal() {}
  union {
    OperatingSystem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperatingSystemDefaultTypeInternal _OperatingSystem_default_instance_;
PROTOBUF_CONSTEXPR Motherboard::Motherboard(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.manufacturer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MotherboardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MotherboardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MotherboardDefaultTypeInternal() {}
  union {
    Motherboard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MotherboardDefaultTypeInternal _Motherboard_default_instance_;
PROTOBUF_CONSTEXPR Bios::Bios(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BiosDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BiosDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BiosDefaultTypeInternal() {}
  union {
    Bios _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BiosDefaultTypeInternal _Bios_default_instance_;
PROTOBUF_CONSTEXPR Processor::Processor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.packages_)*/0u
  , /*decltype(_impl_.cores_)*/0u
  , /*decltype(_impl_.threads_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessorDefaultTypeInternal() {}
  union {
    Processor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessorDefaultTypeInternal _Processor_default_instance_;
PROTOBUF_CONSTEXPR Memory_Module::Memory_Module(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacturer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.form_factor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.part_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.present_)*/false
  , /*decltype(_impl_.speed_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Memory_ModuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Memory_ModuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Memory_ModuleDefaultTypeInternal() {}
  union {
    Memory_Module _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Memory_ModuleDefaultTypeInternal _Memory_Module_default_instance_;
PROTOBUF_CONSTEXPR Memory::Memory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.module_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemoryDefaultTypeInternal() {}
  union {
    Memory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemoryDefaultTypeInternal _Memory_default_instance_;
PROTOBUF_CONSTEXPR LogicalDrives_Drive::LogicalDrives_Drive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_system_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.total_size_)*/uint64_t{0u}
  , /*decltype(_impl_.free_size_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogicalDrives_DriveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalDrives_DriveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalDrives_DriveDefaultTypeInternal() {}
  union {
    LogicalDrives_Drive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalDrives_DriveDefaultTypeInternal _LogicalDrives_Drive_default_instance_;
PROTOBUF_CONSTEXPR LogicalDrives::LogicalDrives(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.drive_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogicalDrivesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalDrivesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalDrivesDefaultTypeInternal() {}
  union {
    LogicalDrives _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalDrivesDefaultTypeInternal _LogicalDrives_default_instance_;
PROTOBUF_CONSTEXPR Printers_Printer::Printers_Printer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.share_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default__)*/false
  , /*decltype(_impl_.shared_)*/false
  , /*decltype(_impl_.jobs_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Printers_PrinterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Printers_PrinterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Printers_PrinterDefaultTypeInternal() {}
  union {
    Printers_Printer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Printers_PrinterDefaultTypeInternal _Printers_Printer_default_instance_;
PROTOBUF_CONSTEXPR Printers::Printers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.printer_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PrintersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrintersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrintersDefaultTypeInternal() {}
  union {
    Printers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrintersDefaultTypeInternal _Printers_default_instance_;
PROTOBUF_CONSTEXPR NetworkAdapters_Adapter_Address::NetworkAdapters_Adapter_Address(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mask_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkAdapters_Adapter_AddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkAdapters_Adapter_AddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkAdapters_Adapter_AddressDefaultTypeInternal() {}
  union {
    NetworkAdapters_Adapter_Address _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkAdapters_Adapter_AddressDefaultTypeInternal _NetworkAdapters_Adapter_Address_default_instance_;
PROTOBUF_CONSTEXPR NetworkAdapters_Adapter::NetworkAdapters_Adapter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gateway_)*/{}
  , /*decltype(_impl_.address_)*/{}
  , /*decltype(_impl_.dns_)*/{}
  , /*decltype(_impl_.dhcp_)*/{}
  , /*decltype(_impl_.adapter_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.speed_)*/uint64_t{0u}
  , /*decltype(_impl_.dhcp_enabled_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkAdapters_AdapterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkAdapters_AdapterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkAdapters_AdapterDefaultTypeInternal() {}
  union {
    NetworkAdapters_Adapter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkAdapters_AdapterDefaultTypeInternal _NetworkAdapters_Adapter_default_instance_;
PROTOBUF_CONSTEXPR NetworkAdapters::NetworkAdapters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.adapter_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkAdaptersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkAdaptersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkAdaptersDefaultTypeInternal() {}
  union {
    NetworkAdapters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkAdaptersDefaultTypeInternal _NetworkAdapters_default_instance_;
PROTOBUF_CONSTEXPR NetworkShares_Share::NetworkShares_Share(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.local_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.current_uses_)*/0u
  , /*decltype(_impl_.max_uses_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkShares_ShareDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkShares_ShareDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkShares_ShareDefaultTypeInternal() {}
  union {
    NetworkShares_Share _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkShares_ShareDefaultTypeInternal _NetworkShares_Share_default_instance_;
PROTOBUF_CONSTEXPR NetworkShares::NetworkShares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.share_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkSharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkSharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkSharesDefaultTypeInternal() {}
  union {
    NetworkShares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkSharesDefaultTypeInternal _NetworkShares_default_instance_;
PROTOBUF_CONSTEXPR WindowsDevices_Device::WindowsDevices_Device(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.friendly_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WindowsDevices_DeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WindowsDevices_DeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WindowsDevices_DeviceDefaultTypeInternal() {}
  union {
    WindowsDevices_Device _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WindowsDevices_DeviceDefaultTypeInternal _WindowsDevices_Device_default_instance_;
PROTOBUF_CONSTEXPR WindowsDevices::WindowsDevices(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WindowsDevicesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WindowsDevicesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WindowsDevicesDefaultTypeInternal() {}
  union {
    WindowsDevices _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WindowsDevicesDefaultTypeInternal _WindowsDevices_default_instance_;
PROTOBUF_CONSTEXPR VideoAdapters_Adapter::VideoAdapters_Adapter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.adapter_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bios_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chip_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dac_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_provider_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.memory_size_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VideoAdapters_AdapterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoAdapters_AdapterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoAdapters_AdapterDefaultTypeInternal() {}
  union {
    VideoAdapters_Adapter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoAdapters_AdapterDefaultTypeInternal _VideoAdapters_Adapter_default_instance_;
PROTOBUF_CONSTEXPR VideoAdapters::VideoAdapters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.adapter_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VideoAdaptersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoAdaptersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoAdaptersDefaultTypeInternal() {}
  union {
    VideoAdapters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoAdaptersDefaultTypeInternal _VideoAdapters_default_instance_;
PROTOBUF_CONSTEXPR Monitors_Monitor_Timing::Monitors_Monitor_Timing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.frequency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Monitors_Monitor_TimingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Monitors_Monitor_TimingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Monitors_Monitor_TimingDefaultTypeInternal() {}
  union {
    Monitors_Monitor_Timing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Monitors_Monitor_TimingDefaultTypeInternal _Monitors_Monitor_Timing_default_instance_;
PROTOBUF_CONSTEXPR Monitors_Monitor::Monitors_Monitor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.timings_)*/{}
  , /*decltype(_impl_.system_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.monitor_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacturer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.monitor_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.edid_version_)*/0
  , /*decltype(_impl_.edid_revision_)*/0
  , /*decltype(_impl_.week_of_manufacture_)*/0
  , /*decltype(_impl_.year_of_manufacture_)*/0
  , /*decltype(_impl_.max_horizontal_image_size_)*/0
  , /*decltype(_impl_.max_vertical_image_size_)*/0
  , /*decltype(_impl_.horizontal_resolution_)*/0
  , /*decltype(_impl_.vertical_resoulution_)*/0
  , /*decltype(_impl_.gamma_)*/0
  , /*decltype(_impl_.min_horizontal_rate_)*/0
  , /*decltype(_impl_.max_horizontal_rate_)*/0
  , /*decltype(_impl_.min_vertical_rate_)*/0
  , /*decltype(_impl_.max_vertical_rate_)*/0
  , /*decltype(_impl_.pixel_clock_)*/0
  , /*decltype(_impl_.max_pixel_clock_)*/0
  , /*decltype(_impl_.input_signal_type_)*/0
  , /*decltype(_impl_.default_gtf_supported_)*/false
  , /*decltype(_impl_.suspend_supported_)*/false
  , /*decltype(_impl_.standby_supported_)*/false
  , /*decltype(_impl_.active_off_supported_)*/false
  , /*decltype(_impl_.preferred_timing_mode_supported_)*/false
  , /*decltype(_impl_.srgb_supported_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Monitors_MonitorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Monitors_MonitorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Monitors_MonitorDefaultTypeInternal() {}
  union {
    Monitors_Monitor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Monitors_MonitorDefaultTypeInternal _Monitors_Monitor_default_instance_;
PROTOBUF_CONSTEXPR Monitors::Monitors(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.monitor_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonitorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonitorsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonitorsDefaultTypeInternal() {}
  union {
    Monitors _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonitorsDefaultTypeInternal _Monitors_default_instance_;
PROTOBUF_CONSTEXPR PowerOptions_Battery::PowerOptions_Battery(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacturer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacture_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unique_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.temperature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.design_capacity_)*/0u
  , /*decltype(_impl_.full_charged_capacity_)*/0u
  , /*decltype(_impl_.depreciation_)*/0u
  , /*decltype(_impl_.current_capacity_)*/0u
  , /*decltype(_impl_.voltage_)*/0u
  , /*decltype(_impl_.state_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PowerOptions_BatteryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PowerOptions_BatteryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PowerOptions_BatteryDefaultTypeInternal() {}
  union {
    PowerOptions_Battery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PowerOptions_BatteryDefaultTypeInternal _PowerOptions_Battery_default_instance_;
PROTOBUF_CONSTEXPR PowerOptions::PowerOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.battery_)*/{}
  , /*decltype(_impl_.power_source_)*/0
  , /*decltype(_impl_.battery_status_)*/0
  , /*decltype(_impl_.full_battery_life_time_)*/uint64_t{0u}
  , /*decltype(_impl_.remaining_battery_life_time_)*/uint64_t{0u}
  , /*decltype(_impl_.battery_life_percent_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PowerOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PowerOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PowerOptionsDefaultTypeInternal() {}
  union {
    PowerOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PowerOptionsDefaultTypeInternal _PowerOptions_default_instance_;
PROTOBUF_CONSTEXPR Drivers_Driver::Drivers_Driver(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.binary_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.startup_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Drivers_DriverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Drivers_DriverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Drivers_DriverDefaultTypeInternal() {}
  union {
    Drivers_Driver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Drivers_DriverDefaultTypeInternal _Drivers_Driver_default_instance_;
PROTOBUF_CONSTEXPR Drivers::Drivers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.driver_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DriversDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DriversDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DriversDefaultTypeInternal() {}
  union {
    Drivers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DriversDefaultTypeInternal _Drivers_default_instance_;
PROTOBUF_CONSTEXPR Services_Service::Services_Service(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.binary_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.startup_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Services_ServiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Services_ServiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Services_ServiceDefaultTypeInternal() {}
  union {
    Services_Service _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Services_ServiceDefaultTypeInternal _Services_Service_default_instance_;
PROTOBUF_CONSTEXPR Services::Services(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.service_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServicesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServicesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServicesDefaultTypeInternal() {}
  union {
    Services _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServicesDefaultTypeInternal _Services_default_instance_;
PROTOBUF_CONSTEXPR EnvironmentVariables_Variable::EnvironmentVariables_Variable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnvironmentVariables_VariableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvironmentVariables_VariableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvironmentVariables_VariableDefaultTypeInternal() {}
  union {
    EnvironmentVariables_Variable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvironmentVariables_VariableDefaultTypeInternal _EnvironmentVariables_Variable_default_instance_;
PROTOBUF_CONSTEXPR EnvironmentVariables::EnvironmentVariables(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.variable_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnvironmentVariablesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvironmentVariablesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvironmentVariablesDefaultTypeInternal() {}
  union {
    EnvironmentVariables _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvironmentVariablesDefaultTypeInternal _EnvironmentVariables_default_instance_;
PROTOBUF_CONSTEXPR EventLogs_Event::EventLogs_Event(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.category_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/int64_t{0}
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventLogs_EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventLogs_EventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventLogs_EventDefaultTypeInternal() {}
  union {
    EventLogs_Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventLogs_EventDefaultTypeInternal _EventLogs_Event_default_instance_;
PROTOBUF_CONSTEXPR EventLogs::EventLogs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.event_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.total_records_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventLogsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventLogsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventLogsDefaultTypeInternal() {}
  union {
    EventLogs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventLogsDefaultTypeInternal _EventLogs_default_instance_;
PROTOBUF_CONSTEXPR EventLogsData::EventLogsData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.record_start_)*/0u
  , /*decltype(_impl_.record_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventLogsDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventLogsDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventLogsDataDefaultTypeInternal() {}
  union {
    EventLogsData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventLogsDataDefaultTypeInternal _EventLogsData_default_instance_;
PROTOBUF_CONSTEXPR Routes_Route::Routes_Route(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.destonation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mask_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gateway_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metric_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Routes_RouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Routes_RouteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Routes_RouteDefaultTypeInternal() {}
  union {
    Routes_Route _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Routes_RouteDefaultTypeInternal _Routes_Route_default_instance_;
PROTOBUF_CONSTEXPR Routes::Routes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.route_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoutesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoutesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoutesDefaultTypeInternal() {}
  union {
    Routes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoutesDefaultTypeInternal _Routes_default_instance_;
PROTOBUF_CONSTEXPR Connections_Connection::Connections_Connection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.process_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.protocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.local_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.remote_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.local_port_)*/0u
  , /*decltype(_impl_.remote_port_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Connections_ConnectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Connections_ConnectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Connections_ConnectionDefaultTypeInternal() {}
  union {
    Connections_Connection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Connections_ConnectionDefaultTypeInternal _Connections_Connection_default_instance_;
PROTOBUF_CONSTEXPR Connections::Connections(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.connection_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConnectionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsDefaultTypeInternal() {}
  union {
    Connections _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsDefaultTypeInternal _Connections_default_instance_;
PROTOBUF_CONSTEXPR Licenses_License_Field::Licenses_License_Field(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Licenses_License_FieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Licenses_License_FieldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Licenses_License_FieldDefaultTypeInternal() {}
  union {
    Licenses_License_Field _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Licenses_License_FieldDefaultTypeInternal _Licenses_License_Field_default_instance_;
PROTOBUF_CONSTEXPR Licenses_License::Licenses_License(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.field_)*/{}
  , /*decltype(_impl_.product_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Licenses_LicenseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Licenses_LicenseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Licenses_LicenseDefaultTypeInternal() {}
  union {
    Licenses_License _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Licenses_LicenseDefaultTypeInternal _Licenses_License_default_instance_;
PROTOBUF_CONSTEXPR Licenses::Licenses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.license_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LicensesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicensesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicensesDefaultTypeInternal() {}
  union {
    Licenses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicensesDefaultTypeInternal _Licenses_default_instance_;
PROTOBUF_CONSTEXPR Applications_Application::Applications_Application(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.publisher_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.install_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.install_location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Applications_ApplicationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Applications_ApplicationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Applications_ApplicationDefaultTypeInternal() {}
  union {
    Applications_Application _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Applications_ApplicationDefaultTypeInternal _Applications_Application_default_instance_;
PROTOBUF_CONSTEXPR Applications::Applications(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.application_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplicationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplicationsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplicationsDefaultTypeInternal() {}
  union {
    Applications _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplicationsDefaultTypeInternal _Applications_default_instance_;
PROTOBUF_CONSTEXPR OpenFiles_OpenFile::OpenFiles_OpenFile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.lock_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpenFiles_OpenFileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpenFiles_OpenFileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpenFiles_OpenFileDefaultTypeInternal() {}
  union {
    OpenFiles_OpenFile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpenFiles_OpenFileDefaultTypeInternal _OpenFiles_OpenFile_default_instance_;
PROTOBUF_CONSTEXPR OpenFiles::OpenFiles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.open_file_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OpenFilesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpenFilesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpenFilesDefaultTypeInternal() {}
  union {
    OpenFiles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpenFilesDefaultTypeInternal _OpenFiles_default_instance_;
PROTOBUF_CONSTEXPR LocalUsers_LocalUser_LocalUserGroup::LocalUsers_LocalUser_LocalUserGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalUsers_LocalUser_LocalUserGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalUsers_LocalUser_LocalUserGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalUsers_LocalUser_LocalUserGroupDefaultTypeInternal() {}
  union {
    LocalUsers_LocalUser_LocalUserGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalUsers_LocalUser_LocalUserGroupDefaultTypeInternal _LocalUsers_LocalUser_LocalUserGroup_default_instance_;
PROTOBUF_CONSTEXPR LocalUsers_LocalUser::LocalUsers_LocalUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.group_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.full_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.home_dir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.disabled_)*/false
  , /*decltype(_impl_.password_cant_change_)*/false
  , /*decltype(_impl_.password_expired_)*/false
  , /*decltype(_impl_.dont_expire_password_)*/false
  , /*decltype(_impl_.lockout_)*/false
  , /*decltype(_impl_.number_logons_)*/0u
  , /*decltype(_impl_.bad_password_count_)*/0u
  , /*decltype(_impl_.last_logon_time_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalUsers_LocalUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalUsers_LocalUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalUsers_LocalUserDefaultTypeInternal() {}
  union {
    LocalUsers_LocalUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalUsers_LocalUserDefaultTypeInternal _LocalUsers_LocalUser_default_instance_;
PROTOBUF_CONSTEXPR LocalUsers::LocalUsers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.local_user_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalUsersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalUsersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalUsersDefaultTypeInternal() {}
  union {
    LocalUsers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalUsersDefaultTypeInternal _LocalUsers_default_instance_;
PROTOBUF_CONSTEXPR LocalUserGroups_LocalUserGroup::LocalUserGroups_LocalUserGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalUserGroups_LocalUserGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalUserGroups_LocalUserGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalUserGroups_LocalUserGroupDefaultTypeInternal() {}
  union {
    LocalUserGroups_LocalUserGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalUserGroups_LocalUserGroupDefaultTypeInternal _LocalUserGroups_LocalUserGroup_default_instance_;
PROTOBUF_CONSTEXPR LocalUserGroups::LocalUserGroups(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.local_user_group_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalUserGroupsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalUserGroupsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalUserGroupsDefaultTypeInternal() {}
  union {
    LocalUserGroups _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalUserGroupsDefaultTypeInternal _LocalUserGroups_default_instance_;
PROTOBUF_CONSTEXPR Processes_Process::Processes_Process(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0u
  , /*decltype(_impl_.sid_)*/0u
  , /*decltype(_impl_.memory_)*/int64_t{0}
  , /*decltype(_impl_.cpu_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Processes_ProcessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Processes_ProcessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Processes_ProcessDefaultTypeInternal() {}
  union {
    Processes_Process _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Processes_ProcessDefaultTypeInternal _Processes_Process_default_instance_;
PROTOBUF_CONSTEXPR Processes::Processes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.process_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessesDefaultTypeInternal() {}
  union {
    Processes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessesDefaultTypeInternal _Processes_default_instance_;
PROTOBUF_CONSTEXPR SystemInfoRequest::SystemInfoRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.category_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.event_logs_data_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemInfoRequestDefaultTypeInternal() {}
  union {
    SystemInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemInfoRequestDefaultTypeInternal _SystemInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR SystemInfoFooter::SystemInfoFooter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.category_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemInfoFooterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemInfoFooterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemInfoFooterDefaultTypeInternal() {}
  union {
    SystemInfoFooter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemInfoFooterDefaultTypeInternal _SystemInfoFooter_default_instance_;
PROTOBUF_CONSTEXPR SystemInfo::SystemInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.computer_)*/nullptr
  , /*decltype(_impl_.operating_system_)*/nullptr
  , /*decltype(_impl_.motherboard_)*/nullptr
  , /*decltype(_impl_.bios_)*/nullptr
  , /*decltype(_impl_.processor_)*/nullptr
  , /*decltype(_impl_.memory_)*/nullptr
  , /*decltype(_impl_.logical_drives_)*/nullptr
  , /*decltype(_impl_.printers_)*/nullptr
  , /*decltype(_impl_.network_adapters_)*/nullptr
  , /*decltype(_impl_.network_shares_)*/nullptr
  , /*decltype(_impl_.windows_devices_)*/nullptr
  , /*decltype(_impl_.video_adapters_)*/nullptr
  , /*decltype(_impl_.monitors_)*/nullptr
  , /*decltype(_impl_.power_options_)*/nullptr
  , /*decltype(_impl_.drivers_)*/nullptr
  , /*decltype(_impl_.services_)*/nullptr
  , /*decltype(_impl_.env_vars_)*/nullptr
  , /*decltype(_impl_.event_logs_)*/nullptr
  , /*decltype(_impl_.routes_)*/nullptr
  , /*decltype(_impl_.connections_)*/nullptr
  , /*decltype(_impl_.licenses_)*/nullptr
  , /*decltype(_impl_.applications_)*/nullptr
  , /*decltype(_impl_.open_files_)*/nullptr
  , /*decltype(_impl_.local_users_)*/nullptr
  , /*decltype(_impl_.local_user_groups_)*/nullptr
  , /*decltype(_impl_.processes_)*/nullptr
  , /*decltype(_impl_.footer_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemInfoDefaultTypeInternal() {}
  union {
    SystemInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
}  // namespace system_info
}  // namespace proto
namespace proto {
namespace system_info {
bool Monitors_Monitor_InputSignalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Monitors_Monitor_InputSignalType_strings[3] = {};

static const char Monitors_Monitor_InputSignalType_names[] =
  "INPUT_SIGNAL_TYPE_ANALOG"
  "INPUT_SIGNAL_TYPE_DIGITAL"
  "INPUT_SIGNAL_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Monitors_Monitor_InputSignalType_entries[] = {
  { {Monitors_Monitor_InputSignalType_names + 0, 24}, 1 },
  { {Monitors_Monitor_InputSignalType_names + 24, 25}, 2 },
  { {Monitors_Monitor_InputSignalType_names + 49, 25}, 0 },
};

static const int Monitors_Monitor_InputSignalType_entries_by_number[] = {
  2, // 0 -> INPUT_SIGNAL_TYPE_UNKNOWN
  0, // 1 -> INPUT_SIGNAL_TYPE_ANALOG
  1, // 2 -> INPUT_SIGNAL_TYPE_DIGITAL
};

const std::string& Monitors_Monitor_InputSignalType_Name(
    Monitors_Monitor_InputSignalType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Monitors_Monitor_InputSignalType_entries,
          Monitors_Monitor_InputSignalType_entries_by_number,
          3, Monitors_Monitor_InputSignalType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Monitors_Monitor_InputSignalType_entries,
      Monitors_Monitor_InputSignalType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Monitors_Monitor_InputSignalType_strings[idx].get();
}
bool Monitors_Monitor_InputSignalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Monitors_Monitor_InputSignalType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Monitors_Monitor_InputSignalType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Monitors_Monitor_InputSignalType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor::INPUT_SIGNAL_TYPE_UNKNOWN;
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor::INPUT_SIGNAL_TYPE_ANALOG;
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor::INPUT_SIGNAL_TYPE_DIGITAL;
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor::InputSignalType_MIN;
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor::InputSignalType_MAX;
constexpr int Monitors_Monitor::InputSignalType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PowerOptions_Battery_State_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PowerOptions_Battery_State_strings[5] = {};

static const char PowerOptions_Battery_State_names[] =
  "STATE_CHARGING"
  "STATE_CRITICAL"
  "STATE_DISCHARGING"
  "STATE_POWER_ONLINE"
  "STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PowerOptions_Battery_State_entries[] = {
  { {PowerOptions_Battery_State_names + 0, 14}, 1 },
  { {PowerOptions_Battery_State_names + 14, 14}, 2 },
  { {PowerOptions_Battery_State_names + 28, 17}, 4 },
  { {PowerOptions_Battery_State_names + 45, 18}, 8 },
  { {PowerOptions_Battery_State_names + 63, 13}, 0 },
};

static const int PowerOptions_Battery_State_entries_by_number[] = {
  4, // 0 -> STATE_UNKNOWN
  0, // 1 -> STATE_CHARGING
  1, // 2 -> STATE_CRITICAL
  2, // 4 -> STATE_DISCHARGING
  3, // 8 -> STATE_POWER_ONLINE
};

const std::string& PowerOptions_Battery_State_Name(
    PowerOptions_Battery_State value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PowerOptions_Battery_State_entries,
          PowerOptions_Battery_State_entries_by_number,
          5, PowerOptions_Battery_State_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PowerOptions_Battery_State_entries,
      PowerOptions_Battery_State_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PowerOptions_Battery_State_strings[idx].get();
}
bool PowerOptions_Battery_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerOptions_Battery_State* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PowerOptions_Battery_State_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<PowerOptions_Battery_State>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PowerOptions_Battery_State PowerOptions_Battery::STATE_UNKNOWN;
constexpr PowerOptions_Battery_State PowerOptions_Battery::STATE_CHARGING;
constexpr PowerOptions_Battery_State PowerOptions_Battery::STATE_CRITICAL;
constexpr PowerOptions_Battery_State PowerOptions_Battery::STATE_DISCHARGING;
constexpr PowerOptions_Battery_State PowerOptions_Battery::STATE_POWER_ONLINE;
constexpr PowerOptions_Battery_State PowerOptions_Battery::State_MIN;
constexpr PowerOptions_Battery_State PowerOptions_Battery::State_MAX;
constexpr int PowerOptions_Battery::State_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PowerOptions_PowerSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PowerOptions_PowerSource_strings[3] = {};

static const char PowerOptions_PowerSource_names[] =
  "POWER_SOURCE_AC_LINE"
  "POWER_SOURCE_DC_BATTERY"
  "POWER_SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PowerOptions_PowerSource_entries[] = {
  { {PowerOptions_PowerSource_names + 0, 20}, 2 },
  { {PowerOptions_PowerSource_names + 20, 23}, 1 },
  { {PowerOptions_PowerSource_names + 43, 20}, 0 },
};

static const int PowerOptions_PowerSource_entries_by_number[] = {
  2, // 0 -> POWER_SOURCE_UNKNOWN
  1, // 1 -> POWER_SOURCE_DC_BATTERY
  0, // 2 -> POWER_SOURCE_AC_LINE
};

const std::string& PowerOptions_PowerSource_Name(
    PowerOptions_PowerSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PowerOptions_PowerSource_entries,
          PowerOptions_PowerSource_entries_by_number,
          3, PowerOptions_PowerSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PowerOptions_PowerSource_entries,
      PowerOptions_PowerSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PowerOptions_PowerSource_strings[idx].get();
}
bool PowerOptions_PowerSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerOptions_PowerSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PowerOptions_PowerSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PowerOptions_PowerSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PowerOptions_PowerSource PowerOptions::POWER_SOURCE_UNKNOWN;
constexpr PowerOptions_PowerSource PowerOptions::POWER_SOURCE_DC_BATTERY;
constexpr PowerOptions_PowerSource PowerOptions::POWER_SOURCE_AC_LINE;
constexpr PowerOptions_PowerSource PowerOptions::PowerSource_MIN;
constexpr PowerOptions_PowerSource PowerOptions::PowerSource_MAX;
constexpr int PowerOptions::PowerSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PowerOptions_BatteryStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PowerOptions_BatteryStatus_strings[6] = {};

static const char PowerOptions_BatteryStatus_names[] =
  "BATTERY_STATUS_CHARGING"
  "BATTERY_STATUS_CRITICAL"
  "BATTERY_STATUS_HIGH"
  "BATTERY_STATUS_LOW"
  "BATTERY_STATUS_NO_BATTERY"
  "BATTERY_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PowerOptions_BatteryStatus_entries[] = {
  { {PowerOptions_BatteryStatus_names + 0, 23}, 4 },
  { {PowerOptions_BatteryStatus_names + 23, 23}, 3 },
  { {PowerOptions_BatteryStatus_names + 46, 19}, 1 },
  { {PowerOptions_BatteryStatus_names + 65, 18}, 2 },
  { {PowerOptions_BatteryStatus_names + 83, 25}, 5 },
  { {PowerOptions_BatteryStatus_names + 108, 22}, 0 },
};

static const int PowerOptions_BatteryStatus_entries_by_number[] = {
  5, // 0 -> BATTERY_STATUS_UNKNOWN
  2, // 1 -> BATTERY_STATUS_HIGH
  3, // 2 -> BATTERY_STATUS_LOW
  1, // 3 -> BATTERY_STATUS_CRITICAL
  0, // 4 -> BATTERY_STATUS_CHARGING
  4, // 5 -> BATTERY_STATUS_NO_BATTERY
};

const std::string& PowerOptions_BatteryStatus_Name(
    PowerOptions_BatteryStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PowerOptions_BatteryStatus_entries,
          PowerOptions_BatteryStatus_entries_by_number,
          6, PowerOptions_BatteryStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PowerOptions_BatteryStatus_entries,
      PowerOptions_BatteryStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PowerOptions_BatteryStatus_strings[idx].get();
}
bool PowerOptions_BatteryStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerOptions_BatteryStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PowerOptions_BatteryStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<PowerOptions_BatteryStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PowerOptions_BatteryStatus PowerOptions::BATTERY_STATUS_UNKNOWN;
constexpr PowerOptions_BatteryStatus PowerOptions::BATTERY_STATUS_HIGH;
constexpr PowerOptions_BatteryStatus PowerOptions::BATTERY_STATUS_LOW;
constexpr PowerOptions_BatteryStatus PowerOptions::BATTERY_STATUS_CRITICAL;
constexpr PowerOptions_BatteryStatus PowerOptions::BATTERY_STATUS_CHARGING;
constexpr PowerOptions_BatteryStatus PowerOptions::BATTERY_STATUS_NO_BATTERY;
constexpr PowerOptions_BatteryStatus PowerOptions::BatteryStatus_MIN;
constexpr PowerOptions_BatteryStatus PowerOptions::BatteryStatus_MAX;
constexpr int PowerOptions::BatteryStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Drivers_Driver_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Drivers_Driver_Status_strings[8] = {};

static const char Drivers_Driver_Status_names[] =
  "STATUS_CONTINUE_PENDING"
  "STATUS_PAUSED"
  "STATUS_PAUSE_PENDING"
  "STATUS_RUNNING"
  "STATUS_START_PENDING"
  "STATUS_STOPPED"
  "STATUS_STOP_PENDING"
  "STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Drivers_Driver_Status_entries[] = {
  { {Drivers_Driver_Status_names + 0, 23}, 1 },
  { {Drivers_Driver_Status_names + 23, 13}, 3 },
  { {Drivers_Driver_Status_names + 36, 20}, 2 },
  { {Drivers_Driver_Status_names + 56, 14}, 4 },
  { {Drivers_Driver_Status_names + 70, 20}, 5 },
  { {Drivers_Driver_Status_names + 90, 14}, 7 },
  { {Drivers_Driver_Status_names + 104, 19}, 6 },
  { {Drivers_Driver_Status_names + 123, 14}, 0 },
};

static const int Drivers_Driver_Status_entries_by_number[] = {
  7, // 0 -> STATUS_UNKNOWN
  0, // 1 -> STATUS_CONTINUE_PENDING
  2, // 2 -> STATUS_PAUSE_PENDING
  1, // 3 -> STATUS_PAUSED
  3, // 4 -> STATUS_RUNNING
  4, // 5 -> STATUS_START_PENDING
  6, // 6 -> STATUS_STOP_PENDING
  5, // 7 -> STATUS_STOPPED
};

const std::string& Drivers_Driver_Status_Name(
    Drivers_Driver_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Drivers_Driver_Status_entries,
          Drivers_Driver_Status_entries_by_number,
          8, Drivers_Driver_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Drivers_Driver_Status_entries,
      Drivers_Driver_Status_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Drivers_Driver_Status_strings[idx].get();
}
bool Drivers_Driver_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Drivers_Driver_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Drivers_Driver_Status_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<Drivers_Driver_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_UNKNOWN;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_CONTINUE_PENDING;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_PAUSE_PENDING;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_PAUSED;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_RUNNING;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_START_PENDING;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_STOP_PENDING;
constexpr Drivers_Driver_Status Drivers_Driver::STATUS_STOPPED;
constexpr Drivers_Driver_Status Drivers_Driver::Status_MIN;
constexpr Drivers_Driver_Status Drivers_Driver::Status_MAX;
constexpr int Drivers_Driver::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Drivers_Driver_StartupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Drivers_Driver_StartupType_strings[6] = {};

static const char Drivers_Driver_StartupType_names[] =
  "STARTUP_TYPE_AUTO_START"
  "STARTUP_TYPE_BOOT_START"
  "STARTUP_TYPE_DEMAND_START"
  "STARTUP_TYPE_DISABLED"
  "STARTUP_TYPE_SYSTEM_START"
  "STARTUP_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Drivers_Driver_StartupType_entries[] = {
  { {Drivers_Driver_StartupType_names + 0, 23}, 1 },
  { {Drivers_Driver_StartupType_names + 23, 23}, 4 },
  { {Drivers_Driver_StartupType_names + 46, 25}, 2 },
  { {Drivers_Driver_StartupType_names + 71, 21}, 3 },
  { {Drivers_Driver_StartupType_names + 92, 25}, 5 },
  { {Drivers_Driver_StartupType_names + 117, 20}, 0 },
};

static const int Drivers_Driver_StartupType_entries_by_number[] = {
  5, // 0 -> STARTUP_TYPE_UNKNOWN
  0, // 1 -> STARTUP_TYPE_AUTO_START
  2, // 2 -> STARTUP_TYPE_DEMAND_START
  3, // 3 -> STARTUP_TYPE_DISABLED
  1, // 4 -> STARTUP_TYPE_BOOT_START
  4, // 5 -> STARTUP_TYPE_SYSTEM_START
};

const std::string& Drivers_Driver_StartupType_Name(
    Drivers_Driver_StartupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Drivers_Driver_StartupType_entries,
          Drivers_Driver_StartupType_entries_by_number,
          6, Drivers_Driver_StartupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Drivers_Driver_StartupType_entries,
      Drivers_Driver_StartupType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Drivers_Driver_StartupType_strings[idx].get();
}
bool Drivers_Driver_StartupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Drivers_Driver_StartupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Drivers_Driver_StartupType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Drivers_Driver_StartupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Drivers_Driver_StartupType Drivers_Driver::STARTUP_TYPE_UNKNOWN;
constexpr Drivers_Driver_StartupType Drivers_Driver::STARTUP_TYPE_AUTO_START;
constexpr Drivers_Driver_StartupType Drivers_Driver::STARTUP_TYPE_DEMAND_START;
constexpr Drivers_Driver_StartupType Drivers_Driver::STARTUP_TYPE_DISABLED;
constexpr Drivers_Driver_StartupType Drivers_Driver::STARTUP_TYPE_BOOT_START;
constexpr Drivers_Driver_StartupType Drivers_Driver::STARTUP_TYPE_SYSTEM_START;
constexpr Drivers_Driver_StartupType Drivers_Driver::StartupType_MIN;
constexpr Drivers_Driver_StartupType Drivers_Driver::StartupType_MAX;
constexpr int Drivers_Driver::StartupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Services_Service_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Services_Service_Status_strings[8] = {};

static const char Services_Service_Status_names[] =
  "STATUS_CONTINUE_PENDING"
  "STATUS_PAUSED"
  "STATUS_PAUSE_PENDING"
  "STATUS_RUNNING"
  "STATUS_START_PENDING"
  "STATUS_STOPPED"
  "STATUS_STOP_PENDING"
  "STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Services_Service_Status_entries[] = {
  { {Services_Service_Status_names + 0, 23}, 1 },
  { {Services_Service_Status_names + 23, 13}, 3 },
  { {Services_Service_Status_names + 36, 20}, 2 },
  { {Services_Service_Status_names + 56, 14}, 4 },
  { {Services_Service_Status_names + 70, 20}, 5 },
  { {Services_Service_Status_names + 90, 14}, 7 },
  { {Services_Service_Status_names + 104, 19}, 6 },
  { {Services_Service_Status_names + 123, 14}, 0 },
};

static const int Services_Service_Status_entries_by_number[] = {
  7, // 0 -> STATUS_UNKNOWN
  0, // 1 -> STATUS_CONTINUE_PENDING
  2, // 2 -> STATUS_PAUSE_PENDING
  1, // 3 -> STATUS_PAUSED
  3, // 4 -> STATUS_RUNNING
  4, // 5 -> STATUS_START_PENDING
  6, // 6 -> STATUS_STOP_PENDING
  5, // 7 -> STATUS_STOPPED
};

const std::string& Services_Service_Status_Name(
    Services_Service_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Services_Service_Status_entries,
          Services_Service_Status_entries_by_number,
          8, Services_Service_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Services_Service_Status_entries,
      Services_Service_Status_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Services_Service_Status_strings[idx].get();
}
bool Services_Service_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Services_Service_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Services_Service_Status_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<Services_Service_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Services_Service_Status Services_Service::STATUS_UNKNOWN;
constexpr Services_Service_Status Services_Service::STATUS_CONTINUE_PENDING;
constexpr Services_Service_Status Services_Service::STATUS_PAUSE_PENDING;
constexpr Services_Service_Status Services_Service::STATUS_PAUSED;
constexpr Services_Service_Status Services_Service::STATUS_RUNNING;
constexpr Services_Service_Status Services_Service::STATUS_START_PENDING;
constexpr Services_Service_Status Services_Service::STATUS_STOP_PENDING;
constexpr Services_Service_Status Services_Service::STATUS_STOPPED;
constexpr Services_Service_Status Services_Service::Status_MIN;
constexpr Services_Service_Status Services_Service::Status_MAX;
constexpr int Services_Service::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Services_Service_StartupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Services_Service_StartupType_strings[6] = {};

static const char Services_Service_StartupType_names[] =
  "STARTUP_TYPE_AUTO_START"
  "STARTUP_TYPE_BOOT_START"
  "STARTUP_TYPE_DEMAND_START"
  "STARTUP_TYPE_DISABLED"
  "STARTUP_TYPE_SYSTEM_START"
  "STARTUP_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Services_Service_StartupType_entries[] = {
  { {Services_Service_StartupType_names + 0, 23}, 1 },
  { {Services_Service_StartupType_names + 23, 23}, 4 },
  { {Services_Service_StartupType_names + 46, 25}, 2 },
  { {Services_Service_StartupType_names + 71, 21}, 3 },
  { {Services_Service_StartupType_names + 92, 25}, 5 },
  { {Services_Service_StartupType_names + 117, 20}, 0 },
};

static const int Services_Service_StartupType_entries_by_number[] = {
  5, // 0 -> STARTUP_TYPE_UNKNOWN
  0, // 1 -> STARTUP_TYPE_AUTO_START
  2, // 2 -> STARTUP_TYPE_DEMAND_START
  3, // 3 -> STARTUP_TYPE_DISABLED
  1, // 4 -> STARTUP_TYPE_BOOT_START
  4, // 5 -> STARTUP_TYPE_SYSTEM_START
};

const std::string& Services_Service_StartupType_Name(
    Services_Service_StartupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Services_Service_StartupType_entries,
          Services_Service_StartupType_entries_by_number,
          6, Services_Service_StartupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Services_Service_StartupType_entries,
      Services_Service_StartupType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Services_Service_StartupType_strings[idx].get();
}
bool Services_Service_StartupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Services_Service_StartupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Services_Service_StartupType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Services_Service_StartupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Services_Service_StartupType Services_Service::STARTUP_TYPE_UNKNOWN;
constexpr Services_Service_StartupType Services_Service::STARTUP_TYPE_AUTO_START;
constexpr Services_Service_StartupType Services_Service::STARTUP_TYPE_DEMAND_START;
constexpr Services_Service_StartupType Services_Service::STARTUP_TYPE_DISABLED;
constexpr Services_Service_StartupType Services_Service::STARTUP_TYPE_BOOT_START;
constexpr Services_Service_StartupType Services_Service::STARTUP_TYPE_SYSTEM_START;
constexpr Services_Service_StartupType Services_Service::StartupType_MIN;
constexpr Services_Service_StartupType Services_Service::StartupType_MAX;
constexpr int Services_Service::StartupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EventLogs_Event_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventLogs_Event_Type_strings[4] = {};

static const char EventLogs_Event_Type_names[] =
  "TYPE_APPLICATION"
  "TYPE_SECURITY"
  "TYPE_SYSTEM"
  "TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventLogs_Event_Type_entries[] = {
  { {EventLogs_Event_Type_names + 0, 16}, 1 },
  { {EventLogs_Event_Type_names + 16, 13}, 2 },
  { {EventLogs_Event_Type_names + 29, 11}, 3 },
  { {EventLogs_Event_Type_names + 40, 12}, 0 },
};

static const int EventLogs_Event_Type_entries_by_number[] = {
  3, // 0 -> TYPE_UNKNOWN
  0, // 1 -> TYPE_APPLICATION
  1, // 2 -> TYPE_SECURITY
  2, // 3 -> TYPE_SYSTEM
};

const std::string& EventLogs_Event_Type_Name(
    EventLogs_Event_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventLogs_Event_Type_entries,
          EventLogs_Event_Type_entries_by_number,
          4, EventLogs_Event_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventLogs_Event_Type_entries,
      EventLogs_Event_Type_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventLogs_Event_Type_strings[idx].get();
}
bool EventLogs_Event_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventLogs_Event_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventLogs_Event_Type_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EventLogs_Event_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EventLogs_Event_Type EventLogs_Event::TYPE_UNKNOWN;
constexpr EventLogs_Event_Type EventLogs_Event::TYPE_APPLICATION;
constexpr EventLogs_Event_Type EventLogs_Event::TYPE_SECURITY;
constexpr EventLogs_Event_Type EventLogs_Event::TYPE_SYSTEM;
constexpr EventLogs_Event_Type EventLogs_Event::Type_MIN;
constexpr EventLogs_Event_Type EventLogs_Event::Type_MAX;
constexpr int EventLogs_Event::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EventLogs_Event_Level_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventLogs_Event_Level_strings[7] = {};

static const char EventLogs_Event_Level_names[] =
  "LEVEL_AUDIT_FAILURE"
  "LEVEL_AUDIT_SUCCESS"
  "LEVEL_ERROR"
  "LEVEL_INFORMATION"
  "LEVEL_SUCCESS"
  "LEVEL_UNKNOWN"
  "LEVEL_WARNING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventLogs_Event_Level_entries[] = {
  { {EventLogs_Event_Level_names + 0, 19}, 32 },
  { {EventLogs_Event_Level_names + 19, 19}, 16 },
  { {EventLogs_Event_Level_names + 38, 11}, 8 },
  { {EventLogs_Event_Level_names + 49, 17}, 2 },
  { {EventLogs_Event_Level_names + 66, 13}, 1 },
  { {EventLogs_Event_Level_names + 79, 13}, 0 },
  { {EventLogs_Event_Level_names + 92, 13}, 4 },
};

static const int EventLogs_Event_Level_entries_by_number[] = {
  5, // 0 -> LEVEL_UNKNOWN
  4, // 1 -> LEVEL_SUCCESS
  3, // 2 -> LEVEL_INFORMATION
  6, // 4 -> LEVEL_WARNING
  2, // 8 -> LEVEL_ERROR
  1, // 16 -> LEVEL_AUDIT_SUCCESS
  0, // 32 -> LEVEL_AUDIT_FAILURE
};

const std::string& EventLogs_Event_Level_Name(
    EventLogs_Event_Level value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventLogs_Event_Level_entries,
          EventLogs_Event_Level_entries_by_number,
          7, EventLogs_Event_Level_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventLogs_Event_Level_entries,
      EventLogs_Event_Level_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventLogs_Event_Level_strings[idx].get();
}
bool EventLogs_Event_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventLogs_Event_Level* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventLogs_Event_Level_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<EventLogs_Event_Level>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_UNKNOWN;
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_SUCCESS;
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_INFORMATION;
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_WARNING;
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_ERROR;
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_AUDIT_SUCCESS;
constexpr EventLogs_Event_Level EventLogs_Event::LEVEL_AUDIT_FAILURE;
constexpr EventLogs_Event_Level EventLogs_Event::Level_MIN;
constexpr EventLogs_Event_Level EventLogs_Event::Level_MAX;
constexpr int EventLogs_Event::Level_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Licenses_License_Field_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Licenses_License_Field_Type_strings[7] = {};

static const char Licenses_License_Field_Type_names[] =
  "TYPE_LICENSE_TYPE"
  "TYPE_LICENSE_VERSION"
  "TYPE_ORGANIZATION"
  "TYPE_OWNER"
  "TYPE_PRODUCT_ID"
  "TYPE_PRODUCT_KEY"
  "TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Licenses_License_Field_Type_entries[] = {
  { {Licenses_License_Field_Type_names + 0, 17}, 7 },
  { {Licenses_License_Field_Type_names + 17, 20}, 6 },
  { {Licenses_License_Field_Type_names + 37, 17}, 3 },
  { {Licenses_License_Field_Type_names + 54, 10}, 2 },
  { {Licenses_License_Field_Type_names + 64, 15}, 5 },
  { {Licenses_License_Field_Type_names + 79, 16}, 4 },
  { {Licenses_License_Field_Type_names + 95, 12}, 0 },
};

static const int Licenses_License_Field_Type_entries_by_number[] = {
  6, // 0 -> TYPE_UNKNOWN
  3, // 2 -> TYPE_OWNER
  2, // 3 -> TYPE_ORGANIZATION
  5, // 4 -> TYPE_PRODUCT_KEY
  4, // 5 -> TYPE_PRODUCT_ID
  1, // 6 -> TYPE_LICENSE_VERSION
  0, // 7 -> TYPE_LICENSE_TYPE
};

const std::string& Licenses_License_Field_Type_Name(
    Licenses_License_Field_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Licenses_License_Field_Type_entries,
          Licenses_License_Field_Type_entries_by_number,
          7, Licenses_License_Field_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Licenses_License_Field_Type_entries,
      Licenses_License_Field_Type_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Licenses_License_Field_Type_strings[idx].get();
}
bool Licenses_License_Field_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Licenses_License_Field_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Licenses_License_Field_Type_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<Licenses_License_Field_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_UNKNOWN;
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_OWNER;
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_ORGANIZATION;
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_PRODUCT_KEY;
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_PRODUCT_ID;
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_LICENSE_VERSION;
constexpr Licenses_License_Field_Type Licenses_License_Field::TYPE_LICENSE_TYPE;
constexpr Licenses_License_Field_Type Licenses_License_Field::Type_MIN;
constexpr Licenses_License_Field_Type Licenses_License_Field::Type_MAX;
constexpr int Licenses_License_Field::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Computer::_Internal {
 public:
};

Computer::Computer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Computer)
}
Computer::Computer(const Computer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Computer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.workgroup_){}
    , decltype(_impl_.uptime_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_domain().empty()) {
    _this->_impl_.domain_.Set(from._internal_domain(), 
      _this->GetArenaForAllocation());
  }
  _impl_.workgroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.workgroup_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_workgroup().empty()) {
    _this->_impl_.workgroup_.Set(from._internal_workgroup(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.uptime_ = from._impl_.uptime_;
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Computer)
}

inline void Computer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.workgroup_){}
    , decltype(_impl_.uptime_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.workgroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.workgroup_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Computer::~Computer() {
  // @@protoc_insertion_point(destructor:proto.system_info.Computer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Computer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.domain_.Destroy();
  _impl_.workgroup_.Destroy();
}

void Computer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Computer::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Computer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.domain_.ClearToEmpty();
  _impl_.workgroup_.ClearToEmpty();
  _impl_.uptime_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Computer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string workgroup = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_workgroup();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 uptime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.uptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Computer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Computer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Computer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string domain = 2;
  if (!this->_internal_domain().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain().data(), static_cast<int>(this->_internal_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Computer.domain");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain(), target);
  }

  // string workgroup = 3;
  if (!this->_internal_workgroup().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_workgroup().data(), static_cast<int>(this->_internal_workgroup().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Computer.workgroup");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_workgroup(), target);
  }

  // uint64 uptime = 4;
  if (this->_internal_uptime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_uptime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Computer)
  return target;
}

size_t Computer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Computer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string domain = 2;
  if (!this->_internal_domain().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain());
  }

  // string workgroup = 3;
  if (!this->_internal_workgroup().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_workgroup());
  }

  // uint64 uptime = 4;
  if (this->_internal_uptime() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_uptime());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Computer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Computer*>(
      &from));
}

void Computer::MergeFrom(const Computer& from) {
  Computer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Computer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_domain().empty()) {
    _this->_internal_set_domain(from._internal_domain());
  }
  if (!from._internal_workgroup().empty()) {
    _this->_internal_set_workgroup(from._internal_workgroup());
  }
  if (from._internal_uptime() != 0) {
    _this->_internal_set_uptime(from._internal_uptime());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Computer::CopyFrom(const Computer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Computer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Computer::IsInitialized() const {
  return true;
}

void Computer::InternalSwap(Computer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_, lhs_arena,
      &other->_impl_.domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.workgroup_, lhs_arena,
      &other->_impl_.workgroup_, rhs_arena
  );
  swap(_impl_.uptime_, other->_impl_.uptime_);
}

std::string Computer::GetTypeName() const {
  return "proto.system_info.Computer";
}


// ===================================================================

class OperatingSystem::_Internal {
 public:
};

OperatingSystem::OperatingSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.OperatingSystem)
}
OperatingSystem::OperatingSystem(const OperatingSystem& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OperatingSystem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.arch_){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.install_date_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.arch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_arch().empty()) {
    _this->_impl_.arch_.Set(from._internal_arch(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.install_date_ = from._impl_.install_date_;
  // @@protoc_insertion_point(copy_constructor:proto.system_info.OperatingSystem)
}

inline void OperatingSystem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.arch_){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.install_date_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.arch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OperatingSystem::~OperatingSystem() {
  // @@protoc_insertion_point(destructor:proto.system_info.OperatingSystem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperatingSystem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.version_.Destroy();
  _impl_.arch_.Destroy();
  _impl_.key_.Destroy();
}

void OperatingSystem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperatingSystem::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.OperatingSystem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  _impl_.arch_.ClearToEmpty();
  _impl_.key_.ClearToEmpty();
  _impl_.install_date_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* OperatingSystem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string arch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_arch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int64 install_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.install_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OperatingSystem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.OperatingSystem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.OperatingSystem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.OperatingSystem.version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // string arch = 3;
  if (!this->_internal_arch().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_arch().data(), static_cast<int>(this->_internal_arch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.OperatingSystem.arch");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_arch(), target);
  }

  // string key = 4;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.OperatingSystem.key");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_key(), target);
  }

  // int64 install_date = 5;
  if (this->_internal_install_date() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_install_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.OperatingSystem)
  return target;
}

size_t OperatingSystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.OperatingSystem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string arch = 3;
  if (!this->_internal_arch().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_arch());
  }

  // string key = 4;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // int64 install_date = 5;
  if (this->_internal_install_date() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_install_date());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OperatingSystem::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OperatingSystem*>(
      &from));
}

void OperatingSystem::MergeFrom(const OperatingSystem& from) {
  OperatingSystem* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.OperatingSystem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_arch().empty()) {
    _this->_internal_set_arch(from._internal_arch());
  }
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_install_date() != 0) {
    _this->_internal_set_install_date(from._internal_install_date());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OperatingSystem::CopyFrom(const OperatingSystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.OperatingSystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperatingSystem::IsInitialized() const {
  return true;
}

void OperatingSystem::InternalSwap(OperatingSystem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.arch_, lhs_arena,
      &other->_impl_.arch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.install_date_, other->_impl_.install_date_);
}

std::string OperatingSystem::GetTypeName() const {
  return "proto.system_info.OperatingSystem";
}


// ===================================================================

class Motherboard::_Internal {
 public:
};

Motherboard::Motherboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Motherboard)
}
Motherboard::Motherboard(const Motherboard& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Motherboard* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.manufacturer_){}
    , decltype(_impl_.model_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_manufacturer().empty()) {
    _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Motherboard)
}

inline void Motherboard::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.manufacturer_){}
    , decltype(_impl_.model_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Motherboard::~Motherboard() {
  // @@protoc_insertion_point(destructor:proto.system_info.Motherboard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Motherboard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.manufacturer_.Destroy();
  _impl_.model_.Destroy();
}

void Motherboard::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Motherboard::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Motherboard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.manufacturer_.ClearToEmpty();
  _impl_.model_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Motherboard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Motherboard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Motherboard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string manufacturer = 1;
  if (!this->_internal_manufacturer().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_manufacturer().data(), static_cast<int>(this->_internal_manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Motherboard.manufacturer");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_manufacturer(), target);
  }

  // string model = 2;
  if (!this->_internal_model().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Motherboard.model");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Motherboard)
  return target;
}

size_t Motherboard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Motherboard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string manufacturer = 1;
  if (!this->_internal_manufacturer().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_manufacturer());
  }

  // string model = 2;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Motherboard::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Motherboard*>(
      &from));
}

void Motherboard::MergeFrom(const Motherboard& from) {
  Motherboard* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Motherboard)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_manufacturer().empty()) {
    _this->_internal_set_manufacturer(from._internal_manufacturer());
  }
  if (!from._internal_model().empty()) {
    _this->_internal_set_model(from._internal_model());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Motherboard::CopyFrom(const Motherboard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Motherboard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Motherboard::IsInitialized() const {
  return true;
}

void Motherboard::InternalSwap(Motherboard* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacturer_, lhs_arena,
      &other->_impl_.manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
}

std::string Motherboard::GetTypeName() const {
  return "proto.system_info.Motherboard";
}


// ===================================================================

class Bios::_Internal {
 public:
};

Bios::Bios(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Bios)
}
Bios::Bios(const Bios& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Bios* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vendor_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.date_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_vendor().empty()) {
    _this->_impl_.vendor_.Set(from._internal_vendor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_date().empty()) {
    _this->_impl_.date_.Set(from._internal_date(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Bios)
}

inline void Bios::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vendor_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.date_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Bios::~Bios() {
  // @@protoc_insertion_point(destructor:proto.system_info.Bios)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bios::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vendor_.Destroy();
  _impl_.version_.Destroy();
  _impl_.date_.Destroy();
}

void Bios::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bios::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Bios)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vendor_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  _impl_.date_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Bios::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string vendor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bios::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Bios)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string vendor = 1;
  if (!this->_internal_vendor().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vendor().data(), static_cast<int>(this->_internal_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Bios.vendor");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vendor(), target);
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Bios.version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // string date = 3;
  if (!this->_internal_date().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_date().data(), static_cast<int>(this->_internal_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Bios.date");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Bios)
  return target;
}

size_t Bios::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Bios)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vendor = 1;
  if (!this->_internal_vendor().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vendor());
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string date = 3;
  if (!this->_internal_date().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_date());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Bios::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Bios*>(
      &from));
}

void Bios::MergeFrom(const Bios& from) {
  Bios* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Bios)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_vendor().empty()) {
    _this->_internal_set_vendor(from._internal_vendor());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_date().empty()) {
    _this->_internal_set_date(from._internal_date());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Bios::CopyFrom(const Bios& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Bios)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bios::IsInitialized() const {
  return true;
}

void Bios::InternalSwap(Bios* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vendor_, lhs_arena,
      &other->_impl_.vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.date_, lhs_arena,
      &other->_impl_.date_, rhs_arena
  );
}

std::string Bios::GetTypeName() const {
  return "proto.system_info.Bios";
}


// ===================================================================

class Processor::_Internal {
 public:
};

Processor::Processor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Processor)
}
Processor::Processor(const Processor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Processor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vendor_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.packages_){}
    , decltype(_impl_.cores_){}
    , decltype(_impl_.threads_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_vendor().empty()) {
    _this->_impl_.vendor_.Set(from._internal_vendor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.packages_, &from._impl_.packages_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threads_) -
    reinterpret_cast<char*>(&_impl_.packages_)) + sizeof(_impl_.threads_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Processor)
}

inline void Processor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vendor_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.packages_){0u}
    , decltype(_impl_.cores_){0u}
    , decltype(_impl_.threads_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Processor::~Processor() {
  // @@protoc_insertion_point(destructor:proto.system_info.Processor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Processor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vendor_.Destroy();
  _impl_.model_.Destroy();
}

void Processor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Processor::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Processor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vendor_.ClearToEmpty();
  _impl_.model_.ClearToEmpty();
  ::memset(&_impl_.packages_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.threads_) -
      reinterpret_cast<char*>(&_impl_.packages_)) + sizeof(_impl_.threads_));
  _internal_metadata_.Clear<std::string>();
}

const char* Processor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string vendor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 packages = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.packages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 cores = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.cores_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 threads = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Processor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Processor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string vendor = 1;
  if (!this->_internal_vendor().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vendor().data(), static_cast<int>(this->_internal_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Processor.vendor");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vendor(), target);
  }

  // string model = 2;
  if (!this->_internal_model().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Processor.model");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model(), target);
  }

  // uint32 packages = 3;
  if (this->_internal_packages() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_packages(), target);
  }

  // uint32 cores = 4;
  if (this->_internal_cores() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cores(), target);
  }

  // uint32 threads = 5;
  if (this->_internal_threads() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_threads(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Processor)
  return target;
}

size_t Processor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Processor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vendor = 1;
  if (!this->_internal_vendor().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vendor());
  }

  // string model = 2;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model());
  }

  // uint32 packages = 3;
  if (this->_internal_packages() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_packages());
  }

  // uint32 cores = 4;
  if (this->_internal_cores() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cores());
  }

  // uint32 threads = 5;
  if (this->_internal_threads() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_threads());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Processor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Processor*>(
      &from));
}

void Processor::MergeFrom(const Processor& from) {
  Processor* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Processor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_vendor().empty()) {
    _this->_internal_set_vendor(from._internal_vendor());
  }
  if (!from._internal_model().empty()) {
    _this->_internal_set_model(from._internal_model());
  }
  if (from._internal_packages() != 0) {
    _this->_internal_set_packages(from._internal_packages());
  }
  if (from._internal_cores() != 0) {
    _this->_internal_set_cores(from._internal_cores());
  }
  if (from._internal_threads() != 0) {
    _this->_internal_set_threads(from._internal_threads());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Processor::CopyFrom(const Processor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Processor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Processor::IsInitialized() const {
  return true;
}

void Processor::InternalSwap(Processor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vendor_, lhs_arena,
      &other->_impl_.vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Processor, _impl_.threads_)
      + sizeof(Processor::_impl_.threads_)
      - PROTOBUF_FIELD_OFFSET(Processor, _impl_.packages_)>(
          reinterpret_cast<char*>(&_impl_.packages_),
          reinterpret_cast<char*>(&other->_impl_.packages_));
}

std::string Processor::GetTypeName() const {
  return "proto.system_info.Processor";
}


// ===================================================================

class Memory_Module::_Internal {
 public:
};

Memory_Module::Memory_Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Memory.Module)
}
Memory_Module::Memory_Module(const Memory_Module& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Memory_Module* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.form_factor_){}
    , decltype(_impl_.part_number_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.present_){}
    , decltype(_impl_.speed_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_location().empty()) {
    _this->_impl_.location_.Set(from._internal_location(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_manufacturer().empty()) {
    _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.form_factor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_factor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_form_factor().empty()) {
    _this->_impl_.form_factor_.Set(from._internal_form_factor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.part_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.part_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_part_number().empty()) {
    _this->_impl_.part_number_.Set(from._internal_part_number(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.speed_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Memory.Module)
}

inline void Memory_Module::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.form_factor_){}
    , decltype(_impl_.part_number_){}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.present_){false}
    , decltype(_impl_.speed_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.form_factor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_factor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.part_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.part_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Memory_Module::~Memory_Module() {
  // @@protoc_insertion_point(destructor:proto.system_info.Memory.Module)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Memory_Module::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.location_.Destroy();
  _impl_.manufacturer_.Destroy();
  _impl_.type_.Destroy();
  _impl_.form_factor_.Destroy();
  _impl_.part_number_.Destroy();
}

void Memory_Module::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Memory_Module::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Memory.Module)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.location_.ClearToEmpty();
  _impl_.manufacturer_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.form_factor_.ClearToEmpty();
  _impl_.part_number_.ClearToEmpty();
  ::memset(&_impl_.size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.speed_) -
      reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.speed_));
  _internal_metadata_.Clear<std::string>();
}

const char* Memory_Module::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool present = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string manufacturer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string form_factor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_form_factor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string part_number = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_part_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 speed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Memory_Module::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Memory.Module)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool present = 1;
  if (this->_internal_present() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_present(), target);
  }

  // string location = 2;
  if (!this->_internal_location().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Memory.Module.location");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_location(), target);
  }

  // string manufacturer = 3;
  if (!this->_internal_manufacturer().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_manufacturer().data(), static_cast<int>(this->_internal_manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Memory.Module.manufacturer");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_manufacturer(), target);
  }

  // uint64 size = 4;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_size(), target);
  }

  // string type = 5;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Memory.Module.type");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_type(), target);
  }

  // string form_factor = 6;
  if (!this->_internal_form_factor().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_form_factor().data(), static_cast<int>(this->_internal_form_factor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Memory.Module.form_factor");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_form_factor(), target);
  }

  // string part_number = 7;
  if (!this->_internal_part_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_part_number().data(), static_cast<int>(this->_internal_part_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Memory.Module.part_number");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_part_number(), target);
  }

  // uint32 speed = 8;
  if (this->_internal_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Memory.Module)
  return target;
}

size_t Memory_Module::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Memory.Module)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string location = 2;
  if (!this->_internal_location().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_location());
  }

  // string manufacturer = 3;
  if (!this->_internal_manufacturer().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_manufacturer());
  }

  // string type = 5;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string form_factor = 6;
  if (!this->_internal_form_factor().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_form_factor());
  }

  // string part_number = 7;
  if (!this->_internal_part_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_part_number());
  }

  // uint64 size = 4;
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  // bool present = 1;
  if (this->_internal_present() != 0) {
    total_size += 1 + 1;
  }

  // uint32 speed = 8;
  if (this->_internal_speed() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_speed());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Memory_Module::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Memory_Module*>(
      &from));
}

void Memory_Module::MergeFrom(const Memory_Module& from) {
  Memory_Module* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Memory.Module)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_location().empty()) {
    _this->_internal_set_location(from._internal_location());
  }
  if (!from._internal_manufacturer().empty()) {
    _this->_internal_set_manufacturer(from._internal_manufacturer());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_form_factor().empty()) {
    _this->_internal_set_form_factor(from._internal_form_factor());
  }
  if (!from._internal_part_number().empty()) {
    _this->_internal_set_part_number(from._internal_part_number());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  if (from._internal_present() != 0) {
    _this->_internal_set_present(from._internal_present());
  }
  if (from._internal_speed() != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Memory_Module::CopyFrom(const Memory_Module& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Memory.Module)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Memory_Module::IsInitialized() const {
  return true;
}

void Memory_Module::InternalSwap(Memory_Module* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.location_, lhs_arena,
      &other->_impl_.location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacturer_, lhs_arena,
      &other->_impl_.manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.form_factor_, lhs_arena,
      &other->_impl_.form_factor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.part_number_, lhs_arena,
      &other->_impl_.part_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Memory_Module, _impl_.speed_)
      + sizeof(Memory_Module::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(Memory_Module, _impl_.size_)>(
          reinterpret_cast<char*>(&_impl_.size_),
          reinterpret_cast<char*>(&other->_impl_.size_));
}

std::string Memory_Module::GetTypeName() const {
  return "proto.system_info.Memory.Module";
}


// ===================================================================

class Memory::_Internal {
 public:
};

Memory::Memory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Memory)
}
Memory::Memory(const Memory& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Memory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.module_){from._impl_.module_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Memory)
}

inline void Memory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.module_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Memory::~Memory() {
  // @@protoc_insertion_point(destructor:proto.system_info.Memory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Memory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.module_.~RepeatedPtrField();
}

void Memory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Memory::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Memory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.module_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Memory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Memory.Module module = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_module(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Memory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Memory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Memory.Module module = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_module_size()); i < n; i++) {
    const auto& repfield = this->_internal_module(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Memory)
  return target;
}

size_t Memory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Memory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Memory.Module module = 1;
  total_size += 1UL * this->_internal_module_size();
  for (const auto& msg : this->_impl_.module_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Memory::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Memory*>(
      &from));
}

void Memory::MergeFrom(const Memory& from) {
  Memory* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Memory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.module_.MergeFrom(from._impl_.module_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Memory::CopyFrom(const Memory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Memory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Memory::IsInitialized() const {
  return true;
}

void Memory::InternalSwap(Memory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.module_.InternalSwap(&other->_impl_.module_);
}

std::string Memory::GetTypeName() const {
  return "proto.system_info.Memory";
}


// ===================================================================

class LogicalDrives_Drive::_Internal {
 public:
};

LogicalDrives_Drive::LogicalDrives_Drive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LogicalDrives.Drive)
}
LogicalDrives_Drive::LogicalDrives_Drive(const LogicalDrives_Drive& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LogicalDrives_Drive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.file_system_){}
    , decltype(_impl_.total_size_){}
    , decltype(_impl_.free_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_system_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_system_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_system().empty()) {
    _this->_impl_.file_system_.Set(from._internal_file_system(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.total_size_, &from._impl_.total_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.free_size_) -
    reinterpret_cast<char*>(&_impl_.total_size_)) + sizeof(_impl_.free_size_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LogicalDrives.Drive)
}

inline void LogicalDrives_Drive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.file_system_){}
    , decltype(_impl_.total_size_){uint64_t{0u}}
    , decltype(_impl_.free_size_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_system_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_system_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LogicalDrives_Drive::~LogicalDrives_Drive() {
  // @@protoc_insertion_point(destructor:proto.system_info.LogicalDrives.Drive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalDrives_Drive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.file_system_.Destroy();
}

void LogicalDrives_Drive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalDrives_Drive::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LogicalDrives.Drive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _impl_.file_system_.ClearToEmpty();
  ::memset(&_impl_.total_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.free_size_) -
      reinterpret_cast<char*>(&_impl_.total_size_)) + sizeof(_impl_.free_size_));
  _internal_metadata_.Clear<std::string>();
}

const char* LogicalDrives_Drive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string file_system = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_system();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 total_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.total_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 free_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.free_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalDrives_Drive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LogicalDrives.Drive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LogicalDrives.Drive.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // string file_system = 2;
  if (!this->_internal_file_system().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_system().data(), static_cast<int>(this->_internal_file_system().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LogicalDrives.Drive.file_system");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_system(), target);
  }

  // uint64 total_size = 3;
  if (this->_internal_total_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_total_size(), target);
  }

  // uint64 free_size = 4;
  if (this->_internal_free_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_free_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LogicalDrives.Drive)
  return target;
}

size_t LogicalDrives_Drive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LogicalDrives.Drive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // string file_system = 2;
  if (!this->_internal_file_system().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_system());
  }

  // uint64 total_size = 3;
  if (this->_internal_total_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_size());
  }

  // uint64 free_size = 4;
  if (this->_internal_free_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_free_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalDrives_Drive::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LogicalDrives_Drive*>(
      &from));
}

void LogicalDrives_Drive::MergeFrom(const LogicalDrives_Drive& from) {
  LogicalDrives_Drive* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LogicalDrives.Drive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (!from._internal_file_system().empty()) {
    _this->_internal_set_file_system(from._internal_file_system());
  }
  if (from._internal_total_size() != 0) {
    _this->_internal_set_total_size(from._internal_total_size());
  }
  if (from._internal_free_size() != 0) {
    _this->_internal_set_free_size(from._internal_free_size());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalDrives_Drive::CopyFrom(const LogicalDrives_Drive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LogicalDrives.Drive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalDrives_Drive::IsInitialized() const {
  return true;
}

void LogicalDrives_Drive::InternalSwap(LogicalDrives_Drive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_system_, lhs_arena,
      &other->_impl_.file_system_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalDrives_Drive, _impl_.free_size_)
      + sizeof(LogicalDrives_Drive::_impl_.free_size_)
      - PROTOBUF_FIELD_OFFSET(LogicalDrives_Drive, _impl_.total_size_)>(
          reinterpret_cast<char*>(&_impl_.total_size_),
          reinterpret_cast<char*>(&other->_impl_.total_size_));
}

std::string LogicalDrives_Drive::GetTypeName() const {
  return "proto.system_info.LogicalDrives.Drive";
}


// ===================================================================

class LogicalDrives::_Internal {
 public:
};

LogicalDrives::LogicalDrives(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LogicalDrives)
}
LogicalDrives::LogicalDrives(const LogicalDrives& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LogicalDrives* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.drive_){from._impl_.drive_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LogicalDrives)
}

inline void LogicalDrives::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.drive_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LogicalDrives::~LogicalDrives() {
  // @@protoc_insertion_point(destructor:proto.system_info.LogicalDrives)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalDrives::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drive_.~RepeatedPtrField();
}

void LogicalDrives::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalDrives::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LogicalDrives)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drive_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LogicalDrives::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.LogicalDrives.Drive drive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drive(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalDrives::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LogicalDrives)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.LogicalDrives.Drive drive = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drive_size()); i < n; i++) {
    const auto& repfield = this->_internal_drive(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LogicalDrives)
  return target;
}

size_t LogicalDrives::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LogicalDrives)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.LogicalDrives.Drive drive = 1;
  total_size += 1UL * this->_internal_drive_size();
  for (const auto& msg : this->_impl_.drive_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalDrives::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LogicalDrives*>(
      &from));
}

void LogicalDrives::MergeFrom(const LogicalDrives& from) {
  LogicalDrives* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LogicalDrives)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drive_.MergeFrom(from._impl_.drive_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalDrives::CopyFrom(const LogicalDrives& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LogicalDrives)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalDrives::IsInitialized() const {
  return true;
}

void LogicalDrives::InternalSwap(LogicalDrives* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.drive_.InternalSwap(&other->_impl_.drive_);
}

std::string LogicalDrives::GetTypeName() const {
  return "proto.system_info.LogicalDrives";
}


// ===================================================================

class Printers_Printer::_Internal {
 public:
};

Printers_Printer::Printers_Printer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Printers.Printer)
}
Printers_Printer::Printers_Printer(const Printers_Printer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Printers_Printer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.share_name_){}
    , decltype(_impl_.default__){}
    , decltype(_impl_.shared_){}
    , decltype(_impl_.jobs_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_port().empty()) {
    _this->_impl_.port_.Set(from._internal_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver().empty()) {
    _this->_impl_.driver_.Set(from._internal_driver(), 
      _this->GetArenaForAllocation());
  }
  _impl_.share_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_share_name().empty()) {
    _this->_impl_.share_name_.Set(from._internal_share_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.default__, &from._impl_.default__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.jobs_count_) -
    reinterpret_cast<char*>(&_impl_.default__)) + sizeof(_impl_.jobs_count_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Printers.Printer)
}

inline void Printers_Printer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.share_name_){}
    , decltype(_impl_.default__){false}
    , decltype(_impl_.shared_){false}
    , decltype(_impl_.jobs_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.share_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Printers_Printer::~Printers_Printer() {
  // @@protoc_insertion_point(destructor:proto.system_info.Printers.Printer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Printers_Printer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.port_.Destroy();
  _impl_.driver_.Destroy();
  _impl_.share_name_.Destroy();
}

void Printers_Printer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Printers_Printer::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Printers.Printer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.port_.ClearToEmpty();
  _impl_.driver_.ClearToEmpty();
  _impl_.share_name_.ClearToEmpty();
  ::memset(&_impl_.default__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.jobs_count_) -
      reinterpret_cast<char*>(&_impl_.default__)) + sizeof(_impl_.jobs_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* Printers_Printer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool default = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.default__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool shared = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.shared_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_driver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 jobs_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.jobs_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string share_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_share_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Printers_Printer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Printers.Printer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Printers.Printer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool default = 2;
  if (this->_internal_default_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_default_(), target);
  }

  // bool shared = 3;
  if (this->_internal_shared() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_shared(), target);
  }

  // string port = 4;
  if (!this->_internal_port().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_port().data(), static_cast<int>(this->_internal_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Printers.Printer.port");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_port(), target);
  }

  // string driver = 5;
  if (!this->_internal_driver().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver().data(), static_cast<int>(this->_internal_driver().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Printers.Printer.driver");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_driver(), target);
  }

  // uint32 jobs_count = 6;
  if (this->_internal_jobs_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_jobs_count(), target);
  }

  // string share_name = 7;
  if (!this->_internal_share_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_share_name().data(), static_cast<int>(this->_internal_share_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Printers.Printer.share_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_share_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Printers.Printer)
  return target;
}

size_t Printers_Printer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Printers.Printer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string port = 4;
  if (!this->_internal_port().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());
  }

  // string driver = 5;
  if (!this->_internal_driver().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver());
  }

  // string share_name = 7;
  if (!this->_internal_share_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_share_name());
  }

  // bool default = 2;
  if (this->_internal_default_() != 0) {
    total_size += 1 + 1;
  }

  // bool shared = 3;
  if (this->_internal_shared() != 0) {
    total_size += 1 + 1;
  }

  // uint32 jobs_count = 6;
  if (this->_internal_jobs_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_jobs_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Printers_Printer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Printers_Printer*>(
      &from));
}

void Printers_Printer::MergeFrom(const Printers_Printer& from) {
  Printers_Printer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Printers.Printer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_port().empty()) {
    _this->_internal_set_port(from._internal_port());
  }
  if (!from._internal_driver().empty()) {
    _this->_internal_set_driver(from._internal_driver());
  }
  if (!from._internal_share_name().empty()) {
    _this->_internal_set_share_name(from._internal_share_name());
  }
  if (from._internal_default_() != 0) {
    _this->_internal_set_default_(from._internal_default_());
  }
  if (from._internal_shared() != 0) {
    _this->_internal_set_shared(from._internal_shared());
  }
  if (from._internal_jobs_count() != 0) {
    _this->_internal_set_jobs_count(from._internal_jobs_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Printers_Printer::CopyFrom(const Printers_Printer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Printers.Printer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Printers_Printer::IsInitialized() const {
  return true;
}

void Printers_Printer::InternalSwap(Printers_Printer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.port_, lhs_arena,
      &other->_impl_.port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_, lhs_arena,
      &other->_impl_.driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.share_name_, lhs_arena,
      &other->_impl_.share_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Printers_Printer, _impl_.jobs_count_)
      + sizeof(Printers_Printer::_impl_.jobs_count_)
      - PROTOBUF_FIELD_OFFSET(Printers_Printer, _impl_.default__)>(
          reinterpret_cast<char*>(&_impl_.default__),
          reinterpret_cast<char*>(&other->_impl_.default__));
}

std::string Printers_Printer::GetTypeName() const {
  return "proto.system_info.Printers.Printer";
}


// ===================================================================

class Printers::_Internal {
 public:
};

Printers::Printers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Printers)
}
Printers::Printers(const Printers& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Printers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.printer_){from._impl_.printer_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Printers)
}

inline void Printers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.printer_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Printers::~Printers() {
  // @@protoc_insertion_point(destructor:proto.system_info.Printers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Printers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.printer_.~RepeatedPtrField();
}

void Printers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Printers::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Printers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.printer_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Printers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Printers.Printer printer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_printer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Printers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Printers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Printers.Printer printer = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_printer_size()); i < n; i++) {
    const auto& repfield = this->_internal_printer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Printers)
  return target;
}

size_t Printers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Printers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Printers.Printer printer = 1;
  total_size += 1UL * this->_internal_printer_size();
  for (const auto& msg : this->_impl_.printer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Printers::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Printers*>(
      &from));
}

void Printers::MergeFrom(const Printers& from) {
  Printers* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Printers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.printer_.MergeFrom(from._impl_.printer_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Printers::CopyFrom(const Printers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Printers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Printers::IsInitialized() const {
  return true;
}

void Printers::InternalSwap(Printers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.printer_.InternalSwap(&other->_impl_.printer_);
}

std::string Printers::GetTypeName() const {
  return "proto.system_info.Printers";
}


// ===================================================================

class NetworkAdapters_Adapter_Address::_Internal {
 public:
};

NetworkAdapters_Adapter_Address::NetworkAdapters_Adapter_Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.NetworkAdapters.Adapter.Address)
}
NetworkAdapters_Adapter_Address::NetworkAdapters_Adapter_Address(const NetworkAdapters_Adapter_Address& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkAdapters_Adapter_Address* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.mask_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ip().empty()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mask().empty()) {
    _this->_impl_.mask_.Set(from._internal_mask(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.NetworkAdapters.Adapter.Address)
}

inline void NetworkAdapters_Adapter_Address::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.mask_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkAdapters_Adapter_Address::~NetworkAdapters_Adapter_Address() {
  // @@protoc_insertion_point(destructor:proto.system_info.NetworkAdapters.Adapter.Address)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkAdapters_Adapter_Address::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
  _impl_.mask_.Destroy();
}

void NetworkAdapters_Adapter_Address::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkAdapters_Adapter_Address::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.NetworkAdapters.Adapter.Address)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ip_.ClearToEmpty();
  _impl_.mask_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkAdapters_Adapter_Address::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string mask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mask();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkAdapters_Adapter_Address::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.NetworkAdapters.Adapter.Address)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ip = 1;
  if (!this->_internal_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.Address.ip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // string mask = 2;
  if (!this->_internal_mask().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mask().data(), static_cast<int>(this->_internal_mask().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.Address.mask");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.NetworkAdapters.Adapter.Address)
  return target;
}

size_t NetworkAdapters_Adapter_Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.NetworkAdapters.Adapter.Address)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ip = 1;
  if (!this->_internal_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  // string mask = 2;
  if (!this->_internal_mask().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mask());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkAdapters_Adapter_Address::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkAdapters_Adapter_Address*>(
      &from));
}

void NetworkAdapters_Adapter_Address::MergeFrom(const NetworkAdapters_Adapter_Address& from) {
  NetworkAdapters_Adapter_Address* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.NetworkAdapters.Adapter.Address)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ip().empty()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (!from._internal_mask().empty()) {
    _this->_internal_set_mask(from._internal_mask());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkAdapters_Adapter_Address::CopyFrom(const NetworkAdapters_Adapter_Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.NetworkAdapters.Adapter.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkAdapters_Adapter_Address::IsInitialized() const {
  return true;
}

void NetworkAdapters_Adapter_Address::InternalSwap(NetworkAdapters_Adapter_Address* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mask_, lhs_arena,
      &other->_impl_.mask_, rhs_arena
  );
}

std::string NetworkAdapters_Adapter_Address::GetTypeName() const {
  return "proto.system_info.NetworkAdapters.Adapter.Address";
}


// ===================================================================

class NetworkAdapters_Adapter::_Internal {
 public:
};

NetworkAdapters_Adapter::NetworkAdapters_Adapter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.NetworkAdapters.Adapter)
}
NetworkAdapters_Adapter::NetworkAdapters_Adapter(const NetworkAdapters_Adapter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkAdapters_Adapter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gateway_){from._impl_.gateway_}
    , decltype(_impl_.address_){from._impl_.address_}
    , decltype(_impl_.dns_){from._impl_.dns_}
    , decltype(_impl_.dhcp_){from._impl_.dhcp_}
    , decltype(_impl_.adapter_name_){}
    , decltype(_impl_.connection_name_){}
    , decltype(_impl_.iface_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.dhcp_enabled_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.adapter_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.adapter_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_adapter_name().empty()) {
    _this->_impl_.adapter_name_.Set(from._internal_adapter_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.connection_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.connection_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_connection_name().empty()) {
    _this->_impl_.connection_name_.Set(from._internal_connection_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.iface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_iface().empty()) {
    _this->_impl_.iface_.Set(from._internal_iface(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.speed_, &from._impl_.speed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dhcp_enabled_) -
    reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.dhcp_enabled_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.NetworkAdapters.Adapter)
}

inline void NetworkAdapters_Adapter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gateway_){arena}
    , decltype(_impl_.address_){arena}
    , decltype(_impl_.dns_){arena}
    , decltype(_impl_.dhcp_){arena}
    , decltype(_impl_.adapter_name_){}
    , decltype(_impl_.connection_name_){}
    , decltype(_impl_.iface_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.speed_){uint64_t{0u}}
    , decltype(_impl_.dhcp_enabled_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.adapter_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.adapter_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connection_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.connection_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkAdapters_Adapter::~NetworkAdapters_Adapter() {
  // @@protoc_insertion_point(destructor:proto.system_info.NetworkAdapters.Adapter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkAdapters_Adapter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gateway_.~RepeatedPtrField();
  _impl_.address_.~RepeatedPtrField();
  _impl_.dns_.~RepeatedPtrField();
  _impl_.dhcp_.~RepeatedPtrField();
  _impl_.adapter_name_.Destroy();
  _impl_.connection_name_.Destroy();
  _impl_.iface_.Destroy();
  _impl_.mac_.Destroy();
}

void NetworkAdapters_Adapter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkAdapters_Adapter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.NetworkAdapters.Adapter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gateway_.Clear();
  _impl_.address_.Clear();
  _impl_.dns_.Clear();
  _impl_.dhcp_.Clear();
  _impl_.adapter_name_.ClearToEmpty();
  _impl_.connection_name_.ClearToEmpty();
  _impl_.iface_.ClearToEmpty();
  _impl_.mac_.ClearToEmpty();
  ::memset(&_impl_.speed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dhcp_enabled_) -
      reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.dhcp_enabled_));
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkAdapters_Adapter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string adapter_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_adapter_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string connection_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_connection_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string iface = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_iface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 speed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string mac = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool dhcp_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.dhcp_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string gateway = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_gateway();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.system_info.NetworkAdapters.Adapter.Address address = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_address(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string dns = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_dns();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string dhcp = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_dhcp();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkAdapters_Adapter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.NetworkAdapters.Adapter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string adapter_name = 1;
  if (!this->_internal_adapter_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_adapter_name().data(), static_cast<int>(this->_internal_adapter_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.adapter_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_adapter_name(), target);
  }

  // string connection_name = 2;
  if (!this->_internal_connection_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_connection_name().data(), static_cast<int>(this->_internal_connection_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.connection_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_connection_name(), target);
  }

  // string iface = 3;
  if (!this->_internal_iface().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_iface().data(), static_cast<int>(this->_internal_iface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.iface");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_iface(), target);
  }

  // uint64 speed = 4;
  if (this->_internal_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_speed(), target);
  }

  // string mac = 5;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.mac");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_mac(), target);
  }

  // bool dhcp_enabled = 6;
  if (this->_internal_dhcp_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_dhcp_enabled(), target);
  }

  // repeated string gateway = 7;
  for (int i = 0, n = this->_internal_gateway_size(); i < n; i++) {
    const auto& s = this->_internal_gateway(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.gateway");
    target = stream->WriteString(7, s, target);
  }

  // repeated .proto.system_info.NetworkAdapters.Adapter.Address address = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_address_size()); i < n; i++) {
    const auto& repfield = this->_internal_address(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string dns = 9;
  for (int i = 0, n = this->_internal_dns_size(); i < n; i++) {
    const auto& s = this->_internal_dns(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.dns");
    target = stream->WriteString(9, s, target);
  }

  // repeated string dhcp = 10;
  for (int i = 0, n = this->_internal_dhcp_size(); i < n; i++) {
    const auto& s = this->_internal_dhcp(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkAdapters.Adapter.dhcp");
    target = stream->WriteString(10, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.NetworkAdapters.Adapter)
  return target;
}

size_t NetworkAdapters_Adapter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.NetworkAdapters.Adapter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string gateway = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.gateway_.size());
  for (int i = 0, n = _impl_.gateway_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.gateway_.Get(i));
  }

  // repeated .proto.system_info.NetworkAdapters.Adapter.Address address = 8;
  total_size += 1UL * this->_internal_address_size();
  for (const auto& msg : this->_impl_.address_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string dns = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.dns_.size());
  for (int i = 0, n = _impl_.dns_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.dns_.Get(i));
  }

  // repeated string dhcp = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.dhcp_.size());
  for (int i = 0, n = _impl_.dhcp_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.dhcp_.Get(i));
  }

  // string adapter_name = 1;
  if (!this->_internal_adapter_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_adapter_name());
  }

  // string connection_name = 2;
  if (!this->_internal_connection_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_connection_name());
  }

  // string iface = 3;
  if (!this->_internal_iface().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_iface());
  }

  // string mac = 5;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  // uint64 speed = 4;
  if (this->_internal_speed() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_speed());
  }

  // bool dhcp_enabled = 6;
  if (this->_internal_dhcp_enabled() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkAdapters_Adapter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkAdapters_Adapter*>(
      &from));
}

void NetworkAdapters_Adapter::MergeFrom(const NetworkAdapters_Adapter& from) {
  NetworkAdapters_Adapter* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.NetworkAdapters.Adapter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gateway_.MergeFrom(from._impl_.gateway_);
  _this->_impl_.address_.MergeFrom(from._impl_.address_);
  _this->_impl_.dns_.MergeFrom(from._impl_.dns_);
  _this->_impl_.dhcp_.MergeFrom(from._impl_.dhcp_);
  if (!from._internal_adapter_name().empty()) {
    _this->_internal_set_adapter_name(from._internal_adapter_name());
  }
  if (!from._internal_connection_name().empty()) {
    _this->_internal_set_connection_name(from._internal_connection_name());
  }
  if (!from._internal_iface().empty()) {
    _this->_internal_set_iface(from._internal_iface());
  }
  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  if (from._internal_speed() != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_dhcp_enabled() != 0) {
    _this->_internal_set_dhcp_enabled(from._internal_dhcp_enabled());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkAdapters_Adapter::CopyFrom(const NetworkAdapters_Adapter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.NetworkAdapters.Adapter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkAdapters_Adapter::IsInitialized() const {
  return true;
}

void NetworkAdapters_Adapter::InternalSwap(NetworkAdapters_Adapter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gateway_.InternalSwap(&other->_impl_.gateway_);
  _impl_.address_.InternalSwap(&other->_impl_.address_);
  _impl_.dns_.InternalSwap(&other->_impl_.dns_);
  _impl_.dhcp_.InternalSwap(&other->_impl_.dhcp_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.adapter_name_, lhs_arena,
      &other->_impl_.adapter_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.connection_name_, lhs_arena,
      &other->_impl_.connection_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iface_, lhs_arena,
      &other->_impl_.iface_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetworkAdapters_Adapter, _impl_.dhcp_enabled_)
      + sizeof(NetworkAdapters_Adapter::_impl_.dhcp_enabled_)
      - PROTOBUF_FIELD_OFFSET(NetworkAdapters_Adapter, _impl_.speed_)>(
          reinterpret_cast<char*>(&_impl_.speed_),
          reinterpret_cast<char*>(&other->_impl_.speed_));
}

std::string NetworkAdapters_Adapter::GetTypeName() const {
  return "proto.system_info.NetworkAdapters.Adapter";
}


// ===================================================================

class NetworkAdapters::_Internal {
 public:
};

NetworkAdapters::NetworkAdapters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.NetworkAdapters)
}
NetworkAdapters::NetworkAdapters(const NetworkAdapters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkAdapters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.adapter_){from._impl_.adapter_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.NetworkAdapters)
}

inline void NetworkAdapters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.adapter_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NetworkAdapters::~NetworkAdapters() {
  // @@protoc_insertion_point(destructor:proto.system_info.NetworkAdapters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkAdapters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.adapter_.~RepeatedPtrField();
}

void NetworkAdapters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkAdapters::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.NetworkAdapters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.adapter_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkAdapters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.NetworkAdapters.Adapter adapter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_adapter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkAdapters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.NetworkAdapters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.NetworkAdapters.Adapter adapter = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_adapter_size()); i < n; i++) {
    const auto& repfield = this->_internal_adapter(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.NetworkAdapters)
  return target;
}

size_t NetworkAdapters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.NetworkAdapters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.NetworkAdapters.Adapter adapter = 1;
  total_size += 1UL * this->_internal_adapter_size();
  for (const auto& msg : this->_impl_.adapter_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkAdapters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkAdapters*>(
      &from));
}

void NetworkAdapters::MergeFrom(const NetworkAdapters& from) {
  NetworkAdapters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.NetworkAdapters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.adapter_.MergeFrom(from._impl_.adapter_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkAdapters::CopyFrom(const NetworkAdapters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.NetworkAdapters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkAdapters::IsInitialized() const {
  return true;
}

void NetworkAdapters::InternalSwap(NetworkAdapters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.adapter_.InternalSwap(&other->_impl_.adapter_);
}

std::string NetworkAdapters::GetTypeName() const {
  return "proto.system_info.NetworkAdapters";
}


// ===================================================================

class NetworkShares_Share::_Internal {
 public:
};

NetworkShares_Share::NetworkShares_Share(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.NetworkShares.Share)
}
NetworkShares_Share::NetworkShares_Share(const NetworkShares_Share& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkShares_Share* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.local_path_){}
    , decltype(_impl_.current_uses_){}
    , decltype(_impl_.max_uses_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.local_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_local_path().empty()) {
    _this->_impl_.local_path_.Set(from._internal_local_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.current_uses_, &from._impl_.current_uses_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_uses_) -
    reinterpret_cast<char*>(&_impl_.current_uses_)) + sizeof(_impl_.max_uses_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.NetworkShares.Share)
}

inline void NetworkShares_Share::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.local_path_){}
    , decltype(_impl_.current_uses_){0u}
    , decltype(_impl_.max_uses_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.local_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkShares_Share::~NetworkShares_Share() {
  // @@protoc_insertion_point(destructor:proto.system_info.NetworkShares.Share)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkShares_Share::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.type_.Destroy();
  _impl_.local_path_.Destroy();
}

void NetworkShares_Share::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkShares_Share::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.NetworkShares.Share)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.local_path_.ClearToEmpty();
  ::memset(&_impl_.current_uses_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_uses_) -
      reinterpret_cast<char*>(&_impl_.current_uses_)) + sizeof(_impl_.max_uses_));
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkShares_Share::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string local_path = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_local_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 current_uses = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.current_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_uses = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.max_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkShares_Share::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.NetworkShares.Share)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkShares.Share.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkShares.Share.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // string type = 3;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkShares.Share.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // string local_path = 4;
  if (!this->_internal_local_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_local_path().data(), static_cast<int>(this->_internal_local_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.NetworkShares.Share.local_path");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_local_path(), target);
  }

  // uint32 current_uses = 5;
  if (this->_internal_current_uses() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_current_uses(), target);
  }

  // uint32 max_uses = 6;
  if (this->_internal_max_uses() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_max_uses(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.NetworkShares.Share)
  return target;
}

size_t NetworkShares_Share::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.NetworkShares.Share)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string type = 3;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string local_path = 4;
  if (!this->_internal_local_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_local_path());
  }

  // uint32 current_uses = 5;
  if (this->_internal_current_uses() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_uses());
  }

  // uint32 max_uses = 6;
  if (this->_internal_max_uses() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_uses());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkShares_Share::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkShares_Share*>(
      &from));
}

void NetworkShares_Share::MergeFrom(const NetworkShares_Share& from) {
  NetworkShares_Share* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.NetworkShares.Share)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_local_path().empty()) {
    _this->_internal_set_local_path(from._internal_local_path());
  }
  if (from._internal_current_uses() != 0) {
    _this->_internal_set_current_uses(from._internal_current_uses());
  }
  if (from._internal_max_uses() != 0) {
    _this->_internal_set_max_uses(from._internal_max_uses());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkShares_Share::CopyFrom(const NetworkShares_Share& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.NetworkShares.Share)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkShares_Share::IsInitialized() const {
  return true;
}

void NetworkShares_Share::InternalSwap(NetworkShares_Share* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.local_path_, lhs_arena,
      &other->_impl_.local_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetworkShares_Share, _impl_.max_uses_)
      + sizeof(NetworkShares_Share::_impl_.max_uses_)
      - PROTOBUF_FIELD_OFFSET(NetworkShares_Share, _impl_.current_uses_)>(
          reinterpret_cast<char*>(&_impl_.current_uses_),
          reinterpret_cast<char*>(&other->_impl_.current_uses_));
}

std::string NetworkShares_Share::GetTypeName() const {
  return "proto.system_info.NetworkShares.Share";
}


// ===================================================================

class NetworkShares::_Internal {
 public:
};

NetworkShares::NetworkShares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.NetworkShares)
}
NetworkShares::NetworkShares(const NetworkShares& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkShares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.share_){from._impl_.share_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.NetworkShares)
}

inline void NetworkShares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.share_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NetworkShares::~NetworkShares() {
  // @@protoc_insertion_point(destructor:proto.system_info.NetworkShares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkShares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.share_.~RepeatedPtrField();
}

void NetworkShares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkShares::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.NetworkShares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.share_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkShares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.NetworkShares.Share share = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_share(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkShares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.NetworkShares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.NetworkShares.Share share = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_share_size()); i < n; i++) {
    const auto& repfield = this->_internal_share(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.NetworkShares)
  return target;
}

size_t NetworkShares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.NetworkShares)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.NetworkShares.Share share = 1;
  total_size += 1UL * this->_internal_share_size();
  for (const auto& msg : this->_impl_.share_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkShares::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkShares*>(
      &from));
}

void NetworkShares::MergeFrom(const NetworkShares& from) {
  NetworkShares* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.NetworkShares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.share_.MergeFrom(from._impl_.share_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkShares::CopyFrom(const NetworkShares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.NetworkShares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkShares::IsInitialized() const {
  return true;
}

void NetworkShares::InternalSwap(NetworkShares* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.share_.InternalSwap(&other->_impl_.share_);
}

std::string NetworkShares::GetTypeName() const {
  return "proto.system_info.NetworkShares";
}


// ===================================================================

class WindowsDevices_Device::_Internal {
 public:
};

WindowsDevices_Device::WindowsDevices_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.WindowsDevices.Device)
}
WindowsDevices_Device::WindowsDevices_Device(const WindowsDevices_Device& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WindowsDevices_Device* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.friendly_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.driver_version_){}
    , decltype(_impl_.driver_date_){}
    , decltype(_impl_.driver_vendor_){}
    , decltype(_impl_.device_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_friendly_name().empty()) {
    _this->_impl_.friendly_name_.Set(from._internal_friendly_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver_version().empty()) {
    _this->_impl_.driver_version_.Set(from._internal_driver_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver_date().empty()) {
    _this->_impl_.driver_date_.Set(from._internal_driver_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver_vendor().empty()) {
    _this->_impl_.driver_vendor_.Set(from._internal_driver_vendor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_device_id().empty()) {
    _this->_impl_.device_id_.Set(from._internal_device_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.WindowsDevices.Device)
}

inline void WindowsDevices_Device::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.friendly_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.driver_version_){}
    , decltype(_impl_.driver_date_){}
    , decltype(_impl_.driver_vendor_){}
    , decltype(_impl_.device_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WindowsDevices_Device::~WindowsDevices_Device() {
  // @@protoc_insertion_point(destructor:proto.system_info.WindowsDevices.Device)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WindowsDevices_Device::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.friendly_name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.driver_version_.Destroy();
  _impl_.driver_date_.Destroy();
  _impl_.driver_vendor_.Destroy();
  _impl_.device_id_.Destroy();
}

void WindowsDevices_Device::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WindowsDevices_Device::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.WindowsDevices.Device)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.friendly_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.driver_version_.ClearToEmpty();
  _impl_.driver_date_.ClearToEmpty();
  _impl_.driver_vendor_.ClearToEmpty();
  _impl_.device_id_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* WindowsDevices_Device::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string friendly_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_driver_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver_date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_driver_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver_vendor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_driver_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string device_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WindowsDevices_Device::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.WindowsDevices.Device)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string friendly_name = 1;
  if (!this->_internal_friendly_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.WindowsDevices.Device.friendly_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_friendly_name(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.WindowsDevices.Device.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // string driver_version = 3;
  if (!this->_internal_driver_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver_version().data(), static_cast<int>(this->_internal_driver_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.WindowsDevices.Device.driver_version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_driver_version(), target);
  }

  // string driver_date = 4;
  if (!this->_internal_driver_date().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver_date().data(), static_cast<int>(this->_internal_driver_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.WindowsDevices.Device.driver_date");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_driver_date(), target);
  }

  // string driver_vendor = 5;
  if (!this->_internal_driver_vendor().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver_vendor().data(), static_cast<int>(this->_internal_driver_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.WindowsDevices.Device.driver_vendor");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_driver_vendor(), target);
  }

  // string device_id = 6;
  if (!this->_internal_device_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.WindowsDevices.Device.device_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.WindowsDevices.Device)
  return target;
}

size_t WindowsDevices_Device::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.WindowsDevices.Device)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string friendly_name = 1;
  if (!this->_internal_friendly_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_friendly_name());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string driver_version = 3;
  if (!this->_internal_driver_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver_version());
  }

  // string driver_date = 4;
  if (!this->_internal_driver_date().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver_date());
  }

  // string driver_vendor = 5;
  if (!this->_internal_driver_vendor().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver_vendor());
  }

  // string device_id = 6;
  if (!this->_internal_device_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WindowsDevices_Device::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WindowsDevices_Device*>(
      &from));
}

void WindowsDevices_Device::MergeFrom(const WindowsDevices_Device& from) {
  WindowsDevices_Device* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.WindowsDevices.Device)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_friendly_name().empty()) {
    _this->_internal_set_friendly_name(from._internal_friendly_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_driver_version().empty()) {
    _this->_internal_set_driver_version(from._internal_driver_version());
  }
  if (!from._internal_driver_date().empty()) {
    _this->_internal_set_driver_date(from._internal_driver_date());
  }
  if (!from._internal_driver_vendor().empty()) {
    _this->_internal_set_driver_vendor(from._internal_driver_vendor());
  }
  if (!from._internal_device_id().empty()) {
    _this->_internal_set_device_id(from._internal_device_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WindowsDevices_Device::CopyFrom(const WindowsDevices_Device& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.WindowsDevices.Device)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowsDevices_Device::IsInitialized() const {
  return true;
}

void WindowsDevices_Device::InternalSwap(WindowsDevices_Device* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.friendly_name_, lhs_arena,
      &other->_impl_.friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_version_, lhs_arena,
      &other->_impl_.driver_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_date_, lhs_arena,
      &other->_impl_.driver_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_vendor_, lhs_arena,
      &other->_impl_.driver_vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_id_, lhs_arena,
      &other->_impl_.device_id_, rhs_arena
  );
}

std::string WindowsDevices_Device::GetTypeName() const {
  return "proto.system_info.WindowsDevices.Device";
}


// ===================================================================

class WindowsDevices::_Internal {
 public:
};

WindowsDevices::WindowsDevices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.WindowsDevices)
}
WindowsDevices::WindowsDevices(const WindowsDevices& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WindowsDevices* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_){from._impl_.device_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.WindowsDevices)
}

inline void WindowsDevices::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WindowsDevices::~WindowsDevices() {
  // @@protoc_insertion_point(destructor:proto.system_info.WindowsDevices)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WindowsDevices::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_.~RepeatedPtrField();
}

void WindowsDevices::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WindowsDevices::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.WindowsDevices)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WindowsDevices::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.WindowsDevices.Device device = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_device(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WindowsDevices::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.WindowsDevices)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.WindowsDevices.Device device = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_device_size()); i < n; i++) {
    const auto& repfield = this->_internal_device(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.WindowsDevices)
  return target;
}

size_t WindowsDevices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.WindowsDevices)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.WindowsDevices.Device device = 1;
  total_size += 1UL * this->_internal_device_size();
  for (const auto& msg : this->_impl_.device_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WindowsDevices::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WindowsDevices*>(
      &from));
}

void WindowsDevices::MergeFrom(const WindowsDevices& from) {
  WindowsDevices* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.WindowsDevices)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.device_.MergeFrom(from._impl_.device_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WindowsDevices::CopyFrom(const WindowsDevices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.WindowsDevices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowsDevices::IsInitialized() const {
  return true;
}

void WindowsDevices::InternalSwap(WindowsDevices* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.device_.InternalSwap(&other->_impl_.device_);
}

std::string WindowsDevices::GetTypeName() const {
  return "proto.system_info.WindowsDevices";
}


// ===================================================================

class VideoAdapters_Adapter::_Internal {
 public:
};

VideoAdapters_Adapter::VideoAdapters_Adapter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.VideoAdapters.Adapter)
}
VideoAdapters_Adapter::VideoAdapters_Adapter(const VideoAdapters_Adapter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VideoAdapters_Adapter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.description_){}
    , decltype(_impl_.adapter_string_){}
    , decltype(_impl_.bios_string_){}
    , decltype(_impl_.chip_type_){}
    , decltype(_impl_.dac_type_){}
    , decltype(_impl_.driver_date_){}
    , decltype(_impl_.driver_version_){}
    , decltype(_impl_.driver_provider_){}
    , decltype(_impl_.memory_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.adapter_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.adapter_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_adapter_string().empty()) {
    _this->_impl_.adapter_string_.Set(from._internal_adapter_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bios_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bios_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bios_string().empty()) {
    _this->_impl_.bios_string_.Set(from._internal_bios_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.chip_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chip_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_chip_type().empty()) {
    _this->_impl_.chip_type_.Set(from._internal_chip_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dac_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dac_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dac_type().empty()) {
    _this->_impl_.dac_type_.Set(from._internal_dac_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver_date().empty()) {
    _this->_impl_.driver_date_.Set(from._internal_driver_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver_version().empty()) {
    _this->_impl_.driver_version_.Set(from._internal_driver_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_provider_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver_provider().empty()) {
    _this->_impl_.driver_provider_.Set(from._internal_driver_provider(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.memory_size_ = from._impl_.memory_size_;
  // @@protoc_insertion_point(copy_constructor:proto.system_info.VideoAdapters.Adapter)
}

inline void VideoAdapters_Adapter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.description_){}
    , decltype(_impl_.adapter_string_){}
    , decltype(_impl_.bios_string_){}
    , decltype(_impl_.chip_type_){}
    , decltype(_impl_.dac_type_){}
    , decltype(_impl_.driver_date_){}
    , decltype(_impl_.driver_version_){}
    , decltype(_impl_.driver_provider_){}
    , decltype(_impl_.memory_size_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.adapter_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.adapter_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bios_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bios_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chip_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chip_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dac_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dac_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_provider_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VideoAdapters_Adapter::~VideoAdapters_Adapter() {
  // @@protoc_insertion_point(destructor:proto.system_info.VideoAdapters.Adapter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoAdapters_Adapter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.description_.Destroy();
  _impl_.adapter_string_.Destroy();
  _impl_.bios_string_.Destroy();
  _impl_.chip_type_.Destroy();
  _impl_.dac_type_.Destroy();
  _impl_.driver_date_.Destroy();
  _impl_.driver_version_.Destroy();
  _impl_.driver_provider_.Destroy();
}

void VideoAdapters_Adapter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoAdapters_Adapter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.VideoAdapters.Adapter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.description_.ClearToEmpty();
  _impl_.adapter_string_.ClearToEmpty();
  _impl_.bios_string_.ClearToEmpty();
  _impl_.chip_type_.ClearToEmpty();
  _impl_.dac_type_.ClearToEmpty();
  _impl_.driver_date_.ClearToEmpty();
  _impl_.driver_version_.ClearToEmpty();
  _impl_.driver_provider_.ClearToEmpty();
  _impl_.memory_size_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* VideoAdapters_Adapter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string adapter_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_adapter_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string bios_string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bios_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string chip_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_chip_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string dac_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_dac_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver_date = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_driver_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_driver_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string driver_provider = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_driver_provider();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 memory_size = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.memory_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoAdapters_Adapter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.VideoAdapters.Adapter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // string adapter_string = 2;
  if (!this->_internal_adapter_string().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_adapter_string().data(), static_cast<int>(this->_internal_adapter_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.adapter_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_adapter_string(), target);
  }

  // string bios_string = 3;
  if (!this->_internal_bios_string().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bios_string().data(), static_cast<int>(this->_internal_bios_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.bios_string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_bios_string(), target);
  }

  // string chip_type = 4;
  if (!this->_internal_chip_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chip_type().data(), static_cast<int>(this->_internal_chip_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.chip_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_chip_type(), target);
  }

  // string dac_type = 5;
  if (!this->_internal_dac_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dac_type().data(), static_cast<int>(this->_internal_dac_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.dac_type");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_dac_type(), target);
  }

  // string driver_date = 6;
  if (!this->_internal_driver_date().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver_date().data(), static_cast<int>(this->_internal_driver_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.driver_date");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_driver_date(), target);
  }

  // string driver_version = 7;
  if (!this->_internal_driver_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver_version().data(), static_cast<int>(this->_internal_driver_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.driver_version");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_driver_version(), target);
  }

  // string driver_provider = 8;
  if (!this->_internal_driver_provider().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver_provider().data(), static_cast<int>(this->_internal_driver_provider().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.VideoAdapters.Adapter.driver_provider");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_driver_provider(), target);
  }

  // uint64 memory_size = 9;
  if (this->_internal_memory_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_memory_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.VideoAdapters.Adapter)
  return target;
}

size_t VideoAdapters_Adapter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.VideoAdapters.Adapter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string adapter_string = 2;
  if (!this->_internal_adapter_string().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_adapter_string());
  }

  // string bios_string = 3;
  if (!this->_internal_bios_string().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bios_string());
  }

  // string chip_type = 4;
  if (!this->_internal_chip_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chip_type());
  }

  // string dac_type = 5;
  if (!this->_internal_dac_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dac_type());
  }

  // string driver_date = 6;
  if (!this->_internal_driver_date().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver_date());
  }

  // string driver_version = 7;
  if (!this->_internal_driver_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver_version());
  }

  // string driver_provider = 8;
  if (!this->_internal_driver_provider().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver_provider());
  }

  // uint64 memory_size = 9;
  if (this->_internal_memory_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_memory_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoAdapters_Adapter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoAdapters_Adapter*>(
      &from));
}

void VideoAdapters_Adapter::MergeFrom(const VideoAdapters_Adapter& from) {
  VideoAdapters_Adapter* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.VideoAdapters.Adapter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_adapter_string().empty()) {
    _this->_internal_set_adapter_string(from._internal_adapter_string());
  }
  if (!from._internal_bios_string().empty()) {
    _this->_internal_set_bios_string(from._internal_bios_string());
  }
  if (!from._internal_chip_type().empty()) {
    _this->_internal_set_chip_type(from._internal_chip_type());
  }
  if (!from._internal_dac_type().empty()) {
    _this->_internal_set_dac_type(from._internal_dac_type());
  }
  if (!from._internal_driver_date().empty()) {
    _this->_internal_set_driver_date(from._internal_driver_date());
  }
  if (!from._internal_driver_version().empty()) {
    _this->_internal_set_driver_version(from._internal_driver_version());
  }
  if (!from._internal_driver_provider().empty()) {
    _this->_internal_set_driver_provider(from._internal_driver_provider());
  }
  if (from._internal_memory_size() != 0) {
    _this->_internal_set_memory_size(from._internal_memory_size());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoAdapters_Adapter::CopyFrom(const VideoAdapters_Adapter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.VideoAdapters.Adapter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoAdapters_Adapter::IsInitialized() const {
  return true;
}

void VideoAdapters_Adapter::InternalSwap(VideoAdapters_Adapter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.adapter_string_, lhs_arena,
      &other->_impl_.adapter_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bios_string_, lhs_arena,
      &other->_impl_.bios_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chip_type_, lhs_arena,
      &other->_impl_.chip_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dac_type_, lhs_arena,
      &other->_impl_.dac_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_date_, lhs_arena,
      &other->_impl_.driver_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_version_, lhs_arena,
      &other->_impl_.driver_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_provider_, lhs_arena,
      &other->_impl_.driver_provider_, rhs_arena
  );
  swap(_impl_.memory_size_, other->_impl_.memory_size_);
}

std::string VideoAdapters_Adapter::GetTypeName() const {
  return "proto.system_info.VideoAdapters.Adapter";
}


// ===================================================================

class VideoAdapters::_Internal {
 public:
};

VideoAdapters::VideoAdapters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.VideoAdapters)
}
VideoAdapters::VideoAdapters(const VideoAdapters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VideoAdapters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.adapter_){from._impl_.adapter_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.VideoAdapters)
}

inline void VideoAdapters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.adapter_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VideoAdapters::~VideoAdapters() {
  // @@protoc_insertion_point(destructor:proto.system_info.VideoAdapters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoAdapters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.adapter_.~RepeatedPtrField();
}

void VideoAdapters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoAdapters::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.VideoAdapters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.adapter_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoAdapters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.VideoAdapters.Adapter adapter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_adapter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoAdapters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.VideoAdapters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.VideoAdapters.Adapter adapter = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_adapter_size()); i < n; i++) {
    const auto& repfield = this->_internal_adapter(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.VideoAdapters)
  return target;
}

size_t VideoAdapters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.VideoAdapters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.VideoAdapters.Adapter adapter = 1;
  total_size += 1UL * this->_internal_adapter_size();
  for (const auto& msg : this->_impl_.adapter_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoAdapters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoAdapters*>(
      &from));
}

void VideoAdapters::MergeFrom(const VideoAdapters& from) {
  VideoAdapters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.VideoAdapters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.adapter_.MergeFrom(from._impl_.adapter_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoAdapters::CopyFrom(const VideoAdapters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.VideoAdapters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoAdapters::IsInitialized() const {
  return true;
}

void VideoAdapters::InternalSwap(VideoAdapters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.adapter_.InternalSwap(&other->_impl_.adapter_);
}

std::string VideoAdapters::GetTypeName() const {
  return "proto.system_info.VideoAdapters";
}


// ===================================================================

class Monitors_Monitor_Timing::_Internal {
 public:
};

Monitors_Monitor_Timing::Monitors_Monitor_Timing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Monitors.Monitor.Timing)
}
Monitors_Monitor_Timing::Monitors_Monitor_Timing(const Monitors_Monitor_Timing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Monitors_Monitor_Timing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.frequency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.frequency_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.frequency_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Monitors.Monitor.Timing)
}

inline void Monitors_Monitor_Timing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.frequency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Monitors_Monitor_Timing::~Monitors_Monitor_Timing() {
  // @@protoc_insertion_point(destructor:proto.system_info.Monitors.Monitor.Timing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Monitors_Monitor_Timing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Monitors_Monitor_Timing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Monitors_Monitor_Timing::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Monitors.Monitor.Timing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.frequency_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.frequency_));
  _internal_metadata_.Clear<std::string>();
}

const char* Monitors_Monitor_Timing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 frequency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Monitors_Monitor_Timing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Monitors.Monitor.Timing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  // int32 frequency = 3;
  if (this->_internal_frequency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_frequency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Monitors.Monitor.Timing)
  return target;
}

size_t Monitors_Monitor_Timing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Monitors.Monitor.Timing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  // int32 frequency = 3;
  if (this->_internal_frequency() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frequency());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Monitors_Monitor_Timing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Monitors_Monitor_Timing*>(
      &from));
}

void Monitors_Monitor_Timing::MergeFrom(const Monitors_Monitor_Timing& from) {
  Monitors_Monitor_Timing* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Monitors.Monitor.Timing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_frequency() != 0) {
    _this->_internal_set_frequency(from._internal_frequency());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Monitors_Monitor_Timing::CopyFrom(const Monitors_Monitor_Timing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Monitors.Monitor.Timing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Monitors_Monitor_Timing::IsInitialized() const {
  return true;
}

void Monitors_Monitor_Timing::InternalSwap(Monitors_Monitor_Timing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Monitors_Monitor_Timing, _impl_.frequency_)
      + sizeof(Monitors_Monitor_Timing::_impl_.frequency_)
      - PROTOBUF_FIELD_OFFSET(Monitors_Monitor_Timing, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

std::string Monitors_Monitor_Timing::GetTypeName() const {
  return "proto.system_info.Monitors.Monitor.Timing";
}


// ===================================================================

class Monitors_Monitor::_Internal {
 public:
};

Monitors_Monitor::Monitors_Monitor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Monitors.Monitor)
}
Monitors_Monitor::Monitors_Monitor(const Monitors_Monitor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Monitors_Monitor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.timings_){from._impl_.timings_}
    , decltype(_impl_.system_name_){}
    , decltype(_impl_.monitor_name_){}
    , decltype(_impl_.manufacturer_name_){}
    , decltype(_impl_.monitor_id_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.edid_version_){}
    , decltype(_impl_.edid_revision_){}
    , decltype(_impl_.week_of_manufacture_){}
    , decltype(_impl_.year_of_manufacture_){}
    , decltype(_impl_.max_horizontal_image_size_){}
    , decltype(_impl_.max_vertical_image_size_){}
    , decltype(_impl_.horizontal_resolution_){}
    , decltype(_impl_.vertical_resoulution_){}
    , decltype(_impl_.gamma_){}
    , decltype(_impl_.min_horizontal_rate_){}
    , decltype(_impl_.max_horizontal_rate_){}
    , decltype(_impl_.min_vertical_rate_){}
    , decltype(_impl_.max_vertical_rate_){}
    , decltype(_impl_.pixel_clock_){}
    , decltype(_impl_.max_pixel_clock_){}
    , decltype(_impl_.input_signal_type_){}
    , decltype(_impl_.default_gtf_supported_){}
    , decltype(_impl_.suspend_supported_){}
    , decltype(_impl_.standby_supported_){}
    , decltype(_impl_.active_off_supported_){}
    , decltype(_impl_.preferred_timing_mode_supported_){}
    , decltype(_impl_.srgb_supported_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.system_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_system_name().empty()) {
    _this->_impl_.system_name_.Set(from._internal_system_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.monitor_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.monitor_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_monitor_name().empty()) {
    _this->_impl_.monitor_name_.Set(from._internal_monitor_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacturer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_manufacturer_name().empty()) {
    _this->_impl_.manufacturer_name_.Set(from._internal_manufacturer_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.monitor_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.monitor_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_monitor_id().empty()) {
    _this->_impl_.monitor_id_.Set(from._internal_monitor_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    _this->_impl_.serial_number_.Set(from._internal_serial_number(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.edid_version_, &from._impl_.edid_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.srgb_supported_) -
    reinterpret_cast<char*>(&_impl_.edid_version_)) + sizeof(_impl_.srgb_supported_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Monitors.Monitor)
}

inline void Monitors_Monitor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.timings_){arena}
    , decltype(_impl_.system_name_){}
    , decltype(_impl_.monitor_name_){}
    , decltype(_impl_.manufacturer_name_){}
    , decltype(_impl_.monitor_id_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.edid_version_){0}
    , decltype(_impl_.edid_revision_){0}
    , decltype(_impl_.week_of_manufacture_){0}
    , decltype(_impl_.year_of_manufacture_){0}
    , decltype(_impl_.max_horizontal_image_size_){0}
    , decltype(_impl_.max_vertical_image_size_){0}
    , decltype(_impl_.horizontal_resolution_){0}
    , decltype(_impl_.vertical_resoulution_){0}
    , decltype(_impl_.gamma_){0}
    , decltype(_impl_.min_horizontal_rate_){0}
    , decltype(_impl_.max_horizontal_rate_){0}
    , decltype(_impl_.min_vertical_rate_){0}
    , decltype(_impl_.max_vertical_rate_){0}
    , decltype(_impl_.pixel_clock_){0}
    , decltype(_impl_.max_pixel_clock_){0}
    , decltype(_impl_.input_signal_type_){0}
    , decltype(_impl_.default_gtf_supported_){false}
    , decltype(_impl_.suspend_supported_){false}
    , decltype(_impl_.standby_supported_){false}
    , decltype(_impl_.active_off_supported_){false}
    , decltype(_impl_.preferred_timing_mode_supported_){false}
    , decltype(_impl_.srgb_supported_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.system_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.monitor_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.monitor_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacturer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.monitor_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.monitor_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Monitors_Monitor::~Monitors_Monitor() {
  // @@protoc_insertion_point(destructor:proto.system_info.Monitors.Monitor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Monitors_Monitor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.timings_.~RepeatedPtrField();
  _impl_.system_name_.Destroy();
  _impl_.monitor_name_.Destroy();
  _impl_.manufacturer_name_.Destroy();
  _impl_.monitor_id_.Destroy();
  _impl_.serial_number_.Destroy();
}

void Monitors_Monitor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Monitors_Monitor::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Monitors.Monitor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.timings_.Clear();
  _impl_.system_name_.ClearToEmpty();
  _impl_.monitor_name_.ClearToEmpty();
  _impl_.manufacturer_name_.ClearToEmpty();
  _impl_.monitor_id_.ClearToEmpty();
  _impl_.serial_number_.ClearToEmpty();
  ::memset(&_impl_.edid_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.srgb_supported_) -
      reinterpret_cast<char*>(&_impl_.edid_version_)) + sizeof(_impl_.srgb_supported_));
  _internal_metadata_.Clear<std::string>();
}

const char* Monitors_Monitor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string system_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_system_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string monitor_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_monitor_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string manufacturer_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_manufacturer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string monitor_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_monitor_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 edid_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.edid_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 edid_revision = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.edid_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 week_of_manufacture = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.week_of_manufacture_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 year_of_manufacture = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.year_of_manufacture_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_horizontal_image_size = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.max_horizontal_image_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_vertical_image_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.max_vertical_image_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 horizontal_resolution = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.horizontal_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 vertical_resoulution = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.vertical_resoulution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double gamma = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _impl_.gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 min_horizontal_rate = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.min_horizontal_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_horizontal_rate = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.max_horizontal_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 min_vertical_rate = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.min_vertical_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_vertical_rate = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.max_vertical_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double pixel_clock = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _impl_.pixel_clock_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 max_pixel_clock = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.max_pixel_clock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Monitors.Monitor.InputSignalType input_signal_type = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_input_signal_type(static_cast<::proto::system_info::Monitors_Monitor_InputSignalType>(val));
        } else
          goto handle_unusual;
        continue;
      // bool default_gtf_supported = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.default_gtf_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool suspend_supported = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _impl_.suspend_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool standby_supported = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _impl_.standby_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool active_off_supported = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.active_off_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool preferred_timing_mode_supported = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _impl_.preferred_timing_mode_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool srgb_supported = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _impl_.srgb_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.system_info.Monitors.Monitor.Timing timings = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_timings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Monitors_Monitor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Monitors.Monitor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string system_name = 1;
  if (!this->_internal_system_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_system_name().data(), static_cast<int>(this->_internal_system_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Monitors.Monitor.system_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_system_name(), target);
  }

  // string monitor_name = 2;
  if (!this->_internal_monitor_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_monitor_name().data(), static_cast<int>(this->_internal_monitor_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Monitors.Monitor.monitor_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_monitor_name(), target);
  }

  // string manufacturer_name = 3;
  if (!this->_internal_manufacturer_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_manufacturer_name().data(), static_cast<int>(this->_internal_manufacturer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Monitors.Monitor.manufacturer_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_manufacturer_name(), target);
  }

  // string monitor_id = 4;
  if (!this->_internal_monitor_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_monitor_id().data(), static_cast<int>(this->_internal_monitor_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Monitors.Monitor.monitor_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_monitor_id(), target);
  }

  // string serial_number = 5;
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Monitors.Monitor.serial_number");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_serial_number(), target);
  }

  // int32 edid_version = 6;
  if (this->_internal_edid_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_edid_version(), target);
  }

  // int32 edid_revision = 7;
  if (this->_internal_edid_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_edid_revision(), target);
  }

  // int32 week_of_manufacture = 8;
  if (this->_internal_week_of_manufacture() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_week_of_manufacture(), target);
  }

  // int32 year_of_manufacture = 9;
  if (this->_internal_year_of_manufacture() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_year_of_manufacture(), target);
  }

  // int32 max_horizontal_image_size = 10;
  if (this->_internal_max_horizontal_image_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_max_horizontal_image_size(), target);
  }

  // int32 max_vertical_image_size = 11;
  if (this->_internal_max_vertical_image_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_max_vertical_image_size(), target);
  }

  // int32 horizontal_resolution = 12;
  if (this->_internal_horizontal_resolution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_horizontal_resolution(), target);
  }

  // int32 vertical_resoulution = 13;
  if (this->_internal_vertical_resoulution() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_vertical_resoulution(), target);
  }

  // double gamma = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_gamma(), target);
  }

  // int32 min_horizontal_rate = 15;
  if (this->_internal_min_horizontal_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_min_horizontal_rate(), target);
  }

  // int32 max_horizontal_rate = 16;
  if (this->_internal_max_horizontal_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_max_horizontal_rate(), target);
  }

  // int32 min_vertical_rate = 17;
  if (this->_internal_min_vertical_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_min_vertical_rate(), target);
  }

  // int32 max_vertical_rate = 18;
  if (this->_internal_max_vertical_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_max_vertical_rate(), target);
  }

  // double pixel_clock = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pixel_clock = this->_internal_pixel_clock();
  uint64_t raw_pixel_clock;
  memcpy(&raw_pixel_clock, &tmp_pixel_clock, sizeof(tmp_pixel_clock));
  if (raw_pixel_clock != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(19, this->_internal_pixel_clock(), target);
  }

  // int32 max_pixel_clock = 20;
  if (this->_internal_max_pixel_clock() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_max_pixel_clock(), target);
  }

  // .proto.system_info.Monitors.Monitor.InputSignalType input_signal_type = 21;
  if (this->_internal_input_signal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      21, this->_internal_input_signal_type(), target);
  }

  // bool default_gtf_supported = 22;
  if (this->_internal_default_gtf_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_default_gtf_supported(), target);
  }

  // bool suspend_supported = 23;
  if (this->_internal_suspend_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_suspend_supported(), target);
  }

  // bool standby_supported = 24;
  if (this->_internal_standby_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_standby_supported(), target);
  }

  // bool active_off_supported = 25;
  if (this->_internal_active_off_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_active_off_supported(), target);
  }

  // bool preferred_timing_mode_supported = 26;
  if (this->_internal_preferred_timing_mode_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_preferred_timing_mode_supported(), target);
  }

  // bool srgb_supported = 27;
  if (this->_internal_srgb_supported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_srgb_supported(), target);
  }

  // repeated .proto.system_info.Monitors.Monitor.Timing timings = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_timings_size()); i < n; i++) {
    const auto& repfield = this->_internal_timings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Monitors.Monitor)
  return target;
}

size_t Monitors_Monitor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Monitors.Monitor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Monitors.Monitor.Timing timings = 28;
  total_size += 2UL * this->_internal_timings_size();
  for (const auto& msg : this->_impl_.timings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string system_name = 1;
  if (!this->_internal_system_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_system_name());
  }

  // string monitor_name = 2;
  if (!this->_internal_monitor_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_monitor_name());
  }

  // string manufacturer_name = 3;
  if (!this->_internal_manufacturer_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_manufacturer_name());
  }

  // string monitor_id = 4;
  if (!this->_internal_monitor_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_monitor_id());
  }

  // string serial_number = 5;
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // int32 edid_version = 6;
  if (this->_internal_edid_version() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_edid_version());
  }

  // int32 edid_revision = 7;
  if (this->_internal_edid_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_edid_revision());
  }

  // int32 week_of_manufacture = 8;
  if (this->_internal_week_of_manufacture() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_week_of_manufacture());
  }

  // int32 year_of_manufacture = 9;
  if (this->_internal_year_of_manufacture() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_year_of_manufacture());
  }

  // int32 max_horizontal_image_size = 10;
  if (this->_internal_max_horizontal_image_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_horizontal_image_size());
  }

  // int32 max_vertical_image_size = 11;
  if (this->_internal_max_vertical_image_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_vertical_image_size());
  }

  // int32 horizontal_resolution = 12;
  if (this->_internal_horizontal_resolution() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_horizontal_resolution());
  }

  // int32 vertical_resoulution = 13;
  if (this->_internal_vertical_resoulution() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vertical_resoulution());
  }

  // double gamma = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = this->_internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    total_size += 1 + 8;
  }

  // int32 min_horizontal_rate = 15;
  if (this->_internal_min_horizontal_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_horizontal_rate());
  }

  // int32 max_horizontal_rate = 16;
  if (this->_internal_max_horizontal_rate() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_max_horizontal_rate());
  }

  // int32 min_vertical_rate = 17;
  if (this->_internal_min_vertical_rate() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_min_vertical_rate());
  }

  // int32 max_vertical_rate = 18;
  if (this->_internal_max_vertical_rate() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_max_vertical_rate());
  }

  // double pixel_clock = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pixel_clock = this->_internal_pixel_clock();
  uint64_t raw_pixel_clock;
  memcpy(&raw_pixel_clock, &tmp_pixel_clock, sizeof(tmp_pixel_clock));
  if (raw_pixel_clock != 0) {
    total_size += 2 + 8;
  }

  // int32 max_pixel_clock = 20;
  if (this->_internal_max_pixel_clock() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_max_pixel_clock());
  }

  // .proto.system_info.Monitors.Monitor.InputSignalType input_signal_type = 21;
  if (this->_internal_input_signal_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_input_signal_type());
  }

  // bool default_gtf_supported = 22;
  if (this->_internal_default_gtf_supported() != 0) {
    total_size += 2 + 1;
  }

  // bool suspend_supported = 23;
  if (this->_internal_suspend_supported() != 0) {
    total_size += 2 + 1;
  }

  // bool standby_supported = 24;
  if (this->_internal_standby_supported() != 0) {
    total_size += 2 + 1;
  }

  // bool active_off_supported = 25;
  if (this->_internal_active_off_supported() != 0) {
    total_size += 2 + 1;
  }

  // bool preferred_timing_mode_supported = 26;
  if (this->_internal_preferred_timing_mode_supported() != 0) {
    total_size += 2 + 1;
  }

  // bool srgb_supported = 27;
  if (this->_internal_srgb_supported() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Monitors_Monitor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Monitors_Monitor*>(
      &from));
}

void Monitors_Monitor::MergeFrom(const Monitors_Monitor& from) {
  Monitors_Monitor* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Monitors.Monitor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.timings_.MergeFrom(from._impl_.timings_);
  if (!from._internal_system_name().empty()) {
    _this->_internal_set_system_name(from._internal_system_name());
  }
  if (!from._internal_monitor_name().empty()) {
    _this->_internal_set_monitor_name(from._internal_monitor_name());
  }
  if (!from._internal_manufacturer_name().empty()) {
    _this->_internal_set_manufacturer_name(from._internal_manufacturer_name());
  }
  if (!from._internal_monitor_id().empty()) {
    _this->_internal_set_monitor_id(from._internal_monitor_id());
  }
  if (!from._internal_serial_number().empty()) {
    _this->_internal_set_serial_number(from._internal_serial_number());
  }
  if (from._internal_edid_version() != 0) {
    _this->_internal_set_edid_version(from._internal_edid_version());
  }
  if (from._internal_edid_revision() != 0) {
    _this->_internal_set_edid_revision(from._internal_edid_revision());
  }
  if (from._internal_week_of_manufacture() != 0) {
    _this->_internal_set_week_of_manufacture(from._internal_week_of_manufacture());
  }
  if (from._internal_year_of_manufacture() != 0) {
    _this->_internal_set_year_of_manufacture(from._internal_year_of_manufacture());
  }
  if (from._internal_max_horizontal_image_size() != 0) {
    _this->_internal_set_max_horizontal_image_size(from._internal_max_horizontal_image_size());
  }
  if (from._internal_max_vertical_image_size() != 0) {
    _this->_internal_set_max_vertical_image_size(from._internal_max_vertical_image_size());
  }
  if (from._internal_horizontal_resolution() != 0) {
    _this->_internal_set_horizontal_resolution(from._internal_horizontal_resolution());
  }
  if (from._internal_vertical_resoulution() != 0) {
    _this->_internal_set_vertical_resoulution(from._internal_vertical_resoulution());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gamma = from._internal_gamma();
  uint64_t raw_gamma;
  memcpy(&raw_gamma, &tmp_gamma, sizeof(tmp_gamma));
  if (raw_gamma != 0) {
    _this->_internal_set_gamma(from._internal_gamma());
  }
  if (from._internal_min_horizontal_rate() != 0) {
    _this->_internal_set_min_horizontal_rate(from._internal_min_horizontal_rate());
  }
  if (from._internal_max_horizontal_rate() != 0) {
    _this->_internal_set_max_horizontal_rate(from._internal_max_horizontal_rate());
  }
  if (from._internal_min_vertical_rate() != 0) {
    _this->_internal_set_min_vertical_rate(from._internal_min_vertical_rate());
  }
  if (from._internal_max_vertical_rate() != 0) {
    _this->_internal_set_max_vertical_rate(from._internal_max_vertical_rate());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pixel_clock = from._internal_pixel_clock();
  uint64_t raw_pixel_clock;
  memcpy(&raw_pixel_clock, &tmp_pixel_clock, sizeof(tmp_pixel_clock));
  if (raw_pixel_clock != 0) {
    _this->_internal_set_pixel_clock(from._internal_pixel_clock());
  }
  if (from._internal_max_pixel_clock() != 0) {
    _this->_internal_set_max_pixel_clock(from._internal_max_pixel_clock());
  }
  if (from._internal_input_signal_type() != 0) {
    _this->_internal_set_input_signal_type(from._internal_input_signal_type());
  }
  if (from._internal_default_gtf_supported() != 0) {
    _this->_internal_set_default_gtf_supported(from._internal_default_gtf_supported());
  }
  if (from._internal_suspend_supported() != 0) {
    _this->_internal_set_suspend_supported(from._internal_suspend_supported());
  }
  if (from._internal_standby_supported() != 0) {
    _this->_internal_set_standby_supported(from._internal_standby_supported());
  }
  if (from._internal_active_off_supported() != 0) {
    _this->_internal_set_active_off_supported(from._internal_active_off_supported());
  }
  if (from._internal_preferred_timing_mode_supported() != 0) {
    _this->_internal_set_preferred_timing_mode_supported(from._internal_preferred_timing_mode_supported());
  }
  if (from._internal_srgb_supported() != 0) {
    _this->_internal_set_srgb_supported(from._internal_srgb_supported());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Monitors_Monitor::CopyFrom(const Monitors_Monitor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Monitors.Monitor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Monitors_Monitor::IsInitialized() const {
  return true;
}

void Monitors_Monitor::InternalSwap(Monitors_Monitor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.timings_.InternalSwap(&other->_impl_.timings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_name_, lhs_arena,
      &other->_impl_.system_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.monitor_name_, lhs_arena,
      &other->_impl_.monitor_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacturer_name_, lhs_arena,
      &other->_impl_.manufacturer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.monitor_id_, lhs_arena,
      &other->_impl_.monitor_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_number_, lhs_arena,
      &other->_impl_.serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Monitors_Monitor, _impl_.srgb_supported_)
      + sizeof(Monitors_Monitor::_impl_.srgb_supported_)
      - PROTOBUF_FIELD_OFFSET(Monitors_Monitor, _impl_.edid_version_)>(
          reinterpret_cast<char*>(&_impl_.edid_version_),
          reinterpret_cast<char*>(&other->_impl_.edid_version_));
}

std::string Monitors_Monitor::GetTypeName() const {
  return "proto.system_info.Monitors.Monitor";
}


// ===================================================================

class Monitors::_Internal {
 public:
};

Monitors::Monitors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Monitors)
}
Monitors::Monitors(const Monitors& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Monitors* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.monitor_){from._impl_.monitor_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Monitors)
}

inline void Monitors::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.monitor_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Monitors::~Monitors() {
  // @@protoc_insertion_point(destructor:proto.system_info.Monitors)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Monitors::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.monitor_.~RepeatedPtrField();
}

void Monitors::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Monitors::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Monitors)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.monitor_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Monitors::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Monitors.Monitor monitor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_monitor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Monitors::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Monitors)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Monitors.Monitor monitor = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_monitor_size()); i < n; i++) {
    const auto& repfield = this->_internal_monitor(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Monitors)
  return target;
}

size_t Monitors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Monitors)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Monitors.Monitor monitor = 1;
  total_size += 1UL * this->_internal_monitor_size();
  for (const auto& msg : this->_impl_.monitor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Monitors::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Monitors*>(
      &from));
}

void Monitors::MergeFrom(const Monitors& from) {
  Monitors* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Monitors)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.monitor_.MergeFrom(from._impl_.monitor_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Monitors::CopyFrom(const Monitors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Monitors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Monitors::IsInitialized() const {
  return true;
}

void Monitors::InternalSwap(Monitors* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.monitor_.InternalSwap(&other->_impl_.monitor_);
}

std::string Monitors::GetTypeName() const {
  return "proto.system_info.Monitors";
}


// ===================================================================

class PowerOptions_Battery::_Internal {
 public:
};

PowerOptions_Battery::PowerOptions_Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.PowerOptions.Battery)
}
PowerOptions_Battery::PowerOptions_Battery(const PowerOptions_Battery& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PowerOptions_Battery* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_name_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.unique_id_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.temperature_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.design_capacity_){}
    , decltype(_impl_.full_charged_capacity_){}
    , decltype(_impl_.depreciation_){}
    , decltype(_impl_.current_capacity_){}
    , decltype(_impl_.voltage_){}
    , decltype(_impl_.state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_device_name().empty()) {
    _this->_impl_.device_name_.Set(from._internal_device_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_manufacturer().empty()) {
    _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_manufacture_date().empty()) {
    _this->_impl_.manufacture_date_.Set(from._internal_manufacture_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.unique_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unique_id().empty()) {
    _this->_impl_.unique_id_.Set(from._internal_unique_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    _this->_impl_.serial_number_.Set(from._internal_serial_number(), 
      _this->GetArenaForAllocation());
  }
  _impl_.temperature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.temperature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_temperature().empty()) {
    _this->_impl_.temperature_.Set(from._internal_temperature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.design_capacity_, &from._impl_.design_capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) -
    reinterpret_cast<char*>(&_impl_.design_capacity_)) + sizeof(_impl_.state_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.PowerOptions.Battery)
}

inline void PowerOptions_Battery::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_name_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.unique_id_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.temperature_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.design_capacity_){0u}
    , decltype(_impl_.full_charged_capacity_){0u}
    , decltype(_impl_.depreciation_){0u}
    , decltype(_impl_.current_capacity_){0u}
    , decltype(_impl_.voltage_){0u}
    , decltype(_impl_.state_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.device_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unique_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.temperature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.temperature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PowerOptions_Battery::~PowerOptions_Battery() {
  // @@protoc_insertion_point(destructor:proto.system_info.PowerOptions.Battery)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PowerOptions_Battery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_name_.Destroy();
  _impl_.manufacturer_.Destroy();
  _impl_.manufacture_date_.Destroy();
  _impl_.unique_id_.Destroy();
  _impl_.serial_number_.Destroy();
  _impl_.temperature_.Destroy();
  _impl_.type_.Destroy();
}

void PowerOptions_Battery::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PowerOptions_Battery::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.PowerOptions.Battery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_name_.ClearToEmpty();
  _impl_.manufacturer_.ClearToEmpty();
  _impl_.manufacture_date_.ClearToEmpty();
  _impl_.unique_id_.ClearToEmpty();
  _impl_.serial_number_.ClearToEmpty();
  _impl_.temperature_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  ::memset(&_impl_.design_capacity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.state_) -
      reinterpret_cast<char*>(&_impl_.design_capacity_)) + sizeof(_impl_.state_));
  _internal_metadata_.Clear<std::string>();
}

const char* PowerOptions_Battery::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string device_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string manufacturer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string manufacture_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_manufacture_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string unique_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_unique_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string temperature = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_temperature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 design_capacity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.design_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 full_charged_capacity = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.full_charged_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 depreciation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.depreciation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 current_capacity = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.current_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 voltage = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 state = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowerOptions_Battery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.PowerOptions.Battery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string device_name = 1;
  if (!this->_internal_device_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_device_name().data(), static_cast<int>(this->_internal_device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.device_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_name(), target);
  }

  // string manufacturer = 2;
  if (!this->_internal_manufacturer().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_manufacturer().data(), static_cast<int>(this->_internal_manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.manufacturer");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_manufacturer(), target);
  }

  // string manufacture_date = 3;
  if (!this->_internal_manufacture_date().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_manufacture_date().data(), static_cast<int>(this->_internal_manufacture_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.manufacture_date");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_manufacture_date(), target);
  }

  // string unique_id = 4;
  if (!this->_internal_unique_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unique_id().data(), static_cast<int>(this->_internal_unique_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.unique_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_unique_id(), target);
  }

  // string serial_number = 5;
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.serial_number");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_serial_number(), target);
  }

  // string temperature = 6;
  if (!this->_internal_temperature().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_temperature().data(), static_cast<int>(this->_internal_temperature().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.temperature");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_temperature(), target);
  }

  // uint32 design_capacity = 7;
  if (this->_internal_design_capacity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_design_capacity(), target);
  }

  // string type = 8;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.PowerOptions.Battery.type");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_type(), target);
  }

  // uint32 full_charged_capacity = 9;
  if (this->_internal_full_charged_capacity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_full_charged_capacity(), target);
  }

  // uint32 depreciation = 10;
  if (this->_internal_depreciation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_depreciation(), target);
  }

  // uint32 current_capacity = 11;
  if (this->_internal_current_capacity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_current_capacity(), target);
  }

  // uint32 voltage = 12;
  if (this->_internal_voltage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_voltage(), target);
  }

  // uint32 state = 13;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.PowerOptions.Battery)
  return target;
}

size_t PowerOptions_Battery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.PowerOptions.Battery)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string device_name = 1;
  if (!this->_internal_device_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_name());
  }

  // string manufacturer = 2;
  if (!this->_internal_manufacturer().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_manufacturer());
  }

  // string manufacture_date = 3;
  if (!this->_internal_manufacture_date().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_manufacture_date());
  }

  // string unique_id = 4;
  if (!this->_internal_unique_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unique_id());
  }

  // string serial_number = 5;
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // string temperature = 6;
  if (!this->_internal_temperature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_temperature());
  }

  // string type = 8;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // uint32 design_capacity = 7;
  if (this->_internal_design_capacity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_design_capacity());
  }

  // uint32 full_charged_capacity = 9;
  if (this->_internal_full_charged_capacity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_full_charged_capacity());
  }

  // uint32 depreciation = 10;
  if (this->_internal_depreciation() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_depreciation());
  }

  // uint32 current_capacity = 11;
  if (this->_internal_current_capacity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_capacity());
  }

  // uint32 voltage = 12;
  if (this->_internal_voltage() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_voltage());
  }

  // uint32 state = 13;
  if (this->_internal_state() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PowerOptions_Battery::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PowerOptions_Battery*>(
      &from));
}

void PowerOptions_Battery::MergeFrom(const PowerOptions_Battery& from) {
  PowerOptions_Battery* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.PowerOptions.Battery)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_device_name().empty()) {
    _this->_internal_set_device_name(from._internal_device_name());
  }
  if (!from._internal_manufacturer().empty()) {
    _this->_internal_set_manufacturer(from._internal_manufacturer());
  }
  if (!from._internal_manufacture_date().empty()) {
    _this->_internal_set_manufacture_date(from._internal_manufacture_date());
  }
  if (!from._internal_unique_id().empty()) {
    _this->_internal_set_unique_id(from._internal_unique_id());
  }
  if (!from._internal_serial_number().empty()) {
    _this->_internal_set_serial_number(from._internal_serial_number());
  }
  if (!from._internal_temperature().empty()) {
    _this->_internal_set_temperature(from._internal_temperature());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_design_capacity() != 0) {
    _this->_internal_set_design_capacity(from._internal_design_capacity());
  }
  if (from._internal_full_charged_capacity() != 0) {
    _this->_internal_set_full_charged_capacity(from._internal_full_charged_capacity());
  }
  if (from._internal_depreciation() != 0) {
    _this->_internal_set_depreciation(from._internal_depreciation());
  }
  if (from._internal_current_capacity() != 0) {
    _this->_internal_set_current_capacity(from._internal_current_capacity());
  }
  if (from._internal_voltage() != 0) {
    _this->_internal_set_voltage(from._internal_voltage());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PowerOptions_Battery::CopyFrom(const PowerOptions_Battery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.PowerOptions.Battery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerOptions_Battery::IsInitialized() const {
  return true;
}

void PowerOptions_Battery::InternalSwap(PowerOptions_Battery* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_name_, lhs_arena,
      &other->_impl_.device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacturer_, lhs_arena,
      &other->_impl_.manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacture_date_, lhs_arena,
      &other->_impl_.manufacture_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unique_id_, lhs_arena,
      &other->_impl_.unique_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_number_, lhs_arena,
      &other->_impl_.serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.temperature_, lhs_arena,
      &other->_impl_.temperature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PowerOptions_Battery, _impl_.state_)
      + sizeof(PowerOptions_Battery::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(PowerOptions_Battery, _impl_.design_capacity_)>(
          reinterpret_cast<char*>(&_impl_.design_capacity_),
          reinterpret_cast<char*>(&other->_impl_.design_capacity_));
}

std::string PowerOptions_Battery::GetTypeName() const {
  return "proto.system_info.PowerOptions.Battery";
}


// ===================================================================

class PowerOptions::_Internal {
 public:
};

PowerOptions::PowerOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.PowerOptions)
}
PowerOptions::PowerOptions(const PowerOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PowerOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.battery_){from._impl_.battery_}
    , decltype(_impl_.power_source_){}
    , decltype(_impl_.battery_status_){}
    , decltype(_impl_.full_battery_life_time_){}
    , decltype(_impl_.remaining_battery_life_time_){}
    , decltype(_impl_.battery_life_percent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.power_source_, &from._impl_.power_source_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.battery_life_percent_) -
    reinterpret_cast<char*>(&_impl_.power_source_)) + sizeof(_impl_.battery_life_percent_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.PowerOptions)
}

inline void PowerOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.battery_){arena}
    , decltype(_impl_.power_source_){0}
    , decltype(_impl_.battery_status_){0}
    , decltype(_impl_.full_battery_life_time_){uint64_t{0u}}
    , decltype(_impl_.remaining_battery_life_time_){uint64_t{0u}}
    , decltype(_impl_.battery_life_percent_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PowerOptions::~PowerOptions() {
  // @@protoc_insertion_point(destructor:proto.system_info.PowerOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PowerOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.battery_.~RepeatedPtrField();
}

void PowerOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PowerOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.PowerOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.battery_.Clear();
  ::memset(&_impl_.power_source_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.battery_life_percent_) -
      reinterpret_cast<char*>(&_impl_.power_source_)) + sizeof(_impl_.battery_life_percent_));
  _internal_metadata_.Clear<std::string>();
}

const char* PowerOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.system_info.PowerOptions.PowerSource power_source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_power_source(static_cast<::proto::system_info::PowerOptions_PowerSource>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.PowerOptions.BatteryStatus battery_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_battery_status(static_cast<::proto::system_info::PowerOptions_BatteryStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 full_battery_life_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.full_battery_life_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 remaining_battery_life_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.remaining_battery_life_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 battery_life_percent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.battery_life_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.system_info.PowerOptions.Battery battery = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_battery(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowerOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.PowerOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.system_info.PowerOptions.PowerSource power_source = 1;
  if (this->_internal_power_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_power_source(), target);
  }

  // .proto.system_info.PowerOptions.BatteryStatus battery_status = 2;
  if (this->_internal_battery_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_battery_status(), target);
  }

  // uint64 full_battery_life_time = 3;
  if (this->_internal_full_battery_life_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_full_battery_life_time(), target);
  }

  // uint64 remaining_battery_life_time = 4;
  if (this->_internal_remaining_battery_life_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_remaining_battery_life_time(), target);
  }

  // uint32 battery_life_percent = 5;
  if (this->_internal_battery_life_percent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_battery_life_percent(), target);
  }

  // repeated .proto.system_info.PowerOptions.Battery battery = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_battery_size()); i < n; i++) {
    const auto& repfield = this->_internal_battery(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.PowerOptions)
  return target;
}

size_t PowerOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.PowerOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.PowerOptions.Battery battery = 6;
  total_size += 1UL * this->_internal_battery_size();
  for (const auto& msg : this->_impl_.battery_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .proto.system_info.PowerOptions.PowerSource power_source = 1;
  if (this->_internal_power_source() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_power_source());
  }

  // .proto.system_info.PowerOptions.BatteryStatus battery_status = 2;
  if (this->_internal_battery_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_battery_status());
  }

  // uint64 full_battery_life_time = 3;
  if (this->_internal_full_battery_life_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_full_battery_life_time());
  }

  // uint64 remaining_battery_life_time = 4;
  if (this->_internal_remaining_battery_life_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_remaining_battery_life_time());
  }

  // uint32 battery_life_percent = 5;
  if (this->_internal_battery_life_percent() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_battery_life_percent());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PowerOptions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PowerOptions*>(
      &from));
}

void PowerOptions::MergeFrom(const PowerOptions& from) {
  PowerOptions* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.PowerOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.battery_.MergeFrom(from._impl_.battery_);
  if (from._internal_power_source() != 0) {
    _this->_internal_set_power_source(from._internal_power_source());
  }
  if (from._internal_battery_status() != 0) {
    _this->_internal_set_battery_status(from._internal_battery_status());
  }
  if (from._internal_full_battery_life_time() != 0) {
    _this->_internal_set_full_battery_life_time(from._internal_full_battery_life_time());
  }
  if (from._internal_remaining_battery_life_time() != 0) {
    _this->_internal_set_remaining_battery_life_time(from._internal_remaining_battery_life_time());
  }
  if (from._internal_battery_life_percent() != 0) {
    _this->_internal_set_battery_life_percent(from._internal_battery_life_percent());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PowerOptions::CopyFrom(const PowerOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.PowerOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerOptions::IsInitialized() const {
  return true;
}

void PowerOptions::InternalSwap(PowerOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.battery_.InternalSwap(&other->_impl_.battery_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PowerOptions, _impl_.battery_life_percent_)
      + sizeof(PowerOptions::_impl_.battery_life_percent_)
      - PROTOBUF_FIELD_OFFSET(PowerOptions, _impl_.power_source_)>(
          reinterpret_cast<char*>(&_impl_.power_source_),
          reinterpret_cast<char*>(&other->_impl_.power_source_));
}

std::string PowerOptions::GetTypeName() const {
  return "proto.system_info.PowerOptions";
}


// ===================================================================

class Drivers_Driver::_Internal {
 public:
};

Drivers_Driver::Drivers_Driver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Drivers.Driver)
}
Drivers_Driver::Drivers_Driver(const Drivers_Driver& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Drivers_Driver* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.binary_path_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.startup_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.binary_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.binary_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_binary_path().empty()) {
    _this->_impl_.binary_path_.Set(from._internal_binary_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.startup_type_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.startup_type_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Drivers.Driver)
}

inline void Drivers_Driver::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.binary_path_){}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.startup_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.binary_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.binary_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Drivers_Driver::~Drivers_Driver() {
  // @@protoc_insertion_point(destructor:proto.system_info.Drivers.Driver)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Drivers_Driver::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.display_name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.binary_path_.Destroy();
}

void Drivers_Driver::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Drivers_Driver::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Drivers.Driver)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.display_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.binary_path_.ClearToEmpty();
  ::memset(&_impl_.status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.startup_type_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.startup_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* Drivers_Driver::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string display_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Drivers.Driver.Status status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::proto::system_info::Drivers_Driver_Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Drivers.Driver.StartupType startup_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_startup_type(static_cast<::proto::system_info::Drivers_Driver_StartupType>(val));
        } else
          goto handle_unusual;
        continue;
      // string binary_path = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_binary_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Drivers_Driver::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Drivers.Driver)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Drivers.Driver.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Drivers.Driver.display_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_display_name(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Drivers.Driver.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // .proto.system_info.Drivers.Driver.Status status = 4;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // .proto.system_info.Drivers.Driver.StartupType startup_type = 5;
  if (this->_internal_startup_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_startup_type(), target);
  }

  // string binary_path = 6;
  if (!this->_internal_binary_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_binary_path().data(), static_cast<int>(this->_internal_binary_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Drivers.Driver.binary_path");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_binary_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Drivers.Driver)
  return target;
}

size_t Drivers_Driver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Drivers.Driver)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_display_name());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string binary_path = 6;
  if (!this->_internal_binary_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_binary_path());
  }

  // .proto.system_info.Drivers.Driver.Status status = 4;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // .proto.system_info.Drivers.Driver.StartupType startup_type = 5;
  if (this->_internal_startup_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_startup_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Drivers_Driver::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Drivers_Driver*>(
      &from));
}

void Drivers_Driver::MergeFrom(const Drivers_Driver& from) {
  Drivers_Driver* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Drivers.Driver)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_binary_path().empty()) {
    _this->_internal_set_binary_path(from._internal_binary_path());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_startup_type() != 0) {
    _this->_internal_set_startup_type(from._internal_startup_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Drivers_Driver::CopyFrom(const Drivers_Driver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Drivers.Driver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Drivers_Driver::IsInitialized() const {
  return true;
}

void Drivers_Driver::InternalSwap(Drivers_Driver* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.binary_path_, lhs_arena,
      &other->_impl_.binary_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Drivers_Driver, _impl_.startup_type_)
      + sizeof(Drivers_Driver::_impl_.startup_type_)
      - PROTOBUF_FIELD_OFFSET(Drivers_Driver, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string Drivers_Driver::GetTypeName() const {
  return "proto.system_info.Drivers.Driver";
}


// ===================================================================

class Drivers::_Internal {
 public:
};

Drivers::Drivers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Drivers)
}
Drivers::Drivers(const Drivers& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Drivers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.driver_){from._impl_.driver_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Drivers)
}

inline void Drivers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.driver_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Drivers::~Drivers() {
  // @@protoc_insertion_point(destructor:proto.system_info.Drivers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Drivers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.driver_.~RepeatedPtrField();
}

void Drivers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Drivers::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Drivers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.driver_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Drivers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Drivers.Driver driver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_driver(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Drivers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Drivers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Drivers.Driver driver = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_driver_size()); i < n; i++) {
    const auto& repfield = this->_internal_driver(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Drivers)
  return target;
}

size_t Drivers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Drivers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Drivers.Driver driver = 1;
  total_size += 1UL * this->_internal_driver_size();
  for (const auto& msg : this->_impl_.driver_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Drivers::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Drivers*>(
      &from));
}

void Drivers::MergeFrom(const Drivers& from) {
  Drivers* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Drivers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.driver_.MergeFrom(from._impl_.driver_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Drivers::CopyFrom(const Drivers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Drivers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Drivers::IsInitialized() const {
  return true;
}

void Drivers::InternalSwap(Drivers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.driver_.InternalSwap(&other->_impl_.driver_);
}

std::string Drivers::GetTypeName() const {
  return "proto.system_info.Drivers";
}


// ===================================================================

class Services_Service::_Internal {
 public:
};

Services_Service::Services_Service(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Services.Service)
}
Services_Service::Services_Service(const Services_Service& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Services_Service* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.binary_path_){}
    , decltype(_impl_.start_name_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.startup_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.binary_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.binary_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_binary_path().empty()) {
    _this->_impl_.binary_path_.Set(from._internal_binary_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.start_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_start_name().empty()) {
    _this->_impl_.start_name_.Set(from._internal_start_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.startup_type_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.startup_type_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Services.Service)
}

inline void Services_Service::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.binary_path_){}
    , decltype(_impl_.start_name_){}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.startup_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.binary_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.binary_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Services_Service::~Services_Service() {
  // @@protoc_insertion_point(destructor:proto.system_info.Services.Service)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Services_Service::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.display_name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.binary_path_.Destroy();
  _impl_.start_name_.Destroy();
}

void Services_Service::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Services_Service::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Services.Service)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.display_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.binary_path_.ClearToEmpty();
  _impl_.start_name_.ClearToEmpty();
  ::memset(&_impl_.status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.startup_type_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.startup_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* Services_Service::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string display_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Services.Service.Status status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::proto::system_info::Services_Service_Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Services.Service.StartupType startup_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_startup_type(static_cast<::proto::system_info::Services_Service_StartupType>(val));
        } else
          goto handle_unusual;
        continue;
      // string binary_path = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_binary_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string start_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_start_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Services_Service::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Services.Service)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Services.Service.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Services.Service.display_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_display_name(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Services.Service.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // .proto.system_info.Services.Service.Status status = 4;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // .proto.system_info.Services.Service.StartupType startup_type = 5;
  if (this->_internal_startup_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_startup_type(), target);
  }

  // string binary_path = 6;
  if (!this->_internal_binary_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_binary_path().data(), static_cast<int>(this->_internal_binary_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Services.Service.binary_path");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_binary_path(), target);
  }

  // string start_name = 7;
  if (!this->_internal_start_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_start_name().data(), static_cast<int>(this->_internal_start_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Services.Service.start_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_start_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Services.Service)
  return target;
}

size_t Services_Service::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Services.Service)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_display_name());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string binary_path = 6;
  if (!this->_internal_binary_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_binary_path());
  }

  // string start_name = 7;
  if (!this->_internal_start_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_start_name());
  }

  // .proto.system_info.Services.Service.Status status = 4;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // .proto.system_info.Services.Service.StartupType startup_type = 5;
  if (this->_internal_startup_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_startup_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Services_Service::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Services_Service*>(
      &from));
}

void Services_Service::MergeFrom(const Services_Service& from) {
  Services_Service* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Services.Service)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_binary_path().empty()) {
    _this->_internal_set_binary_path(from._internal_binary_path());
  }
  if (!from._internal_start_name().empty()) {
    _this->_internal_set_start_name(from._internal_start_name());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_startup_type() != 0) {
    _this->_internal_set_startup_type(from._internal_startup_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Services_Service::CopyFrom(const Services_Service& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Services.Service)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Services_Service::IsInitialized() const {
  return true;
}

void Services_Service::InternalSwap(Services_Service* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.binary_path_, lhs_arena,
      &other->_impl_.binary_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.start_name_, lhs_arena,
      &other->_impl_.start_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Services_Service, _impl_.startup_type_)
      + sizeof(Services_Service::_impl_.startup_type_)
      - PROTOBUF_FIELD_OFFSET(Services_Service, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string Services_Service::GetTypeName() const {
  return "proto.system_info.Services.Service";
}


// ===================================================================

class Services::_Internal {
 public:
};

Services::Services(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Services)
}
Services::Services(const Services& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Services* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){from._impl_.service_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Services)
}

inline void Services::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Services::~Services() {
  // @@protoc_insertion_point(destructor:proto.system_info.Services)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Services::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_.~RepeatedPtrField();
}

void Services::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Services::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Services)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Services::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Services.Service service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_service(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Services::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Services)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Services.Service service = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_service_size()); i < n; i++) {
    const auto& repfield = this->_internal_service(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Services)
  return target;
}

size_t Services::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Services)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Services.Service service = 1;
  total_size += 1UL * this->_internal_service_size();
  for (const auto& msg : this->_impl_.service_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Services::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Services*>(
      &from));
}

void Services::MergeFrom(const Services& from) {
  Services* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Services)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.service_.MergeFrom(from._impl_.service_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Services::CopyFrom(const Services& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Services)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Services::IsInitialized() const {
  return true;
}

void Services::InternalSwap(Services* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.service_.InternalSwap(&other->_impl_.service_);
}

std::string Services::GetTypeName() const {
  return "proto.system_info.Services";
}


// ===================================================================

class EnvironmentVariables_Variable::_Internal {
 public:
};

EnvironmentVariables_Variable::EnvironmentVariables_Variable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.EnvironmentVariables.Variable)
}
EnvironmentVariables_Variable::EnvironmentVariables_Variable(const EnvironmentVariables_Variable& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EnvironmentVariables_Variable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.EnvironmentVariables.Variable)
}

inline void EnvironmentVariables_Variable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EnvironmentVariables_Variable::~EnvironmentVariables_Variable() {
  // @@protoc_insertion_point(destructor:proto.system_info.EnvironmentVariables.Variable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnvironmentVariables_Variable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void EnvironmentVariables_Variable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvironmentVariables_Variable::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.EnvironmentVariables.Variable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* EnvironmentVariables_Variable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnvironmentVariables_Variable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.EnvironmentVariables.Variable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.EnvironmentVariables.Variable.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.EnvironmentVariables.Variable.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.EnvironmentVariables.Variable)
  return target;
}

size_t EnvironmentVariables_Variable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.EnvironmentVariables.Variable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnvironmentVariables_Variable::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EnvironmentVariables_Variable*>(
      &from));
}

void EnvironmentVariables_Variable::MergeFrom(const EnvironmentVariables_Variable& from) {
  EnvironmentVariables_Variable* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.EnvironmentVariables.Variable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EnvironmentVariables_Variable::CopyFrom(const EnvironmentVariables_Variable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.EnvironmentVariables.Variable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvironmentVariables_Variable::IsInitialized() const {
  return true;
}

void EnvironmentVariables_Variable::InternalSwap(EnvironmentVariables_Variable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string EnvironmentVariables_Variable::GetTypeName() const {
  return "proto.system_info.EnvironmentVariables.Variable";
}


// ===================================================================

class EnvironmentVariables::_Internal {
 public:
};

EnvironmentVariables::EnvironmentVariables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.EnvironmentVariables)
}
EnvironmentVariables::EnvironmentVariables(const EnvironmentVariables& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EnvironmentVariables* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.variable_){from._impl_.variable_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.EnvironmentVariables)
}

inline void EnvironmentVariables::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.variable_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EnvironmentVariables::~EnvironmentVariables() {
  // @@protoc_insertion_point(destructor:proto.system_info.EnvironmentVariables)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnvironmentVariables::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.variable_.~RepeatedPtrField();
}

void EnvironmentVariables::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvironmentVariables::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.EnvironmentVariables)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.variable_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EnvironmentVariables::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.EnvironmentVariables.Variable variable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_variable(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnvironmentVariables::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.EnvironmentVariables)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.EnvironmentVariables.Variable variable = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_variable_size()); i < n; i++) {
    const auto& repfield = this->_internal_variable(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.EnvironmentVariables)
  return target;
}

size_t EnvironmentVariables::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.EnvironmentVariables)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.EnvironmentVariables.Variable variable = 1;
  total_size += 1UL * this->_internal_variable_size();
  for (const auto& msg : this->_impl_.variable_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnvironmentVariables::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EnvironmentVariables*>(
      &from));
}

void EnvironmentVariables::MergeFrom(const EnvironmentVariables& from) {
  EnvironmentVariables* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.EnvironmentVariables)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.variable_.MergeFrom(from._impl_.variable_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EnvironmentVariables::CopyFrom(const EnvironmentVariables& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.EnvironmentVariables)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvironmentVariables::IsInitialized() const {
  return true;
}

void EnvironmentVariables::InternalSwap(EnvironmentVariables* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.variable_.InternalSwap(&other->_impl_.variable_);
}

std::string EnvironmentVariables::GetTypeName() const {
  return "proto.system_info.EnvironmentVariables";
}


// ===================================================================

class EventLogs_Event::_Internal {
 public:
};

EventLogs_Event::EventLogs_Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.EventLogs.Event)
}
EventLogs_Event::EventLogs_Event(const EventLogs_Event& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EventLogs_Event* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.category_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.event_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_category().empty()) {
    _this->_impl_.category_.Set(from._internal_category(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source().empty()) {
    _this->_impl_.source_.Set(from._internal_source(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.event_id_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.event_id_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.EventLogs.Event)
}

inline void EventLogs_Event::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.category_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.time_){int64_t{0}}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.event_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventLogs_Event::~EventLogs_Event() {
  // @@protoc_insertion_point(destructor:proto.system_info.EventLogs.Event)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventLogs_Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.category_.Destroy();
  _impl_.source_.Destroy();
  _impl_.description_.Destroy();
}

void EventLogs_Event::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventLogs_Event::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.EventLogs.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.category_.ClearToEmpty();
  _impl_.source_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  ::memset(&_impl_.time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.event_id_) -
      reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.event_id_));
  _internal_metadata_.Clear<std::string>();
}

const char* EventLogs_Event::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.system_info.EventLogs.Event.Level level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::proto::system_info::EventLogs_Event_Level>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string category = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_category();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 event_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventLogs_Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.EventLogs.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.system_info.EventLogs.Event.Level level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_level(), target);
  }

  // int64 time = 2;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_time(), target);
  }

  // string category = 3;
  if (!this->_internal_category().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_category().data(), static_cast<int>(this->_internal_category().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.EventLogs.Event.category");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_category(), target);
  }

  // uint32 event_id = 4;
  if (this->_internal_event_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_event_id(), target);
  }

  // string source = 5;
  if (!this->_internal_source().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source().data(), static_cast<int>(this->_internal_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.EventLogs.Event.source");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_source(), target);
  }

  // string description = 6;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.EventLogs.Event.description");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.EventLogs.Event)
  return target;
}

size_t EventLogs_Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.EventLogs.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string category = 3;
  if (!this->_internal_category().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_category());
  }

  // string source = 5;
  if (!this->_internal_source().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source());
  }

  // string description = 6;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // int64 time = 2;
  if (this->_internal_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time());
  }

  // .proto.system_info.EventLogs.Event.Level level = 1;
  if (this->_internal_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // uint32 event_id = 4;
  if (this->_internal_event_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventLogs_Event::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventLogs_Event*>(
      &from));
}

void EventLogs_Event::MergeFrom(const EventLogs_Event& from) {
  EventLogs_Event* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.EventLogs.Event)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_category().empty()) {
    _this->_internal_set_category(from._internal_category());
  }
  if (!from._internal_source().empty()) {
    _this->_internal_set_source(from._internal_source());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_event_id() != 0) {
    _this->_internal_set_event_id(from._internal_event_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventLogs_Event::CopyFrom(const EventLogs_Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.EventLogs.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventLogs_Event::IsInitialized() const {
  return true;
}

void EventLogs_Event::InternalSwap(EventLogs_Event* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.category_, lhs_arena,
      &other->_impl_.category_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_, lhs_arena,
      &other->_impl_.source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventLogs_Event, _impl_.event_id_)
      + sizeof(EventLogs_Event::_impl_.event_id_)
      - PROTOBUF_FIELD_OFFSET(EventLogs_Event, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

std::string EventLogs_Event::GetTypeName() const {
  return "proto.system_info.EventLogs.Event";
}


// ===================================================================

class EventLogs::_Internal {
 public:
};

EventLogs::EventLogs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.EventLogs)
}
EventLogs::EventLogs(const EventLogs& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EventLogs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.event_){from._impl_.event_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.total_records_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_records_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.total_records_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.EventLogs)
}

inline void EventLogs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.event_){arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.total_records_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventLogs::~EventLogs() {
  // @@protoc_insertion_point(destructor:proto.system_info.EventLogs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventLogs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.event_.~RepeatedPtrField();
}

void EventLogs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventLogs::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.EventLogs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.event_.Clear();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.total_records_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.total_records_));
  _internal_metadata_.Clear<std::string>();
}

const char* EventLogs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.system_info.EventLogs.Event.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::proto::system_info::EventLogs_Event_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 total_records = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_records_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.system_info.EventLogs.Event event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventLogs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.EventLogs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.system_info.EventLogs.Event.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // uint32 total_records = 2;
  if (this->_internal_total_records() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_total_records(), target);
  }

  // repeated .proto.system_info.EventLogs.Event event = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_event_size()); i < n; i++) {
    const auto& repfield = this->_internal_event(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.EventLogs)
  return target;
}

size_t EventLogs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.EventLogs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.EventLogs.Event event = 3;
  total_size += 1UL * this->_internal_event_size();
  for (const auto& msg : this->_impl_.event_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .proto.system_info.EventLogs.Event.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 total_records = 2;
  if (this->_internal_total_records() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_records());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventLogs::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventLogs*>(
      &from));
}

void EventLogs::MergeFrom(const EventLogs& from) {
  EventLogs* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.EventLogs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.event_.MergeFrom(from._impl_.event_);
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_total_records() != 0) {
    _this->_internal_set_total_records(from._internal_total_records());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventLogs::CopyFrom(const EventLogs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.EventLogs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventLogs::IsInitialized() const {
  return true;
}

void EventLogs::InternalSwap(EventLogs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.event_.InternalSwap(&other->_impl_.event_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventLogs, _impl_.total_records_)
      + sizeof(EventLogs::_impl_.total_records_)
      - PROTOBUF_FIELD_OFFSET(EventLogs, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string EventLogs::GetTypeName() const {
  return "proto.system_info.EventLogs";
}


// ===================================================================

class EventLogsData::_Internal {
 public:
};

EventLogsData::EventLogsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.EventLogsData)
}
EventLogsData::EventLogsData(const EventLogsData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EventLogsData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.record_start_){}
    , decltype(_impl_.record_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.record_count_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.record_count_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.EventLogsData)
}

inline void EventLogsData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , decltype(_impl_.record_start_){0u}
    , decltype(_impl_.record_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventLogsData::~EventLogsData() {
  // @@protoc_insertion_point(destructor:proto.system_info.EventLogsData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventLogsData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EventLogsData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventLogsData::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.EventLogsData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.record_count_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.record_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* EventLogsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.system_info.EventLogs.Event.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::proto::system_info::EventLogs_Event_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 record_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.record_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 record_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.record_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventLogsData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.EventLogsData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.system_info.EventLogs.Event.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // uint32 record_start = 2;
  if (this->_internal_record_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_record_start(), target);
  }

  // uint32 record_count = 3;
  if (this->_internal_record_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_record_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.EventLogsData)
  return target;
}

size_t EventLogsData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.EventLogsData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.system_info.EventLogs.Event.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 record_start = 2;
  if (this->_internal_record_start() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_record_start());
  }

  // uint32 record_count = 3;
  if (this->_internal_record_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_record_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventLogsData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventLogsData*>(
      &from));
}

void EventLogsData::MergeFrom(const EventLogsData& from) {
  EventLogsData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.EventLogsData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_record_start() != 0) {
    _this->_internal_set_record_start(from._internal_record_start());
  }
  if (from._internal_record_count() != 0) {
    _this->_internal_set_record_count(from._internal_record_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventLogsData::CopyFrom(const EventLogsData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.EventLogsData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventLogsData::IsInitialized() const {
  return true;
}

void EventLogsData::InternalSwap(EventLogsData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventLogsData, _impl_.record_count_)
      + sizeof(EventLogsData::_impl_.record_count_)
      - PROTOBUF_FIELD_OFFSET(EventLogsData, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string EventLogsData::GetTypeName() const {
  return "proto.system_info.EventLogsData";
}


// ===================================================================

class Routes_Route::_Internal {
 public:
};

Routes_Route::Routes_Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Routes.Route)
}
Routes_Route::Routes_Route(const Routes_Route& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Routes_Route* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.destonation_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.metric_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.destonation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destonation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_destonation().empty()) {
    _this->_impl_.destonation_.Set(from._internal_destonation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mask().empty()) {
    _this->_impl_.mask_.Set(from._internal_mask(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gateway().empty()) {
    _this->_impl_.gateway_.Set(from._internal_gateway(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.metric_ = from._impl_.metric_;
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Routes.Route)
}

inline void Routes_Route::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.destonation_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.metric_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.destonation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destonation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Routes_Route::~Routes_Route() {
  // @@protoc_insertion_point(destructor:proto.system_info.Routes.Route)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Routes_Route::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.destonation_.Destroy();
  _impl_.mask_.Destroy();
  _impl_.gateway_.Destroy();
}

void Routes_Route::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Routes_Route::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Routes.Route)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.destonation_.ClearToEmpty();
  _impl_.mask_.ClearToEmpty();
  _impl_.gateway_.ClearToEmpty();
  _impl_.metric_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* Routes_Route::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string destonation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_destonation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string mask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mask();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string gateway = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gateway();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 metric = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.metric_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Routes_Route::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Routes.Route)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string destonation = 1;
  if (!this->_internal_destonation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_destonation().data(), static_cast<int>(this->_internal_destonation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Routes.Route.destonation");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_destonation(), target);
  }

  // string mask = 2;
  if (!this->_internal_mask().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mask().data(), static_cast<int>(this->_internal_mask().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Routes.Route.mask");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mask(), target);
  }

  // string gateway = 3;
  if (!this->_internal_gateway().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gateway().data(), static_cast<int>(this->_internal_gateway().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Routes.Route.gateway");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gateway(), target);
  }

  // uint32 metric = 4;
  if (this->_internal_metric() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_metric(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Routes.Route)
  return target;
}

size_t Routes_Route::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Routes.Route)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string destonation = 1;
  if (!this->_internal_destonation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_destonation());
  }

  // string mask = 2;
  if (!this->_internal_mask().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mask());
  }

  // string gateway = 3;
  if (!this->_internal_gateway().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gateway());
  }

  // uint32 metric = 4;
  if (this->_internal_metric() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_metric());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Routes_Route::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Routes_Route*>(
      &from));
}

void Routes_Route::MergeFrom(const Routes_Route& from) {
  Routes_Route* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Routes.Route)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_destonation().empty()) {
    _this->_internal_set_destonation(from._internal_destonation());
  }
  if (!from._internal_mask().empty()) {
    _this->_internal_set_mask(from._internal_mask());
  }
  if (!from._internal_gateway().empty()) {
    _this->_internal_set_gateway(from._internal_gateway());
  }
  if (from._internal_metric() != 0) {
    _this->_internal_set_metric(from._internal_metric());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Routes_Route::CopyFrom(const Routes_Route& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Routes.Route)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Routes_Route::IsInitialized() const {
  return true;
}

void Routes_Route::InternalSwap(Routes_Route* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.destonation_, lhs_arena,
      &other->_impl_.destonation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mask_, lhs_arena,
      &other->_impl_.mask_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gateway_, lhs_arena,
      &other->_impl_.gateway_, rhs_arena
  );
  swap(_impl_.metric_, other->_impl_.metric_);
}

std::string Routes_Route::GetTypeName() const {
  return "proto.system_info.Routes.Route";
}


// ===================================================================

class Routes::_Internal {
 public:
};

Routes::Routes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Routes)
}
Routes::Routes(const Routes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Routes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.route_){from._impl_.route_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Routes)
}

inline void Routes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.route_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Routes::~Routes() {
  // @@protoc_insertion_point(destructor:proto.system_info.Routes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Routes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.route_.~RepeatedPtrField();
}

void Routes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Routes::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Routes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.route_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Routes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Routes.Route route = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_route(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Routes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Routes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Routes.Route route = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_route_size()); i < n; i++) {
    const auto& repfield = this->_internal_route(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Routes)
  return target;
}

size_t Routes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Routes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Routes.Route route = 1;
  total_size += 1UL * this->_internal_route_size();
  for (const auto& msg : this->_impl_.route_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Routes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Routes*>(
      &from));
}

void Routes::MergeFrom(const Routes& from) {
  Routes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Routes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.route_.MergeFrom(from._impl_.route_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Routes::CopyFrom(const Routes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Routes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Routes::IsInitialized() const {
  return true;
}

void Routes::InternalSwap(Routes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.route_.InternalSwap(&other->_impl_.route_);
}

std::string Routes::GetTypeName() const {
  return "proto.system_info.Routes";
}


// ===================================================================

class Connections_Connection::_Internal {
 public:
};

Connections_Connection::Connections_Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Connections.Connection)
}
Connections_Connection::Connections_Connection(const Connections_Connection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Connections_Connection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.process_name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.local_address_){}
    , decltype(_impl_.remote_address_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.local_port_){}
    , decltype(_impl_.remote_port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.process_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.process_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_process_name().empty()) {
    _this->_impl_.process_name_.Set(from._internal_process_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_protocol().empty()) {
    _this->_impl_.protocol_.Set(from._internal_protocol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.local_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_local_address().empty()) {
    _this->_impl_.local_address_.Set(from._internal_local_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.remote_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_remote_address().empty()) {
    _this->_impl_.remote_address_.Set(from._internal_remote_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state().empty()) {
    _this->_impl_.state_.Set(from._internal_state(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.local_port_, &from._impl_.local_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.remote_port_) -
    reinterpret_cast<char*>(&_impl_.local_port_)) + sizeof(_impl_.remote_port_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Connections.Connection)
}

inline void Connections_Connection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.process_name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.local_address_){}
    , decltype(_impl_.remote_address_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.local_port_){0u}
    , decltype(_impl_.remote_port_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.process_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.process_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.local_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Connections_Connection::~Connections_Connection() {
  // @@protoc_insertion_point(destructor:proto.system_info.Connections.Connection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Connections_Connection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.process_name_.Destroy();
  _impl_.protocol_.Destroy();
  _impl_.local_address_.Destroy();
  _impl_.remote_address_.Destroy();
  _impl_.state_.Destroy();
}

void Connections_Connection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Connections_Connection::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Connections.Connection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.process_name_.ClearToEmpty();
  _impl_.protocol_.ClearToEmpty();
  _impl_.local_address_.ClearToEmpty();
  _impl_.remote_address_.ClearToEmpty();
  _impl_.state_.ClearToEmpty();
  ::memset(&_impl_.local_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.remote_port_) -
      reinterpret_cast<char*>(&_impl_.local_port_)) + sizeof(_impl_.remote_port_));
  _internal_metadata_.Clear<std::string>();
}

const char* Connections_Connection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string process_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_process_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string protocol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_protocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string local_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_local_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string remote_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_remote_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 local_port = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.local_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 remote_port = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.remote_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Connections_Connection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Connections.Connection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string process_name = 1;
  if (!this->_internal_process_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_process_name().data(), static_cast<int>(this->_internal_process_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Connections.Connection.process_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_process_name(), target);
  }

  // string protocol = 2;
  if (!this->_internal_protocol().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_protocol().data(), static_cast<int>(this->_internal_protocol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Connections.Connection.protocol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_protocol(), target);
  }

  // string local_address = 3;
  if (!this->_internal_local_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_local_address().data(), static_cast<int>(this->_internal_local_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Connections.Connection.local_address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_local_address(), target);
  }

  // string remote_address = 4;
  if (!this->_internal_remote_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_remote_address().data(), static_cast<int>(this->_internal_remote_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Connections.Connection.remote_address");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_remote_address(), target);
  }

  // uint32 local_port = 5;
  if (this->_internal_local_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_local_port(), target);
  }

  // uint32 remote_port = 6;
  if (this->_internal_remote_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_remote_port(), target);
  }

  // string state = 7;
  if (!this->_internal_state().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state().data(), static_cast<int>(this->_internal_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Connections.Connection.state");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Connections.Connection)
  return target;
}

size_t Connections_Connection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Connections.Connection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string process_name = 1;
  if (!this->_internal_process_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_process_name());
  }

  // string protocol = 2;
  if (!this->_internal_protocol().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_protocol());
  }

  // string local_address = 3;
  if (!this->_internal_local_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_local_address());
  }

  // string remote_address = 4;
  if (!this->_internal_remote_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_remote_address());
  }

  // string state = 7;
  if (!this->_internal_state().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_state());
  }

  // uint32 local_port = 5;
  if (this->_internal_local_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_local_port());
  }

  // uint32 remote_port = 6;
  if (this->_internal_remote_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remote_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Connections_Connection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Connections_Connection*>(
      &from));
}

void Connections_Connection::MergeFrom(const Connections_Connection& from) {
  Connections_Connection* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Connections.Connection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_process_name().empty()) {
    _this->_internal_set_process_name(from._internal_process_name());
  }
  if (!from._internal_protocol().empty()) {
    _this->_internal_set_protocol(from._internal_protocol());
  }
  if (!from._internal_local_address().empty()) {
    _this->_internal_set_local_address(from._internal_local_address());
  }
  if (!from._internal_remote_address().empty()) {
    _this->_internal_set_remote_address(from._internal_remote_address());
  }
  if (!from._internal_state().empty()) {
    _this->_internal_set_state(from._internal_state());
  }
  if (from._internal_local_port() != 0) {
    _this->_internal_set_local_port(from._internal_local_port());
  }
  if (from._internal_remote_port() != 0) {
    _this->_internal_set_remote_port(from._internal_remote_port());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Connections_Connection::CopyFrom(const Connections_Connection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Connections.Connection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connections_Connection::IsInitialized() const {
  return true;
}

void Connections_Connection::InternalSwap(Connections_Connection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.process_name_, lhs_arena,
      &other->_impl_.process_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protocol_, lhs_arena,
      &other->_impl_.protocol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.local_address_, lhs_arena,
      &other->_impl_.local_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_address_, lhs_arena,
      &other->_impl_.remote_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.state_, lhs_arena,
      &other->_impl_.state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Connections_Connection, _impl_.remote_port_)
      + sizeof(Connections_Connection::_impl_.remote_port_)
      - PROTOBUF_FIELD_OFFSET(Connections_Connection, _impl_.local_port_)>(
          reinterpret_cast<char*>(&_impl_.local_port_),
          reinterpret_cast<char*>(&other->_impl_.local_port_));
}

std::string Connections_Connection::GetTypeName() const {
  return "proto.system_info.Connections.Connection";
}


// ===================================================================

class Connections::_Internal {
 public:
};

Connections::Connections(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Connections)
}
Connections::Connections(const Connections& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Connections* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.connection_){from._impl_.connection_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Connections)
}

inline void Connections::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.connection_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Connections::~Connections() {
  // @@protoc_insertion_point(destructor:proto.system_info.Connections)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Connections::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.connection_.~RepeatedPtrField();
}

void Connections::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Connections::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Connections)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.connection_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Connections::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Connections.Connection connection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_connection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Connections::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Connections)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Connections.Connection connection = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_connection_size()); i < n; i++) {
    const auto& repfield = this->_internal_connection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Connections)
  return target;
}

size_t Connections::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Connections)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Connections.Connection connection = 1;
  total_size += 1UL * this->_internal_connection_size();
  for (const auto& msg : this->_impl_.connection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Connections::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Connections*>(
      &from));
}

void Connections::MergeFrom(const Connections& from) {
  Connections* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Connections)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.connection_.MergeFrom(from._impl_.connection_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Connections::CopyFrom(const Connections& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Connections)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connections::IsInitialized() const {
  return true;
}

void Connections::InternalSwap(Connections* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.connection_.InternalSwap(&other->_impl_.connection_);
}

std::string Connections::GetTypeName() const {
  return "proto.system_info.Connections";
}


// ===================================================================

class Licenses_License_Field::_Internal {
 public:
};

Licenses_License_Field::Licenses_License_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Licenses.License.Field)
}
Licenses_License_Field::Licenses_License_Field(const Licenses_License_Field& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Licenses_License_Field* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Licenses.License.Field)
}

inline void Licenses_License_Field::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Licenses_License_Field::~Licenses_License_Field() {
  // @@protoc_insertion_point(destructor:proto.system_info.Licenses.License.Field)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Licenses_License_Field::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void Licenses_License_Field::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Licenses_License_Field::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Licenses.License.Field)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Licenses_License_Field::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.system_info.Licenses.License.Field.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::proto::system_info::Licenses_License_Field_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Licenses_License_Field::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Licenses.License.Field)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.system_info.Licenses.License.Field.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Licenses.License.Field.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Licenses.License.Field)
  return target;
}

size_t Licenses_License_Field::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Licenses.License.Field)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // .proto.system_info.Licenses.License.Field.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Licenses_License_Field::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Licenses_License_Field*>(
      &from));
}

void Licenses_License_Field::MergeFrom(const Licenses_License_Field& from) {
  Licenses_License_Field* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Licenses.License.Field)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Licenses_License_Field::CopyFrom(const Licenses_License_Field& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Licenses.License.Field)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Licenses_License_Field::IsInitialized() const {
  return true;
}

void Licenses_License_Field::InternalSwap(Licenses_License_Field* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string Licenses_License_Field::GetTypeName() const {
  return "proto.system_info.Licenses.License.Field";
}


// ===================================================================

class Licenses_License::_Internal {
 public:
};

Licenses_License::Licenses_License(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Licenses.License)
}
Licenses_License::Licenses_License(const Licenses_License& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Licenses_License* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.field_){from._impl_.field_}
    , decltype(_impl_.product_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_product_name().empty()) {
    _this->_impl_.product_name_.Set(from._internal_product_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Licenses.License)
}

inline void Licenses_License::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.field_){arena}
    , decltype(_impl_.product_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Licenses_License::~Licenses_License() {
  // @@protoc_insertion_point(destructor:proto.system_info.Licenses.License)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Licenses_License::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.field_.~RepeatedPtrField();
  _impl_.product_name_.Destroy();
}

void Licenses_License::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Licenses_License::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Licenses.License)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.field_.Clear();
  _impl_.product_name_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Licenses_License::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string product_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_product_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.system_info.Licenses.License.Field field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_field(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Licenses_License::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Licenses.License)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string product_name = 1;
  if (!this->_internal_product_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_product_name().data(), static_cast<int>(this->_internal_product_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Licenses.License.product_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_product_name(), target);
  }

  // repeated .proto.system_info.Licenses.License.Field field = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_field_size()); i < n; i++) {
    const auto& repfield = this->_internal_field(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Licenses.License)
  return target;
}

size_t Licenses_License::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Licenses.License)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Licenses.License.Field field = 2;
  total_size += 1UL * this->_internal_field_size();
  for (const auto& msg : this->_impl_.field_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string product_name = 1;
  if (!this->_internal_product_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_product_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Licenses_License::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Licenses_License*>(
      &from));
}

void Licenses_License::MergeFrom(const Licenses_License& from) {
  Licenses_License* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Licenses.License)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.field_.MergeFrom(from._impl_.field_);
  if (!from._internal_product_name().empty()) {
    _this->_internal_set_product_name(from._internal_product_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Licenses_License::CopyFrom(const Licenses_License& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Licenses.License)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Licenses_License::IsInitialized() const {
  return true;
}

void Licenses_License::InternalSwap(Licenses_License* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.field_.InternalSwap(&other->_impl_.field_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.product_name_, lhs_arena,
      &other->_impl_.product_name_, rhs_arena
  );
}

std::string Licenses_License::GetTypeName() const {
  return "proto.system_info.Licenses.License";
}


// ===================================================================

class Licenses::_Internal {
 public:
};

Licenses::Licenses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Licenses)
}
Licenses::Licenses(const Licenses& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Licenses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.license_){from._impl_.license_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Licenses)
}

inline void Licenses::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.license_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Licenses::~Licenses() {
  // @@protoc_insertion_point(destructor:proto.system_info.Licenses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Licenses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.license_.~RepeatedPtrField();
}

void Licenses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Licenses::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Licenses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.license_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Licenses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Licenses.License license = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_license(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Licenses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Licenses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Licenses.License license = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_license_size()); i < n; i++) {
    const auto& repfield = this->_internal_license(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Licenses)
  return target;
}

size_t Licenses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Licenses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Licenses.License license = 1;
  total_size += 1UL * this->_internal_license_size();
  for (const auto& msg : this->_impl_.license_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Licenses::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Licenses*>(
      &from));
}

void Licenses::MergeFrom(const Licenses& from) {
  Licenses* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Licenses)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.license_.MergeFrom(from._impl_.license_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Licenses::CopyFrom(const Licenses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Licenses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Licenses::IsInitialized() const {
  return true;
}

void Licenses::InternalSwap(Licenses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.license_.InternalSwap(&other->_impl_.license_);
}

std::string Licenses::GetTypeName() const {
  return "proto.system_info.Licenses";
}


// ===================================================================

class Applications_Application::_Internal {
 public:
};

Applications_Application::Applications_Application(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Applications.Application)
}
Applications_Application::Applications_Application(const Applications_Application& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Applications_Application* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.publisher_){}
    , decltype(_impl_.install_date_){}
    , decltype(_impl_.install_location_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.publisher_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publisher_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_publisher().empty()) {
    _this->_impl_.publisher_.Set(from._internal_publisher(), 
      _this->GetArenaForAllocation());
  }
  _impl_.install_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.install_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_install_date().empty()) {
    _this->_impl_.install_date_.Set(from._internal_install_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.install_location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.install_location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_install_location().empty()) {
    _this->_impl_.install_location_.Set(from._internal_install_location(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Applications.Application)
}

inline void Applications_Application::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.publisher_){}
    , decltype(_impl_.install_date_){}
    , decltype(_impl_.install_location_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.publisher_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publisher_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.install_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.install_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.install_location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.install_location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Applications_Application::~Applications_Application() {
  // @@protoc_insertion_point(destructor:proto.system_info.Applications.Application)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Applications_Application::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.version_.Destroy();
  _impl_.publisher_.Destroy();
  _impl_.install_date_.Destroy();
  _impl_.install_location_.Destroy();
}

void Applications_Application::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Applications_Application::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Applications.Application)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  _impl_.publisher_.ClearToEmpty();
  _impl_.install_date_.ClearToEmpty();
  _impl_.install_location_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Applications_Application::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string publisher = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_publisher();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string install_date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_install_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string install_location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_install_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Applications_Application::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Applications.Application)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Applications.Application.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Applications.Application.version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // string publisher = 3;
  if (!this->_internal_publisher().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_publisher().data(), static_cast<int>(this->_internal_publisher().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Applications.Application.publisher");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_publisher(), target);
  }

  // string install_date = 4;
  if (!this->_internal_install_date().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_install_date().data(), static_cast<int>(this->_internal_install_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Applications.Application.install_date");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_install_date(), target);
  }

  // string install_location = 5;
  if (!this->_internal_install_location().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_install_location().data(), static_cast<int>(this->_internal_install_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Applications.Application.install_location");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_install_location(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Applications.Application)
  return target;
}

size_t Applications_Application::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Applications.Application)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string publisher = 3;
  if (!this->_internal_publisher().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publisher());
  }

  // string install_date = 4;
  if (!this->_internal_install_date().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_install_date());
  }

  // string install_location = 5;
  if (!this->_internal_install_location().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_install_location());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Applications_Application::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Applications_Application*>(
      &from));
}

void Applications_Application::MergeFrom(const Applications_Application& from) {
  Applications_Application* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Applications.Application)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_publisher().empty()) {
    _this->_internal_set_publisher(from._internal_publisher());
  }
  if (!from._internal_install_date().empty()) {
    _this->_internal_set_install_date(from._internal_install_date());
  }
  if (!from._internal_install_location().empty()) {
    _this->_internal_set_install_location(from._internal_install_location());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Applications_Application::CopyFrom(const Applications_Application& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Applications.Application)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Applications_Application::IsInitialized() const {
  return true;
}

void Applications_Application::InternalSwap(Applications_Application* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publisher_, lhs_arena,
      &other->_impl_.publisher_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.install_date_, lhs_arena,
      &other->_impl_.install_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.install_location_, lhs_arena,
      &other->_impl_.install_location_, rhs_arena
  );
}

std::string Applications_Application::GetTypeName() const {
  return "proto.system_info.Applications.Application";
}


// ===================================================================

class Applications::_Internal {
 public:
};

Applications::Applications(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Applications)
}
Applications::Applications(const Applications& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Applications* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.application_){from._impl_.application_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Applications)
}

inline void Applications::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.application_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Applications::~Applications() {
  // @@protoc_insertion_point(destructor:proto.system_info.Applications)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Applications::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.application_.~RepeatedPtrField();
}

void Applications::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Applications::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Applications)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.application_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Applications::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Applications.Application application = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_application(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Applications::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Applications)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Applications.Application application = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_application_size()); i < n; i++) {
    const auto& repfield = this->_internal_application(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Applications)
  return target;
}

size_t Applications::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Applications)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Applications.Application application = 1;
  total_size += 1UL * this->_internal_application_size();
  for (const auto& msg : this->_impl_.application_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Applications::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Applications*>(
      &from));
}

void Applications::MergeFrom(const Applications& from) {
  Applications* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Applications)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.application_.MergeFrom(from._impl_.application_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Applications::CopyFrom(const Applications& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Applications)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Applications::IsInitialized() const {
  return true;
}

void Applications::InternalSwap(Applications* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.application_.InternalSwap(&other->_impl_.application_);
}

std::string Applications::GetTypeName() const {
  return "proto.system_info.Applications";
}


// ===================================================================

class OpenFiles_OpenFile::_Internal {
 public:
};

OpenFiles_OpenFile::OpenFiles_OpenFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.OpenFiles.OpenFile)
}
OpenFiles_OpenFile::OpenFiles_OpenFile(const OpenFiles_OpenFile& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OpenFiles_OpenFile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_name_){}
    , decltype(_impl_.file_path_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.lock_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_name().empty()) {
    _this->_impl_.user_name_.Set(from._internal_user_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_path().empty()) {
    _this->_impl_.file_path_.Set(from._internal_file_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lock_count_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.lock_count_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.OpenFiles.OpenFile)
}

inline void OpenFiles_OpenFile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_name_){}
    , decltype(_impl_.file_path_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.lock_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OpenFiles_OpenFile::~OpenFiles_OpenFile() {
  // @@protoc_insertion_point(destructor:proto.system_info.OpenFiles.OpenFile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpenFiles_OpenFile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.file_path_.Destroy();
}

void OpenFiles_OpenFile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpenFiles_OpenFile::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.OpenFiles.OpenFile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_name_.ClearToEmpty();
  _impl_.file_path_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.lock_count_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.lock_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* OpenFiles_OpenFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 lock_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.lock_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_path = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_file_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpenFiles_OpenFile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.OpenFiles.OpenFile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // string user_name = 2;
  if (!this->_internal_user_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.OpenFiles.OpenFile.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  // uint32 lock_count = 3;
  if (this->_internal_lock_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lock_count(), target);
  }

  // string file_path = 4;
  if (!this->_internal_file_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_path().data(), static_cast<int>(this->_internal_file_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.OpenFiles.OpenFile.file_path");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_file_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.OpenFiles.OpenFile)
  return target;
}

size_t OpenFiles_OpenFile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.OpenFiles.OpenFile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_name = 2;
  if (!this->_internal_user_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  // string file_path = 4;
  if (!this->_internal_file_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_path());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // uint32 lock_count = 3;
  if (this->_internal_lock_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lock_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OpenFiles_OpenFile::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OpenFiles_OpenFile*>(
      &from));
}

void OpenFiles_OpenFile::MergeFrom(const OpenFiles_OpenFile& from) {
  OpenFiles_OpenFile* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.OpenFiles.OpenFile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_name().empty()) {
    _this->_internal_set_user_name(from._internal_user_name());
  }
  if (!from._internal_file_path().empty()) {
    _this->_internal_set_file_path(from._internal_file_path());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_lock_count() != 0) {
    _this->_internal_set_lock_count(from._internal_lock_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OpenFiles_OpenFile::CopyFrom(const OpenFiles_OpenFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.OpenFiles.OpenFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenFiles_OpenFile::IsInitialized() const {
  return true;
}

void OpenFiles_OpenFile::InternalSwap(OpenFiles_OpenFile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_path_, lhs_arena,
      &other->_impl_.file_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpenFiles_OpenFile, _impl_.lock_count_)
      + sizeof(OpenFiles_OpenFile::_impl_.lock_count_)
      - PROTOBUF_FIELD_OFFSET(OpenFiles_OpenFile, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string OpenFiles_OpenFile::GetTypeName() const {
  return "proto.system_info.OpenFiles.OpenFile";
}


// ===================================================================

class OpenFiles::_Internal {
 public:
};

OpenFiles::OpenFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.OpenFiles)
}
OpenFiles::OpenFiles(const OpenFiles& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OpenFiles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.open_file_){from._impl_.open_file_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.OpenFiles)
}

inline void OpenFiles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.open_file_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OpenFiles::~OpenFiles() {
  // @@protoc_insertion_point(destructor:proto.system_info.OpenFiles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpenFiles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.open_file_.~RepeatedPtrField();
}

void OpenFiles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpenFiles::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.OpenFiles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.open_file_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OpenFiles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.OpenFiles.OpenFile open_file = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_open_file(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpenFiles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.OpenFiles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.OpenFiles.OpenFile open_file = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_open_file_size()); i < n; i++) {
    const auto& repfield = this->_internal_open_file(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.OpenFiles)
  return target;
}

size_t OpenFiles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.OpenFiles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.OpenFiles.OpenFile open_file = 1;
  total_size += 1UL * this->_internal_open_file_size();
  for (const auto& msg : this->_impl_.open_file_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OpenFiles::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OpenFiles*>(
      &from));
}

void OpenFiles::MergeFrom(const OpenFiles& from) {
  OpenFiles* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.OpenFiles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.open_file_.MergeFrom(from._impl_.open_file_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OpenFiles::CopyFrom(const OpenFiles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.OpenFiles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenFiles::IsInitialized() const {
  return true;
}

void OpenFiles::InternalSwap(OpenFiles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.open_file_.InternalSwap(&other->_impl_.open_file_);
}

std::string OpenFiles::GetTypeName() const {
  return "proto.system_info.OpenFiles";
}


// ===================================================================

class LocalUsers_LocalUser_LocalUserGroup::_Internal {
 public:
};

LocalUsers_LocalUser_LocalUserGroup::LocalUsers_LocalUser_LocalUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
}
LocalUsers_LocalUser_LocalUserGroup::LocalUsers_LocalUser_LocalUserGroup(const LocalUsers_LocalUser_LocalUserGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LocalUsers_LocalUser_LocalUserGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.comment_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
}

inline void LocalUsers_LocalUser_LocalUserGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.comment_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalUsers_LocalUser_LocalUserGroup::~LocalUsers_LocalUser_LocalUserGroup() {
  // @@protoc_insertion_point(destructor:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalUsers_LocalUser_LocalUserGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.comment_.Destroy();
}

void LocalUsers_LocalUser_LocalUserGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalUsers_LocalUser_LocalUserGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.comment_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* LocalUsers_LocalUser_LocalUserGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string comment = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalUsers_LocalUser_LocalUserGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUsers.LocalUser.LocalUserGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string comment = 2;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUsers.LocalUser.LocalUserGroup.comment");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_comment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  return target;
}

size_t LocalUsers_LocalUser_LocalUserGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string comment = 2;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocalUsers_LocalUser_LocalUserGroup::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LocalUsers_LocalUser_LocalUserGroup*>(
      &from));
}

void LocalUsers_LocalUser_LocalUserGroup::MergeFrom(const LocalUsers_LocalUser_LocalUserGroup& from) {
  LocalUsers_LocalUser_LocalUserGroup* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocalUsers_LocalUser_LocalUserGroup::CopyFrom(const LocalUsers_LocalUser_LocalUserGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalUsers_LocalUser_LocalUserGroup::IsInitialized() const {
  return true;
}

void LocalUsers_LocalUser_LocalUserGroup::InternalSwap(LocalUsers_LocalUser_LocalUserGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
}

std::string LocalUsers_LocalUser_LocalUserGroup::GetTypeName() const {
  return "proto.system_info.LocalUsers.LocalUser.LocalUserGroup";
}


// ===================================================================

class LocalUsers_LocalUser::_Internal {
 public:
};

LocalUsers_LocalUser::LocalUsers_LocalUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LocalUsers.LocalUser)
}
LocalUsers_LocalUser::LocalUsers_LocalUser(const LocalUsers_LocalUser& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LocalUsers_LocalUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.group_){from._impl_.group_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.full_name_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.home_dir_){}
    , decltype(_impl_.disabled_){}
    , decltype(_impl_.password_cant_change_){}
    , decltype(_impl_.password_expired_){}
    , decltype(_impl_.dont_expire_password_){}
    , decltype(_impl_.lockout_){}
    , decltype(_impl_.number_logons_){}
    , decltype(_impl_.bad_password_count_){}
    , decltype(_impl_.last_logon_time_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.full_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_full_name().empty()) {
    _this->_impl_.full_name_.Set(from._internal_full_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.home_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.home_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_home_dir().empty()) {
    _this->_impl_.home_dir_.Set(from._internal_home_dir(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.disabled_, &from._impl_.disabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_logon_time_) -
    reinterpret_cast<char*>(&_impl_.disabled_)) + sizeof(_impl_.last_logon_time_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LocalUsers.LocalUser)
}

inline void LocalUsers_LocalUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.group_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.full_name_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.home_dir_){}
    , decltype(_impl_.disabled_){false}
    , decltype(_impl_.password_cant_change_){false}
    , decltype(_impl_.password_expired_){false}
    , decltype(_impl_.dont_expire_password_){false}
    , decltype(_impl_.lockout_){false}
    , decltype(_impl_.number_logons_){0u}
    , decltype(_impl_.bad_password_count_){0u}
    , decltype(_impl_.last_logon_time_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.full_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.home_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.home_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalUsers_LocalUser::~LocalUsers_LocalUser() {
  // @@protoc_insertion_point(destructor:proto.system_info.LocalUsers.LocalUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalUsers_LocalUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.full_name_.Destroy();
  _impl_.comment_.Destroy();
  _impl_.home_dir_.Destroy();
}

void LocalUsers_LocalUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalUsers_LocalUser::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LocalUsers.LocalUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.full_name_.ClearToEmpty();
  _impl_.comment_.ClearToEmpty();
  _impl_.home_dir_.ClearToEmpty();
  ::memset(&_impl_.disabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.last_logon_time_) -
      reinterpret_cast<char*>(&_impl_.disabled_)) + sizeof(_impl_.last_logon_time_));
  _internal_metadata_.Clear<std::string>();
}

const char* LocalUsers_LocalUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string full_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_full_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string comment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string home_dir = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_home_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.system_info.LocalUsers.LocalUser.LocalUserGroup group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_group(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool disabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.disabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool password_cant_change = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.password_cant_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool password_expired = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.password_expired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dont_expire_password = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.dont_expire_password_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool lockout = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.lockout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 number_logons = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.number_logons_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 bad_password_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.bad_password_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 last_logon_time = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.last_logon_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalUsers_LocalUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LocalUsers.LocalUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUsers.LocalUser.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string full_name = 2;
  if (!this->_internal_full_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_full_name().data(), static_cast<int>(this->_internal_full_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUsers.LocalUser.full_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_full_name(), target);
  }

  // string comment = 3;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUsers.LocalUser.comment");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_comment(), target);
  }

  // string home_dir = 4;
  if (!this->_internal_home_dir().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_home_dir().data(), static_cast<int>(this->_internal_home_dir().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUsers.LocalUser.home_dir");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_home_dir(), target);
  }

  // repeated .proto.system_info.LocalUsers.LocalUser.LocalUserGroup group = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_group_size()); i < n; i++) {
    const auto& repfield = this->_internal_group(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool disabled = 6;
  if (this->_internal_disabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_disabled(), target);
  }

  // bool password_cant_change = 7;
  if (this->_internal_password_cant_change() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_password_cant_change(), target);
  }

  // bool password_expired = 8;
  if (this->_internal_password_expired() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_password_expired(), target);
  }

  // bool dont_expire_password = 9;
  if (this->_internal_dont_expire_password() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_dont_expire_password(), target);
  }

  // bool lockout = 10;
  if (this->_internal_lockout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_lockout(), target);
  }

  // uint32 number_logons = 11;
  if (this->_internal_number_logons() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_number_logons(), target);
  }

  // uint32 bad_password_count = 12;
  if (this->_internal_bad_password_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_bad_password_count(), target);
  }

  // uint64 last_logon_time = 13;
  if (this->_internal_last_logon_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_last_logon_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LocalUsers.LocalUser)
  return target;
}

size_t LocalUsers_LocalUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LocalUsers.LocalUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.LocalUsers.LocalUser.LocalUserGroup group = 5;
  total_size += 1UL * this->_internal_group_size();
  for (const auto& msg : this->_impl_.group_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string full_name = 2;
  if (!this->_internal_full_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_full_name());
  }

  // string comment = 3;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  // string home_dir = 4;
  if (!this->_internal_home_dir().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_home_dir());
  }

  // bool disabled = 6;
  if (this->_internal_disabled() != 0) {
    total_size += 1 + 1;
  }

  // bool password_cant_change = 7;
  if (this->_internal_password_cant_change() != 0) {
    total_size += 1 + 1;
  }

  // bool password_expired = 8;
  if (this->_internal_password_expired() != 0) {
    total_size += 1 + 1;
  }

  // bool dont_expire_password = 9;
  if (this->_internal_dont_expire_password() != 0) {
    total_size += 1 + 1;
  }

  // bool lockout = 10;
  if (this->_internal_lockout() != 0) {
    total_size += 1 + 1;
  }

  // uint32 number_logons = 11;
  if (this->_internal_number_logons() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_logons());
  }

  // uint32 bad_password_count = 12;
  if (this->_internal_bad_password_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bad_password_count());
  }

  // uint64 last_logon_time = 13;
  if (this->_internal_last_logon_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_logon_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocalUsers_LocalUser::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LocalUsers_LocalUser*>(
      &from));
}

void LocalUsers_LocalUser::MergeFrom(const LocalUsers_LocalUser& from) {
  LocalUsers_LocalUser* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LocalUsers.LocalUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.group_.MergeFrom(from._impl_.group_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_full_name().empty()) {
    _this->_internal_set_full_name(from._internal_full_name());
  }
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  if (!from._internal_home_dir().empty()) {
    _this->_internal_set_home_dir(from._internal_home_dir());
  }
  if (from._internal_disabled() != 0) {
    _this->_internal_set_disabled(from._internal_disabled());
  }
  if (from._internal_password_cant_change() != 0) {
    _this->_internal_set_password_cant_change(from._internal_password_cant_change());
  }
  if (from._internal_password_expired() != 0) {
    _this->_internal_set_password_expired(from._internal_password_expired());
  }
  if (from._internal_dont_expire_password() != 0) {
    _this->_internal_set_dont_expire_password(from._internal_dont_expire_password());
  }
  if (from._internal_lockout() != 0) {
    _this->_internal_set_lockout(from._internal_lockout());
  }
  if (from._internal_number_logons() != 0) {
    _this->_internal_set_number_logons(from._internal_number_logons());
  }
  if (from._internal_bad_password_count() != 0) {
    _this->_internal_set_bad_password_count(from._internal_bad_password_count());
  }
  if (from._internal_last_logon_time() != 0) {
    _this->_internal_set_last_logon_time(from._internal_last_logon_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocalUsers_LocalUser::CopyFrom(const LocalUsers_LocalUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LocalUsers.LocalUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalUsers_LocalUser::IsInitialized() const {
  return true;
}

void LocalUsers_LocalUser::InternalSwap(LocalUsers_LocalUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.group_.InternalSwap(&other->_impl_.group_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.full_name_, lhs_arena,
      &other->_impl_.full_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.home_dir_, lhs_arena,
      &other->_impl_.home_dir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocalUsers_LocalUser, _impl_.last_logon_time_)
      + sizeof(LocalUsers_LocalUser::_impl_.last_logon_time_)
      - PROTOBUF_FIELD_OFFSET(LocalUsers_LocalUser, _impl_.disabled_)>(
          reinterpret_cast<char*>(&_impl_.disabled_),
          reinterpret_cast<char*>(&other->_impl_.disabled_));
}

std::string LocalUsers_LocalUser::GetTypeName() const {
  return "proto.system_info.LocalUsers.LocalUser";
}


// ===================================================================

class LocalUsers::_Internal {
 public:
};

LocalUsers::LocalUsers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LocalUsers)
}
LocalUsers::LocalUsers(const LocalUsers& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LocalUsers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.local_user_){from._impl_.local_user_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LocalUsers)
}

inline void LocalUsers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.local_user_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LocalUsers::~LocalUsers() {
  // @@protoc_insertion_point(destructor:proto.system_info.LocalUsers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalUsers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.local_user_.~RepeatedPtrField();
}

void LocalUsers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalUsers::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LocalUsers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.local_user_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LocalUsers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.LocalUsers.LocalUser local_user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_local_user(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalUsers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LocalUsers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.LocalUsers.LocalUser local_user = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_local_user_size()); i < n; i++) {
    const auto& repfield = this->_internal_local_user(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LocalUsers)
  return target;
}

size_t LocalUsers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LocalUsers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.LocalUsers.LocalUser local_user = 1;
  total_size += 1UL * this->_internal_local_user_size();
  for (const auto& msg : this->_impl_.local_user_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocalUsers::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LocalUsers*>(
      &from));
}

void LocalUsers::MergeFrom(const LocalUsers& from) {
  LocalUsers* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LocalUsers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.local_user_.MergeFrom(from._impl_.local_user_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocalUsers::CopyFrom(const LocalUsers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LocalUsers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalUsers::IsInitialized() const {
  return true;
}

void LocalUsers::InternalSwap(LocalUsers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.local_user_.InternalSwap(&other->_impl_.local_user_);
}

std::string LocalUsers::GetTypeName() const {
  return "proto.system_info.LocalUsers";
}


// ===================================================================

class LocalUserGroups_LocalUserGroup::_Internal {
 public:
};

LocalUserGroups_LocalUserGroup::LocalUserGroups_LocalUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LocalUserGroups.LocalUserGroup)
}
LocalUserGroups_LocalUserGroup::LocalUserGroups_LocalUserGroup(const LocalUserGroups_LocalUserGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LocalUserGroups_LocalUserGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.comment_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LocalUserGroups.LocalUserGroup)
}

inline void LocalUserGroups_LocalUserGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.comment_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalUserGroups_LocalUserGroup::~LocalUserGroups_LocalUserGroup() {
  // @@protoc_insertion_point(destructor:proto.system_info.LocalUserGroups.LocalUserGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalUserGroups_LocalUserGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.comment_.Destroy();
}

void LocalUserGroups_LocalUserGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalUserGroups_LocalUserGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LocalUserGroups.LocalUserGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.comment_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* LocalUserGroups_LocalUserGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string comment = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalUserGroups_LocalUserGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LocalUserGroups.LocalUserGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUserGroups.LocalUserGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string comment = 2;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.LocalUserGroups.LocalUserGroup.comment");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_comment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LocalUserGroups.LocalUserGroup)
  return target;
}

size_t LocalUserGroups_LocalUserGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LocalUserGroups.LocalUserGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string comment = 2;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocalUserGroups_LocalUserGroup::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LocalUserGroups_LocalUserGroup*>(
      &from));
}

void LocalUserGroups_LocalUserGroup::MergeFrom(const LocalUserGroups_LocalUserGroup& from) {
  LocalUserGroups_LocalUserGroup* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LocalUserGroups.LocalUserGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocalUserGroups_LocalUserGroup::CopyFrom(const LocalUserGroups_LocalUserGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LocalUserGroups.LocalUserGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalUserGroups_LocalUserGroup::IsInitialized() const {
  return true;
}

void LocalUserGroups_LocalUserGroup::InternalSwap(LocalUserGroups_LocalUserGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
}

std::string LocalUserGroups_LocalUserGroup::GetTypeName() const {
  return "proto.system_info.LocalUserGroups.LocalUserGroup";
}


// ===================================================================

class LocalUserGroups::_Internal {
 public:
};

LocalUserGroups::LocalUserGroups(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.LocalUserGroups)
}
LocalUserGroups::LocalUserGroups(const LocalUserGroups& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LocalUserGroups* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.local_user_group_){from._impl_.local_user_group_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.LocalUserGroups)
}

inline void LocalUserGroups::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.local_user_group_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LocalUserGroups::~LocalUserGroups() {
  // @@protoc_insertion_point(destructor:proto.system_info.LocalUserGroups)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalUserGroups::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.local_user_group_.~RepeatedPtrField();
}

void LocalUserGroups::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalUserGroups::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.LocalUserGroups)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.local_user_group_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LocalUserGroups::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.LocalUserGroups.LocalUserGroup local_user_group = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_local_user_group(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalUserGroups::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.LocalUserGroups)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.LocalUserGroups.LocalUserGroup local_user_group = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_local_user_group_size()); i < n; i++) {
    const auto& repfield = this->_internal_local_user_group(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.LocalUserGroups)
  return target;
}

size_t LocalUserGroups::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.LocalUserGroups)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.LocalUserGroups.LocalUserGroup local_user_group = 1;
  total_size += 1UL * this->_internal_local_user_group_size();
  for (const auto& msg : this->_impl_.local_user_group_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocalUserGroups::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LocalUserGroups*>(
      &from));
}

void LocalUserGroups::MergeFrom(const LocalUserGroups& from) {
  LocalUserGroups* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.LocalUserGroups)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.local_user_group_.MergeFrom(from._impl_.local_user_group_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocalUserGroups::CopyFrom(const LocalUserGroups& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.LocalUserGroups)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalUserGroups::IsInitialized() const {
  return true;
}

void LocalUserGroups::InternalSwap(LocalUserGroups* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.local_user_group_.InternalSwap(&other->_impl_.local_user_group_);
}

std::string LocalUserGroups::GetTypeName() const {
  return "proto.system_info.LocalUserGroups";
}


// ===================================================================

class Processes_Process::_Internal {
 public:
};

Processes_Process::Processes_Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Processes.Process)
}
Processes_Process::Processes_Process(const Processes_Process& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Processes_Process* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.sid_){}
    , decltype(_impl_.memory_){}
    , decltype(_impl_.cpu_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.cpu_));
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Processes.Process)
}

inline void Processes_Process::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.pid_){0u}
    , decltype(_impl_.sid_){0u}
    , decltype(_impl_.memory_){int64_t{0}}
    , decltype(_impl_.cpu_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Processes_Process::~Processes_Process() {
  // @@protoc_insertion_point(destructor:proto.system_info.Processes.Process)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Processes_Process::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.user_.Destroy();
  _impl_.path_.Destroy();
}

void Processes_Process::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Processes_Process::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Processes.Process)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.user_.ClearToEmpty();
  _impl_.path_.ClearToEmpty();
  ::memset(&_impl_.pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cpu_) -
      reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.cpu_));
  _internal_metadata_.Clear<std::string>();
}

const char* Processes_Process::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.sid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string user = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 cpu = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 memory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Processes_Process::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Processes.Process)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Processes.Process.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // uint32 pid = 2;
  if (this->_internal_pid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_pid(), target);
  }

  // uint32 sid = 3;
  if (this->_internal_sid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sid(), target);
  }

  // string user = 4;
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Processes.Process.user");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user(), target);
  }

  // string path = 5;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.Processes.Process.path");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_path(), target);
  }

  // int32 cpu = 6;
  if (this->_internal_cpu() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_cpu(), target);
  }

  // int64 memory = 7;
  if (this->_internal_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_memory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Processes.Process)
  return target;
}

size_t Processes_Process::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Processes.Process)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string user = 4;
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // string path = 5;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // uint32 pid = 2;
  if (this->_internal_pid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pid());
  }

  // uint32 sid = 3;
  if (this->_internal_sid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sid());
  }

  // int64 memory = 7;
  if (this->_internal_memory() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_memory());
  }

  // int32 cpu = 6;
  if (this->_internal_cpu() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Processes_Process::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Processes_Process*>(
      &from));
}

void Processes_Process::MergeFrom(const Processes_Process& from) {
  Processes_Process* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Processes.Process)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (from._internal_pid() != 0) {
    _this->_internal_set_pid(from._internal_pid());
  }
  if (from._internal_sid() != 0) {
    _this->_internal_set_sid(from._internal_sid());
  }
  if (from._internal_memory() != 0) {
    _this->_internal_set_memory(from._internal_memory());
  }
  if (from._internal_cpu() != 0) {
    _this->_internal_set_cpu(from._internal_cpu());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Processes_Process::CopyFrom(const Processes_Process& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Processes.Process)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Processes_Process::IsInitialized() const {
  return true;
}

void Processes_Process::InternalSwap(Processes_Process* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Processes_Process, _impl_.cpu_)
      + sizeof(Processes_Process::_impl_.cpu_)
      - PROTOBUF_FIELD_OFFSET(Processes_Process, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string Processes_Process::GetTypeName() const {
  return "proto.system_info.Processes.Process";
}


// ===================================================================

class Processes::_Internal {
 public:
};

Processes::Processes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.Processes)
}
Processes::Processes(const Processes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Processes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.process_){from._impl_.process_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.system_info.Processes)
}

inline void Processes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.process_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Processes::~Processes() {
  // @@protoc_insertion_point(destructor:proto.system_info.Processes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Processes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.process_.~RepeatedPtrField();
}

void Processes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Processes::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.Processes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.process_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Processes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.system_info.Processes.Process process = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_process(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Processes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.Processes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.system_info.Processes.Process process = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_process_size()); i < n; i++) {
    const auto& repfield = this->_internal_process(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.Processes)
  return target;
}

size_t Processes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.Processes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.system_info.Processes.Process process = 1;
  total_size += 1UL * this->_internal_process_size();
  for (const auto& msg : this->_impl_.process_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Processes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Processes*>(
      &from));
}

void Processes::MergeFrom(const Processes& from) {
  Processes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.Processes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.process_.MergeFrom(from._impl_.process_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Processes::CopyFrom(const Processes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.Processes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Processes::IsInitialized() const {
  return true;
}

void Processes::InternalSwap(Processes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.process_.InternalSwap(&other->_impl_.process_);
}

std::string Processes::GetTypeName() const {
  return "proto.system_info.Processes";
}


// ===================================================================

class SystemInfoRequest::_Internal {
 public:
  static const ::proto::system_info::EventLogsData& event_logs_data(const SystemInfoRequest* msg);
};

const ::proto::system_info::EventLogsData&
SystemInfoRequest::_Internal::event_logs_data(const SystemInfoRequest* msg) {
  return *msg->_impl_.event_logs_data_;
}
SystemInfoRequest::SystemInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.SystemInfoRequest)
}
SystemInfoRequest::SystemInfoRequest(const SystemInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemInfoRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.category_){}
    , decltype(_impl_.event_logs_data_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_category().empty()) {
    _this->_impl_.category_.Set(from._internal_category(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_event_logs_data()) {
    _this->_impl_.event_logs_data_ = new ::proto::system_info::EventLogsData(*from._impl_.event_logs_data_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.SystemInfoRequest)
}

inline void SystemInfoRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.category_){}
    , decltype(_impl_.event_logs_data_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemInfoRequest::~SystemInfoRequest() {
  // @@protoc_insertion_point(destructor:proto.system_info.SystemInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.category_.Destroy();
  if (this != internal_default_instance()) delete _impl_.event_logs_data_;
}

void SystemInfoRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.SystemInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.category_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.event_logs_data_ != nullptr) {
    delete _impl_.event_logs_data_;
  }
  _impl_.event_logs_data_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* SystemInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string category = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_category();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.EventLogsData event_logs_data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_event_logs_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.SystemInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string category = 1;
  if (!this->_internal_category().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_category().data(), static_cast<int>(this->_internal_category().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.SystemInfoRequest.category");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_category(), target);
  }

  // .proto.system_info.EventLogsData event_logs_data = 11;
  if (this->_internal_has_event_logs_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::event_logs_data(this),
        _Internal::event_logs_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.SystemInfoRequest)
  return target;
}

size_t SystemInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.SystemInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string category = 1;
  if (!this->_internal_category().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_category());
  }

  // .proto.system_info.EventLogsData event_logs_data = 11;
  if (this->_internal_has_event_logs_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.event_logs_data_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemInfoRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemInfoRequest*>(
      &from));
}

void SystemInfoRequest::MergeFrom(const SystemInfoRequest& from) {
  SystemInfoRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.SystemInfoRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_category().empty()) {
    _this->_internal_set_category(from._internal_category());
  }
  if (from._internal_has_event_logs_data()) {
    _this->_internal_mutable_event_logs_data()->::proto::system_info::EventLogsData::MergeFrom(
        from._internal_event_logs_data());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemInfoRequest::CopyFrom(const SystemInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.SystemInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemInfoRequest::IsInitialized() const {
  return true;
}

void SystemInfoRequest::InternalSwap(SystemInfoRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.category_, lhs_arena,
      &other->_impl_.category_, rhs_arena
  );
  swap(_impl_.event_logs_data_, other->_impl_.event_logs_data_);
}

std::string SystemInfoRequest::GetTypeName() const {
  return "proto.system_info.SystemInfoRequest";
}


// ===================================================================

class SystemInfoFooter::_Internal {
 public:
};

SystemInfoFooter::SystemInfoFooter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.SystemInfoFooter)
}
SystemInfoFooter::SystemInfoFooter(const SystemInfoFooter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemInfoFooter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.category_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_category().empty()) {
    _this->_impl_.category_.Set(from._internal_category(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.SystemInfoFooter)
}

inline void SystemInfoFooter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.category_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemInfoFooter::~SystemInfoFooter() {
  // @@protoc_insertion_point(destructor:proto.system_info.SystemInfoFooter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemInfoFooter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.category_.Destroy();
}

void SystemInfoFooter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemInfoFooter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.SystemInfoFooter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.category_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemInfoFooter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string category = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_category();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemInfoFooter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.SystemInfoFooter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string category = 1;
  if (!this->_internal_category().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_category().data(), static_cast<int>(this->_internal_category().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.system_info.SystemInfoFooter.category");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_category(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.SystemInfoFooter)
  return target;
}

size_t SystemInfoFooter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.SystemInfoFooter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string category = 1;
  if (!this->_internal_category().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_category());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemInfoFooter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemInfoFooter*>(
      &from));
}

void SystemInfoFooter::MergeFrom(const SystemInfoFooter& from) {
  SystemInfoFooter* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.SystemInfoFooter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_category().empty()) {
    _this->_internal_set_category(from._internal_category());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemInfoFooter::CopyFrom(const SystemInfoFooter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.SystemInfoFooter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemInfoFooter::IsInitialized() const {
  return true;
}

void SystemInfoFooter::InternalSwap(SystemInfoFooter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.category_, lhs_arena,
      &other->_impl_.category_, rhs_arena
  );
}

std::string SystemInfoFooter::GetTypeName() const {
  return "proto.system_info.SystemInfoFooter";
}


// ===================================================================

class SystemInfo::_Internal {
 public:
  static const ::proto::system_info::Computer& computer(const SystemInfo* msg);
  static const ::proto::system_info::OperatingSystem& operating_system(const SystemInfo* msg);
  static const ::proto::system_info::Motherboard& motherboard(const SystemInfo* msg);
  static const ::proto::system_info::Bios& bios(const SystemInfo* msg);
  static const ::proto::system_info::Processor& processor(const SystemInfo* msg);
  static const ::proto::system_info::Memory& memory(const SystemInfo* msg);
  static const ::proto::system_info::LogicalDrives& logical_drives(const SystemInfo* msg);
  static const ::proto::system_info::Printers& printers(const SystemInfo* msg);
  static const ::proto::system_info::NetworkAdapters& network_adapters(const SystemInfo* msg);
  static const ::proto::system_info::NetworkShares& network_shares(const SystemInfo* msg);
  static const ::proto::system_info::WindowsDevices& windows_devices(const SystemInfo* msg);
  static const ::proto::system_info::VideoAdapters& video_adapters(const SystemInfo* msg);
  static const ::proto::system_info::Monitors& monitors(const SystemInfo* msg);
  static const ::proto::system_info::PowerOptions& power_options(const SystemInfo* msg);
  static const ::proto::system_info::Drivers& drivers(const SystemInfo* msg);
  static const ::proto::system_info::Services& services(const SystemInfo* msg);
  static const ::proto::system_info::EnvironmentVariables& env_vars(const SystemInfo* msg);
  static const ::proto::system_info::EventLogs& event_logs(const SystemInfo* msg);
  static const ::proto::system_info::Routes& routes(const SystemInfo* msg);
  static const ::proto::system_info::Connections& connections(const SystemInfo* msg);
  static const ::proto::system_info::Licenses& licenses(const SystemInfo* msg);
  static const ::proto::system_info::Applications& applications(const SystemInfo* msg);
  static const ::proto::system_info::OpenFiles& open_files(const SystemInfo* msg);
  static const ::proto::system_info::LocalUsers& local_users(const SystemInfo* msg);
  static const ::proto::system_info::LocalUserGroups& local_user_groups(const SystemInfo* msg);
  static const ::proto::system_info::Processes& processes(const SystemInfo* msg);
  static const ::proto::system_info::SystemInfoFooter& footer(const SystemInfo* msg);
};

const ::proto::system_info::Computer&
SystemInfo::_Internal::computer(const SystemInfo* msg) {
  return *msg->_impl_.computer_;
}
const ::proto::system_info::OperatingSystem&
SystemInfo::_Internal::operating_system(const SystemInfo* msg) {
  return *msg->_impl_.operating_system_;
}
const ::proto::system_info::Motherboard&
SystemInfo::_Internal::motherboard(const SystemInfo* msg) {
  return *msg->_impl_.motherboard_;
}
const ::proto::system_info::Bios&
SystemInfo::_Internal::bios(const SystemInfo* msg) {
  return *msg->_impl_.bios_;
}
const ::proto::system_info::Processor&
SystemInfo::_Internal::processor(const SystemInfo* msg) {
  return *msg->_impl_.processor_;
}
const ::proto::system_info::Memory&
SystemInfo::_Internal::memory(const SystemInfo* msg) {
  return *msg->_impl_.memory_;
}
const ::proto::system_info::LogicalDrives&
SystemInfo::_Internal::logical_drives(const SystemInfo* msg) {
  return *msg->_impl_.logical_drives_;
}
const ::proto::system_info::Printers&
SystemInfo::_Internal::printers(const SystemInfo* msg) {
  return *msg->_impl_.printers_;
}
const ::proto::system_info::NetworkAdapters&
SystemInfo::_Internal::network_adapters(const SystemInfo* msg) {
  return *msg->_impl_.network_adapters_;
}
const ::proto::system_info::NetworkShares&
SystemInfo::_Internal::network_shares(const SystemInfo* msg) {
  return *msg->_impl_.network_shares_;
}
const ::proto::system_info::WindowsDevices&
SystemInfo::_Internal::windows_devices(const SystemInfo* msg) {
  return *msg->_impl_.windows_devices_;
}
const ::proto::system_info::VideoAdapters&
SystemInfo::_Internal::video_adapters(const SystemInfo* msg) {
  return *msg->_impl_.video_adapters_;
}
const ::proto::system_info::Monitors&
SystemInfo::_Internal::monitors(const SystemInfo* msg) {
  return *msg->_impl_.monitors_;
}
const ::proto::system_info::PowerOptions&
SystemInfo::_Internal::power_options(const SystemInfo* msg) {
  return *msg->_impl_.power_options_;
}
const ::proto::system_info::Drivers&
SystemInfo::_Internal::drivers(const SystemInfo* msg) {
  return *msg->_impl_.drivers_;
}
const ::proto::system_info::Services&
SystemInfo::_Internal::services(const SystemInfo* msg) {
  return *msg->_impl_.services_;
}
const ::proto::system_info::EnvironmentVariables&
SystemInfo::_Internal::env_vars(const SystemInfo* msg) {
  return *msg->_impl_.env_vars_;
}
const ::proto::system_info::EventLogs&
SystemInfo::_Internal::event_logs(const SystemInfo* msg) {
  return *msg->_impl_.event_logs_;
}
const ::proto::system_info::Routes&
SystemInfo::_Internal::routes(const SystemInfo* msg) {
  return *msg->_impl_.routes_;
}
const ::proto::system_info::Connections&
SystemInfo::_Internal::connections(const SystemInfo* msg) {
  return *msg->_impl_.connections_;
}
const ::proto::system_info::Licenses&
SystemInfo::_Internal::licenses(const SystemInfo* msg) {
  return *msg->_impl_.licenses_;
}
const ::proto::system_info::Applications&
SystemInfo::_Internal::applications(const SystemInfo* msg) {
  return *msg->_impl_.applications_;
}
const ::proto::system_info::OpenFiles&
SystemInfo::_Internal::open_files(const SystemInfo* msg) {
  return *msg->_impl_.open_files_;
}
const ::proto::system_info::LocalUsers&
SystemInfo::_Internal::local_users(const SystemInfo* msg) {
  return *msg->_impl_.local_users_;
}
const ::proto::system_info::LocalUserGroups&
SystemInfo::_Internal::local_user_groups(const SystemInfo* msg) {
  return *msg->_impl_.local_user_groups_;
}
const ::proto::system_info::Processes&
SystemInfo::_Internal::processes(const SystemInfo* msg) {
  return *msg->_impl_.processes_;
}
const ::proto::system_info::SystemInfoFooter&
SystemInfo::_Internal::footer(const SystemInfo* msg) {
  return *msg->_impl_.footer_;
}
SystemInfo::SystemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.system_info.SystemInfo)
}
SystemInfo::SystemInfo(const SystemInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.computer_){nullptr}
    , decltype(_impl_.operating_system_){nullptr}
    , decltype(_impl_.motherboard_){nullptr}
    , decltype(_impl_.bios_){nullptr}
    , decltype(_impl_.processor_){nullptr}
    , decltype(_impl_.memory_){nullptr}
    , decltype(_impl_.logical_drives_){nullptr}
    , decltype(_impl_.printers_){nullptr}
    , decltype(_impl_.network_adapters_){nullptr}
    , decltype(_impl_.network_shares_){nullptr}
    , decltype(_impl_.windows_devices_){nullptr}
    , decltype(_impl_.video_adapters_){nullptr}
    , decltype(_impl_.monitors_){nullptr}
    , decltype(_impl_.power_options_){nullptr}
    , decltype(_impl_.drivers_){nullptr}
    , decltype(_impl_.services_){nullptr}
    , decltype(_impl_.env_vars_){nullptr}
    , decltype(_impl_.event_logs_){nullptr}
    , decltype(_impl_.routes_){nullptr}
    , decltype(_impl_.connections_){nullptr}
    , decltype(_impl_.licenses_){nullptr}
    , decltype(_impl_.applications_){nullptr}
    , decltype(_impl_.open_files_){nullptr}
    , decltype(_impl_.local_users_){nullptr}
    , decltype(_impl_.local_user_groups_){nullptr}
    , decltype(_impl_.processes_){nullptr}
    , decltype(_impl_.footer_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_computer()) {
    _this->_impl_.computer_ = new ::proto::system_info::Computer(*from._impl_.computer_);
  }
  if (from._internal_has_operating_system()) {
    _this->_impl_.operating_system_ = new ::proto::system_info::OperatingSystem(*from._impl_.operating_system_);
  }
  if (from._internal_has_motherboard()) {
    _this->_impl_.motherboard_ = new ::proto::system_info::Motherboard(*from._impl_.motherboard_);
  }
  if (from._internal_has_bios()) {
    _this->_impl_.bios_ = new ::proto::system_info::Bios(*from._impl_.bios_);
  }
  if (from._internal_has_processor()) {
    _this->_impl_.processor_ = new ::proto::system_info::Processor(*from._impl_.processor_);
  }
  if (from._internal_has_memory()) {
    _this->_impl_.memory_ = new ::proto::system_info::Memory(*from._impl_.memory_);
  }
  if (from._internal_has_logical_drives()) {
    _this->_impl_.logical_drives_ = new ::proto::system_info::LogicalDrives(*from._impl_.logical_drives_);
  }
  if (from._internal_has_printers()) {
    _this->_impl_.printers_ = new ::proto::system_info::Printers(*from._impl_.printers_);
  }
  if (from._internal_has_network_adapters()) {
    _this->_impl_.network_adapters_ = new ::proto::system_info::NetworkAdapters(*from._impl_.network_adapters_);
  }
  if (from._internal_has_network_shares()) {
    _this->_impl_.network_shares_ = new ::proto::system_info::NetworkShares(*from._impl_.network_shares_);
  }
  if (from._internal_has_windows_devices()) {
    _this->_impl_.windows_devices_ = new ::proto::system_info::WindowsDevices(*from._impl_.windows_devices_);
  }
  if (from._internal_has_video_adapters()) {
    _this->_impl_.video_adapters_ = new ::proto::system_info::VideoAdapters(*from._impl_.video_adapters_);
  }
  if (from._internal_has_monitors()) {
    _this->_impl_.monitors_ = new ::proto::system_info::Monitors(*from._impl_.monitors_);
  }
  if (from._internal_has_power_options()) {
    _this->_impl_.power_options_ = new ::proto::system_info::PowerOptions(*from._impl_.power_options_);
  }
  if (from._internal_has_drivers()) {
    _this->_impl_.drivers_ = new ::proto::system_info::Drivers(*from._impl_.drivers_);
  }
  if (from._internal_has_services()) {
    _this->_impl_.services_ = new ::proto::system_info::Services(*from._impl_.services_);
  }
  if (from._internal_has_env_vars()) {
    _this->_impl_.env_vars_ = new ::proto::system_info::EnvironmentVariables(*from._impl_.env_vars_);
  }
  if (from._internal_has_event_logs()) {
    _this->_impl_.event_logs_ = new ::proto::system_info::EventLogs(*from._impl_.event_logs_);
  }
  if (from._internal_has_routes()) {
    _this->_impl_.routes_ = new ::proto::system_info::Routes(*from._impl_.routes_);
  }
  if (from._internal_has_connections()) {
    _this->_impl_.connections_ = new ::proto::system_info::Connections(*from._impl_.connections_);
  }
  if (from._internal_has_licenses()) {
    _this->_impl_.licenses_ = new ::proto::system_info::Licenses(*from._impl_.licenses_);
  }
  if (from._internal_has_applications()) {
    _this->_impl_.applications_ = new ::proto::system_info::Applications(*from._impl_.applications_);
  }
  if (from._internal_has_open_files()) {
    _this->_impl_.open_files_ = new ::proto::system_info::OpenFiles(*from._impl_.open_files_);
  }
  if (from._internal_has_local_users()) {
    _this->_impl_.local_users_ = new ::proto::system_info::LocalUsers(*from._impl_.local_users_);
  }
  if (from._internal_has_local_user_groups()) {
    _this->_impl_.local_user_groups_ = new ::proto::system_info::LocalUserGroups(*from._impl_.local_user_groups_);
  }
  if (from._internal_has_processes()) {
    _this->_impl_.processes_ = new ::proto::system_info::Processes(*from._impl_.processes_);
  }
  if (from._internal_has_footer()) {
    _this->_impl_.footer_ = new ::proto::system_info::SystemInfoFooter(*from._impl_.footer_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.system_info.SystemInfo)
}

inline void SystemInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.computer_){nullptr}
    , decltype(_impl_.operating_system_){nullptr}
    , decltype(_impl_.motherboard_){nullptr}
    , decltype(_impl_.bios_){nullptr}
    , decltype(_impl_.processor_){nullptr}
    , decltype(_impl_.memory_){nullptr}
    , decltype(_impl_.logical_drives_){nullptr}
    , decltype(_impl_.printers_){nullptr}
    , decltype(_impl_.network_adapters_){nullptr}
    , decltype(_impl_.network_shares_){nullptr}
    , decltype(_impl_.windows_devices_){nullptr}
    , decltype(_impl_.video_adapters_){nullptr}
    , decltype(_impl_.monitors_){nullptr}
    , decltype(_impl_.power_options_){nullptr}
    , decltype(_impl_.drivers_){nullptr}
    , decltype(_impl_.services_){nullptr}
    , decltype(_impl_.env_vars_){nullptr}
    , decltype(_impl_.event_logs_){nullptr}
    , decltype(_impl_.routes_){nullptr}
    , decltype(_impl_.connections_){nullptr}
    , decltype(_impl_.licenses_){nullptr}
    , decltype(_impl_.applications_){nullptr}
    , decltype(_impl_.open_files_){nullptr}
    , decltype(_impl_.local_users_){nullptr}
    , decltype(_impl_.local_user_groups_){nullptr}
    , decltype(_impl_.processes_){nullptr}
    , decltype(_impl_.footer_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SystemInfo::~SystemInfo() {
  // @@protoc_insertion_point(destructor:proto.system_info.SystemInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.computer_;
  if (this != internal_default_instance()) delete _impl_.operating_system_;
  if (this != internal_default_instance()) delete _impl_.motherboard_;
  if (this != internal_default_instance()) delete _impl_.bios_;
  if (this != internal_default_instance()) delete _impl_.processor_;
  if (this != internal_default_instance()) delete _impl_.memory_;
  if (this != internal_default_instance()) delete _impl_.logical_drives_;
  if (this != internal_default_instance()) delete _impl_.printers_;
  if (this != internal_default_instance()) delete _impl_.network_adapters_;
  if (this != internal_default_instance()) delete _impl_.network_shares_;
  if (this != internal_default_instance()) delete _impl_.windows_devices_;
  if (this != internal_default_instance()) delete _impl_.video_adapters_;
  if (this != internal_default_instance()) delete _impl_.monitors_;
  if (this != internal_default_instance()) delete _impl_.power_options_;
  if (this != internal_default_instance()) delete _impl_.drivers_;
  if (this != internal_default_instance()) delete _impl_.services_;
  if (this != internal_default_instance()) delete _impl_.env_vars_;
  if (this != internal_default_instance()) delete _impl_.event_logs_;
  if (this != internal_default_instance()) delete _impl_.routes_;
  if (this != internal_default_instance()) delete _impl_.connections_;
  if (this != internal_default_instance()) delete _impl_.licenses_;
  if (this != internal_default_instance()) delete _impl_.applications_;
  if (this != internal_default_instance()) delete _impl_.open_files_;
  if (this != internal_default_instance()) delete _impl_.local_users_;
  if (this != internal_default_instance()) delete _impl_.local_user_groups_;
  if (this != internal_default_instance()) delete _impl_.processes_;
  if (this != internal_default_instance()) delete _impl_.footer_;
}

void SystemInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.system_info.SystemInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.computer_ != nullptr) {
    delete _impl_.computer_;
  }
  _impl_.computer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.operating_system_ != nullptr) {
    delete _impl_.operating_system_;
  }
  _impl_.operating_system_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.motherboard_ != nullptr) {
    delete _impl_.motherboard_;
  }
  _impl_.motherboard_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.bios_ != nullptr) {
    delete _impl_.bios_;
  }
  _impl_.bios_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.processor_ != nullptr) {
    delete _impl_.processor_;
  }
  _impl_.processor_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.memory_ != nullptr) {
    delete _impl_.memory_;
  }
  _impl_.memory_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.logical_drives_ != nullptr) {
    delete _impl_.logical_drives_;
  }
  _impl_.logical_drives_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.printers_ != nullptr) {
    delete _impl_.printers_;
  }
  _impl_.printers_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.network_adapters_ != nullptr) {
    delete _impl_.network_adapters_;
  }
  _impl_.network_adapters_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.network_shares_ != nullptr) {
    delete _impl_.network_shares_;
  }
  _impl_.network_shares_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.windows_devices_ != nullptr) {
    delete _impl_.windows_devices_;
  }
  _impl_.windows_devices_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.video_adapters_ != nullptr) {
    delete _impl_.video_adapters_;
  }
  _impl_.video_adapters_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.monitors_ != nullptr) {
    delete _impl_.monitors_;
  }
  _impl_.monitors_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.power_options_ != nullptr) {
    delete _impl_.power_options_;
  }
  _impl_.power_options_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.drivers_ != nullptr) {
    delete _impl_.drivers_;
  }
  _impl_.drivers_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.services_ != nullptr) {
    delete _impl_.services_;
  }
  _impl_.services_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.env_vars_ != nullptr) {
    delete _impl_.env_vars_;
  }
  _impl_.env_vars_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.event_logs_ != nullptr) {
    delete _impl_.event_logs_;
  }
  _impl_.event_logs_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.routes_ != nullptr) {
    delete _impl_.routes_;
  }
  _impl_.routes_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.connections_ != nullptr) {
    delete _impl_.connections_;
  }
  _impl_.connections_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.licenses_ != nullptr) {
    delete _impl_.licenses_;
  }
  _impl_.licenses_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.applications_ != nullptr) {
    delete _impl_.applications_;
  }
  _impl_.applications_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.open_files_ != nullptr) {
    delete _impl_.open_files_;
  }
  _impl_.open_files_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.local_users_ != nullptr) {
    delete _impl_.local_users_;
  }
  _impl_.local_users_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.local_user_groups_ != nullptr) {
    delete _impl_.local_user_groups_;
  }
  _impl_.local_user_groups_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.processes_ != nullptr) {
    delete _impl_.processes_;
  }
  _impl_.processes_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.footer_ != nullptr) {
    delete _impl_.footer_;
  }
  _impl_.footer_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* SystemInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.system_info.Computer computer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_computer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.OperatingSystem operating_system = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_operating_system(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Motherboard motherboard = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_motherboard(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Bios bios = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bios(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Processor processor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_processor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Memory memory = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_memory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.LogicalDrives logical_drives = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_logical_drives(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Printers printers = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_printers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.NetworkAdapters network_adapters = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_adapters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.NetworkShares network_shares = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_shares(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.WindowsDevices windows_devices = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_windows_devices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.VideoAdapters video_adapters = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_adapters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Monitors monitors = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.PowerOptions power_options = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_power_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Drivers drivers = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_drivers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Services services = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_services(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.EnvironmentVariables env_vars = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_env_vars(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.EventLogs event_logs = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_event_logs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Routes routes = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_routes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Connections connections = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_connections(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Licenses licenses = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_licenses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Applications applications = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_applications(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.OpenFiles open_files = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_open_files(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.LocalUsers local_users = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_local_users(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.LocalUserGroups local_user_groups = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_local_user_groups(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.Processes processes = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_processes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.system_info.SystemInfoFooter footer = 128000;
      case 128000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_footer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.system_info.SystemInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.system_info.Computer computer = 1;
  if (this->_internal_has_computer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::computer(this),
        _Internal::computer(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.OperatingSystem operating_system = 2;
  if (this->_internal_has_operating_system()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::operating_system(this),
        _Internal::operating_system(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Motherboard motherboard = 3;
  if (this->_internal_has_motherboard()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::motherboard(this),
        _Internal::motherboard(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Bios bios = 4;
  if (this->_internal_has_bios()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::bios(this),
        _Internal::bios(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Processor processor = 5;
  if (this->_internal_has_processor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::processor(this),
        _Internal::processor(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Memory memory = 6;
  if (this->_internal_has_memory()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::memory(this),
        _Internal::memory(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.LogicalDrives logical_drives = 7;
  if (this->_internal_has_logical_drives()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::logical_drives(this),
        _Internal::logical_drives(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Printers printers = 8;
  if (this->_internal_has_printers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::printers(this),
        _Internal::printers(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.NetworkAdapters network_adapters = 9;
  if (this->_internal_has_network_adapters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::network_adapters(this),
        _Internal::network_adapters(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.NetworkShares network_shares = 10;
  if (this->_internal_has_network_shares()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::network_shares(this),
        _Internal::network_shares(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.WindowsDevices windows_devices = 11;
  if (this->_internal_has_windows_devices()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::windows_devices(this),
        _Internal::windows_devices(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.VideoAdapters video_adapters = 12;
  if (this->_internal_has_video_adapters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::video_adapters(this),
        _Internal::video_adapters(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Monitors monitors = 13;
  if (this->_internal_has_monitors()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::monitors(this),
        _Internal::monitors(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.PowerOptions power_options = 14;
  if (this->_internal_has_power_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::power_options(this),
        _Internal::power_options(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Drivers drivers = 15;
  if (this->_internal_has_drivers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::drivers(this),
        _Internal::drivers(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Services services = 16;
  if (this->_internal_has_services()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::services(this),
        _Internal::services(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.EnvironmentVariables env_vars = 17;
  if (this->_internal_has_env_vars()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::env_vars(this),
        _Internal::env_vars(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.EventLogs event_logs = 18;
  if (this->_internal_has_event_logs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::event_logs(this),
        _Internal::event_logs(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Routes routes = 19;
  if (this->_internal_has_routes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::routes(this),
        _Internal::routes(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Connections connections = 20;
  if (this->_internal_has_connections()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::connections(this),
        _Internal::connections(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Licenses licenses = 21;
  if (this->_internal_has_licenses()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::licenses(this),
        _Internal::licenses(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Applications applications = 22;
  if (this->_internal_has_applications()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::applications(this),
        _Internal::applications(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.OpenFiles open_files = 23;
  if (this->_internal_has_open_files()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::open_files(this),
        _Internal::open_files(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.LocalUsers local_users = 24;
  if (this->_internal_has_local_users()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::local_users(this),
        _Internal::local_users(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.LocalUserGroups local_user_groups = 25;
  if (this->_internal_has_local_user_groups()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::local_user_groups(this),
        _Internal::local_user_groups(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.Processes processes = 26;
  if (this->_internal_has_processes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::processes(this),
        _Internal::processes(this).GetCachedSize(), target, stream);
  }

  // .proto.system_info.SystemInfoFooter footer = 128000;
  if (this->_internal_has_footer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(128000, _Internal::footer(this),
        _Internal::footer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.system_info.SystemInfo)
  return target;
}

size_t SystemInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.system_info.SystemInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.system_info.Computer computer = 1;
  if (this->_internal_has_computer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.computer_);
  }

  // .proto.system_info.OperatingSystem operating_system = 2;
  if (this->_internal_has_operating_system()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.operating_system_);
  }

  // .proto.system_info.Motherboard motherboard = 3;
  if (this->_internal_has_motherboard()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.motherboard_);
  }

  // .proto.system_info.Bios bios = 4;
  if (this->_internal_has_bios()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bios_);
  }

  // .proto.system_info.Processor processor = 5;
  if (this->_internal_has_processor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.processor_);
  }

  // .proto.system_info.Memory memory = 6;
  if (this->_internal_has_memory()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.memory_);
  }

  // .proto.system_info.LogicalDrives logical_drives = 7;
  if (this->_internal_has_logical_drives()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logical_drives_);
  }

  // .proto.system_info.Printers printers = 8;
  if (this->_internal_has_printers()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.printers_);
  }

  // .proto.system_info.NetworkAdapters network_adapters = 9;
  if (this->_internal_has_network_adapters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.network_adapters_);
  }

  // .proto.system_info.NetworkShares network_shares = 10;
  if (this->_internal_has_network_shares()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.network_shares_);
  }

  // .proto.system_info.WindowsDevices windows_devices = 11;
  if (this->_internal_has_windows_devices()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.windows_devices_);
  }

  // .proto.system_info.VideoAdapters video_adapters = 12;
  if (this->_internal_has_video_adapters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_adapters_);
  }

  // .proto.system_info.Monitors monitors = 13;
  if (this->_internal_has_monitors()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.monitors_);
  }

  // .proto.system_info.PowerOptions power_options = 14;
  if (this->_internal_has_power_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.power_options_);
  }

  // .proto.system_info.Drivers drivers = 15;
  if (this->_internal_has_drivers()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.drivers_);
  }

  // .proto.system_info.Services services = 16;
  if (this->_internal_has_services()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.services_);
  }

  // .proto.system_info.EnvironmentVariables env_vars = 17;
  if (this->_internal_has_env_vars()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.env_vars_);
  }

  // .proto.system_info.EventLogs event_logs = 18;
  if (this->_internal_has_event_logs()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.event_logs_);
  }

  // .proto.system_info.Routes routes = 19;
  if (this->_internal_has_routes()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.routes_);
  }

  // .proto.system_info.Connections connections = 20;
  if (this->_internal_has_connections()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connections_);
  }

  // .proto.system_info.Licenses licenses = 21;
  if (this->_internal_has_licenses()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.licenses_);
  }

  // .proto.system_info.Applications applications = 22;
  if (this->_internal_has_applications()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.applications_);
  }

  // .proto.system_info.OpenFiles open_files = 23;
  if (this->_internal_has_open_files()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.open_files_);
  }

  // .proto.system_info.LocalUsers local_users = 24;
  if (this->_internal_has_local_users()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.local_users_);
  }

  // .proto.system_info.LocalUserGroups local_user_groups = 25;
  if (this->_internal_has_local_user_groups()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.local_user_groups_);
  }

  // .proto.system_info.Processes processes = 26;
  if (this->_internal_has_processes()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.processes_);
  }

  // .proto.system_info.SystemInfoFooter footer = 128000;
  if (this->_internal_has_footer()) {
    total_size += 3 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemInfo*>(
      &from));
}

void SystemInfo::MergeFrom(const SystemInfo& from) {
  SystemInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.system_info.SystemInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_computer()) {
    _this->_internal_mutable_computer()->::proto::system_info::Computer::MergeFrom(
        from._internal_computer());
  }
  if (from._internal_has_operating_system()) {
    _this->_internal_mutable_operating_system()->::proto::system_info::OperatingSystem::MergeFrom(
        from._internal_operating_system());
  }
  if (from._internal_has_motherboard()) {
    _this->_internal_mutable_motherboard()->::proto::system_info::Motherboard::MergeFrom(
        from._internal_motherboard());
  }
  if (from._internal_has_bios()) {
    _this->_internal_mutable_bios()->::proto::system_info::Bios::MergeFrom(
        from._internal_bios());
  }
  if (from._internal_has_processor()) {
    _this->_internal_mutable_processor()->::proto::system_info::Processor::MergeFrom(
        from._internal_processor());
  }
  if (from._internal_has_memory()) {
    _this->_internal_mutable_memory()->::proto::system_info::Memory::MergeFrom(
        from._internal_memory());
  }
  if (from._internal_has_logical_drives()) {
    _this->_internal_mutable_logical_drives()->::proto::system_info::LogicalDrives::MergeFrom(
        from._internal_logical_drives());
  }
  if (from._internal_has_printers()) {
    _this->_internal_mutable_printers()->::proto::system_info::Printers::MergeFrom(
        from._internal_printers());
  }
  if (from._internal_has_network_adapters()) {
    _this->_internal_mutable_network_adapters()->::proto::system_info::NetworkAdapters::MergeFrom(
        from._internal_network_adapters());
  }
  if (from._internal_has_network_shares()) {
    _this->_internal_mutable_network_shares()->::proto::system_info::NetworkShares::MergeFrom(
        from._internal_network_shares());
  }
  if (from._internal_has_windows_devices()) {
    _this->_internal_mutable_windows_devices()->::proto::system_info::WindowsDevices::MergeFrom(
        from._internal_windows_devices());
  }
  if (from._internal_has_video_adapters()) {
    _this->_internal_mutable_video_adapters()->::proto::system_info::VideoAdapters::MergeFrom(
        from._internal_video_adapters());
  }
  if (from._internal_has_monitors()) {
    _this->_internal_mutable_monitors()->::proto::system_info::Monitors::MergeFrom(
        from._internal_monitors());
  }
  if (from._internal_has_power_options()) {
    _this->_internal_mutable_power_options()->::proto::system_info::PowerOptions::MergeFrom(
        from._internal_power_options());
  }
  if (from._internal_has_drivers()) {
    _this->_internal_mutable_drivers()->::proto::system_info::Drivers::MergeFrom(
        from._internal_drivers());
  }
  if (from._internal_has_services()) {
    _this->_internal_mutable_services()->::proto::system_info::Services::MergeFrom(
        from._internal_services());
  }
  if (from._internal_has_env_vars()) {
    _this->_internal_mutable_env_vars()->::proto::system_info::EnvironmentVariables::MergeFrom(
        from._internal_env_vars());
  }
  if (from._internal_has_event_logs()) {
    _this->_internal_mutable_event_logs()->::proto::system_info::EventLogs::MergeFrom(
        from._internal_event_logs());
  }
  if (from._internal_has_routes()) {
    _this->_internal_mutable_routes()->::proto::system_info::Routes::MergeFrom(
        from._internal_routes());
  }
  if (from._internal_has_connections()) {
    _this->_internal_mutable_connections()->::proto::system_info::Connections::MergeFrom(
        from._internal_connections());
  }
  if (from._internal_has_licenses()) {
    _this->_internal_mutable_licenses()->::proto::system_info::Licenses::MergeFrom(
        from._internal_licenses());
  }
  if (from._internal_has_applications()) {
    _this->_internal_mutable_applications()->::proto::system_info::Applications::MergeFrom(
        from._internal_applications());
  }
  if (from._internal_has_open_files()) {
    _this->_internal_mutable_open_files()->::proto::system_info::OpenFiles::MergeFrom(
        from._internal_open_files());
  }
  if (from._internal_has_local_users()) {
    _this->_internal_mutable_local_users()->::proto::system_info::LocalUsers::MergeFrom(
        from._internal_local_users());
  }
  if (from._internal_has_local_user_groups()) {
    _this->_internal_mutable_local_user_groups()->::proto::system_info::LocalUserGroups::MergeFrom(
        from._internal_local_user_groups());
  }
  if (from._internal_has_processes()) {
    _this->_internal_mutable_processes()->::proto::system_info::Processes::MergeFrom(
        from._internal_processes());
  }
  if (from._internal_has_footer()) {
    _this->_internal_mutable_footer()->::proto::system_info::SystemInfoFooter::MergeFrom(
        from._internal_footer());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemInfo::CopyFrom(const SystemInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.system_info.SystemInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemInfo::IsInitialized() const {
  return true;
}

void SystemInfo::InternalSwap(SystemInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemInfo, _impl_.footer_)
      + sizeof(SystemInfo::_impl_.footer_)
      - PROTOBUF_FIELD_OFFSET(SystemInfo, _impl_.computer_)>(
          reinterpret_cast<char*>(&_impl_.computer_),
          reinterpret_cast<char*>(&other->_impl_.computer_));
}

std::string SystemInfo::GetTypeName() const {
  return "proto.system_info.SystemInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace system_info
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::system_info::Computer*
Arena::CreateMaybeMessage< ::proto::system_info::Computer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Computer >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::OperatingSystem*
Arena::CreateMaybeMessage< ::proto::system_info::OperatingSystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::OperatingSystem >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Motherboard*
Arena::CreateMaybeMessage< ::proto::system_info::Motherboard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Motherboard >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Bios*
Arena::CreateMaybeMessage< ::proto::system_info::Bios >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Bios >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Processor*
Arena::CreateMaybeMessage< ::proto::system_info::Processor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Processor >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Memory_Module*
Arena::CreateMaybeMessage< ::proto::system_info::Memory_Module >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Memory_Module >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Memory*
Arena::CreateMaybeMessage< ::proto::system_info::Memory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Memory >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LogicalDrives_Drive*
Arena::CreateMaybeMessage< ::proto::system_info::LogicalDrives_Drive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LogicalDrives_Drive >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LogicalDrives*
Arena::CreateMaybeMessage< ::proto::system_info::LogicalDrives >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LogicalDrives >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Printers_Printer*
Arena::CreateMaybeMessage< ::proto::system_info::Printers_Printer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Printers_Printer >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Printers*
Arena::CreateMaybeMessage< ::proto::system_info::Printers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Printers >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::NetworkAdapters_Adapter_Address*
Arena::CreateMaybeMessage< ::proto::system_info::NetworkAdapters_Adapter_Address >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::NetworkAdapters_Adapter_Address >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::NetworkAdapters_Adapter*
Arena::CreateMaybeMessage< ::proto::system_info::NetworkAdapters_Adapter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::NetworkAdapters_Adapter >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::NetworkAdapters*
Arena::CreateMaybeMessage< ::proto::system_info::NetworkAdapters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::NetworkAdapters >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::NetworkShares_Share*
Arena::CreateMaybeMessage< ::proto::system_info::NetworkShares_Share >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::NetworkShares_Share >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::NetworkShares*
Arena::CreateMaybeMessage< ::proto::system_info::NetworkShares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::NetworkShares >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::WindowsDevices_Device*
Arena::CreateMaybeMessage< ::proto::system_info::WindowsDevices_Device >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::WindowsDevices_Device >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::WindowsDevices*
Arena::CreateMaybeMessage< ::proto::system_info::WindowsDevices >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::WindowsDevices >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::VideoAdapters_Adapter*
Arena::CreateMaybeMessage< ::proto::system_info::VideoAdapters_Adapter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::VideoAdapters_Adapter >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::VideoAdapters*
Arena::CreateMaybeMessage< ::proto::system_info::VideoAdapters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::VideoAdapters >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Monitors_Monitor_Timing*
Arena::CreateMaybeMessage< ::proto::system_info::Monitors_Monitor_Timing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Monitors_Monitor_Timing >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Monitors_Monitor*
Arena::CreateMaybeMessage< ::proto::system_info::Monitors_Monitor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Monitors_Monitor >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Monitors*
Arena::CreateMaybeMessage< ::proto::system_info::Monitors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Monitors >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::PowerOptions_Battery*
Arena::CreateMaybeMessage< ::proto::system_info::PowerOptions_Battery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::PowerOptions_Battery >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::PowerOptions*
Arena::CreateMaybeMessage< ::proto::system_info::PowerOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::PowerOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Drivers_Driver*
Arena::CreateMaybeMessage< ::proto::system_info::Drivers_Driver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Drivers_Driver >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Drivers*
Arena::CreateMaybeMessage< ::proto::system_info::Drivers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Drivers >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Services_Service*
Arena::CreateMaybeMessage< ::proto::system_info::Services_Service >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Services_Service >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Services*
Arena::CreateMaybeMessage< ::proto::system_info::Services >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Services >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::EnvironmentVariables_Variable*
Arena::CreateMaybeMessage< ::proto::system_info::EnvironmentVariables_Variable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::EnvironmentVariables_Variable >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::EnvironmentVariables*
Arena::CreateMaybeMessage< ::proto::system_info::EnvironmentVariables >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::EnvironmentVariables >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::EventLogs_Event*
Arena::CreateMaybeMessage< ::proto::system_info::EventLogs_Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::EventLogs_Event >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::EventLogs*
Arena::CreateMaybeMessage< ::proto::system_info::EventLogs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::EventLogs >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::EventLogsData*
Arena::CreateMaybeMessage< ::proto::system_info::EventLogsData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::EventLogsData >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Routes_Route*
Arena::CreateMaybeMessage< ::proto::system_info::Routes_Route >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Routes_Route >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Routes*
Arena::CreateMaybeMessage< ::proto::system_info::Routes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Routes >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Connections_Connection*
Arena::CreateMaybeMessage< ::proto::system_info::Connections_Connection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Connections_Connection >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Connections*
Arena::CreateMaybeMessage< ::proto::system_info::Connections >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Connections >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Licenses_License_Field*
Arena::CreateMaybeMessage< ::proto::system_info::Licenses_License_Field >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Licenses_License_Field >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Licenses_License*
Arena::CreateMaybeMessage< ::proto::system_info::Licenses_License >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Licenses_License >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Licenses*
Arena::CreateMaybeMessage< ::proto::system_info::Licenses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Licenses >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Applications_Application*
Arena::CreateMaybeMessage< ::proto::system_info::Applications_Application >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Applications_Application >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Applications*
Arena::CreateMaybeMessage< ::proto::system_info::Applications >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Applications >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::OpenFiles_OpenFile*
Arena::CreateMaybeMessage< ::proto::system_info::OpenFiles_OpenFile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::OpenFiles_OpenFile >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::OpenFiles*
Arena::CreateMaybeMessage< ::proto::system_info::OpenFiles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::OpenFiles >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup*
Arena::CreateMaybeMessage< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LocalUsers_LocalUser*
Arena::CreateMaybeMessage< ::proto::system_info::LocalUsers_LocalUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LocalUsers_LocalUser >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LocalUsers*
Arena::CreateMaybeMessage< ::proto::system_info::LocalUsers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LocalUsers >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LocalUserGroups_LocalUserGroup*
Arena::CreateMaybeMessage< ::proto::system_info::LocalUserGroups_LocalUserGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LocalUserGroups_LocalUserGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::LocalUserGroups*
Arena::CreateMaybeMessage< ::proto::system_info::LocalUserGroups >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::LocalUserGroups >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Processes_Process*
Arena::CreateMaybeMessage< ::proto::system_info::Processes_Process >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Processes_Process >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::Processes*
Arena::CreateMaybeMessage< ::proto::system_info::Processes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::Processes >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::SystemInfoRequest*
Arena::CreateMaybeMessage< ::proto::system_info::SystemInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::SystemInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::SystemInfoFooter*
Arena::CreateMaybeMessage< ::proto::system_info::SystemInfoFooter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::SystemInfoFooter >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::system_info::SystemInfo*
Arena::CreateMaybeMessage< ::proto::system_info::SystemInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::system_info::SystemInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
