// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: file_transfer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_file_5ftransfer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_file_5ftransfer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_file_5ftransfer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_file_5ftransfer_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class CreateDirectoryRequest;
struct CreateDirectoryRequestDefaultTypeInternal;
extern CreateDirectoryRequestDefaultTypeInternal _CreateDirectoryRequest_default_instance_;
class DownloadRequest;
struct DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class DriveList;
struct DriveListDefaultTypeInternal;
extern DriveListDefaultTypeInternal _DriveList_default_instance_;
class DriveListRequest;
struct DriveListRequestDefaultTypeInternal;
extern DriveListRequestDefaultTypeInternal _DriveListRequest_default_instance_;
class DriveList_Item;
struct DriveList_ItemDefaultTypeInternal;
extern DriveList_ItemDefaultTypeInternal _DriveList_Item_default_instance_;
class FileList;
struct FileListDefaultTypeInternal;
extern FileListDefaultTypeInternal _FileList_default_instance_;
class FileListRequest;
struct FileListRequestDefaultTypeInternal;
extern FileListRequestDefaultTypeInternal _FileListRequest_default_instance_;
class FileList_Item;
struct FileList_ItemDefaultTypeInternal;
extern FileList_ItemDefaultTypeInternal _FileList_Item_default_instance_;
class FilePacket;
struct FilePacketDefaultTypeInternal;
extern FilePacketDefaultTypeInternal _FilePacket_default_instance_;
class FilePacketRequest;
struct FilePacketRequestDefaultTypeInternal;
extern FilePacketRequestDefaultTypeInternal _FilePacketRequest_default_instance_;
class FileReply;
struct FileReplyDefaultTypeInternal;
extern FileReplyDefaultTypeInternal _FileReply_default_instance_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class RemoveRequest;
struct RemoveRequestDefaultTypeInternal;
extern RemoveRequestDefaultTypeInternal _RemoveRequest_default_instance_;
class RenameRequest;
struct RenameRequestDefaultTypeInternal;
extern RenameRequestDefaultTypeInternal _RenameRequest_default_instance_;
class UploadRequest;
struct UploadRequestDefaultTypeInternal;
extern UploadRequestDefaultTypeInternal _UploadRequest_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::CreateDirectoryRequest* Arena::CreateMaybeMessage<::proto::CreateDirectoryRequest>(Arena*);
template<> ::proto::DownloadRequest* Arena::CreateMaybeMessage<::proto::DownloadRequest>(Arena*);
template<> ::proto::DriveList* Arena::CreateMaybeMessage<::proto::DriveList>(Arena*);
template<> ::proto::DriveListRequest* Arena::CreateMaybeMessage<::proto::DriveListRequest>(Arena*);
template<> ::proto::DriveList_Item* Arena::CreateMaybeMessage<::proto::DriveList_Item>(Arena*);
template<> ::proto::FileList* Arena::CreateMaybeMessage<::proto::FileList>(Arena*);
template<> ::proto::FileListRequest* Arena::CreateMaybeMessage<::proto::FileListRequest>(Arena*);
template<> ::proto::FileList_Item* Arena::CreateMaybeMessage<::proto::FileList_Item>(Arena*);
template<> ::proto::FilePacket* Arena::CreateMaybeMessage<::proto::FilePacket>(Arena*);
template<> ::proto::FilePacketRequest* Arena::CreateMaybeMessage<::proto::FilePacketRequest>(Arena*);
template<> ::proto::FileReply* Arena::CreateMaybeMessage<::proto::FileReply>(Arena*);
template<> ::proto::FileRequest* Arena::CreateMaybeMessage<::proto::FileRequest>(Arena*);
template<> ::proto::RemoveRequest* Arena::CreateMaybeMessage<::proto::RemoveRequest>(Arena*);
template<> ::proto::RenameRequest* Arena::CreateMaybeMessage<::proto::RenameRequest>(Arena*);
template<> ::proto::UploadRequest* Arena::CreateMaybeMessage<::proto::UploadRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum DriveList_Item_Type : int {
  DriveList_Item_Type_TYPE_UNKNOWN = 0,
  DriveList_Item_Type_TYPE_CDROM = 1,
  DriveList_Item_Type_TYPE_REMOVABLE = 2,
  DriveList_Item_Type_TYPE_FIXED = 3,
  DriveList_Item_Type_TYPE_REMOTE = 4,
  DriveList_Item_Type_TYPE_RAM = 5,
  DriveList_Item_Type_TYPE_HOME_FOLDER = 6,
  DriveList_Item_Type_TYPE_DESKTOP_FOLDER = 7,
  DriveList_Item_Type_TYPE_ROOT_DIRECTORY = 8,
  DriveList_Item_Type_DriveList_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DriveList_Item_Type_DriveList_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DriveList_Item_Type_IsValid(int value);
constexpr DriveList_Item_Type DriveList_Item_Type_Type_MIN = DriveList_Item_Type_TYPE_UNKNOWN;
constexpr DriveList_Item_Type DriveList_Item_Type_Type_MAX = DriveList_Item_Type_TYPE_ROOT_DIRECTORY;
constexpr int DriveList_Item_Type_Type_ARRAYSIZE = DriveList_Item_Type_Type_MAX + 1;

const std::string& DriveList_Item_Type_Name(DriveList_Item_Type value);
template<typename T>
inline const std::string& DriveList_Item_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriveList_Item_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriveList_Item_Type_Name.");
  return DriveList_Item_Type_Name(static_cast<DriveList_Item_Type>(enum_t_value));
}
bool DriveList_Item_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriveList_Item_Type* value);
enum FilePacketRequest_Flags : int {
  FilePacketRequest_Flags_NO_FLAGS = 0,
  FilePacketRequest_Flags_CANCEL = 1,
  FilePacketRequest_Flags_FilePacketRequest_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FilePacketRequest_Flags_FilePacketRequest_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FilePacketRequest_Flags_IsValid(int value);
constexpr FilePacketRequest_Flags FilePacketRequest_Flags_Flags_MIN = FilePacketRequest_Flags_NO_FLAGS;
constexpr FilePacketRequest_Flags FilePacketRequest_Flags_Flags_MAX = FilePacketRequest_Flags_CANCEL;
constexpr int FilePacketRequest_Flags_Flags_ARRAYSIZE = FilePacketRequest_Flags_Flags_MAX + 1;

const std::string& FilePacketRequest_Flags_Name(FilePacketRequest_Flags value);
template<typename T>
inline const std::string& FilePacketRequest_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilePacketRequest_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilePacketRequest_Flags_Name.");
  return FilePacketRequest_Flags_Name(static_cast<FilePacketRequest_Flags>(enum_t_value));
}
bool FilePacketRequest_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilePacketRequest_Flags* value);
enum FilePacket_Flags : int {
  FilePacket_Flags_NO_FLAGS = 0,
  FilePacket_Flags_FIRST_PACKET = 1,
  FilePacket_Flags_LAST_PACKET = 2,
  FilePacket_Flags_FilePacket_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FilePacket_Flags_FilePacket_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FilePacket_Flags_IsValid(int value);
constexpr FilePacket_Flags FilePacket_Flags_Flags_MIN = FilePacket_Flags_NO_FLAGS;
constexpr FilePacket_Flags FilePacket_Flags_Flags_MAX = FilePacket_Flags_LAST_PACKET;
constexpr int FilePacket_Flags_Flags_ARRAYSIZE = FilePacket_Flags_Flags_MAX + 1;

const std::string& FilePacket_Flags_Name(FilePacket_Flags value);
template<typename T>
inline const std::string& FilePacket_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilePacket_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilePacket_Flags_Name.");
  return FilePacket_Flags_Name(static_cast<FilePacket_Flags>(enum_t_value));
}
bool FilePacket_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilePacket_Flags* value);
enum FileError : int {
  FILE_ERROR_UNKNOWN = 0,
  FILE_ERROR_SUCCESS = 1,
  FILE_ERROR_NO_LOGGED_ON_USER = 2,
  FILE_ERROR_INVALID_REQUEST = 3,
  FILE_ERROR_INVALID_PATH_NAME = 4,
  FILE_ERROR_PATH_NOT_FOUND = 5,
  FILE_ERROR_PATH_ALREADY_EXISTS = 6,
  FILE_ERROR_NO_DRIVES_FOUND = 7,
  FILE_ERROR_DISK_FULL = 8,
  FILE_ERROR_ACCESS_DENIED = 9,
  FILE_ERROR_FILE_OPEN_ERROR = 10,
  FILE_ERROR_FILE_CREATE_ERROR = 11,
  FILE_ERROR_FILE_WRITE_ERROR = 12,
  FILE_ERROR_FILE_READ_ERROR = 13,
  FILE_ERROR_DISK_NOT_READY = 14,
  FileError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FileError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FileError_IsValid(int value);
constexpr FileError FileError_MIN = FILE_ERROR_UNKNOWN;
constexpr FileError FileError_MAX = FILE_ERROR_DISK_NOT_READY;
constexpr int FileError_ARRAYSIZE = FileError_MAX + 1;

const std::string& FileError_Name(FileError value);
template<typename T>
inline const std::string& FileError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileError_Name.");
  return FileError_Name(static_cast<FileError>(enum_t_value));
}
bool FileError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileError* value);
// ===================================================================

class DriveList_Item final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DriveList.Item) */ {
 public:
  inline DriveList_Item() : DriveList_Item(nullptr) {}
  ~DriveList_Item() override;
  explicit PROTOBUF_CONSTEXPR DriveList_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriveList_Item(const DriveList_Item& from);
  DriveList_Item(DriveList_Item&& from) noexcept
    : DriveList_Item() {
    *this = ::std::move(from);
  }

  inline DriveList_Item& operator=(const DriveList_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriveList_Item& operator=(DriveList_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriveList_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriveList_Item* internal_default_instance() {
    return reinterpret_cast<const DriveList_Item*>(
               &_DriveList_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DriveList_Item& a, DriveList_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(DriveList_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriveList_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriveList_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DriveList_Item>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DriveList_Item& from);
  void MergeFrom(const DriveList_Item& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriveList_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DriveList.Item";
  }
  protected:
  explicit DriveList_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DriveList_Item_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    DriveList_Item_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_CDROM =
    DriveList_Item_Type_TYPE_CDROM;
  static constexpr Type TYPE_REMOVABLE =
    DriveList_Item_Type_TYPE_REMOVABLE;
  static constexpr Type TYPE_FIXED =
    DriveList_Item_Type_TYPE_FIXED;
  static constexpr Type TYPE_REMOTE =
    DriveList_Item_Type_TYPE_REMOTE;
  static constexpr Type TYPE_RAM =
    DriveList_Item_Type_TYPE_RAM;
  static constexpr Type TYPE_HOME_FOLDER =
    DriveList_Item_Type_TYPE_HOME_FOLDER;
  static constexpr Type TYPE_DESKTOP_FOLDER =
    DriveList_Item_Type_TYPE_DESKTOP_FOLDER;
  static constexpr Type TYPE_ROOT_DIRECTORY =
    DriveList_Item_Type_TYPE_ROOT_DIRECTORY;
  static inline bool Type_IsValid(int value) {
    return DriveList_Item_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DriveList_Item_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DriveList_Item_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DriveList_Item_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DriveList_Item_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DriveList_Item_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kNameFieldNumber = 3,
    kTotalSpaceFieldNumber = 4,
    kFreeSpaceFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 total_space = 4;
  void clear_total_space();
  int64_t total_space() const;
  void set_total_space(int64_t value);
  private:
  int64_t _internal_total_space() const;
  void _internal_set_total_space(int64_t value);
  public:

  // int64 free_space = 5;
  void clear_free_space();
  int64_t free_space() const;
  void set_free_space(int64_t value);
  private:
  int64_t _internal_free_space() const;
  void _internal_set_free_space(int64_t value);
  public:

  // .proto.DriveList.Item.Type type = 1;
  void clear_type();
  ::proto::DriveList_Item_Type type() const;
  void set_type(::proto::DriveList_Item_Type value);
  private:
  ::proto::DriveList_Item_Type _internal_type() const;
  void _internal_set_type(::proto::DriveList_Item_Type value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DriveList.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t total_space_;
    int64_t free_space_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class DriveList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DriveList) */ {
 public:
  inline DriveList() : DriveList(nullptr) {}
  ~DriveList() override;
  explicit PROTOBUF_CONSTEXPR DriveList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriveList(const DriveList& from);
  DriveList(DriveList&& from) noexcept
    : DriveList() {
    *this = ::std::move(from);
  }

  inline DriveList& operator=(const DriveList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriveList& operator=(DriveList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriveList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriveList* internal_default_instance() {
    return reinterpret_cast<const DriveList*>(
               &_DriveList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DriveList& a, DriveList& b) {
    a.Swap(&b);
  }
  inline void Swap(DriveList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriveList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriveList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DriveList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DriveList& from);
  void MergeFrom(const DriveList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriveList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DriveList";
  }
  protected:
  explicit DriveList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DriveList_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // repeated .proto.DriveList.Item item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::proto::DriveList_Item* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DriveList_Item >*
      mutable_item();
  private:
  const ::proto::DriveList_Item& _internal_item(int index) const;
  ::proto::DriveList_Item* _internal_add_item();
  public:
  const ::proto::DriveList_Item& item(int index) const;
  ::proto::DriveList_Item* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DriveList_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:proto.DriveList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DriveList_Item > item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class DriveListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DriveListRequest) */ {
 public:
  inline DriveListRequest() : DriveListRequest(nullptr) {}
  ~DriveListRequest() override;
  explicit PROTOBUF_CONSTEXPR DriveListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriveListRequest(const DriveListRequest& from);
  DriveListRequest(DriveListRequest&& from) noexcept
    : DriveListRequest() {
    *this = ::std::move(from);
  }

  inline DriveListRequest& operator=(const DriveListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriveListRequest& operator=(DriveListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriveListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriveListRequest* internal_default_instance() {
    return reinterpret_cast<const DriveListRequest*>(
               &_DriveListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DriveListRequest& a, DriveListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DriveListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriveListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriveListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DriveListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DriveListRequest& from);
  void MergeFrom(const DriveListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriveListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DriveListRequest";
  }
  protected:
  explicit DriveListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // uint32 dummy = 1;
  void clear_dummy();
  uint32_t dummy() const;
  void set_dummy(uint32_t value);
  private:
  uint32_t _internal_dummy() const;
  void _internal_set_dummy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DriveListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FileList_Item final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FileList.Item) */ {
 public:
  inline FileList_Item() : FileList_Item(nullptr) {}
  ~FileList_Item() override;
  explicit PROTOBUF_CONSTEXPR FileList_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileList_Item(const FileList_Item& from);
  FileList_Item(FileList_Item&& from) noexcept
    : FileList_Item() {
    *this = ::std::move(from);
  }

  inline FileList_Item& operator=(const FileList_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileList_Item& operator=(FileList_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FileList_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileList_Item* internal_default_instance() {
    return reinterpret_cast<const FileList_Item*>(
               &_FileList_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileList_Item& a, FileList_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(FileList_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileList_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileList_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileList_Item>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileList_Item& from);
  void MergeFrom(const FileList_Item& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileList_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FileList.Item";
  }
  protected:
  explicit FileList_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSizeFieldNumber = 2,
    kModificationTimeFieldNumber = 3,
    kIsDirectoryFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 size = 2;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // int64 modification_time = 3;
  void clear_modification_time();
  int64_t modification_time() const;
  void set_modification_time(int64_t value);
  private:
  int64_t _internal_modification_time() const;
  void _internal_set_modification_time(int64_t value);
  public:

  // bool is_directory = 4;
  void clear_is_directory();
  bool is_directory() const;
  void set_is_directory(bool value);
  private:
  bool _internal_is_directory() const;
  void _internal_set_is_directory(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FileList.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t size_;
    int64_t modification_time_;
    bool is_directory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FileList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FileList) */ {
 public:
  inline FileList() : FileList(nullptr) {}
  ~FileList() override;
  explicit PROTOBUF_CONSTEXPR FileList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileList(const FileList& from);
  FileList(FileList&& from) noexcept
    : FileList() {
    *this = ::std::move(from);
  }

  inline FileList& operator=(const FileList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileList& operator=(FileList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FileList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileList* internal_default_instance() {
    return reinterpret_cast<const FileList*>(
               &_FileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileList& a, FileList& b) {
    a.Swap(&b);
  }
  inline void Swap(FileList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileList& from);
  void MergeFrom(const FileList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FileList";
  }
  protected:
  explicit FileList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FileList_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // repeated .proto.FileList.Item item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::proto::FileList_Item* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FileList_Item >*
      mutable_item();
  private:
  const ::proto::FileList_Item& _internal_item(int index) const;
  ::proto::FileList_Item* _internal_add_item();
  public:
  const ::proto::FileList_Item& item(int index) const;
  ::proto::FileList_Item* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FileList_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:proto.FileList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FileList_Item > item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FileListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FileListRequest) */ {
 public:
  inline FileListRequest() : FileListRequest(nullptr) {}
  ~FileListRequest() override;
  explicit PROTOBUF_CONSTEXPR FileListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileListRequest(const FileListRequest& from);
  FileListRequest(FileListRequest&& from) noexcept
    : FileListRequest() {
    *this = ::std::move(from);
  }

  inline FileListRequest& operator=(const FileListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileListRequest& operator=(FileListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FileListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileListRequest* internal_default_instance() {
    return reinterpret_cast<const FileListRequest*>(
               &_FileListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FileListRequest& a, FileListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileListRequest& from);
  void MergeFrom(const FileListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FileListRequest";
  }
  protected:
  explicit FileListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:proto.FileListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class UploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UploadRequest) */ {
 public:
  inline UploadRequest() : UploadRequest(nullptr) {}
  ~UploadRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadRequest(const UploadRequest& from);
  UploadRequest(UploadRequest&& from) noexcept
    : UploadRequest() {
    *this = ::std::move(from);
  }

  inline UploadRequest& operator=(const UploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadRequest& operator=(UploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UploadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadRequest* internal_default_instance() {
    return reinterpret_cast<const UploadRequest*>(
               &_UploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UploadRequest& a, UploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadRequest& from);
  void MergeFrom(const UploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UploadRequest";
  }
  protected:
  explicit UploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kOverwriteFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // bool overwrite = 2;
  void clear_overwrite();
  bool overwrite() const;
  void set_overwrite(bool value);
  private:
  bool _internal_overwrite() const;
  void _internal_set_overwrite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    bool overwrite_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class DownloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {}
  ~DownloadRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadRequest(const DownloadRequest& from);
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadRequest& from);
  void MergeFrom(const DownloadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:proto.DownloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FilePacketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FilePacketRequest) */ {
 public:
  inline FilePacketRequest() : FilePacketRequest(nullptr) {}
  ~FilePacketRequest() override;
  explicit PROTOBUF_CONSTEXPR FilePacketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilePacketRequest(const FilePacketRequest& from);
  FilePacketRequest(FilePacketRequest&& from) noexcept
    : FilePacketRequest() {
    *this = ::std::move(from);
  }

  inline FilePacketRequest& operator=(const FilePacketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilePacketRequest& operator=(FilePacketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FilePacketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilePacketRequest* internal_default_instance() {
    return reinterpret_cast<const FilePacketRequest*>(
               &_FilePacketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FilePacketRequest& a, FilePacketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FilePacketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilePacketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilePacketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilePacketRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FilePacketRequest& from);
  void MergeFrom(const FilePacketRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FilePacketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FilePacketRequest";
  }
  protected:
  explicit FilePacketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FilePacketRequest_Flags Flags;
  static constexpr Flags NO_FLAGS =
    FilePacketRequest_Flags_NO_FLAGS;
  static constexpr Flags CANCEL =
    FilePacketRequest_Flags_CANCEL;
  static inline bool Flags_IsValid(int value) {
    return FilePacketRequest_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    FilePacketRequest_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    FilePacketRequest_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    FilePacketRequest_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return FilePacketRequest_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return FilePacketRequest_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFlagsFieldNumber = 1,
  };
  // uint32 flags = 1;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FilePacketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FilePacket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FilePacket) */ {
 public:
  inline FilePacket() : FilePacket(nullptr) {}
  ~FilePacket() override;
  explicit PROTOBUF_CONSTEXPR FilePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilePacket(const FilePacket& from);
  FilePacket(FilePacket&& from) noexcept
    : FilePacket() {
    *this = ::std::move(from);
  }

  inline FilePacket& operator=(const FilePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilePacket& operator=(FilePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FilePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilePacket* internal_default_instance() {
    return reinterpret_cast<const FilePacket*>(
               &_FilePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FilePacket& a, FilePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(FilePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilePacket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FilePacket& from);
  void MergeFrom(const FilePacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FilePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FilePacket";
  }
  protected:
  explicit FilePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FilePacket_Flags Flags;
  static constexpr Flags NO_FLAGS =
    FilePacket_Flags_NO_FLAGS;
  static constexpr Flags FIRST_PACKET =
    FilePacket_Flags_FIRST_PACKET;
  static constexpr Flags LAST_PACKET =
    FilePacket_Flags_LAST_PACKET;
  static inline bool Flags_IsValid(int value) {
    return FilePacket_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    FilePacket_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    FilePacket_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    FilePacket_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return FilePacket_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return FilePacket_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kFileSizeFieldNumber = 2,
    kFlagsFieldNumber = 1,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 file_size = 2;
  void clear_file_size();
  uint64_t file_size() const;
  void set_file_size(uint64_t value);
  private:
  uint64_t _internal_file_size() const;
  void _internal_set_file_size(uint64_t value);
  public:

  // uint32 flags = 1;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FilePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t file_size_;
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class CreateDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.CreateDirectoryRequest) */ {
 public:
  inline CreateDirectoryRequest() : CreateDirectoryRequest(nullptr) {}
  ~CreateDirectoryRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDirectoryRequest(const CreateDirectoryRequest& from);
  CreateDirectoryRequest(CreateDirectoryRequest&& from) noexcept
    : CreateDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryRequest& operator=(const CreateDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryRequest& operator=(CreateDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CreateDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryRequest*>(
               &_CreateDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateDirectoryRequest& a, CreateDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDirectoryRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreateDirectoryRequest& from);
  void MergeFrom(const CreateDirectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateDirectoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CreateDirectoryRequest";
  }
  protected:
  explicit CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:proto.CreateDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class RenameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RenameRequest) */ {
 public:
  inline RenameRequest() : RenameRequest(nullptr) {}
  ~RenameRequest() override;
  explicit PROTOBUF_CONSTEXPR RenameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameRequest(const RenameRequest& from);
  RenameRequest(RenameRequest&& from) noexcept
    : RenameRequest() {
    *this = ::std::move(from);
  }

  inline RenameRequest& operator=(const RenameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameRequest& operator=(RenameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RenameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameRequest* internal_default_instance() {
    return reinterpret_cast<const RenameRequest*>(
               &_RenameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RenameRequest& a, RenameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RenameRequest& from);
  void MergeFrom(const RenameRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RenameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RenameRequest";
  }
  protected:
  explicit RenameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldNameFieldNumber = 1,
    kNewNameFieldNumber = 2,
  };
  // string old_name = 1;
  void clear_old_name();
  const std::string& old_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_name();
  PROTOBUF_NODISCARD std::string* release_old_name();
  void set_allocated_old_name(std::string* old_name);
  private:
  const std::string& _internal_old_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_name(const std::string& value);
  std::string* _internal_mutable_old_name();
  public:

  // string new_name = 2;
  void clear_new_name();
  const std::string& new_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_name();
  PROTOBUF_NODISCARD std::string* release_new_name();
  void set_allocated_new_name(std::string* new_name);
  private:
  const std::string& _internal_new_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(const std::string& value);
  std::string* _internal_mutable_new_name();
  public:

  // @@protoc_insertion_point(class_scope:proto.RenameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class RemoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RemoveRequest) */ {
 public:
  inline RemoveRequest() : RemoveRequest(nullptr) {}
  ~RemoveRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRequest(const RemoveRequest& from);
  RemoveRequest(RemoveRequest&& from) noexcept
    : RemoveRequest() {
    *this = ::std::move(from);
  }

  inline RemoveRequest& operator=(const RemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRequest& operator=(RemoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RemoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRequest*>(
               &_RemoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RemoveRequest& a, RemoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemoveRequest& from);
  void MergeFrom(const RemoveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RemoveRequest";
  }
  protected:
  explicit RemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:proto.RemoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FileReply final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FileReply) */ {
 public:
  inline FileReply() : FileReply(nullptr) {}
  ~FileReply() override;
  explicit PROTOBUF_CONSTEXPR FileReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileReply(const FileReply& from);
  FileReply(FileReply&& from) noexcept
    : FileReply() {
    *this = ::std::move(from);
  }

  inline FileReply& operator=(const FileReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileReply& operator=(FileReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FileReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileReply* internal_default_instance() {
    return reinterpret_cast<const FileReply*>(
               &_FileReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FileReply& a, FileReply& b) {
    a.Swap(&b);
  }
  inline void Swap(FileReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileReply>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileReply& from);
  void MergeFrom(const FileReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FileReply";
  }
  protected:
  explicit FileReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriveListFieldNumber = 2,
    kFileListFieldNumber = 3,
    kPacketFieldNumber = 4,
    kErrorCodeFieldNumber = 1,
  };
  // .proto.DriveList drive_list = 2;
  bool has_drive_list() const;
  private:
  bool _internal_has_drive_list() const;
  public:
  void clear_drive_list();
  const ::proto::DriveList& drive_list() const;
  PROTOBUF_NODISCARD ::proto::DriveList* release_drive_list();
  ::proto::DriveList* mutable_drive_list();
  void set_allocated_drive_list(::proto::DriveList* drive_list);
  private:
  const ::proto::DriveList& _internal_drive_list() const;
  ::proto::DriveList* _internal_mutable_drive_list();
  public:
  void unsafe_arena_set_allocated_drive_list(
      ::proto::DriveList* drive_list);
  ::proto::DriveList* unsafe_arena_release_drive_list();

  // .proto.FileList file_list = 3;
  bool has_file_list() const;
  private:
  bool _internal_has_file_list() const;
  public:
  void clear_file_list();
  const ::proto::FileList& file_list() const;
  PROTOBUF_NODISCARD ::proto::FileList* release_file_list();
  ::proto::FileList* mutable_file_list();
  void set_allocated_file_list(::proto::FileList* file_list);
  private:
  const ::proto::FileList& _internal_file_list() const;
  ::proto::FileList* _internal_mutable_file_list();
  public:
  void unsafe_arena_set_allocated_file_list(
      ::proto::FileList* file_list);
  ::proto::FileList* unsafe_arena_release_file_list();

  // .proto.FilePacket packet = 4;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const ::proto::FilePacket& packet() const;
  PROTOBUF_NODISCARD ::proto::FilePacket* release_packet();
  ::proto::FilePacket* mutable_packet();
  void set_allocated_packet(::proto::FilePacket* packet);
  private:
  const ::proto::FilePacket& _internal_packet() const;
  ::proto::FilePacket* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::proto::FilePacket* packet);
  ::proto::FilePacket* unsafe_arena_release_packet();

  // .proto.FileError error_code = 1;
  void clear_error_code();
  ::proto::FileError error_code() const;
  void set_error_code(::proto::FileError value);
  private:
  ::proto::FileError _internal_error_code() const;
  void _internal_set_error_code(::proto::FileError value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FileReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::DriveList* drive_list_;
    ::proto::FileList* file_list_;
    ::proto::FilePacket* packet_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// -------------------------------------------------------------------

class FileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.FileRequest) */ {
 public:
  inline FileRequest() : FileRequest(nullptr) {}
  ~FileRequest() override;
  explicit PROTOBUF_CONSTEXPR FileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRequest(const FileRequest& from);
  FileRequest(FileRequest&& from) noexcept
    : FileRequest() {
    *this = ::std::move(from);
  }

  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRequest* internal_default_instance() {
    return reinterpret_cast<const FileRequest*>(
               &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FileRequest& a, FileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileRequest& from);
  void MergeFrom(const FileRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FileRequest";
  }
  protected:
  explicit FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriveListRequestFieldNumber = 1,
    kFileListRequestFieldNumber = 2,
    kCreateDirectoryRequestFieldNumber = 3,
    kRenameRequestFieldNumber = 4,
    kRemoveRequestFieldNumber = 5,
    kDownloadRequestFieldNumber = 6,
    kUploadRequestFieldNumber = 7,
    kPacketRequestFieldNumber = 8,
    kPacketFieldNumber = 9,
  };
  // .proto.DriveListRequest drive_list_request = 1;
  bool has_drive_list_request() const;
  private:
  bool _internal_has_drive_list_request() const;
  public:
  void clear_drive_list_request();
  const ::proto::DriveListRequest& drive_list_request() const;
  PROTOBUF_NODISCARD ::proto::DriveListRequest* release_drive_list_request();
  ::proto::DriveListRequest* mutable_drive_list_request();
  void set_allocated_drive_list_request(::proto::DriveListRequest* drive_list_request);
  private:
  const ::proto::DriveListRequest& _internal_drive_list_request() const;
  ::proto::DriveListRequest* _internal_mutable_drive_list_request();
  public:
  void unsafe_arena_set_allocated_drive_list_request(
      ::proto::DriveListRequest* drive_list_request);
  ::proto::DriveListRequest* unsafe_arena_release_drive_list_request();

  // .proto.FileListRequest file_list_request = 2;
  bool has_file_list_request() const;
  private:
  bool _internal_has_file_list_request() const;
  public:
  void clear_file_list_request();
  const ::proto::FileListRequest& file_list_request() const;
  PROTOBUF_NODISCARD ::proto::FileListRequest* release_file_list_request();
  ::proto::FileListRequest* mutable_file_list_request();
  void set_allocated_file_list_request(::proto::FileListRequest* file_list_request);
  private:
  const ::proto::FileListRequest& _internal_file_list_request() const;
  ::proto::FileListRequest* _internal_mutable_file_list_request();
  public:
  void unsafe_arena_set_allocated_file_list_request(
      ::proto::FileListRequest* file_list_request);
  ::proto::FileListRequest* unsafe_arena_release_file_list_request();

  // .proto.CreateDirectoryRequest create_directory_request = 3;
  bool has_create_directory_request() const;
  private:
  bool _internal_has_create_directory_request() const;
  public:
  void clear_create_directory_request();
  const ::proto::CreateDirectoryRequest& create_directory_request() const;
  PROTOBUF_NODISCARD ::proto::CreateDirectoryRequest* release_create_directory_request();
  ::proto::CreateDirectoryRequest* mutable_create_directory_request();
  void set_allocated_create_directory_request(::proto::CreateDirectoryRequest* create_directory_request);
  private:
  const ::proto::CreateDirectoryRequest& _internal_create_directory_request() const;
  ::proto::CreateDirectoryRequest* _internal_mutable_create_directory_request();
  public:
  void unsafe_arena_set_allocated_create_directory_request(
      ::proto::CreateDirectoryRequest* create_directory_request);
  ::proto::CreateDirectoryRequest* unsafe_arena_release_create_directory_request();

  // .proto.RenameRequest rename_request = 4;
  bool has_rename_request() const;
  private:
  bool _internal_has_rename_request() const;
  public:
  void clear_rename_request();
  const ::proto::RenameRequest& rename_request() const;
  PROTOBUF_NODISCARD ::proto::RenameRequest* release_rename_request();
  ::proto::RenameRequest* mutable_rename_request();
  void set_allocated_rename_request(::proto::RenameRequest* rename_request);
  private:
  const ::proto::RenameRequest& _internal_rename_request() const;
  ::proto::RenameRequest* _internal_mutable_rename_request();
  public:
  void unsafe_arena_set_allocated_rename_request(
      ::proto::RenameRequest* rename_request);
  ::proto::RenameRequest* unsafe_arena_release_rename_request();

  // .proto.RemoveRequest remove_request = 5;
  bool has_remove_request() const;
  private:
  bool _internal_has_remove_request() const;
  public:
  void clear_remove_request();
  const ::proto::RemoveRequest& remove_request() const;
  PROTOBUF_NODISCARD ::proto::RemoveRequest* release_remove_request();
  ::proto::RemoveRequest* mutable_remove_request();
  void set_allocated_remove_request(::proto::RemoveRequest* remove_request);
  private:
  const ::proto::RemoveRequest& _internal_remove_request() const;
  ::proto::RemoveRequest* _internal_mutable_remove_request();
  public:
  void unsafe_arena_set_allocated_remove_request(
      ::proto::RemoveRequest* remove_request);
  ::proto::RemoveRequest* unsafe_arena_release_remove_request();

  // .proto.DownloadRequest download_request = 6;
  bool has_download_request() const;
  private:
  bool _internal_has_download_request() const;
  public:
  void clear_download_request();
  const ::proto::DownloadRequest& download_request() const;
  PROTOBUF_NODISCARD ::proto::DownloadRequest* release_download_request();
  ::proto::DownloadRequest* mutable_download_request();
  void set_allocated_download_request(::proto::DownloadRequest* download_request);
  private:
  const ::proto::DownloadRequest& _internal_download_request() const;
  ::proto::DownloadRequest* _internal_mutable_download_request();
  public:
  void unsafe_arena_set_allocated_download_request(
      ::proto::DownloadRequest* download_request);
  ::proto::DownloadRequest* unsafe_arena_release_download_request();

  // .proto.UploadRequest upload_request = 7;
  bool has_upload_request() const;
  private:
  bool _internal_has_upload_request() const;
  public:
  void clear_upload_request();
  const ::proto::UploadRequest& upload_request() const;
  PROTOBUF_NODISCARD ::proto::UploadRequest* release_upload_request();
  ::proto::UploadRequest* mutable_upload_request();
  void set_allocated_upload_request(::proto::UploadRequest* upload_request);
  private:
  const ::proto::UploadRequest& _internal_upload_request() const;
  ::proto::UploadRequest* _internal_mutable_upload_request();
  public:
  void unsafe_arena_set_allocated_upload_request(
      ::proto::UploadRequest* upload_request);
  ::proto::UploadRequest* unsafe_arena_release_upload_request();

  // .proto.FilePacketRequest packet_request = 8;
  bool has_packet_request() const;
  private:
  bool _internal_has_packet_request() const;
  public:
  void clear_packet_request();
  const ::proto::FilePacketRequest& packet_request() const;
  PROTOBUF_NODISCARD ::proto::FilePacketRequest* release_packet_request();
  ::proto::FilePacketRequest* mutable_packet_request();
  void set_allocated_packet_request(::proto::FilePacketRequest* packet_request);
  private:
  const ::proto::FilePacketRequest& _internal_packet_request() const;
  ::proto::FilePacketRequest* _internal_mutable_packet_request();
  public:
  void unsafe_arena_set_allocated_packet_request(
      ::proto::FilePacketRequest* packet_request);
  ::proto::FilePacketRequest* unsafe_arena_release_packet_request();

  // .proto.FilePacket packet = 9;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const ::proto::FilePacket& packet() const;
  PROTOBUF_NODISCARD ::proto::FilePacket* release_packet();
  ::proto::FilePacket* mutable_packet();
  void set_allocated_packet(::proto::FilePacket* packet);
  private:
  const ::proto::FilePacket& _internal_packet() const;
  ::proto::FilePacket* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::proto::FilePacket* packet);
  ::proto::FilePacket* unsafe_arena_release_packet();

  // @@protoc_insertion_point(class_scope:proto.FileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::DriveListRequest* drive_list_request_;
    ::proto::FileListRequest* file_list_request_;
    ::proto::CreateDirectoryRequest* create_directory_request_;
    ::proto::RenameRequest* rename_request_;
    ::proto::RemoveRequest* remove_request_;
    ::proto::DownloadRequest* download_request_;
    ::proto::UploadRequest* upload_request_;
    ::proto::FilePacketRequest* packet_request_;
    ::proto::FilePacket* packet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5ftransfer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DriveList_Item

// .proto.DriveList.Item.Type type = 1;
inline void DriveList_Item::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::DriveList_Item_Type DriveList_Item::_internal_type() const {
  return static_cast< ::proto::DriveList_Item_Type >(_impl_.type_);
}
inline ::proto::DriveList_Item_Type DriveList_Item::type() const {
  // @@protoc_insertion_point(field_get:proto.DriveList.Item.type)
  return _internal_type();
}
inline void DriveList_Item::_internal_set_type(::proto::DriveList_Item_Type value) {
  
  _impl_.type_ = value;
}
inline void DriveList_Item::set_type(::proto::DriveList_Item_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.DriveList.Item.type)
}

// string path = 2;
inline void DriveList_Item::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DriveList_Item::path() const {
  // @@protoc_insertion_point(field_get:proto.DriveList.Item.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DriveList_Item::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DriveList.Item.path)
}
inline std::string* DriveList_Item::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.DriveList.Item.path)
  return _s;
}
inline const std::string& DriveList_Item::_internal_path() const {
  return _impl_.path_.Get();
}
inline void DriveList_Item::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* DriveList_Item::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* DriveList_Item::release_path() {
  // @@protoc_insertion_point(field_release:proto.DriveList.Item.path)
  return _impl_.path_.Release();
}
inline void DriveList_Item::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DriveList.Item.path)
}

// string name = 3;
inline void DriveList_Item::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DriveList_Item::name() const {
  // @@protoc_insertion_point(field_get:proto.DriveList.Item.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DriveList_Item::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DriveList.Item.name)
}
inline std::string* DriveList_Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.DriveList.Item.name)
  return _s;
}
inline const std::string& DriveList_Item::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DriveList_Item::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DriveList_Item::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DriveList_Item::release_name() {
  // @@protoc_insertion_point(field_release:proto.DriveList.Item.name)
  return _impl_.name_.Release();
}
inline void DriveList_Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DriveList.Item.name)
}

// int64 total_space = 4;
inline void DriveList_Item::clear_total_space() {
  _impl_.total_space_ = int64_t{0};
}
inline int64_t DriveList_Item::_internal_total_space() const {
  return _impl_.total_space_;
}
inline int64_t DriveList_Item::total_space() const {
  // @@protoc_insertion_point(field_get:proto.DriveList.Item.total_space)
  return _internal_total_space();
}
inline void DriveList_Item::_internal_set_total_space(int64_t value) {
  
  _impl_.total_space_ = value;
}
inline void DriveList_Item::set_total_space(int64_t value) {
  _internal_set_total_space(value);
  // @@protoc_insertion_point(field_set:proto.DriveList.Item.total_space)
}

// int64 free_space = 5;
inline void DriveList_Item::clear_free_space() {
  _impl_.free_space_ = int64_t{0};
}
inline int64_t DriveList_Item::_internal_free_space() const {
  return _impl_.free_space_;
}
inline int64_t DriveList_Item::free_space() const {
  // @@protoc_insertion_point(field_get:proto.DriveList.Item.free_space)
  return _internal_free_space();
}
inline void DriveList_Item::_internal_set_free_space(int64_t value) {
  
  _impl_.free_space_ = value;
}
inline void DriveList_Item::set_free_space(int64_t value) {
  _internal_set_free_space(value);
  // @@protoc_insertion_point(field_set:proto.DriveList.Item.free_space)
}

// -------------------------------------------------------------------

// DriveList

// repeated .proto.DriveList.Item item = 1;
inline int DriveList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int DriveList::item_size() const {
  return _internal_item_size();
}
inline void DriveList::clear_item() {
  _impl_.item_.Clear();
}
inline ::proto::DriveList_Item* DriveList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:proto.DriveList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DriveList_Item >*
DriveList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:proto.DriveList.item)
  return &_impl_.item_;
}
inline const ::proto::DriveList_Item& DriveList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::proto::DriveList_Item& DriveList::item(int index) const {
  // @@protoc_insertion_point(field_get:proto.DriveList.item)
  return _internal_item(index);
}
inline ::proto::DriveList_Item* DriveList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::proto::DriveList_Item* DriveList::add_item() {
  ::proto::DriveList_Item* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:proto.DriveList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DriveList_Item >&
DriveList::item() const {
  // @@protoc_insertion_point(field_list:proto.DriveList.item)
  return _impl_.item_;
}

// -------------------------------------------------------------------

// DriveListRequest

// uint32 dummy = 1;
inline void DriveListRequest::clear_dummy() {
  _impl_.dummy_ = 0u;
}
inline uint32_t DriveListRequest::_internal_dummy() const {
  return _impl_.dummy_;
}
inline uint32_t DriveListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.DriveListRequest.dummy)
  return _internal_dummy();
}
inline void DriveListRequest::_internal_set_dummy(uint32_t value) {
  
  _impl_.dummy_ = value;
}
inline void DriveListRequest::set_dummy(uint32_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:proto.DriveListRequest.dummy)
}

// -------------------------------------------------------------------

// FileList_Item

// string name = 1;
inline void FileList_Item::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FileList_Item::name() const {
  // @@protoc_insertion_point(field_get:proto.FileList.Item.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileList_Item::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.FileList.Item.name)
}
inline std::string* FileList_Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.FileList.Item.name)
  return _s;
}
inline const std::string& FileList_Item::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FileList_Item::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileList_Item::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileList_Item::release_name() {
  // @@protoc_insertion_point(field_release:proto.FileList.Item.name)
  return _impl_.name_.Release();
}
inline void FileList_Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.FileList.Item.name)
}

// uint64 size = 2;
inline void FileList_Item::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t FileList_Item::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t FileList_Item::size() const {
  // @@protoc_insertion_point(field_get:proto.FileList.Item.size)
  return _internal_size();
}
inline void FileList_Item::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void FileList_Item::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:proto.FileList.Item.size)
}

// int64 modification_time = 3;
inline void FileList_Item::clear_modification_time() {
  _impl_.modification_time_ = int64_t{0};
}
inline int64_t FileList_Item::_internal_modification_time() const {
  return _impl_.modification_time_;
}
inline int64_t FileList_Item::modification_time() const {
  // @@protoc_insertion_point(field_get:proto.FileList.Item.modification_time)
  return _internal_modification_time();
}
inline void FileList_Item::_internal_set_modification_time(int64_t value) {
  
  _impl_.modification_time_ = value;
}
inline void FileList_Item::set_modification_time(int64_t value) {
  _internal_set_modification_time(value);
  // @@protoc_insertion_point(field_set:proto.FileList.Item.modification_time)
}

// bool is_directory = 4;
inline void FileList_Item::clear_is_directory() {
  _impl_.is_directory_ = false;
}
inline bool FileList_Item::_internal_is_directory() const {
  return _impl_.is_directory_;
}
inline bool FileList_Item::is_directory() const {
  // @@protoc_insertion_point(field_get:proto.FileList.Item.is_directory)
  return _internal_is_directory();
}
inline void FileList_Item::_internal_set_is_directory(bool value) {
  
  _impl_.is_directory_ = value;
}
inline void FileList_Item::set_is_directory(bool value) {
  _internal_set_is_directory(value);
  // @@protoc_insertion_point(field_set:proto.FileList.Item.is_directory)
}

// -------------------------------------------------------------------

// FileList

// repeated .proto.FileList.Item item = 1;
inline int FileList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int FileList::item_size() const {
  return _internal_item_size();
}
inline void FileList::clear_item() {
  _impl_.item_.Clear();
}
inline ::proto::FileList_Item* FileList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:proto.FileList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FileList_Item >*
FileList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:proto.FileList.item)
  return &_impl_.item_;
}
inline const ::proto::FileList_Item& FileList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::proto::FileList_Item& FileList::item(int index) const {
  // @@protoc_insertion_point(field_get:proto.FileList.item)
  return _internal_item(index);
}
inline ::proto::FileList_Item* FileList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::proto::FileList_Item* FileList::add_item() {
  ::proto::FileList_Item* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:proto.FileList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FileList_Item >&
FileList::item() const {
  // @@protoc_insertion_point(field_list:proto.FileList.item)
  return _impl_.item_;
}

// -------------------------------------------------------------------

// FileListRequest

// string path = 1;
inline void FileListRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& FileListRequest::path() const {
  // @@protoc_insertion_point(field_get:proto.FileListRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileListRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.FileListRequest.path)
}
inline std::string* FileListRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.FileListRequest.path)
  return _s;
}
inline const std::string& FileListRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void FileListRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* FileListRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* FileListRequest::release_path() {
  // @@protoc_insertion_point(field_release:proto.FileListRequest.path)
  return _impl_.path_.Release();
}
inline void FileListRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.FileListRequest.path)
}

// -------------------------------------------------------------------

// UploadRequest

// string path = 1;
inline void UploadRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& UploadRequest::path() const {
  // @@protoc_insertion_point(field_get:proto.UploadRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.UploadRequest.path)
}
inline std::string* UploadRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.UploadRequest.path)
  return _s;
}
inline const std::string& UploadRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void UploadRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadRequest::release_path() {
  // @@protoc_insertion_point(field_release:proto.UploadRequest.path)
  return _impl_.path_.Release();
}
inline void UploadRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.UploadRequest.path)
}

// bool overwrite = 2;
inline void UploadRequest::clear_overwrite() {
  _impl_.overwrite_ = false;
}
inline bool UploadRequest::_internal_overwrite() const {
  return _impl_.overwrite_;
}
inline bool UploadRequest::overwrite() const {
  // @@protoc_insertion_point(field_get:proto.UploadRequest.overwrite)
  return _internal_overwrite();
}
inline void UploadRequest::_internal_set_overwrite(bool value) {
  
  _impl_.overwrite_ = value;
}
inline void UploadRequest::set_overwrite(bool value) {
  _internal_set_overwrite(value);
  // @@protoc_insertion_point(field_set:proto.UploadRequest.overwrite)
}

// -------------------------------------------------------------------

// DownloadRequest

// string path = 1;
inline void DownloadRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DownloadRequest::path() const {
  // @@protoc_insertion_point(field_get:proto.DownloadRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DownloadRequest.path)
}
inline std::string* DownloadRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.DownloadRequest.path)
  return _s;
}
inline const std::string& DownloadRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void DownloadRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadRequest::release_path() {
  // @@protoc_insertion_point(field_release:proto.DownloadRequest.path)
  return _impl_.path_.Release();
}
inline void DownloadRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DownloadRequest.path)
}

// -------------------------------------------------------------------

// FilePacketRequest

// uint32 flags = 1;
inline void FilePacketRequest::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t FilePacketRequest::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t FilePacketRequest::flags() const {
  // @@protoc_insertion_point(field_get:proto.FilePacketRequest.flags)
  return _internal_flags();
}
inline void FilePacketRequest::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void FilePacketRequest::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.FilePacketRequest.flags)
}

// -------------------------------------------------------------------

// FilePacket

// uint32 flags = 1;
inline void FilePacket::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t FilePacket::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t FilePacket::flags() const {
  // @@protoc_insertion_point(field_get:proto.FilePacket.flags)
  return _internal_flags();
}
inline void FilePacket::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void FilePacket::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.FilePacket.flags)
}

// uint64 file_size = 2;
inline void FilePacket::clear_file_size() {
  _impl_.file_size_ = uint64_t{0u};
}
inline uint64_t FilePacket::_internal_file_size() const {
  return _impl_.file_size_;
}
inline uint64_t FilePacket::file_size() const {
  // @@protoc_insertion_point(field_get:proto.FilePacket.file_size)
  return _internal_file_size();
}
inline void FilePacket::_internal_set_file_size(uint64_t value) {
  
  _impl_.file_size_ = value;
}
inline void FilePacket::set_file_size(uint64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:proto.FilePacket.file_size)
}

// bytes data = 3;
inline void FilePacket::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& FilePacket::data() const {
  // @@protoc_insertion_point(field_get:proto.FilePacket.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FilePacket::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.FilePacket.data)
}
inline std::string* FilePacket::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.FilePacket.data)
  return _s;
}
inline const std::string& FilePacket::_internal_data() const {
  return _impl_.data_.Get();
}
inline void FilePacket::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* FilePacket::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* FilePacket::release_data() {
  // @@protoc_insertion_point(field_release:proto.FilePacket.data)
  return _impl_.data_.Release();
}
inline void FilePacket::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.FilePacket.data)
}

// -------------------------------------------------------------------

// CreateDirectoryRequest

// string path = 1;
inline void CreateDirectoryRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& CreateDirectoryRequest::path() const {
  // @@protoc_insertion_point(field_get:proto.CreateDirectoryRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDirectoryRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CreateDirectoryRequest.path)
}
inline std::string* CreateDirectoryRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.CreateDirectoryRequest.path)
  return _s;
}
inline const std::string& CreateDirectoryRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void CreateDirectoryRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::release_path() {
  // @@protoc_insertion_point(field_release:proto.CreateDirectoryRequest.path)
  return _impl_.path_.Release();
}
inline void CreateDirectoryRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CreateDirectoryRequest.path)
}

// -------------------------------------------------------------------

// RenameRequest

// string old_name = 1;
inline void RenameRequest::clear_old_name() {
  _impl_.old_name_.ClearToEmpty();
}
inline const std::string& RenameRequest::old_name() const {
  // @@protoc_insertion_point(field_get:proto.RenameRequest.old_name)
  return _internal_old_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_old_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RenameRequest.old_name)
}
inline std::string* RenameRequest::mutable_old_name() {
  std::string* _s = _internal_mutable_old_name();
  // @@protoc_insertion_point(field_mutable:proto.RenameRequest.old_name)
  return _s;
}
inline const std::string& RenameRequest::_internal_old_name() const {
  return _impl_.old_name_.Get();
}
inline void RenameRequest::_internal_set_old_name(const std::string& value) {
  
  _impl_.old_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_old_name() {
  
  return _impl_.old_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRequest::release_old_name() {
  // @@protoc_insertion_point(field_release:proto.RenameRequest.old_name)
  return _impl_.old_name_.Release();
}
inline void RenameRequest::set_allocated_old_name(std::string* old_name) {
  if (old_name != nullptr) {
    
  } else {
    
  }
  _impl_.old_name_.SetAllocated(old_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_name_.IsDefault()) {
    _impl_.old_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RenameRequest.old_name)
}

// string new_name = 2;
inline void RenameRequest::clear_new_name() {
  _impl_.new_name_.ClearToEmpty();
}
inline const std::string& RenameRequest::new_name() const {
  // @@protoc_insertion_point(field_get:proto.RenameRequest.new_name)
  return _internal_new_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_new_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RenameRequest.new_name)
}
inline std::string* RenameRequest::mutable_new_name() {
  std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:proto.RenameRequest.new_name)
  return _s;
}
inline const std::string& RenameRequest::_internal_new_name() const {
  return _impl_.new_name_.Get();
}
inline void RenameRequest::_internal_set_new_name(const std::string& value) {
  
  _impl_.new_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_new_name() {
  
  return _impl_.new_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRequest::release_new_name() {
  // @@protoc_insertion_point(field_release:proto.RenameRequest.new_name)
  return _impl_.new_name_.Release();
}
inline void RenameRequest::set_allocated_new_name(std::string* new_name) {
  if (new_name != nullptr) {
    
  } else {
    
  }
  _impl_.new_name_.SetAllocated(new_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_name_.IsDefault()) {
    _impl_.new_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RenameRequest.new_name)
}

// -------------------------------------------------------------------

// RemoveRequest

// string path = 1;
inline void RemoveRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RemoveRequest::path() const {
  // @@protoc_insertion_point(field_get:proto.RemoveRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RemoveRequest.path)
}
inline std::string* RemoveRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.RemoveRequest.path)
  return _s;
}
inline const std::string& RemoveRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RemoveRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveRequest::release_path() {
  // @@protoc_insertion_point(field_release:proto.RemoveRequest.path)
  return _impl_.path_.Release();
}
inline void RemoveRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RemoveRequest.path)
}

// -------------------------------------------------------------------

// FileReply

// .proto.FileError error_code = 1;
inline void FileReply::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::FileError FileReply::_internal_error_code() const {
  return static_cast< ::proto::FileError >(_impl_.error_code_);
}
inline ::proto::FileError FileReply::error_code() const {
  // @@protoc_insertion_point(field_get:proto.FileReply.error_code)
  return _internal_error_code();
}
inline void FileReply::_internal_set_error_code(::proto::FileError value) {
  
  _impl_.error_code_ = value;
}
inline void FileReply::set_error_code(::proto::FileError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.FileReply.error_code)
}

// .proto.DriveList drive_list = 2;
inline bool FileReply::_internal_has_drive_list() const {
  return this != internal_default_instance() && _impl_.drive_list_ != nullptr;
}
inline bool FileReply::has_drive_list() const {
  return _internal_has_drive_list();
}
inline void FileReply::clear_drive_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.drive_list_ != nullptr) {
    delete _impl_.drive_list_;
  }
  _impl_.drive_list_ = nullptr;
}
inline const ::proto::DriveList& FileReply::_internal_drive_list() const {
  const ::proto::DriveList* p = _impl_.drive_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DriveList&>(
      ::proto::_DriveList_default_instance_);
}
inline const ::proto::DriveList& FileReply::drive_list() const {
  // @@protoc_insertion_point(field_get:proto.FileReply.drive_list)
  return _internal_drive_list();
}
inline void FileReply::unsafe_arena_set_allocated_drive_list(
    ::proto::DriveList* drive_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drive_list_);
  }
  _impl_.drive_list_ = drive_list;
  if (drive_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileReply.drive_list)
}
inline ::proto::DriveList* FileReply::release_drive_list() {
  
  ::proto::DriveList* temp = _impl_.drive_list_;
  _impl_.drive_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DriveList* FileReply::unsafe_arena_release_drive_list() {
  // @@protoc_insertion_point(field_release:proto.FileReply.drive_list)
  
  ::proto::DriveList* temp = _impl_.drive_list_;
  _impl_.drive_list_ = nullptr;
  return temp;
}
inline ::proto::DriveList* FileReply::_internal_mutable_drive_list() {
  
  if (_impl_.drive_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DriveList>(GetArenaForAllocation());
    _impl_.drive_list_ = p;
  }
  return _impl_.drive_list_;
}
inline ::proto::DriveList* FileReply::mutable_drive_list() {
  ::proto::DriveList* _msg = _internal_mutable_drive_list();
  // @@protoc_insertion_point(field_mutable:proto.FileReply.drive_list)
  return _msg;
}
inline void FileReply::set_allocated_drive_list(::proto::DriveList* drive_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.drive_list_;
  }
  if (drive_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drive_list);
    if (message_arena != submessage_arena) {
      drive_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drive_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.drive_list_ = drive_list;
  // @@protoc_insertion_point(field_set_allocated:proto.FileReply.drive_list)
}

// .proto.FileList file_list = 3;
inline bool FileReply::_internal_has_file_list() const {
  return this != internal_default_instance() && _impl_.file_list_ != nullptr;
}
inline bool FileReply::has_file_list() const {
  return _internal_has_file_list();
}
inline void FileReply::clear_file_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.file_list_ != nullptr) {
    delete _impl_.file_list_;
  }
  _impl_.file_list_ = nullptr;
}
inline const ::proto::FileList& FileReply::_internal_file_list() const {
  const ::proto::FileList* p = _impl_.file_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FileList&>(
      ::proto::_FileList_default_instance_);
}
inline const ::proto::FileList& FileReply::file_list() const {
  // @@protoc_insertion_point(field_get:proto.FileReply.file_list)
  return _internal_file_list();
}
inline void FileReply::unsafe_arena_set_allocated_file_list(
    ::proto::FileList* file_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_list_);
  }
  _impl_.file_list_ = file_list;
  if (file_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileReply.file_list)
}
inline ::proto::FileList* FileReply::release_file_list() {
  
  ::proto::FileList* temp = _impl_.file_list_;
  _impl_.file_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FileList* FileReply::unsafe_arena_release_file_list() {
  // @@protoc_insertion_point(field_release:proto.FileReply.file_list)
  
  ::proto::FileList* temp = _impl_.file_list_;
  _impl_.file_list_ = nullptr;
  return temp;
}
inline ::proto::FileList* FileReply::_internal_mutable_file_list() {
  
  if (_impl_.file_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FileList>(GetArenaForAllocation());
    _impl_.file_list_ = p;
  }
  return _impl_.file_list_;
}
inline ::proto::FileList* FileReply::mutable_file_list() {
  ::proto::FileList* _msg = _internal_mutable_file_list();
  // @@protoc_insertion_point(field_mutable:proto.FileReply.file_list)
  return _msg;
}
inline void FileReply::set_allocated_file_list(::proto::FileList* file_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_list_;
  }
  if (file_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_list);
    if (message_arena != submessage_arena) {
      file_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.file_list_ = file_list;
  // @@protoc_insertion_point(field_set_allocated:proto.FileReply.file_list)
}

// .proto.FilePacket packet = 4;
inline bool FileReply::_internal_has_packet() const {
  return this != internal_default_instance() && _impl_.packet_ != nullptr;
}
inline bool FileReply::has_packet() const {
  return _internal_has_packet();
}
inline void FileReply::clear_packet() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_ != nullptr) {
    delete _impl_.packet_;
  }
  _impl_.packet_ = nullptr;
}
inline const ::proto::FilePacket& FileReply::_internal_packet() const {
  const ::proto::FilePacket* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FilePacket&>(
      ::proto::_FilePacket_default_instance_);
}
inline const ::proto::FilePacket& FileReply::packet() const {
  // @@protoc_insertion_point(field_get:proto.FileReply.packet)
  return _internal_packet();
}
inline void FileReply::unsafe_arena_set_allocated_packet(
    ::proto::FilePacket* packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = packet;
  if (packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileReply.packet)
}
inline ::proto::FilePacket* FileReply::release_packet() {
  
  ::proto::FilePacket* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FilePacket* FileReply::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_release:proto.FileReply.packet)
  
  ::proto::FilePacket* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::proto::FilePacket* FileReply::_internal_mutable_packet() {
  
  if (_impl_.packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FilePacket>(GetArenaForAllocation());
    _impl_.packet_ = p;
  }
  return _impl_.packet_;
}
inline ::proto::FilePacket* FileReply::mutable_packet() {
  ::proto::FilePacket* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:proto.FileReply.packet)
  return _msg;
}
inline void FileReply::set_allocated_packet(::proto::FilePacket* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_;
  }
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet);
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_ = packet;
  // @@protoc_insertion_point(field_set_allocated:proto.FileReply.packet)
}

// -------------------------------------------------------------------

// FileRequest

// .proto.DriveListRequest drive_list_request = 1;
inline bool FileRequest::_internal_has_drive_list_request() const {
  return this != internal_default_instance() && _impl_.drive_list_request_ != nullptr;
}
inline bool FileRequest::has_drive_list_request() const {
  return _internal_has_drive_list_request();
}
inline void FileRequest::clear_drive_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.drive_list_request_ != nullptr) {
    delete _impl_.drive_list_request_;
  }
  _impl_.drive_list_request_ = nullptr;
}
inline const ::proto::DriveListRequest& FileRequest::_internal_drive_list_request() const {
  const ::proto::DriveListRequest* p = _impl_.drive_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DriveListRequest&>(
      ::proto::_DriveListRequest_default_instance_);
}
inline const ::proto::DriveListRequest& FileRequest::drive_list_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.drive_list_request)
  return _internal_drive_list_request();
}
inline void FileRequest::unsafe_arena_set_allocated_drive_list_request(
    ::proto::DriveListRequest* drive_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drive_list_request_);
  }
  _impl_.drive_list_request_ = drive_list_request;
  if (drive_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.drive_list_request)
}
inline ::proto::DriveListRequest* FileRequest::release_drive_list_request() {
  
  ::proto::DriveListRequest* temp = _impl_.drive_list_request_;
  _impl_.drive_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DriveListRequest* FileRequest::unsafe_arena_release_drive_list_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.drive_list_request)
  
  ::proto::DriveListRequest* temp = _impl_.drive_list_request_;
  _impl_.drive_list_request_ = nullptr;
  return temp;
}
inline ::proto::DriveListRequest* FileRequest::_internal_mutable_drive_list_request() {
  
  if (_impl_.drive_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DriveListRequest>(GetArenaForAllocation());
    _impl_.drive_list_request_ = p;
  }
  return _impl_.drive_list_request_;
}
inline ::proto::DriveListRequest* FileRequest::mutable_drive_list_request() {
  ::proto::DriveListRequest* _msg = _internal_mutable_drive_list_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.drive_list_request)
  return _msg;
}
inline void FileRequest::set_allocated_drive_list_request(::proto::DriveListRequest* drive_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.drive_list_request_;
  }
  if (drive_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drive_list_request);
    if (message_arena != submessage_arena) {
      drive_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drive_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.drive_list_request_ = drive_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.drive_list_request)
}

// .proto.FileListRequest file_list_request = 2;
inline bool FileRequest::_internal_has_file_list_request() const {
  return this != internal_default_instance() && _impl_.file_list_request_ != nullptr;
}
inline bool FileRequest::has_file_list_request() const {
  return _internal_has_file_list_request();
}
inline void FileRequest::clear_file_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.file_list_request_ != nullptr) {
    delete _impl_.file_list_request_;
  }
  _impl_.file_list_request_ = nullptr;
}
inline const ::proto::FileListRequest& FileRequest::_internal_file_list_request() const {
  const ::proto::FileListRequest* p = _impl_.file_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FileListRequest&>(
      ::proto::_FileListRequest_default_instance_);
}
inline const ::proto::FileListRequest& FileRequest::file_list_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.file_list_request)
  return _internal_file_list_request();
}
inline void FileRequest::unsafe_arena_set_allocated_file_list_request(
    ::proto::FileListRequest* file_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_list_request_);
  }
  _impl_.file_list_request_ = file_list_request;
  if (file_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.file_list_request)
}
inline ::proto::FileListRequest* FileRequest::release_file_list_request() {
  
  ::proto::FileListRequest* temp = _impl_.file_list_request_;
  _impl_.file_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FileListRequest* FileRequest::unsafe_arena_release_file_list_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.file_list_request)
  
  ::proto::FileListRequest* temp = _impl_.file_list_request_;
  _impl_.file_list_request_ = nullptr;
  return temp;
}
inline ::proto::FileListRequest* FileRequest::_internal_mutable_file_list_request() {
  
  if (_impl_.file_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FileListRequest>(GetArenaForAllocation());
    _impl_.file_list_request_ = p;
  }
  return _impl_.file_list_request_;
}
inline ::proto::FileListRequest* FileRequest::mutable_file_list_request() {
  ::proto::FileListRequest* _msg = _internal_mutable_file_list_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.file_list_request)
  return _msg;
}
inline void FileRequest::set_allocated_file_list_request(::proto::FileListRequest* file_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_list_request_;
  }
  if (file_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_list_request);
    if (message_arena != submessage_arena) {
      file_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.file_list_request_ = file_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.file_list_request)
}

// .proto.CreateDirectoryRequest create_directory_request = 3;
inline bool FileRequest::_internal_has_create_directory_request() const {
  return this != internal_default_instance() && _impl_.create_directory_request_ != nullptr;
}
inline bool FileRequest::has_create_directory_request() const {
  return _internal_has_create_directory_request();
}
inline void FileRequest::clear_create_directory_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.create_directory_request_ != nullptr) {
    delete _impl_.create_directory_request_;
  }
  _impl_.create_directory_request_ = nullptr;
}
inline const ::proto::CreateDirectoryRequest& FileRequest::_internal_create_directory_request() const {
  const ::proto::CreateDirectoryRequest* p = _impl_.create_directory_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CreateDirectoryRequest&>(
      ::proto::_CreateDirectoryRequest_default_instance_);
}
inline const ::proto::CreateDirectoryRequest& FileRequest::create_directory_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.create_directory_request)
  return _internal_create_directory_request();
}
inline void FileRequest::unsafe_arena_set_allocated_create_directory_request(
    ::proto::CreateDirectoryRequest* create_directory_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_directory_request_);
  }
  _impl_.create_directory_request_ = create_directory_request;
  if (create_directory_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.create_directory_request)
}
inline ::proto::CreateDirectoryRequest* FileRequest::release_create_directory_request() {
  
  ::proto::CreateDirectoryRequest* temp = _impl_.create_directory_request_;
  _impl_.create_directory_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CreateDirectoryRequest* FileRequest::unsafe_arena_release_create_directory_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.create_directory_request)
  
  ::proto::CreateDirectoryRequest* temp = _impl_.create_directory_request_;
  _impl_.create_directory_request_ = nullptr;
  return temp;
}
inline ::proto::CreateDirectoryRequest* FileRequest::_internal_mutable_create_directory_request() {
  
  if (_impl_.create_directory_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CreateDirectoryRequest>(GetArenaForAllocation());
    _impl_.create_directory_request_ = p;
  }
  return _impl_.create_directory_request_;
}
inline ::proto::CreateDirectoryRequest* FileRequest::mutable_create_directory_request() {
  ::proto::CreateDirectoryRequest* _msg = _internal_mutable_create_directory_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.create_directory_request)
  return _msg;
}
inline void FileRequest::set_allocated_create_directory_request(::proto::CreateDirectoryRequest* create_directory_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.create_directory_request_;
  }
  if (create_directory_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_directory_request);
    if (message_arena != submessage_arena) {
      create_directory_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_directory_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_directory_request_ = create_directory_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.create_directory_request)
}

// .proto.RenameRequest rename_request = 4;
inline bool FileRequest::_internal_has_rename_request() const {
  return this != internal_default_instance() && _impl_.rename_request_ != nullptr;
}
inline bool FileRequest::has_rename_request() const {
  return _internal_has_rename_request();
}
inline void FileRequest::clear_rename_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.rename_request_ != nullptr) {
    delete _impl_.rename_request_;
  }
  _impl_.rename_request_ = nullptr;
}
inline const ::proto::RenameRequest& FileRequest::_internal_rename_request() const {
  const ::proto::RenameRequest* p = _impl_.rename_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RenameRequest&>(
      ::proto::_RenameRequest_default_instance_);
}
inline const ::proto::RenameRequest& FileRequest::rename_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.rename_request)
  return _internal_rename_request();
}
inline void FileRequest::unsafe_arena_set_allocated_rename_request(
    ::proto::RenameRequest* rename_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rename_request_);
  }
  _impl_.rename_request_ = rename_request;
  if (rename_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.rename_request)
}
inline ::proto::RenameRequest* FileRequest::release_rename_request() {
  
  ::proto::RenameRequest* temp = _impl_.rename_request_;
  _impl_.rename_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RenameRequest* FileRequest::unsafe_arena_release_rename_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.rename_request)
  
  ::proto::RenameRequest* temp = _impl_.rename_request_;
  _impl_.rename_request_ = nullptr;
  return temp;
}
inline ::proto::RenameRequest* FileRequest::_internal_mutable_rename_request() {
  
  if (_impl_.rename_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RenameRequest>(GetArenaForAllocation());
    _impl_.rename_request_ = p;
  }
  return _impl_.rename_request_;
}
inline ::proto::RenameRequest* FileRequest::mutable_rename_request() {
  ::proto::RenameRequest* _msg = _internal_mutable_rename_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.rename_request)
  return _msg;
}
inline void FileRequest::set_allocated_rename_request(::proto::RenameRequest* rename_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rename_request_;
  }
  if (rename_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rename_request);
    if (message_arena != submessage_arena) {
      rename_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rename_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rename_request_ = rename_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.rename_request)
}

// .proto.RemoveRequest remove_request = 5;
inline bool FileRequest::_internal_has_remove_request() const {
  return this != internal_default_instance() && _impl_.remove_request_ != nullptr;
}
inline bool FileRequest::has_remove_request() const {
  return _internal_has_remove_request();
}
inline void FileRequest::clear_remove_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.remove_request_ != nullptr) {
    delete _impl_.remove_request_;
  }
  _impl_.remove_request_ = nullptr;
}
inline const ::proto::RemoveRequest& FileRequest::_internal_remove_request() const {
  const ::proto::RemoveRequest* p = _impl_.remove_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RemoveRequest&>(
      ::proto::_RemoveRequest_default_instance_);
}
inline const ::proto::RemoveRequest& FileRequest::remove_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.remove_request)
  return _internal_remove_request();
}
inline void FileRequest::unsafe_arena_set_allocated_remove_request(
    ::proto::RemoveRequest* remove_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remove_request_);
  }
  _impl_.remove_request_ = remove_request;
  if (remove_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.remove_request)
}
inline ::proto::RemoveRequest* FileRequest::release_remove_request() {
  
  ::proto::RemoveRequest* temp = _impl_.remove_request_;
  _impl_.remove_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RemoveRequest* FileRequest::unsafe_arena_release_remove_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.remove_request)
  
  ::proto::RemoveRequest* temp = _impl_.remove_request_;
  _impl_.remove_request_ = nullptr;
  return temp;
}
inline ::proto::RemoveRequest* FileRequest::_internal_mutable_remove_request() {
  
  if (_impl_.remove_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RemoveRequest>(GetArenaForAllocation());
    _impl_.remove_request_ = p;
  }
  return _impl_.remove_request_;
}
inline ::proto::RemoveRequest* FileRequest::mutable_remove_request() {
  ::proto::RemoveRequest* _msg = _internal_mutable_remove_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.remove_request)
  return _msg;
}
inline void FileRequest::set_allocated_remove_request(::proto::RemoveRequest* remove_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remove_request_;
  }
  if (remove_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remove_request);
    if (message_arena != submessage_arena) {
      remove_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remove_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remove_request_ = remove_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.remove_request)
}

// .proto.DownloadRequest download_request = 6;
inline bool FileRequest::_internal_has_download_request() const {
  return this != internal_default_instance() && _impl_.download_request_ != nullptr;
}
inline bool FileRequest::has_download_request() const {
  return _internal_has_download_request();
}
inline void FileRequest::clear_download_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.download_request_ != nullptr) {
    delete _impl_.download_request_;
  }
  _impl_.download_request_ = nullptr;
}
inline const ::proto::DownloadRequest& FileRequest::_internal_download_request() const {
  const ::proto::DownloadRequest* p = _impl_.download_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DownloadRequest&>(
      ::proto::_DownloadRequest_default_instance_);
}
inline const ::proto::DownloadRequest& FileRequest::download_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.download_request)
  return _internal_download_request();
}
inline void FileRequest::unsafe_arena_set_allocated_download_request(
    ::proto::DownloadRequest* download_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.download_request_);
  }
  _impl_.download_request_ = download_request;
  if (download_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.download_request)
}
inline ::proto::DownloadRequest* FileRequest::release_download_request() {
  
  ::proto::DownloadRequest* temp = _impl_.download_request_;
  _impl_.download_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DownloadRequest* FileRequest::unsafe_arena_release_download_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.download_request)
  
  ::proto::DownloadRequest* temp = _impl_.download_request_;
  _impl_.download_request_ = nullptr;
  return temp;
}
inline ::proto::DownloadRequest* FileRequest::_internal_mutable_download_request() {
  
  if (_impl_.download_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DownloadRequest>(GetArenaForAllocation());
    _impl_.download_request_ = p;
  }
  return _impl_.download_request_;
}
inline ::proto::DownloadRequest* FileRequest::mutable_download_request() {
  ::proto::DownloadRequest* _msg = _internal_mutable_download_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.download_request)
  return _msg;
}
inline void FileRequest::set_allocated_download_request(::proto::DownloadRequest* download_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.download_request_;
  }
  if (download_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(download_request);
    if (message_arena != submessage_arena) {
      download_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.download_request_ = download_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.download_request)
}

// .proto.UploadRequest upload_request = 7;
inline bool FileRequest::_internal_has_upload_request() const {
  return this != internal_default_instance() && _impl_.upload_request_ != nullptr;
}
inline bool FileRequest::has_upload_request() const {
  return _internal_has_upload_request();
}
inline void FileRequest::clear_upload_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.upload_request_ != nullptr) {
    delete _impl_.upload_request_;
  }
  _impl_.upload_request_ = nullptr;
}
inline const ::proto::UploadRequest& FileRequest::_internal_upload_request() const {
  const ::proto::UploadRequest* p = _impl_.upload_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::UploadRequest&>(
      ::proto::_UploadRequest_default_instance_);
}
inline const ::proto::UploadRequest& FileRequest::upload_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.upload_request)
  return _internal_upload_request();
}
inline void FileRequest::unsafe_arena_set_allocated_upload_request(
    ::proto::UploadRequest* upload_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upload_request_);
  }
  _impl_.upload_request_ = upload_request;
  if (upload_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.upload_request)
}
inline ::proto::UploadRequest* FileRequest::release_upload_request() {
  
  ::proto::UploadRequest* temp = _impl_.upload_request_;
  _impl_.upload_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::UploadRequest* FileRequest::unsafe_arena_release_upload_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.upload_request)
  
  ::proto::UploadRequest* temp = _impl_.upload_request_;
  _impl_.upload_request_ = nullptr;
  return temp;
}
inline ::proto::UploadRequest* FileRequest::_internal_mutable_upload_request() {
  
  if (_impl_.upload_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::UploadRequest>(GetArenaForAllocation());
    _impl_.upload_request_ = p;
  }
  return _impl_.upload_request_;
}
inline ::proto::UploadRequest* FileRequest::mutable_upload_request() {
  ::proto::UploadRequest* _msg = _internal_mutable_upload_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.upload_request)
  return _msg;
}
inline void FileRequest::set_allocated_upload_request(::proto::UploadRequest* upload_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upload_request_;
  }
  if (upload_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upload_request);
    if (message_arena != submessage_arena) {
      upload_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upload_request_ = upload_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.upload_request)
}

// .proto.FilePacketRequest packet_request = 8;
inline bool FileRequest::_internal_has_packet_request() const {
  return this != internal_default_instance() && _impl_.packet_request_ != nullptr;
}
inline bool FileRequest::has_packet_request() const {
  return _internal_has_packet_request();
}
inline void FileRequest::clear_packet_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_request_ != nullptr) {
    delete _impl_.packet_request_;
  }
  _impl_.packet_request_ = nullptr;
}
inline const ::proto::FilePacketRequest& FileRequest::_internal_packet_request() const {
  const ::proto::FilePacketRequest* p = _impl_.packet_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FilePacketRequest&>(
      ::proto::_FilePacketRequest_default_instance_);
}
inline const ::proto::FilePacketRequest& FileRequest::packet_request() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.packet_request)
  return _internal_packet_request();
}
inline void FileRequest::unsafe_arena_set_allocated_packet_request(
    ::proto::FilePacketRequest* packet_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_request_);
  }
  _impl_.packet_request_ = packet_request;
  if (packet_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.packet_request)
}
inline ::proto::FilePacketRequest* FileRequest::release_packet_request() {
  
  ::proto::FilePacketRequest* temp = _impl_.packet_request_;
  _impl_.packet_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FilePacketRequest* FileRequest::unsafe_arena_release_packet_request() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.packet_request)
  
  ::proto::FilePacketRequest* temp = _impl_.packet_request_;
  _impl_.packet_request_ = nullptr;
  return temp;
}
inline ::proto::FilePacketRequest* FileRequest::_internal_mutable_packet_request() {
  
  if (_impl_.packet_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FilePacketRequest>(GetArenaForAllocation());
    _impl_.packet_request_ = p;
  }
  return _impl_.packet_request_;
}
inline ::proto::FilePacketRequest* FileRequest::mutable_packet_request() {
  ::proto::FilePacketRequest* _msg = _internal_mutable_packet_request();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.packet_request)
  return _msg;
}
inline void FileRequest::set_allocated_packet_request(::proto::FilePacketRequest* packet_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_request_;
  }
  if (packet_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet_request);
    if (message_arena != submessage_arena) {
      packet_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_request_ = packet_request;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.packet_request)
}

// .proto.FilePacket packet = 9;
inline bool FileRequest::_internal_has_packet() const {
  return this != internal_default_instance() && _impl_.packet_ != nullptr;
}
inline bool FileRequest::has_packet() const {
  return _internal_has_packet();
}
inline void FileRequest::clear_packet() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_ != nullptr) {
    delete _impl_.packet_;
  }
  _impl_.packet_ = nullptr;
}
inline const ::proto::FilePacket& FileRequest::_internal_packet() const {
  const ::proto::FilePacket* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FilePacket&>(
      ::proto::_FilePacket_default_instance_);
}
inline const ::proto::FilePacket& FileRequest::packet() const {
  // @@protoc_insertion_point(field_get:proto.FileRequest.packet)
  return _internal_packet();
}
inline void FileRequest::unsafe_arena_set_allocated_packet(
    ::proto::FilePacket* packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = packet;
  if (packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FileRequest.packet)
}
inline ::proto::FilePacket* FileRequest::release_packet() {
  
  ::proto::FilePacket* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FilePacket* FileRequest::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_release:proto.FileRequest.packet)
  
  ::proto::FilePacket* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::proto::FilePacket* FileRequest::_internal_mutable_packet() {
  
  if (_impl_.packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FilePacket>(GetArenaForAllocation());
    _impl_.packet_ = p;
  }
  return _impl_.packet_;
}
inline ::proto::FilePacket* FileRequest::mutable_packet() {
  ::proto::FilePacket* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:proto.FileRequest.packet)
  return _msg;
}
inline void FileRequest::set_allocated_packet(::proto::FilePacket* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_;
  }
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet);
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_ = packet;
  // @@protoc_insertion_point(field_set_allocated:proto.FileRequest.packet)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::DriveList_Item_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::FilePacketRequest_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::FilePacket_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::FileError> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_file_5ftransfer_2eproto
