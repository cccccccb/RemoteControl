// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserList;
struct UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserListRequest;
struct UserListRequestDefaultTypeInternal;
extern UserListRequestDefaultTypeInternal _UserListRequest_default_instance_;
class UserRequest;
struct UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserResult;
struct UserResultDefaultTypeInternal;
extern UserResultDefaultTypeInternal _UserResult_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::User* Arena::CreateMaybeMessage<::proto::User>(Arena*);
template<> ::proto::UserList* Arena::CreateMaybeMessage<::proto::UserList>(Arena*);
template<> ::proto::UserListRequest* Arena::CreateMaybeMessage<::proto::UserListRequest>(Arena*);
template<> ::proto::UserRequest* Arena::CreateMaybeMessage<::proto::UserRequest>(Arena*);
template<> ::proto::UserResult* Arena::CreateMaybeMessage<::proto::UserResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum UserList_ErrorCode : int {
  UserList_ErrorCode_SUCCESS = 0,
  UserList_ErrorCode_UNKNOWN_ERROR = 1,
  UserList_ErrorCode_UserList_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserList_ErrorCode_UserList_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserList_ErrorCode_IsValid(int value);
constexpr UserList_ErrorCode UserList_ErrorCode_ErrorCode_MIN = UserList_ErrorCode_SUCCESS;
constexpr UserList_ErrorCode UserList_ErrorCode_ErrorCode_MAX = UserList_ErrorCode_UNKNOWN_ERROR;
constexpr int UserList_ErrorCode_ErrorCode_ARRAYSIZE = UserList_ErrorCode_ErrorCode_MAX + 1;

const std::string& UserList_ErrorCode_Name(UserList_ErrorCode value);
template<typename T>
inline const std::string& UserList_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserList_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserList_ErrorCode_Name.");
  return UserList_ErrorCode_Name(static_cast<UserList_ErrorCode>(enum_t_value));
}
bool UserList_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserList_ErrorCode* value);
enum UserResult_ErrorCode : int {
  UserResult_ErrorCode_SUCCESS = 0,
  UserResult_ErrorCode_INTERNAL_ERROR = 1,
  UserResult_ErrorCode_INVALID_DATA = 2,
  UserResult_ErrorCode_ALREADY_EXISTS = 3,
  UserResult_ErrorCode_UserResult_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserResult_ErrorCode_UserResult_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserResult_ErrorCode_IsValid(int value);
constexpr UserResult_ErrorCode UserResult_ErrorCode_ErrorCode_MIN = UserResult_ErrorCode_SUCCESS;
constexpr UserResult_ErrorCode UserResult_ErrorCode_ErrorCode_MAX = UserResult_ErrorCode_ALREADY_EXISTS;
constexpr int UserResult_ErrorCode_ErrorCode_ARRAYSIZE = UserResult_ErrorCode_ErrorCode_MAX + 1;

const std::string& UserResult_ErrorCode_Name(UserResult_ErrorCode value);
template<typename T>
inline const std::string& UserResult_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserResult_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserResult_ErrorCode_Name.");
  return UserResult_ErrorCode_Name(static_cast<UserResult_ErrorCode>(enum_t_value));
}
bool UserResult_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserResult_ErrorCode* value);
enum UserRequestType : int {
  USER_REQUEST_UNKNOWN = 0,
  USER_REQUEST_ADD = 1,
  USER_REQUEST_MODIFY = 2,
  USER_REQUEST_DELETE = 3,
  UserRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserRequestType_IsValid(int value);
constexpr UserRequestType UserRequestType_MIN = USER_REQUEST_UNKNOWN;
constexpr UserRequestType UserRequestType_MAX = USER_REQUEST_DELETE;
constexpr int UserRequestType_ARRAYSIZE = UserRequestType_MAX + 1;

const std::string& UserRequestType_Name(UserRequestType value);
template<typename T>
inline const std::string& UserRequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserRequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserRequestType_Name.");
  return UserRequestType_Name(static_cast<UserRequestType>(enum_t_value));
}
bool UserRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserRequestType* value);
// ===================================================================

class User final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGroupFieldNumber = 3,
    kSaltFieldNumber = 4,
    kVerifierFieldNumber = 5,
    kEntryIdFieldNumber = 1,
    kSessionsFieldNumber = 6,
    kFlagsFieldNumber = 7,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string group = 3;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // bytes salt = 4;
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // bytes verifier = 5;
  void clear_verifier();
  const std::string& verifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verifier();
  PROTOBUF_NODISCARD std::string* release_verifier();
  void set_allocated_verifier(std::string* verifier);
  private:
  const std::string& _internal_verifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifier(const std::string& value);
  std::string* _internal_mutable_verifier();
  public:

  // int64 entry_id = 1;
  void clear_entry_id();
  int64_t entry_id() const;
  void set_entry_id(int64_t value);
  private:
  int64_t _internal_entry_id() const;
  void _internal_set_entry_id(int64_t value);
  public:

  // uint32 sessions = 6;
  void clear_sessions();
  uint32_t sessions() const;
  void set_sessions(uint32_t value);
  private:
  uint32_t _internal_sessions() const;
  void _internal_set_sessions(uint32_t value);
  public:

  // uint32 flags = 7;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verifier_;
    int64_t entry_id_;
    uint32_t sessions_;
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserListRequest) */ {
 public:
  inline UserListRequest() : UserListRequest(nullptr) {}
  ~UserListRequest() override;
  explicit PROTOBUF_CONSTEXPR UserListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListRequest(const UserListRequest& from);
  UserListRequest(UserListRequest&& from) noexcept
    : UserListRequest() {
    *this = ::std::move(from);
  }

  inline UserListRequest& operator=(const UserListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListRequest& operator=(UserListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListRequest* internal_default_instance() {
    return reinterpret_cast<const UserListRequest*>(
               &_UserListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserListRequest& a, UserListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserListRequest& from);
  void MergeFrom(const UserListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserListRequest";
  }
  protected:
  explicit UserListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // uint32 dummy = 1;
  void clear_dummy();
  uint32_t dummy() const;
  void set_dummy(uint32_t value);
  private:
  uint32_t _internal_dummy() const;
  void _internal_set_dummy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserList) */ {
 public:
  inline UserList() : UserList(nullptr) {}
  ~UserList() override;
  explicit PROTOBUF_CONSTEXPR UserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserList(const UserList& from);
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList& operator=(UserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }
  inline void Swap(UserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserList";
  }
  protected:
  explicit UserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UserList_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    UserList_ErrorCode_SUCCESS;
  static constexpr ErrorCode UNKNOWN_ERROR =
    UserList_ErrorCode_UNKNOWN_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return UserList_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    UserList_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    UserList_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    UserList_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return UserList_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return UserList_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // repeated .proto.User user = 2;
  int user_size() const;
  private:
  int _internal_user_size() const;
  public:
  void clear_user();
  ::proto::User* mutable_user(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >*
      mutable_user();
  private:
  const ::proto::User& _internal_user(int index) const;
  ::proto::User* _internal_add_user();
  public:
  const ::proto::User& user(int index) const;
  ::proto::User* add_user();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >&
      user() const;

  // .proto.UserList.ErrorCode error_code = 1;
  void clear_error_code();
  ::proto::UserList_ErrorCode error_code() const;
  void set_error_code(::proto::UserList_ErrorCode value);
  private:
  ::proto::UserList_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::UserList_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User > user_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserRequest) */ {
 public:
  inline UserRequest() : UserRequest(nullptr) {}
  ~UserRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRequest(const UserRequest& from);
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserRequest";
  }
  protected:
  explicit UserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .proto.User user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::proto::User& user() const;
  PROTOBUF_NODISCARD ::proto::User* release_user();
  ::proto::User* mutable_user();
  void set_allocated_user(::proto::User* user);
  private:
  const ::proto::User& _internal_user() const;
  ::proto::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::proto::User* user);
  ::proto::User* unsafe_arena_release_user();

  // .proto.UserRequestType type = 1;
  void clear_type();
  ::proto::UserRequestType type() const;
  void set_type(::proto::UserRequestType value);
  private:
  ::proto::UserRequestType _internal_type() const;
  void _internal_set_type(::proto::UserRequestType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::User* user_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserResult) */ {
 public:
  inline UserResult() : UserResult(nullptr) {}
  ~UserResult() override;
  explicit PROTOBUF_CONSTEXPR UserResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserResult(const UserResult& from);
  UserResult(UserResult&& from) noexcept
    : UserResult() {
    *this = ::std::move(from);
  }

  inline UserResult& operator=(const UserResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResult& operator=(UserResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResult* internal_default_instance() {
    return reinterpret_cast<const UserResult*>(
               &_UserResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserResult& a, UserResult& b) {
    a.Swap(&b);
  }
  inline void Swap(UserResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserResult& from);
  void MergeFrom(const UserResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserResult";
  }
  protected:
  explicit UserResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UserResult_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    UserResult_ErrorCode_SUCCESS;
  static constexpr ErrorCode INTERNAL_ERROR =
    UserResult_ErrorCode_INTERNAL_ERROR;
  static constexpr ErrorCode INVALID_DATA =
    UserResult_ErrorCode_INVALID_DATA;
  static constexpr ErrorCode ALREADY_EXISTS =
    UserResult_ErrorCode_ALREADY_EXISTS;
  static inline bool ErrorCode_IsValid(int value) {
    return UserResult_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    UserResult_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    UserResult_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    UserResult_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return UserResult_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return UserResult_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .proto.UserRequestType type = 1;
  void clear_type();
  ::proto::UserRequestType type() const;
  void set_type(::proto::UserRequestType value);
  private:
  ::proto::UserRequestType _internal_type() const;
  void _internal_set_type(::proto::UserRequestType value);
  public:

  // .proto.UserResult.ErrorCode error_code = 2;
  void clear_error_code();
  ::proto::UserResult_ErrorCode error_code() const;
  void set_error_code(::proto::UserResult_ErrorCode value);
  private:
  ::proto::UserResult_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::UserResult_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// int64 entry_id = 1;
inline void User::clear_entry_id() {
  _impl_.entry_id_ = int64_t{0};
}
inline int64_t User::_internal_entry_id() const {
  return _impl_.entry_id_;
}
inline int64_t User::entry_id() const {
  // @@protoc_insertion_point(field_get:proto.User.entry_id)
  return _internal_entry_id();
}
inline void User::_internal_set_entry_id(int64_t value) {
  
  _impl_.entry_id_ = value;
}
inline void User::set_entry_id(int64_t value) {
  _internal_set_entry_id(value);
  // @@protoc_insertion_point(field_set:proto.User.entry_id)
}

// string name = 2;
inline void User::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& User::name() const {
  // @@protoc_insertion_point(field_get:proto.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.name)
}
inline std::string* User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:proto.User.name)
  return _impl_.name_.Release();
}
inline void User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.name)
}

// string group = 3;
inline void User::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& User::group() const {
  // @@protoc_insertion_point(field_get:proto.User.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.group)
}
inline std::string* User::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:proto.User.group)
  return _s;
}
inline const std::string& User::_internal_group() const {
  return _impl_.group_.Get();
}
inline void User::_internal_set_group(const std::string& value) {
  
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_group() {
  
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_group() {
  // @@protoc_insertion_point(field_release:proto.User.group)
  return _impl_.group_.Release();
}
inline void User::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.group)
}

// bytes salt = 4;
inline void User::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& User::salt() const {
  // @@protoc_insertion_point(field_get:proto.User.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.salt)
}
inline std::string* User::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:proto.User.salt)
  return _s;
}
inline const std::string& User::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void User::_internal_set_salt(const std::string& value) {
  
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_salt() {
  
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_salt() {
  // @@protoc_insertion_point(field_release:proto.User.salt)
  return _impl_.salt_.Release();
}
inline void User::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.salt)
}

// bytes verifier = 5;
inline void User::clear_verifier() {
  _impl_.verifier_.ClearToEmpty();
}
inline const std::string& User::verifier() const {
  // @@protoc_insertion_point(field_get:proto.User.verifier)
  return _internal_verifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_verifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verifier_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.verifier)
}
inline std::string* User::mutable_verifier() {
  std::string* _s = _internal_mutable_verifier();
  // @@protoc_insertion_point(field_mutable:proto.User.verifier)
  return _s;
}
inline const std::string& User::_internal_verifier() const {
  return _impl_.verifier_.Get();
}
inline void User::_internal_set_verifier(const std::string& value) {
  
  _impl_.verifier_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_verifier() {
  
  return _impl_.verifier_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_verifier() {
  // @@protoc_insertion_point(field_release:proto.User.verifier)
  return _impl_.verifier_.Release();
}
inline void User::set_allocated_verifier(std::string* verifier) {
  if (verifier != nullptr) {
    
  } else {
    
  }
  _impl_.verifier_.SetAllocated(verifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifier_.IsDefault()) {
    _impl_.verifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.verifier)
}

// uint32 sessions = 6;
inline void User::clear_sessions() {
  _impl_.sessions_ = 0u;
}
inline uint32_t User::_internal_sessions() const {
  return _impl_.sessions_;
}
inline uint32_t User::sessions() const {
  // @@protoc_insertion_point(field_get:proto.User.sessions)
  return _internal_sessions();
}
inline void User::_internal_set_sessions(uint32_t value) {
  
  _impl_.sessions_ = value;
}
inline void User::set_sessions(uint32_t value) {
  _internal_set_sessions(value);
  // @@protoc_insertion_point(field_set:proto.User.sessions)
}

// uint32 flags = 7;
inline void User::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t User::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t User::flags() const {
  // @@protoc_insertion_point(field_get:proto.User.flags)
  return _internal_flags();
}
inline void User::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void User::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.User.flags)
}

// -------------------------------------------------------------------

// UserListRequest

// uint32 dummy = 1;
inline void UserListRequest::clear_dummy() {
  _impl_.dummy_ = 0u;
}
inline uint32_t UserListRequest::_internal_dummy() const {
  return _impl_.dummy_;
}
inline uint32_t UserListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.UserListRequest.dummy)
  return _internal_dummy();
}
inline void UserListRequest::_internal_set_dummy(uint32_t value) {
  
  _impl_.dummy_ = value;
}
inline void UserListRequest::set_dummy(uint32_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:proto.UserListRequest.dummy)
}

// -------------------------------------------------------------------

// UserList

// .proto.UserList.ErrorCode error_code = 1;
inline void UserList::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::UserList_ErrorCode UserList::_internal_error_code() const {
  return static_cast< ::proto::UserList_ErrorCode >(_impl_.error_code_);
}
inline ::proto::UserList_ErrorCode UserList::error_code() const {
  // @@protoc_insertion_point(field_get:proto.UserList.error_code)
  return _internal_error_code();
}
inline void UserList::_internal_set_error_code(::proto::UserList_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void UserList::set_error_code(::proto::UserList_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.UserList.error_code)
}

// repeated .proto.User user = 2;
inline int UserList::_internal_user_size() const {
  return _impl_.user_.size();
}
inline int UserList::user_size() const {
  return _internal_user_size();
}
inline void UserList::clear_user() {
  _impl_.user_.Clear();
}
inline ::proto::User* UserList::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:proto.UserList.user)
  return _impl_.user_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >*
UserList::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:proto.UserList.user)
  return &_impl_.user_;
}
inline const ::proto::User& UserList::_internal_user(int index) const {
  return _impl_.user_.Get(index);
}
inline const ::proto::User& UserList::user(int index) const {
  // @@protoc_insertion_point(field_get:proto.UserList.user)
  return _internal_user(index);
}
inline ::proto::User* UserList::_internal_add_user() {
  return _impl_.user_.Add();
}
inline ::proto::User* UserList::add_user() {
  ::proto::User* _add = _internal_add_user();
  // @@protoc_insertion_point(field_add:proto.UserList.user)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >&
UserList::user() const {
  // @@protoc_insertion_point(field_list:proto.UserList.user)
  return _impl_.user_;
}

// -------------------------------------------------------------------

// UserRequest

// .proto.UserRequestType type = 1;
inline void UserRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::UserRequestType UserRequest::_internal_type() const {
  return static_cast< ::proto::UserRequestType >(_impl_.type_);
}
inline ::proto::UserRequestType UserRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.UserRequest.type)
  return _internal_type();
}
inline void UserRequest::_internal_set_type(::proto::UserRequestType value) {
  
  _impl_.type_ = value;
}
inline void UserRequest::set_type(::proto::UserRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.UserRequest.type)
}

// .proto.User user = 2;
inline bool UserRequest::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserRequest::has_user() const {
  return _internal_has_user();
}
inline void UserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::proto::User& UserRequest::_internal_user() const {
  const ::proto::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::User&>(
      ::proto::_User_default_instance_);
}
inline const ::proto::User& UserRequest::user() const {
  // @@protoc_insertion_point(field_get:proto.UserRequest.user)
  return _internal_user();
}
inline void UserRequest::unsafe_arena_set_allocated_user(
    ::proto::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.UserRequest.user)
}
inline ::proto::User* UserRequest::release_user() {
  
  ::proto::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::User* UserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:proto.UserRequest.user)
  
  ::proto::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::proto::User* UserRequest::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::proto::User* UserRequest::mutable_user() {
  ::proto::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:proto.UserRequest.user)
  return _msg;
}
inline void UserRequest::set_allocated_user(::proto::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:proto.UserRequest.user)
}

// -------------------------------------------------------------------

// UserResult

// .proto.UserRequestType type = 1;
inline void UserResult::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::UserRequestType UserResult::_internal_type() const {
  return static_cast< ::proto::UserRequestType >(_impl_.type_);
}
inline ::proto::UserRequestType UserResult::type() const {
  // @@protoc_insertion_point(field_get:proto.UserResult.type)
  return _internal_type();
}
inline void UserResult::_internal_set_type(::proto::UserRequestType value) {
  
  _impl_.type_ = value;
}
inline void UserResult::set_type(::proto::UserRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.UserResult.type)
}

// .proto.UserResult.ErrorCode error_code = 2;
inline void UserResult::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::UserResult_ErrorCode UserResult::_internal_error_code() const {
  return static_cast< ::proto::UserResult_ErrorCode >(_impl_.error_code_);
}
inline ::proto::UserResult_ErrorCode UserResult::error_code() const {
  // @@protoc_insertion_point(field_get:proto.UserResult.error_code)
  return _internal_error_code();
}
inline void UserResult::_internal_set_error_code(::proto::UserResult_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void UserResult::set_error_code(::proto::UserResult_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.UserResult.error_code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::UserList_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::UserResult_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::UserRequestType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_2eproto
