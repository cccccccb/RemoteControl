// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task_manager.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_task_5fmanager_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_task_5fmanager_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_task_5fmanager_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_task_5fmanager_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
namespace task_manager {
class ClientToHost;
struct ClientToHostDefaultTypeInternal;
extern ClientToHostDefaultTypeInternal _ClientToHost_default_instance_;
class EndProcessRequest;
struct EndProcessRequestDefaultTypeInternal;
extern EndProcessRequestDefaultTypeInternal _EndProcessRequest_default_instance_;
class HostToClient;
struct HostToClientDefaultTypeInternal;
extern HostToClientDefaultTypeInternal _HostToClient_default_instance_;
class Process;
struct ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class ProcessList;
struct ProcessListDefaultTypeInternal;
extern ProcessListDefaultTypeInternal _ProcessList_default_instance_;
class ProcessListRequest;
struct ProcessListRequestDefaultTypeInternal;
extern ProcessListRequestDefaultTypeInternal _ProcessListRequest_default_instance_;
class Service;
struct ServiceDefaultTypeInternal;
extern ServiceDefaultTypeInternal _Service_default_instance_;
class ServiceList;
struct ServiceListDefaultTypeInternal;
extern ServiceListDefaultTypeInternal _ServiceList_default_instance_;
class ServiceListRequest;
struct ServiceListRequestDefaultTypeInternal;
extern ServiceListRequestDefaultTypeInternal _ServiceListRequest_default_instance_;
class ServiceRequest;
struct ServiceRequestDefaultTypeInternal;
extern ServiceRequestDefaultTypeInternal _ServiceRequest_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserList;
struct UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserListRequest;
struct UserListRequestDefaultTypeInternal;
extern UserListRequestDefaultTypeInternal _UserListRequest_default_instance_;
class UserRequest;
struct UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
}  // namespace task_manager
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::task_manager::ClientToHost* Arena::CreateMaybeMessage<::proto::task_manager::ClientToHost>(Arena*);
template<> ::proto::task_manager::EndProcessRequest* Arena::CreateMaybeMessage<::proto::task_manager::EndProcessRequest>(Arena*);
template<> ::proto::task_manager::HostToClient* Arena::CreateMaybeMessage<::proto::task_manager::HostToClient>(Arena*);
template<> ::proto::task_manager::Process* Arena::CreateMaybeMessage<::proto::task_manager::Process>(Arena*);
template<> ::proto::task_manager::ProcessList* Arena::CreateMaybeMessage<::proto::task_manager::ProcessList>(Arena*);
template<> ::proto::task_manager::ProcessListRequest* Arena::CreateMaybeMessage<::proto::task_manager::ProcessListRequest>(Arena*);
template<> ::proto::task_manager::Service* Arena::CreateMaybeMessage<::proto::task_manager::Service>(Arena*);
template<> ::proto::task_manager::ServiceList* Arena::CreateMaybeMessage<::proto::task_manager::ServiceList>(Arena*);
template<> ::proto::task_manager::ServiceListRequest* Arena::CreateMaybeMessage<::proto::task_manager::ServiceListRequest>(Arena*);
template<> ::proto::task_manager::ServiceRequest* Arena::CreateMaybeMessage<::proto::task_manager::ServiceRequest>(Arena*);
template<> ::proto::task_manager::User* Arena::CreateMaybeMessage<::proto::task_manager::User>(Arena*);
template<> ::proto::task_manager::UserList* Arena::CreateMaybeMessage<::proto::task_manager::UserList>(Arena*);
template<> ::proto::task_manager::UserListRequest* Arena::CreateMaybeMessage<::proto::task_manager::UserListRequest>(Arena*);
template<> ::proto::task_manager::UserRequest* Arena::CreateMaybeMessage<::proto::task_manager::UserRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace task_manager {

enum ProcessListRequest_Flags : int {
  ProcessListRequest_Flags_NONE = 0,
  ProcessListRequest_Flags_RESET_CACHE = 1,
  ProcessListRequest_Flags_ProcessListRequest_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProcessListRequest_Flags_ProcessListRequest_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProcessListRequest_Flags_IsValid(int value);
constexpr ProcessListRequest_Flags ProcessListRequest_Flags_Flags_MIN = ProcessListRequest_Flags_NONE;
constexpr ProcessListRequest_Flags ProcessListRequest_Flags_Flags_MAX = ProcessListRequest_Flags_RESET_CACHE;
constexpr int ProcessListRequest_Flags_Flags_ARRAYSIZE = ProcessListRequest_Flags_Flags_MAX + 1;

const std::string& ProcessListRequest_Flags_Name(ProcessListRequest_Flags value);
template<typename T>
inline const std::string& ProcessListRequest_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessListRequest_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessListRequest_Flags_Name.");
  return ProcessListRequest_Flags_Name(static_cast<ProcessListRequest_Flags>(enum_t_value));
}
bool ProcessListRequest_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessListRequest_Flags* value);
enum Service_Status : int {
  Service_Status_STATUS_UNKNOWN = 0,
  Service_Status_STATUS_CONTINUE_PENDING = 1,
  Service_Status_STATUS_PAUSE_PENDING = 2,
  Service_Status_STATUS_PAUSED = 3,
  Service_Status_STATUS_RUNNING = 4,
  Service_Status_STATUS_START_PENDING = 5,
  Service_Status_STATUS_STOP_PENDING = 6,
  Service_Status_STATUS_STOPPED = 7,
  Service_Status_Service_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Service_Status_Service_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Service_Status_IsValid(int value);
constexpr Service_Status Service_Status_Status_MIN = Service_Status_STATUS_UNKNOWN;
constexpr Service_Status Service_Status_Status_MAX = Service_Status_STATUS_STOPPED;
constexpr int Service_Status_Status_ARRAYSIZE = Service_Status_Status_MAX + 1;

const std::string& Service_Status_Name(Service_Status value);
template<typename T>
inline const std::string& Service_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Service_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Service_Status_Name.");
  return Service_Status_Name(static_cast<Service_Status>(enum_t_value));
}
bool Service_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Service_Status* value);
enum Service_StartupType : int {
  Service_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Service_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Service_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Service_StartupType_STARTUP_TYPE_DISABLED = 3,
  Service_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Service_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Service_StartupType_Service_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Service_StartupType_Service_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Service_StartupType_IsValid(int value);
constexpr Service_StartupType Service_StartupType_StartupType_MIN = Service_StartupType_STARTUP_TYPE_UNKNOWN;
constexpr Service_StartupType Service_StartupType_StartupType_MAX = Service_StartupType_STARTUP_TYPE_SYSTEM_START;
constexpr int Service_StartupType_StartupType_ARRAYSIZE = Service_StartupType_StartupType_MAX + 1;

const std::string& Service_StartupType_Name(Service_StartupType value);
template<typename T>
inline const std::string& Service_StartupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Service_StartupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Service_StartupType_Name.");
  return Service_StartupType_Name(static_cast<Service_StartupType>(enum_t_value));
}
bool Service_StartupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Service_StartupType* value);
enum ServiceRequest_Command : int {
  ServiceRequest_Command_COMMAND_UNKNOWN = 0,
  ServiceRequest_Command_COMMAND_START = 1,
  ServiceRequest_Command_COMMAND_STOP = 2,
  ServiceRequest_Command_ServiceRequest_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceRequest_Command_ServiceRequest_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceRequest_Command_IsValid(int value);
constexpr ServiceRequest_Command ServiceRequest_Command_Command_MIN = ServiceRequest_Command_COMMAND_UNKNOWN;
constexpr ServiceRequest_Command ServiceRequest_Command_Command_MAX = ServiceRequest_Command_COMMAND_STOP;
constexpr int ServiceRequest_Command_Command_ARRAYSIZE = ServiceRequest_Command_Command_MAX + 1;

const std::string& ServiceRequest_Command_Name(ServiceRequest_Command value);
template<typename T>
inline const std::string& ServiceRequest_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceRequest_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceRequest_Command_Name.");
  return ServiceRequest_Command_Name(static_cast<ServiceRequest_Command>(enum_t_value));
}
bool ServiceRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceRequest_Command* value);
enum User_ConnectState : int {
  User_ConnectState_CONNECT_STATE_UNKNOWN = 0,
  User_ConnectState_CONNECT_STATE_ACTIVE = 1,
  User_ConnectState_CONNECT_STATE_CONNECTED = 2,
  User_ConnectState_CONNECT_STATE_CONNECT_QUERY = 3,
  User_ConnectState_CONNECT_STATE_SHADOW = 4,
  User_ConnectState_CONNECT_STATE_DISCONNECTED = 5,
  User_ConnectState_CONNECT_STATE_IDLE = 6,
  User_ConnectState_CONNECT_STATE_LISTEN = 7,
  User_ConnectState_CONNECT_STATE_RESET = 8,
  User_ConnectState_CONNECT_STATE_DOWN = 9,
  User_ConnectState_CONNECT_STATE_INIT = 10,
  User_ConnectState_User_ConnectState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  User_ConnectState_User_ConnectState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool User_ConnectState_IsValid(int value);
constexpr User_ConnectState User_ConnectState_ConnectState_MIN = User_ConnectState_CONNECT_STATE_UNKNOWN;
constexpr User_ConnectState User_ConnectState_ConnectState_MAX = User_ConnectState_CONNECT_STATE_INIT;
constexpr int User_ConnectState_ConnectState_ARRAYSIZE = User_ConnectState_ConnectState_MAX + 1;

const std::string& User_ConnectState_Name(User_ConnectState value);
template<typename T>
inline const std::string& User_ConnectState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, User_ConnectState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function User_ConnectState_Name.");
  return User_ConnectState_Name(static_cast<User_ConnectState>(enum_t_value));
}
bool User_ConnectState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, User_ConnectState* value);
enum UserRequest_Command : int {
  UserRequest_Command_COMMAND_UNKNOWN = 0,
  UserRequest_Command_COMMAND_DISCONNECT = 1,
  UserRequest_Command_COMMAND_LOGOFF = 2,
  UserRequest_Command_UserRequest_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserRequest_Command_UserRequest_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserRequest_Command_IsValid(int value);
constexpr UserRequest_Command UserRequest_Command_Command_MIN = UserRequest_Command_COMMAND_UNKNOWN;
constexpr UserRequest_Command UserRequest_Command_Command_MAX = UserRequest_Command_COMMAND_LOGOFF;
constexpr int UserRequest_Command_Command_ARRAYSIZE = UserRequest_Command_Command_MAX + 1;

const std::string& UserRequest_Command_Name(UserRequest_Command value);
template<typename T>
inline const std::string& UserRequest_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserRequest_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserRequest_Command_Name.");
  return UserRequest_Command_Name(static_cast<UserRequest_Command>(enum_t_value));
}
bool UserRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserRequest_Command* value);
// ===================================================================

class Process final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.Process) */ {
 public:
  inline Process() : Process(nullptr) {}
  ~Process() override;
  explicit PROTOBUF_CONSTEXPR Process(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Process(const Process& from);
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  inline Process& operator=(Process&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Process& default_instance() {
    return *internal_default_instance();
  }
  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }
  inline void Swap(Process* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Process>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Process* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.Process";
  }
  protected:
  explicit Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessNameFieldNumber = 3,
    kUserNameFieldNumber = 4,
    kFilePathFieldNumber = 5,
    kProcessIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kMemWorkingSetFieldNumber = 7,
    kMemPeakWorkingSetFieldNumber = 8,
    kCpuUsageFieldNumber = 6,
    kThreadCountFieldNumber = 11,
    kMemWorkingSetDeltaFieldNumber = 9,
    kMemPrivateWorkingSetFieldNumber = 10,
  };
  // string process_name = 3;
  void clear_process_name();
  const std::string& process_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_process_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_process_name();
  PROTOBUF_NODISCARD std::string* release_process_name();
  void set_allocated_process_name(std::string* process_name);
  private:
  const std::string& _internal_process_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_name(const std::string& value);
  std::string* _internal_mutable_process_name();
  public:

  // string user_name = 4;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string file_path = 5;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // uint64 process_id = 1;
  void clear_process_id();
  uint64_t process_id() const;
  void set_process_id(uint64_t value);
  private:
  uint64_t _internal_process_id() const;
  void _internal_set_process_id(uint64_t value);
  public:

  // uint64 session_id = 2;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int64 mem_working_set = 7;
  void clear_mem_working_set();
  int64_t mem_working_set() const;
  void set_mem_working_set(int64_t value);
  private:
  int64_t _internal_mem_working_set() const;
  void _internal_set_mem_working_set(int64_t value);
  public:

  // int64 mem_peak_working_set = 8;
  void clear_mem_peak_working_set();
  int64_t mem_peak_working_set() const;
  void set_mem_peak_working_set(int64_t value);
  private:
  int64_t _internal_mem_peak_working_set() const;
  void _internal_set_mem_peak_working_set(int64_t value);
  public:

  // int32 cpu_usage = 6;
  void clear_cpu_usage();
  int32_t cpu_usage() const;
  void set_cpu_usage(int32_t value);
  private:
  int32_t _internal_cpu_usage() const;
  void _internal_set_cpu_usage(int32_t value);
  public:

  // uint32 thread_count = 11;
  void clear_thread_count();
  uint32_t thread_count() const;
  void set_thread_count(uint32_t value);
  private:
  uint32_t _internal_thread_count() const;
  void _internal_set_thread_count(uint32_t value);
  public:

  // int64 mem_working_set_delta = 9;
  void clear_mem_working_set_delta();
  int64_t mem_working_set_delta() const;
  void set_mem_working_set_delta(int64_t value);
  private:
  int64_t _internal_mem_working_set_delta() const;
  void _internal_set_mem_working_set_delta(int64_t value);
  public:

  // int64 mem_private_working_set = 10;
  void clear_mem_private_working_set();
  int64_t mem_private_working_set() const;
  void set_mem_private_working_set(int64_t value);
  private:
  int64_t _internal_mem_private_working_set() const;
  void _internal_set_mem_private_working_set(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.Process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    uint64_t process_id_;
    uint64_t session_id_;
    int64_t mem_working_set_;
    int64_t mem_peak_working_set_;
    int32_t cpu_usage_;
    uint32_t thread_count_;
    int64_t mem_working_set_delta_;
    int64_t mem_private_working_set_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ProcessList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.ProcessList) */ {
 public:
  inline ProcessList() : ProcessList(nullptr) {}
  ~ProcessList() override;
  explicit PROTOBUF_CONSTEXPR ProcessList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessList(const ProcessList& from);
  ProcessList(ProcessList&& from) noexcept
    : ProcessList() {
    *this = ::std::move(from);
  }

  inline ProcessList& operator=(const ProcessList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessList& operator=(ProcessList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ProcessList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessList* internal_default_instance() {
    return reinterpret_cast<const ProcessList*>(
               &_ProcessList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProcessList& a, ProcessList& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProcessList& from);
  void MergeFrom(const ProcessList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.ProcessList";
  }
  protected:
  explicit ProcessList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessFieldNumber = 1,
    kCpuUsageFieldNumber = 2,
    kMemoryUsageFieldNumber = 3,
  };
  // repeated .proto.task_manager.Process process = 1;
  int process_size() const;
  private:
  int _internal_process_size() const;
  public:
  void clear_process();
  ::proto::task_manager::Process* mutable_process(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Process >*
      mutable_process();
  private:
  const ::proto::task_manager::Process& _internal_process(int index) const;
  ::proto::task_manager::Process* _internal_add_process();
  public:
  const ::proto::task_manager::Process& process(int index) const;
  ::proto::task_manager::Process* add_process();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Process >&
      process() const;

  // int32 cpu_usage = 2;
  void clear_cpu_usage();
  int32_t cpu_usage() const;
  void set_cpu_usage(int32_t value);
  private:
  int32_t _internal_cpu_usage() const;
  void _internal_set_cpu_usage(int32_t value);
  public:

  // int32 memory_usage = 3;
  void clear_memory_usage();
  int32_t memory_usage() const;
  void set_memory_usage(int32_t value);
  private:
  int32_t _internal_memory_usage() const;
  void _internal_set_memory_usage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.ProcessList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Process > process_;
    int32_t cpu_usage_;
    int32_t memory_usage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ProcessListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.ProcessListRequest) */ {
 public:
  inline ProcessListRequest() : ProcessListRequest(nullptr) {}
  ~ProcessListRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessListRequest(const ProcessListRequest& from);
  ProcessListRequest(ProcessListRequest&& from) noexcept
    : ProcessListRequest() {
    *this = ::std::move(from);
  }

  inline ProcessListRequest& operator=(const ProcessListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessListRequest& operator=(ProcessListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ProcessListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessListRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessListRequest*>(
               &_ProcessListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProcessListRequest& a, ProcessListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProcessListRequest& from);
  void MergeFrom(const ProcessListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.ProcessListRequest";
  }
  protected:
  explicit ProcessListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ProcessListRequest_Flags Flags;
  static constexpr Flags NONE =
    ProcessListRequest_Flags_NONE;
  static constexpr Flags RESET_CACHE =
    ProcessListRequest_Flags_RESET_CACHE;
  static inline bool Flags_IsValid(int value) {
    return ProcessListRequest_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    ProcessListRequest_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    ProcessListRequest_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    ProcessListRequest_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return ProcessListRequest_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return ProcessListRequest_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFlagsFieldNumber = 1,
  };
  // uint32 flags = 1;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.ProcessListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class EndProcessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.EndProcessRequest) */ {
 public:
  inline EndProcessRequest() : EndProcessRequest(nullptr) {}
  ~EndProcessRequest() override;
  explicit PROTOBUF_CONSTEXPR EndProcessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndProcessRequest(const EndProcessRequest& from);
  EndProcessRequest(EndProcessRequest&& from) noexcept
    : EndProcessRequest() {
    *this = ::std::move(from);
  }

  inline EndProcessRequest& operator=(const EndProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndProcessRequest& operator=(EndProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EndProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndProcessRequest* internal_default_instance() {
    return reinterpret_cast<const EndProcessRequest*>(
               &_EndProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EndProcessRequest& a, EndProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EndProcessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndProcessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndProcessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndProcessRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EndProcessRequest& from);
  void MergeFrom(const EndProcessRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndProcessRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.EndProcessRequest";
  }
  protected:
  explicit EndProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.EndProcessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Service final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.Service) */ {
 public:
  inline Service() : Service(nullptr) {}
  ~Service() override;
  explicit PROTOBUF_CONSTEXPR Service(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service(const Service& from);
  Service(Service&& from) noexcept
    : Service() {
    *this = ::std::move(from);
  }

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service& operator=(Service&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Service& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service* internal_default_instance() {
    return reinterpret_cast<const Service*>(
               &_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Service& a, Service& b) {
    a.Swap(&b);
  }
  inline void Swap(Service* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Service* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.Service";
  }
  protected:
  explicit Service(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Service_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    Service_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_CONTINUE_PENDING =
    Service_Status_STATUS_CONTINUE_PENDING;
  static constexpr Status STATUS_PAUSE_PENDING =
    Service_Status_STATUS_PAUSE_PENDING;
  static constexpr Status STATUS_PAUSED =
    Service_Status_STATUS_PAUSED;
  static constexpr Status STATUS_RUNNING =
    Service_Status_STATUS_RUNNING;
  static constexpr Status STATUS_START_PENDING =
    Service_Status_STATUS_START_PENDING;
  static constexpr Status STATUS_STOP_PENDING =
    Service_Status_STATUS_STOP_PENDING;
  static constexpr Status STATUS_STOPPED =
    Service_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Service_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    Service_Status_Status_MIN;
  static constexpr Status Status_MAX =
    Service_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    Service_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return Service_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return Service_Status_Parse(name, value);
  }

  typedef Service_StartupType StartupType;
  static constexpr StartupType STARTUP_TYPE_UNKNOWN =
    Service_StartupType_STARTUP_TYPE_UNKNOWN;
  static constexpr StartupType STARTUP_TYPE_AUTO_START =
    Service_StartupType_STARTUP_TYPE_AUTO_START;
  static constexpr StartupType STARTUP_TYPE_DEMAND_START =
    Service_StartupType_STARTUP_TYPE_DEMAND_START;
  static constexpr StartupType STARTUP_TYPE_DISABLED =
    Service_StartupType_STARTUP_TYPE_DISABLED;
  static constexpr StartupType STARTUP_TYPE_BOOT_START =
    Service_StartupType_STARTUP_TYPE_BOOT_START;
  static constexpr StartupType STARTUP_TYPE_SYSTEM_START =
    Service_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Service_StartupType_IsValid(value);
  }
  static constexpr StartupType StartupType_MIN =
    Service_StartupType_StartupType_MIN;
  static constexpr StartupType StartupType_MAX =
    Service_StartupType_StartupType_MAX;
  static constexpr int StartupType_ARRAYSIZE =
    Service_StartupType_StartupType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StartupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StartupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StartupType_Name.");
    return Service_StartupType_Name(enum_t_value);
  }
  static inline bool StartupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StartupType* value) {
    return Service_StartupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kStatusFieldNumber = 4,
    kStartupTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .proto.task_manager.Service.Status status = 4;
  void clear_status();
  ::proto::task_manager::Service_Status status() const;
  void set_status(::proto::task_manager::Service_Status value);
  private:
  ::proto::task_manager::Service_Status _internal_status() const;
  void _internal_set_status(::proto::task_manager::Service_Status value);
  public:

  // .proto.task_manager.Service.StartupType startup_type = 5;
  void clear_startup_type();
  ::proto::task_manager::Service_StartupType startup_type() const;
  void set_startup_type(::proto::task_manager::Service_StartupType value);
  private:
  ::proto::task_manager::Service_StartupType _internal_startup_type() const;
  void _internal_set_startup_type(::proto::task_manager::Service_StartupType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.Service)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int status_;
    int startup_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ServiceList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.ServiceList) */ {
 public:
  inline ServiceList() : ServiceList(nullptr) {}
  ~ServiceList() override;
  explicit PROTOBUF_CONSTEXPR ServiceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceList(const ServiceList& from);
  ServiceList(ServiceList&& from) noexcept
    : ServiceList() {
    *this = ::std::move(from);
  }

  inline ServiceList& operator=(const ServiceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceList& operator=(ServiceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ServiceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceList* internal_default_instance() {
    return reinterpret_cast<const ServiceList*>(
               &_ServiceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServiceList& a, ServiceList& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServiceList& from);
  void MergeFrom(const ServiceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.ServiceList";
  }
  protected:
  explicit ServiceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // repeated .proto.task_manager.Service service = 1;
  int service_size() const;
  private:
  int _internal_service_size() const;
  public:
  void clear_service();
  ::proto::task_manager::Service* mutable_service(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Service >*
      mutable_service();
  private:
  const ::proto::task_manager::Service& _internal_service(int index) const;
  ::proto::task_manager::Service* _internal_add_service();
  public:
  const ::proto::task_manager::Service& service(int index) const;
  ::proto::task_manager::Service* add_service();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Service >&
      service() const;

  // @@protoc_insertion_point(class_scope:proto.task_manager.ServiceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Service > service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ServiceListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.ServiceListRequest) */ {
 public:
  inline ServiceListRequest() : ServiceListRequest(nullptr) {}
  ~ServiceListRequest() override;
  explicit PROTOBUF_CONSTEXPR ServiceListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceListRequest(const ServiceListRequest& from);
  ServiceListRequest(ServiceListRequest&& from) noexcept
    : ServiceListRequest() {
    *this = ::std::move(from);
  }

  inline ServiceListRequest& operator=(const ServiceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceListRequest& operator=(ServiceListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ServiceListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceListRequest* internal_default_instance() {
    return reinterpret_cast<const ServiceListRequest*>(
               &_ServiceListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServiceListRequest& a, ServiceListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServiceListRequest& from);
  void MergeFrom(const ServiceListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.ServiceListRequest";
  }
  protected:
  explicit ServiceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // uint32 dummy = 1;
  void clear_dummy();
  uint32_t dummy() const;
  void set_dummy(uint32_t value);
  private:
  uint32_t _internal_dummy() const;
  void _internal_set_dummy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.ServiceListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.ServiceRequest) */ {
 public:
  inline ServiceRequest() : ServiceRequest(nullptr) {}
  ~ServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR ServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceRequest(const ServiceRequest& from);
  ServiceRequest(ServiceRequest&& from) noexcept
    : ServiceRequest() {
    *this = ::std::move(from);
  }

  inline ServiceRequest& operator=(const ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceRequest& operator=(ServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest*>(
               &_ServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServiceRequest& a, ServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServiceRequest& from);
  void MergeFrom(const ServiceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.ServiceRequest";
  }
  protected:
  explicit ServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ServiceRequest_Command Command;
  static constexpr Command COMMAND_UNKNOWN =
    ServiceRequest_Command_COMMAND_UNKNOWN;
  static constexpr Command COMMAND_START =
    ServiceRequest_Command_COMMAND_START;
  static constexpr Command COMMAND_STOP =
    ServiceRequest_Command_COMMAND_STOP;
  static inline bool Command_IsValid(int value) {
    return ServiceRequest_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    ServiceRequest_Command_Command_MIN;
  static constexpr Command Command_MAX =
    ServiceRequest_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    ServiceRequest_Command_Command_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return ServiceRequest_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return ServiceRequest_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .proto.task_manager.ServiceRequest.Command command = 2;
  void clear_command();
  ::proto::task_manager::ServiceRequest_Command command() const;
  void set_command(::proto::task_manager::ServiceRequest_Command value);
  private:
  ::proto::task_manager::ServiceRequest_Command _internal_command() const;
  void _internal_set_command(::proto::task_manager::ServiceRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.ServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef User_ConnectState ConnectState;
  static constexpr ConnectState CONNECT_STATE_UNKNOWN =
    User_ConnectState_CONNECT_STATE_UNKNOWN;
  static constexpr ConnectState CONNECT_STATE_ACTIVE =
    User_ConnectState_CONNECT_STATE_ACTIVE;
  static constexpr ConnectState CONNECT_STATE_CONNECTED =
    User_ConnectState_CONNECT_STATE_CONNECTED;
  static constexpr ConnectState CONNECT_STATE_CONNECT_QUERY =
    User_ConnectState_CONNECT_STATE_CONNECT_QUERY;
  static constexpr ConnectState CONNECT_STATE_SHADOW =
    User_ConnectState_CONNECT_STATE_SHADOW;
  static constexpr ConnectState CONNECT_STATE_DISCONNECTED =
    User_ConnectState_CONNECT_STATE_DISCONNECTED;
  static constexpr ConnectState CONNECT_STATE_IDLE =
    User_ConnectState_CONNECT_STATE_IDLE;
  static constexpr ConnectState CONNECT_STATE_LISTEN =
    User_ConnectState_CONNECT_STATE_LISTEN;
  static constexpr ConnectState CONNECT_STATE_RESET =
    User_ConnectState_CONNECT_STATE_RESET;
  static constexpr ConnectState CONNECT_STATE_DOWN =
    User_ConnectState_CONNECT_STATE_DOWN;
  static constexpr ConnectState CONNECT_STATE_INIT =
    User_ConnectState_CONNECT_STATE_INIT;
  static inline bool ConnectState_IsValid(int value) {
    return User_ConnectState_IsValid(value);
  }
  static constexpr ConnectState ConnectState_MIN =
    User_ConnectState_ConnectState_MIN;
  static constexpr ConnectState ConnectState_MAX =
    User_ConnectState_ConnectState_MAX;
  static constexpr int ConnectState_ARRAYSIZE =
    User_ConnectState_ConnectState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectState_Name.");
    return User_ConnectState_Name(enum_t_value);
  }
  static inline bool ConnectState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectState* value) {
    return User_ConnectState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kClientNameFieldNumber = 3,
    kSessionNameFieldNumber = 4,
    kSessionIdFieldNumber = 2,
    kConnectStateFieldNumber = 5,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string client_name = 3;
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // string session_name = 4;
  void clear_session_name();
  const std::string& session_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_name();
  PROTOBUF_NODISCARD std::string* release_session_name();
  void set_allocated_session_name(std::string* session_name);
  private:
  const std::string& _internal_session_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_name(const std::string& value);
  std::string* _internal_mutable_session_name();
  public:

  // uint32 session_id = 2;
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // .proto.task_manager.User.ConnectState connect_state = 5;
  void clear_connect_state();
  ::proto::task_manager::User_ConnectState connect_state() const;
  void set_connect_state(::proto::task_manager::User_ConnectState value);
  private:
  ::proto::task_manager::User_ConnectState _internal_connect_state() const;
  void _internal_set_connect_state(::proto::task_manager::User_ConnectState value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_name_;
    uint32_t session_id_;
    int connect_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class UserList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.UserList) */ {
 public:
  inline UserList() : UserList(nullptr) {}
  ~UserList() override;
  explicit PROTOBUF_CONSTEXPR UserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserList(const UserList& from);
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList& operator=(UserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }
  inline void Swap(UserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.UserList";
  }
  protected:
  explicit UserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // repeated .proto.task_manager.User user = 1;
  int user_size() const;
  private:
  int _internal_user_size() const;
  public:
  void clear_user();
  ::proto::task_manager::User* mutable_user(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::User >*
      mutable_user();
  private:
  const ::proto::task_manager::User& _internal_user(int index) const;
  ::proto::task_manager::User* _internal_add_user();
  public:
  const ::proto::task_manager::User& user(int index) const;
  ::proto::task_manager::User* add_user();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::User >&
      user() const;

  // @@protoc_insertion_point(class_scope:proto.task_manager.UserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::User > user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class UserListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.UserListRequest) */ {
 public:
  inline UserListRequest() : UserListRequest(nullptr) {}
  ~UserListRequest() override;
  explicit PROTOBUF_CONSTEXPR UserListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListRequest(const UserListRequest& from);
  UserListRequest(UserListRequest&& from) noexcept
    : UserListRequest() {
    *this = ::std::move(from);
  }

  inline UserListRequest& operator=(const UserListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListRequest& operator=(UserListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListRequest* internal_default_instance() {
    return reinterpret_cast<const UserListRequest*>(
               &_UserListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserListRequest& a, UserListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserListRequest& from);
  void MergeFrom(const UserListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.UserListRequest";
  }
  protected:
  explicit UserListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // uint32 dummy = 1;
  void clear_dummy();
  uint32_t dummy() const;
  void set_dummy(uint32_t value);
  private:
  uint32_t _internal_dummy() const;
  void _internal_set_dummy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.UserListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class UserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.UserRequest) */ {
 public:
  inline UserRequest() : UserRequest(nullptr) {}
  ~UserRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRequest(const UserRequest& from);
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.UserRequest";
  }
  protected:
  explicit UserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UserRequest_Command Command;
  static constexpr Command COMMAND_UNKNOWN =
    UserRequest_Command_COMMAND_UNKNOWN;
  static constexpr Command COMMAND_DISCONNECT =
    UserRequest_Command_COMMAND_DISCONNECT;
  static constexpr Command COMMAND_LOGOFF =
    UserRequest_Command_COMMAND_LOGOFF;
  static inline bool Command_IsValid(int value) {
    return UserRequest_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    UserRequest_Command_Command_MIN;
  static constexpr Command Command_MAX =
    UserRequest_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    UserRequest_Command_Command_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return UserRequest_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return UserRequest_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // uint32 session_id = 1;
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // .proto.task_manager.UserRequest.Command command = 2;
  void clear_command();
  ::proto::task_manager::UserRequest_Command command() const;
  void set_command(::proto::task_manager::UserRequest_Command value);
  private:
  ::proto::task_manager::UserRequest_Command _internal_command() const;
  void _internal_set_command(::proto::task_manager::UserRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:proto.task_manager.UserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t session_id_;
    int command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ClientToHost final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.ClientToHost) */ {
 public:
  inline ClientToHost() : ClientToHost(nullptr) {}
  ~ClientToHost() override;
  explicit PROTOBUF_CONSTEXPR ClientToHost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToHost(const ClientToHost& from);
  ClientToHost(ClientToHost&& from) noexcept
    : ClientToHost() {
    *this = ::std::move(from);
  }

  inline ClientToHost& operator=(const ClientToHost& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToHost& operator=(ClientToHost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ClientToHost& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToHost* internal_default_instance() {
    return reinterpret_cast<const ClientToHost*>(
               &_ClientToHost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ClientToHost& a, ClientToHost& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToHost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToHost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToHost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToHost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientToHost& from);
  void MergeFrom(const ClientToHost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToHost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.ClientToHost";
  }
  protected:
  explicit ClientToHost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessListRequestFieldNumber = 1,
    kEndProcessRequestFieldNumber = 2,
    kServiceListRequestFieldNumber = 3,
    kServiceRequestFieldNumber = 4,
    kUserListRequestFieldNumber = 5,
    kUserRequestFieldNumber = 6,
  };
  // .proto.task_manager.ProcessListRequest process_list_request = 1;
  bool has_process_list_request() const;
  private:
  bool _internal_has_process_list_request() const;
  public:
  void clear_process_list_request();
  const ::proto::task_manager::ProcessListRequest& process_list_request() const;
  PROTOBUF_NODISCARD ::proto::task_manager::ProcessListRequest* release_process_list_request();
  ::proto::task_manager::ProcessListRequest* mutable_process_list_request();
  void set_allocated_process_list_request(::proto::task_manager::ProcessListRequest* process_list_request);
  private:
  const ::proto::task_manager::ProcessListRequest& _internal_process_list_request() const;
  ::proto::task_manager::ProcessListRequest* _internal_mutable_process_list_request();
  public:
  void unsafe_arena_set_allocated_process_list_request(
      ::proto::task_manager::ProcessListRequest* process_list_request);
  ::proto::task_manager::ProcessListRequest* unsafe_arena_release_process_list_request();

  // .proto.task_manager.EndProcessRequest end_process_request = 2;
  bool has_end_process_request() const;
  private:
  bool _internal_has_end_process_request() const;
  public:
  void clear_end_process_request();
  const ::proto::task_manager::EndProcessRequest& end_process_request() const;
  PROTOBUF_NODISCARD ::proto::task_manager::EndProcessRequest* release_end_process_request();
  ::proto::task_manager::EndProcessRequest* mutable_end_process_request();
  void set_allocated_end_process_request(::proto::task_manager::EndProcessRequest* end_process_request);
  private:
  const ::proto::task_manager::EndProcessRequest& _internal_end_process_request() const;
  ::proto::task_manager::EndProcessRequest* _internal_mutable_end_process_request();
  public:
  void unsafe_arena_set_allocated_end_process_request(
      ::proto::task_manager::EndProcessRequest* end_process_request);
  ::proto::task_manager::EndProcessRequest* unsafe_arena_release_end_process_request();

  // .proto.task_manager.ServiceListRequest service_list_request = 3;
  bool has_service_list_request() const;
  private:
  bool _internal_has_service_list_request() const;
  public:
  void clear_service_list_request();
  const ::proto::task_manager::ServiceListRequest& service_list_request() const;
  PROTOBUF_NODISCARD ::proto::task_manager::ServiceListRequest* release_service_list_request();
  ::proto::task_manager::ServiceListRequest* mutable_service_list_request();
  void set_allocated_service_list_request(::proto::task_manager::ServiceListRequest* service_list_request);
  private:
  const ::proto::task_manager::ServiceListRequest& _internal_service_list_request() const;
  ::proto::task_manager::ServiceListRequest* _internal_mutable_service_list_request();
  public:
  void unsafe_arena_set_allocated_service_list_request(
      ::proto::task_manager::ServiceListRequest* service_list_request);
  ::proto::task_manager::ServiceListRequest* unsafe_arena_release_service_list_request();

  // .proto.task_manager.ServiceRequest service_request = 4;
  bool has_service_request() const;
  private:
  bool _internal_has_service_request() const;
  public:
  void clear_service_request();
  const ::proto::task_manager::ServiceRequest& service_request() const;
  PROTOBUF_NODISCARD ::proto::task_manager::ServiceRequest* release_service_request();
  ::proto::task_manager::ServiceRequest* mutable_service_request();
  void set_allocated_service_request(::proto::task_manager::ServiceRequest* service_request);
  private:
  const ::proto::task_manager::ServiceRequest& _internal_service_request() const;
  ::proto::task_manager::ServiceRequest* _internal_mutable_service_request();
  public:
  void unsafe_arena_set_allocated_service_request(
      ::proto::task_manager::ServiceRequest* service_request);
  ::proto::task_manager::ServiceRequest* unsafe_arena_release_service_request();

  // .proto.task_manager.UserListRequest user_list_request = 5;
  bool has_user_list_request() const;
  private:
  bool _internal_has_user_list_request() const;
  public:
  void clear_user_list_request();
  const ::proto::task_manager::UserListRequest& user_list_request() const;
  PROTOBUF_NODISCARD ::proto::task_manager::UserListRequest* release_user_list_request();
  ::proto::task_manager::UserListRequest* mutable_user_list_request();
  void set_allocated_user_list_request(::proto::task_manager::UserListRequest* user_list_request);
  private:
  const ::proto::task_manager::UserListRequest& _internal_user_list_request() const;
  ::proto::task_manager::UserListRequest* _internal_mutable_user_list_request();
  public:
  void unsafe_arena_set_allocated_user_list_request(
      ::proto::task_manager::UserListRequest* user_list_request);
  ::proto::task_manager::UserListRequest* unsafe_arena_release_user_list_request();

  // .proto.task_manager.UserRequest user_request = 6;
  bool has_user_request() const;
  private:
  bool _internal_has_user_request() const;
  public:
  void clear_user_request();
  const ::proto::task_manager::UserRequest& user_request() const;
  PROTOBUF_NODISCARD ::proto::task_manager::UserRequest* release_user_request();
  ::proto::task_manager::UserRequest* mutable_user_request();
  void set_allocated_user_request(::proto::task_manager::UserRequest* user_request);
  private:
  const ::proto::task_manager::UserRequest& _internal_user_request() const;
  ::proto::task_manager::UserRequest* _internal_mutable_user_request();
  public:
  void unsafe_arena_set_allocated_user_request(
      ::proto::task_manager::UserRequest* user_request);
  ::proto::task_manager::UserRequest* unsafe_arena_release_user_request();

  // @@protoc_insertion_point(class_scope:proto.task_manager.ClientToHost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::task_manager::ProcessListRequest* process_list_request_;
    ::proto::task_manager::EndProcessRequest* end_process_request_;
    ::proto::task_manager::ServiceListRequest* service_list_request_;
    ::proto::task_manager::ServiceRequest* service_request_;
    ::proto::task_manager::UserListRequest* user_list_request_;
    ::proto::task_manager::UserRequest* user_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class HostToClient final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.task_manager.HostToClient) */ {
 public:
  inline HostToClient() : HostToClient(nullptr) {}
  ~HostToClient() override;
  explicit PROTOBUF_CONSTEXPR HostToClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostToClient(const HostToClient& from);
  HostToClient(HostToClient&& from) noexcept
    : HostToClient() {
    *this = ::std::move(from);
  }

  inline HostToClient& operator=(const HostToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostToClient& operator=(HostToClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostToClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostToClient* internal_default_instance() {
    return reinterpret_cast<const HostToClient*>(
               &_HostToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HostToClient& a, HostToClient& b) {
    a.Swap(&b);
  }
  inline void Swap(HostToClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostToClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostToClient>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostToClient& from);
  void MergeFrom(const HostToClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostToClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.task_manager.HostToClient";
  }
  protected:
  explicit HostToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessListFieldNumber = 1,
    kServiceListFieldNumber = 2,
    kUserListFieldNumber = 3,
  };
  // .proto.task_manager.ProcessList process_list = 1;
  bool has_process_list() const;
  private:
  bool _internal_has_process_list() const;
  public:
  void clear_process_list();
  const ::proto::task_manager::ProcessList& process_list() const;
  PROTOBUF_NODISCARD ::proto::task_manager::ProcessList* release_process_list();
  ::proto::task_manager::ProcessList* mutable_process_list();
  void set_allocated_process_list(::proto::task_manager::ProcessList* process_list);
  private:
  const ::proto::task_manager::ProcessList& _internal_process_list() const;
  ::proto::task_manager::ProcessList* _internal_mutable_process_list();
  public:
  void unsafe_arena_set_allocated_process_list(
      ::proto::task_manager::ProcessList* process_list);
  ::proto::task_manager::ProcessList* unsafe_arena_release_process_list();

  // .proto.task_manager.ServiceList service_list = 2;
  bool has_service_list() const;
  private:
  bool _internal_has_service_list() const;
  public:
  void clear_service_list();
  const ::proto::task_manager::ServiceList& service_list() const;
  PROTOBUF_NODISCARD ::proto::task_manager::ServiceList* release_service_list();
  ::proto::task_manager::ServiceList* mutable_service_list();
  void set_allocated_service_list(::proto::task_manager::ServiceList* service_list);
  private:
  const ::proto::task_manager::ServiceList& _internal_service_list() const;
  ::proto::task_manager::ServiceList* _internal_mutable_service_list();
  public:
  void unsafe_arena_set_allocated_service_list(
      ::proto::task_manager::ServiceList* service_list);
  ::proto::task_manager::ServiceList* unsafe_arena_release_service_list();

  // .proto.task_manager.UserList user_list = 3;
  bool has_user_list() const;
  private:
  bool _internal_has_user_list() const;
  public:
  void clear_user_list();
  const ::proto::task_manager::UserList& user_list() const;
  PROTOBUF_NODISCARD ::proto::task_manager::UserList* release_user_list();
  ::proto::task_manager::UserList* mutable_user_list();
  void set_allocated_user_list(::proto::task_manager::UserList* user_list);
  private:
  const ::proto::task_manager::UserList& _internal_user_list() const;
  ::proto::task_manager::UserList* _internal_mutable_user_list();
  public:
  void unsafe_arena_set_allocated_user_list(
      ::proto::task_manager::UserList* user_list);
  ::proto::task_manager::UserList* unsafe_arena_release_user_list();

  // @@protoc_insertion_point(class_scope:proto.task_manager.HostToClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::task_manager::ProcessList* process_list_;
    ::proto::task_manager::ServiceList* service_list_;
    ::proto::task_manager::UserList* user_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_task_5fmanager_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Process

// uint64 process_id = 1;
inline void Process::clear_process_id() {
  _impl_.process_id_ = uint64_t{0u};
}
inline uint64_t Process::_internal_process_id() const {
  return _impl_.process_id_;
}
inline uint64_t Process::process_id() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.process_id)
  return _internal_process_id();
}
inline void Process::_internal_set_process_id(uint64_t value) {
  
  _impl_.process_id_ = value;
}
inline void Process::set_process_id(uint64_t value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.process_id)
}

// uint64 session_id = 2;
inline void Process::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t Process::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t Process::session_id() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.session_id)
  return _internal_session_id();
}
inline void Process::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void Process::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.session_id)
}

// string process_name = 3;
inline void Process::clear_process_name() {
  _impl_.process_name_.ClearToEmpty();
}
inline const std::string& Process::process_name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.process_name)
  return _internal_process_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_process_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.process_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.process_name)
}
inline std::string* Process::mutable_process_name() {
  std::string* _s = _internal_mutable_process_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.Process.process_name)
  return _s;
}
inline const std::string& Process::_internal_process_name() const {
  return _impl_.process_name_.Get();
}
inline void Process::_internal_set_process_name(const std::string& value) {
  
  _impl_.process_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_process_name() {
  
  return _impl_.process_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_process_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.Process.process_name)
  return _impl_.process_name_.Release();
}
inline void Process::set_allocated_process_name(std::string* process_name) {
  if (process_name != nullptr) {
    
  } else {
    
  }
  _impl_.process_name_.SetAllocated(process_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.process_name_.IsDefault()) {
    _impl_.process_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.Process.process_name)
}

// string user_name = 4;
inline void Process::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& Process::user_name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.user_name)
}
inline std::string* Process::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.Process.user_name)
  return _s;
}
inline const std::string& Process::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void Process::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_user_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.Process.user_name)
  return _impl_.user_name_.Release();
}
inline void Process::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.Process.user_name)
}

// string file_path = 5;
inline void Process::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& Process::file_path() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.file_path)
}
inline std::string* Process::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.Process.file_path)
  return _s;
}
inline const std::string& Process::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void Process::_internal_set_file_path(const std::string& value) {
  
  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_file_path() {
  
  return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_file_path() {
  // @@protoc_insertion_point(field_release:proto.task_manager.Process.file_path)
  return _impl_.file_path_.Release();
}
inline void Process::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.Process.file_path)
}

// int32 cpu_usage = 6;
inline void Process::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline int32_t Process::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline int32_t Process::cpu_usage() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.cpu_usage)
  return _internal_cpu_usage();
}
inline void Process::_internal_set_cpu_usage(int32_t value) {
  
  _impl_.cpu_usage_ = value;
}
inline void Process::set_cpu_usage(int32_t value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.cpu_usage)
}

// int64 mem_working_set = 7;
inline void Process::clear_mem_working_set() {
  _impl_.mem_working_set_ = int64_t{0};
}
inline int64_t Process::_internal_mem_working_set() const {
  return _impl_.mem_working_set_;
}
inline int64_t Process::mem_working_set() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.mem_working_set)
  return _internal_mem_working_set();
}
inline void Process::_internal_set_mem_working_set(int64_t value) {
  
  _impl_.mem_working_set_ = value;
}
inline void Process::set_mem_working_set(int64_t value) {
  _internal_set_mem_working_set(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.mem_working_set)
}

// int64 mem_peak_working_set = 8;
inline void Process::clear_mem_peak_working_set() {
  _impl_.mem_peak_working_set_ = int64_t{0};
}
inline int64_t Process::_internal_mem_peak_working_set() const {
  return _impl_.mem_peak_working_set_;
}
inline int64_t Process::mem_peak_working_set() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.mem_peak_working_set)
  return _internal_mem_peak_working_set();
}
inline void Process::_internal_set_mem_peak_working_set(int64_t value) {
  
  _impl_.mem_peak_working_set_ = value;
}
inline void Process::set_mem_peak_working_set(int64_t value) {
  _internal_set_mem_peak_working_set(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.mem_peak_working_set)
}

// int64 mem_working_set_delta = 9;
inline void Process::clear_mem_working_set_delta() {
  _impl_.mem_working_set_delta_ = int64_t{0};
}
inline int64_t Process::_internal_mem_working_set_delta() const {
  return _impl_.mem_working_set_delta_;
}
inline int64_t Process::mem_working_set_delta() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.mem_working_set_delta)
  return _internal_mem_working_set_delta();
}
inline void Process::_internal_set_mem_working_set_delta(int64_t value) {
  
  _impl_.mem_working_set_delta_ = value;
}
inline void Process::set_mem_working_set_delta(int64_t value) {
  _internal_set_mem_working_set_delta(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.mem_working_set_delta)
}

// int64 mem_private_working_set = 10;
inline void Process::clear_mem_private_working_set() {
  _impl_.mem_private_working_set_ = int64_t{0};
}
inline int64_t Process::_internal_mem_private_working_set() const {
  return _impl_.mem_private_working_set_;
}
inline int64_t Process::mem_private_working_set() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.mem_private_working_set)
  return _internal_mem_private_working_set();
}
inline void Process::_internal_set_mem_private_working_set(int64_t value) {
  
  _impl_.mem_private_working_set_ = value;
}
inline void Process::set_mem_private_working_set(int64_t value) {
  _internal_set_mem_private_working_set(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.mem_private_working_set)
}

// uint32 thread_count = 11;
inline void Process::clear_thread_count() {
  _impl_.thread_count_ = 0u;
}
inline uint32_t Process::_internal_thread_count() const {
  return _impl_.thread_count_;
}
inline uint32_t Process::thread_count() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Process.thread_count)
  return _internal_thread_count();
}
inline void Process::_internal_set_thread_count(uint32_t value) {
  
  _impl_.thread_count_ = value;
}
inline void Process::set_thread_count(uint32_t value) {
  _internal_set_thread_count(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Process.thread_count)
}

// -------------------------------------------------------------------

// ProcessList

// repeated .proto.task_manager.Process process = 1;
inline int ProcessList::_internal_process_size() const {
  return _impl_.process_.size();
}
inline int ProcessList::process_size() const {
  return _internal_process_size();
}
inline void ProcessList::clear_process() {
  _impl_.process_.Clear();
}
inline ::proto::task_manager::Process* ProcessList::mutable_process(int index) {
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ProcessList.process)
  return _impl_.process_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Process >*
ProcessList::mutable_process() {
  // @@protoc_insertion_point(field_mutable_list:proto.task_manager.ProcessList.process)
  return &_impl_.process_;
}
inline const ::proto::task_manager::Process& ProcessList::_internal_process(int index) const {
  return _impl_.process_.Get(index);
}
inline const ::proto::task_manager::Process& ProcessList::process(int index) const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ProcessList.process)
  return _internal_process(index);
}
inline ::proto::task_manager::Process* ProcessList::_internal_add_process() {
  return _impl_.process_.Add();
}
inline ::proto::task_manager::Process* ProcessList::add_process() {
  ::proto::task_manager::Process* _add = _internal_add_process();
  // @@protoc_insertion_point(field_add:proto.task_manager.ProcessList.process)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Process >&
ProcessList::process() const {
  // @@protoc_insertion_point(field_list:proto.task_manager.ProcessList.process)
  return _impl_.process_;
}

// int32 cpu_usage = 2;
inline void ProcessList::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline int32_t ProcessList::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline int32_t ProcessList::cpu_usage() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ProcessList.cpu_usage)
  return _internal_cpu_usage();
}
inline void ProcessList::_internal_set_cpu_usage(int32_t value) {
  
  _impl_.cpu_usage_ = value;
}
inline void ProcessList::set_cpu_usage(int32_t value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.ProcessList.cpu_usage)
}

// int32 memory_usage = 3;
inline void ProcessList::clear_memory_usage() {
  _impl_.memory_usage_ = 0;
}
inline int32_t ProcessList::_internal_memory_usage() const {
  return _impl_.memory_usage_;
}
inline int32_t ProcessList::memory_usage() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ProcessList.memory_usage)
  return _internal_memory_usage();
}
inline void ProcessList::_internal_set_memory_usage(int32_t value) {
  
  _impl_.memory_usage_ = value;
}
inline void ProcessList::set_memory_usage(int32_t value) {
  _internal_set_memory_usage(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.ProcessList.memory_usage)
}

// -------------------------------------------------------------------

// ProcessListRequest

// uint32 flags = 1;
inline void ProcessListRequest::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t ProcessListRequest::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t ProcessListRequest::flags() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ProcessListRequest.flags)
  return _internal_flags();
}
inline void ProcessListRequest::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void ProcessListRequest::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.ProcessListRequest.flags)
}

// -------------------------------------------------------------------

// EndProcessRequest

// uint64 pid = 1;
inline void EndProcessRequest::clear_pid() {
  _impl_.pid_ = uint64_t{0u};
}
inline uint64_t EndProcessRequest::_internal_pid() const {
  return _impl_.pid_;
}
inline uint64_t EndProcessRequest::pid() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.EndProcessRequest.pid)
  return _internal_pid();
}
inline void EndProcessRequest::_internal_set_pid(uint64_t value) {
  
  _impl_.pid_ = value;
}
inline void EndProcessRequest::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.EndProcessRequest.pid)
}

// -------------------------------------------------------------------

// Service

// string name = 1;
inline void Service::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Service::name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Service.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.Service.name)
}
inline std::string* Service::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.Service.name)
  return _s;
}
inline const std::string& Service::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Service::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service::release_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.Service.name)
  return _impl_.name_.Release();
}
inline void Service::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.Service.name)
}

// string display_name = 2;
inline void Service::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Service::display_name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Service.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.Service.display_name)
}
inline std::string* Service::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.Service.display_name)
  return _s;
}
inline const std::string& Service::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Service::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service::release_display_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.Service.display_name)
  return _impl_.display_name_.Release();
}
inline void Service::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.Service.display_name)
}

// string description = 3;
inline void Service::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Service::description() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Service.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.Service.description)
}
inline std::string* Service::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.Service.description)
  return _s;
}
inline const std::string& Service::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Service::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Service::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Service::release_description() {
  // @@protoc_insertion_point(field_release:proto.task_manager.Service.description)
  return _impl_.description_.Release();
}
inline void Service::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.Service.description)
}

// .proto.task_manager.Service.Status status = 4;
inline void Service::clear_status() {
  _impl_.status_ = 0;
}
inline ::proto::task_manager::Service_Status Service::_internal_status() const {
  return static_cast< ::proto::task_manager::Service_Status >(_impl_.status_);
}
inline ::proto::task_manager::Service_Status Service::status() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Service.status)
  return _internal_status();
}
inline void Service::_internal_set_status(::proto::task_manager::Service_Status value) {
  
  _impl_.status_ = value;
}
inline void Service::set_status(::proto::task_manager::Service_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Service.status)
}

// .proto.task_manager.Service.StartupType startup_type = 5;
inline void Service::clear_startup_type() {
  _impl_.startup_type_ = 0;
}
inline ::proto::task_manager::Service_StartupType Service::_internal_startup_type() const {
  return static_cast< ::proto::task_manager::Service_StartupType >(_impl_.startup_type_);
}
inline ::proto::task_manager::Service_StartupType Service::startup_type() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.Service.startup_type)
  return _internal_startup_type();
}
inline void Service::_internal_set_startup_type(::proto::task_manager::Service_StartupType value) {
  
  _impl_.startup_type_ = value;
}
inline void Service::set_startup_type(::proto::task_manager::Service_StartupType value) {
  _internal_set_startup_type(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.Service.startup_type)
}

// -------------------------------------------------------------------

// ServiceList

// repeated .proto.task_manager.Service service = 1;
inline int ServiceList::_internal_service_size() const {
  return _impl_.service_.size();
}
inline int ServiceList::service_size() const {
  return _internal_service_size();
}
inline void ServiceList::clear_service() {
  _impl_.service_.Clear();
}
inline ::proto::task_manager::Service* ServiceList::mutable_service(int index) {
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ServiceList.service)
  return _impl_.service_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Service >*
ServiceList::mutable_service() {
  // @@protoc_insertion_point(field_mutable_list:proto.task_manager.ServiceList.service)
  return &_impl_.service_;
}
inline const ::proto::task_manager::Service& ServiceList::_internal_service(int index) const {
  return _impl_.service_.Get(index);
}
inline const ::proto::task_manager::Service& ServiceList::service(int index) const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ServiceList.service)
  return _internal_service(index);
}
inline ::proto::task_manager::Service* ServiceList::_internal_add_service() {
  return _impl_.service_.Add();
}
inline ::proto::task_manager::Service* ServiceList::add_service() {
  ::proto::task_manager::Service* _add = _internal_add_service();
  // @@protoc_insertion_point(field_add:proto.task_manager.ServiceList.service)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::Service >&
ServiceList::service() const {
  // @@protoc_insertion_point(field_list:proto.task_manager.ServiceList.service)
  return _impl_.service_;
}

// -------------------------------------------------------------------

// ServiceListRequest

// uint32 dummy = 1;
inline void ServiceListRequest::clear_dummy() {
  _impl_.dummy_ = 0u;
}
inline uint32_t ServiceListRequest::_internal_dummy() const {
  return _impl_.dummy_;
}
inline uint32_t ServiceListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ServiceListRequest.dummy)
  return _internal_dummy();
}
inline void ServiceListRequest::_internal_set_dummy(uint32_t value) {
  
  _impl_.dummy_ = value;
}
inline void ServiceListRequest::set_dummy(uint32_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.ServiceListRequest.dummy)
}

// -------------------------------------------------------------------

// ServiceRequest

// string name = 1;
inline void ServiceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServiceRequest::name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ServiceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.ServiceRequest.name)
}
inline std::string* ServiceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ServiceRequest.name)
  return _s;
}
inline const std::string& ServiceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ServiceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRequest::release_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ServiceRequest.name)
  return _impl_.name_.Release();
}
inline void ServiceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ServiceRequest.name)
}

// .proto.task_manager.ServiceRequest.Command command = 2;
inline void ServiceRequest::clear_command() {
  _impl_.command_ = 0;
}
inline ::proto::task_manager::ServiceRequest_Command ServiceRequest::_internal_command() const {
  return static_cast< ::proto::task_manager::ServiceRequest_Command >(_impl_.command_);
}
inline ::proto::task_manager::ServiceRequest_Command ServiceRequest::command() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ServiceRequest.command)
  return _internal_command();
}
inline void ServiceRequest::_internal_set_command(::proto::task_manager::ServiceRequest_Command value) {
  
  _impl_.command_ = value;
}
inline void ServiceRequest::set_command(::proto::task_manager::ServiceRequest_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.ServiceRequest.command)
}

// -------------------------------------------------------------------

// User

// string user_name = 1;
inline void User::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& User::user_name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.User.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.User.user_name)
}
inline std::string* User::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.User.user_name)
  return _s;
}
inline const std::string& User::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void User::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.User.user_name)
  return _impl_.user_name_.Release();
}
inline void User::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.User.user_name)
}

// uint32 session_id = 2;
inline void User::clear_session_id() {
  _impl_.session_id_ = 0u;
}
inline uint32_t User::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t User::session_id() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.User.session_id)
  return _internal_session_id();
}
inline void User::_internal_set_session_id(uint32_t value) {
  
  _impl_.session_id_ = value;
}
inline void User::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.User.session_id)
}

// string client_name = 3;
inline void User::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
}
inline const std::string& User::client_name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.User.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_client_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.User.client_name)
}
inline std::string* User::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.User.client_name)
  return _s;
}
inline const std::string& User::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void User::_internal_set_client_name(const std::string& value) {
  
  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_client_name() {
  
  return _impl_.client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_client_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.User.client_name)
  return _impl_.client_name_.Release();
}
inline void User::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  _impl_.client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_name_.IsDefault()) {
    _impl_.client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.User.client_name)
}

// string session_name = 4;
inline void User::clear_session_name() {
  _impl_.session_name_.ClearToEmpty();
}
inline const std::string& User::session_name() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.User.session_name)
  return _internal_session_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_session_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.task_manager.User.session_name)
}
inline std::string* User::mutable_session_name() {
  std::string* _s = _internal_mutable_session_name();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.User.session_name)
  return _s;
}
inline const std::string& User::_internal_session_name() const {
  return _impl_.session_name_.Get();
}
inline void User::_internal_set_session_name(const std::string& value) {
  
  _impl_.session_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_session_name() {
  
  return _impl_.session_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_session_name() {
  // @@protoc_insertion_point(field_release:proto.task_manager.User.session_name)
  return _impl_.session_name_.Release();
}
inline void User::set_allocated_session_name(std::string* session_name) {
  if (session_name != nullptr) {
    
  } else {
    
  }
  _impl_.session_name_.SetAllocated(session_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_name_.IsDefault()) {
    _impl_.session_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.User.session_name)
}

// .proto.task_manager.User.ConnectState connect_state = 5;
inline void User::clear_connect_state() {
  _impl_.connect_state_ = 0;
}
inline ::proto::task_manager::User_ConnectState User::_internal_connect_state() const {
  return static_cast< ::proto::task_manager::User_ConnectState >(_impl_.connect_state_);
}
inline ::proto::task_manager::User_ConnectState User::connect_state() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.User.connect_state)
  return _internal_connect_state();
}
inline void User::_internal_set_connect_state(::proto::task_manager::User_ConnectState value) {
  
  _impl_.connect_state_ = value;
}
inline void User::set_connect_state(::proto::task_manager::User_ConnectState value) {
  _internal_set_connect_state(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.User.connect_state)
}

// -------------------------------------------------------------------

// UserList

// repeated .proto.task_manager.User user = 1;
inline int UserList::_internal_user_size() const {
  return _impl_.user_.size();
}
inline int UserList::user_size() const {
  return _internal_user_size();
}
inline void UserList::clear_user() {
  _impl_.user_.Clear();
}
inline ::proto::task_manager::User* UserList::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:proto.task_manager.UserList.user)
  return _impl_.user_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::User >*
UserList::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:proto.task_manager.UserList.user)
  return &_impl_.user_;
}
inline const ::proto::task_manager::User& UserList::_internal_user(int index) const {
  return _impl_.user_.Get(index);
}
inline const ::proto::task_manager::User& UserList::user(int index) const {
  // @@protoc_insertion_point(field_get:proto.task_manager.UserList.user)
  return _internal_user(index);
}
inline ::proto::task_manager::User* UserList::_internal_add_user() {
  return _impl_.user_.Add();
}
inline ::proto::task_manager::User* UserList::add_user() {
  ::proto::task_manager::User* _add = _internal_add_user();
  // @@protoc_insertion_point(field_add:proto.task_manager.UserList.user)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::task_manager::User >&
UserList::user() const {
  // @@protoc_insertion_point(field_list:proto.task_manager.UserList.user)
  return _impl_.user_;
}

// -------------------------------------------------------------------

// UserListRequest

// uint32 dummy = 1;
inline void UserListRequest::clear_dummy() {
  _impl_.dummy_ = 0u;
}
inline uint32_t UserListRequest::_internal_dummy() const {
  return _impl_.dummy_;
}
inline uint32_t UserListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.UserListRequest.dummy)
  return _internal_dummy();
}
inline void UserListRequest::_internal_set_dummy(uint32_t value) {
  
  _impl_.dummy_ = value;
}
inline void UserListRequest::set_dummy(uint32_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.UserListRequest.dummy)
}

// -------------------------------------------------------------------

// UserRequest

// uint32 session_id = 1;
inline void UserRequest::clear_session_id() {
  _impl_.session_id_ = 0u;
}
inline uint32_t UserRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t UserRequest::session_id() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.UserRequest.session_id)
  return _internal_session_id();
}
inline void UserRequest::_internal_set_session_id(uint32_t value) {
  
  _impl_.session_id_ = value;
}
inline void UserRequest::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.UserRequest.session_id)
}

// .proto.task_manager.UserRequest.Command command = 2;
inline void UserRequest::clear_command() {
  _impl_.command_ = 0;
}
inline ::proto::task_manager::UserRequest_Command UserRequest::_internal_command() const {
  return static_cast< ::proto::task_manager::UserRequest_Command >(_impl_.command_);
}
inline ::proto::task_manager::UserRequest_Command UserRequest::command() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.UserRequest.command)
  return _internal_command();
}
inline void UserRequest::_internal_set_command(::proto::task_manager::UserRequest_Command value) {
  
  _impl_.command_ = value;
}
inline void UserRequest::set_command(::proto::task_manager::UserRequest_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:proto.task_manager.UserRequest.command)
}

// -------------------------------------------------------------------

// ClientToHost

// .proto.task_manager.ProcessListRequest process_list_request = 1;
inline bool ClientToHost::_internal_has_process_list_request() const {
  return this != internal_default_instance() && _impl_.process_list_request_ != nullptr;
}
inline bool ClientToHost::has_process_list_request() const {
  return _internal_has_process_list_request();
}
inline void ClientToHost::clear_process_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.process_list_request_ != nullptr) {
    delete _impl_.process_list_request_;
  }
  _impl_.process_list_request_ = nullptr;
}
inline const ::proto::task_manager::ProcessListRequest& ClientToHost::_internal_process_list_request() const {
  const ::proto::task_manager::ProcessListRequest* p = _impl_.process_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::ProcessListRequest&>(
      ::proto::task_manager::_ProcessListRequest_default_instance_);
}
inline const ::proto::task_manager::ProcessListRequest& ClientToHost::process_list_request() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ClientToHost.process_list_request)
  return _internal_process_list_request();
}
inline void ClientToHost::unsafe_arena_set_allocated_process_list_request(
    ::proto::task_manager::ProcessListRequest* process_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.process_list_request_);
  }
  _impl_.process_list_request_ = process_list_request;
  if (process_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.ClientToHost.process_list_request)
}
inline ::proto::task_manager::ProcessListRequest* ClientToHost::release_process_list_request() {
  
  ::proto::task_manager::ProcessListRequest* temp = _impl_.process_list_request_;
  _impl_.process_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::ProcessListRequest* ClientToHost::unsafe_arena_release_process_list_request() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ClientToHost.process_list_request)
  
  ::proto::task_manager::ProcessListRequest* temp = _impl_.process_list_request_;
  _impl_.process_list_request_ = nullptr;
  return temp;
}
inline ::proto::task_manager::ProcessListRequest* ClientToHost::_internal_mutable_process_list_request() {
  
  if (_impl_.process_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::ProcessListRequest>(GetArenaForAllocation());
    _impl_.process_list_request_ = p;
  }
  return _impl_.process_list_request_;
}
inline ::proto::task_manager::ProcessListRequest* ClientToHost::mutable_process_list_request() {
  ::proto::task_manager::ProcessListRequest* _msg = _internal_mutable_process_list_request();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ClientToHost.process_list_request)
  return _msg;
}
inline void ClientToHost::set_allocated_process_list_request(::proto::task_manager::ProcessListRequest* process_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.process_list_request_;
  }
  if (process_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(process_list_request);
    if (message_arena != submessage_arena) {
      process_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.process_list_request_ = process_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ClientToHost.process_list_request)
}

// .proto.task_manager.EndProcessRequest end_process_request = 2;
inline bool ClientToHost::_internal_has_end_process_request() const {
  return this != internal_default_instance() && _impl_.end_process_request_ != nullptr;
}
inline bool ClientToHost::has_end_process_request() const {
  return _internal_has_end_process_request();
}
inline void ClientToHost::clear_end_process_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_process_request_ != nullptr) {
    delete _impl_.end_process_request_;
  }
  _impl_.end_process_request_ = nullptr;
}
inline const ::proto::task_manager::EndProcessRequest& ClientToHost::_internal_end_process_request() const {
  const ::proto::task_manager::EndProcessRequest* p = _impl_.end_process_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::EndProcessRequest&>(
      ::proto::task_manager::_EndProcessRequest_default_instance_);
}
inline const ::proto::task_manager::EndProcessRequest& ClientToHost::end_process_request() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ClientToHost.end_process_request)
  return _internal_end_process_request();
}
inline void ClientToHost::unsafe_arena_set_allocated_end_process_request(
    ::proto::task_manager::EndProcessRequest* end_process_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_process_request_);
  }
  _impl_.end_process_request_ = end_process_request;
  if (end_process_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.ClientToHost.end_process_request)
}
inline ::proto::task_manager::EndProcessRequest* ClientToHost::release_end_process_request() {
  
  ::proto::task_manager::EndProcessRequest* temp = _impl_.end_process_request_;
  _impl_.end_process_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::EndProcessRequest* ClientToHost::unsafe_arena_release_end_process_request() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ClientToHost.end_process_request)
  
  ::proto::task_manager::EndProcessRequest* temp = _impl_.end_process_request_;
  _impl_.end_process_request_ = nullptr;
  return temp;
}
inline ::proto::task_manager::EndProcessRequest* ClientToHost::_internal_mutable_end_process_request() {
  
  if (_impl_.end_process_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::EndProcessRequest>(GetArenaForAllocation());
    _impl_.end_process_request_ = p;
  }
  return _impl_.end_process_request_;
}
inline ::proto::task_manager::EndProcessRequest* ClientToHost::mutable_end_process_request() {
  ::proto::task_manager::EndProcessRequest* _msg = _internal_mutable_end_process_request();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ClientToHost.end_process_request)
  return _msg;
}
inline void ClientToHost::set_allocated_end_process_request(::proto::task_manager::EndProcessRequest* end_process_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_process_request_;
  }
  if (end_process_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end_process_request);
    if (message_arena != submessage_arena) {
      end_process_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_process_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_process_request_ = end_process_request;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ClientToHost.end_process_request)
}

// .proto.task_manager.ServiceListRequest service_list_request = 3;
inline bool ClientToHost::_internal_has_service_list_request() const {
  return this != internal_default_instance() && _impl_.service_list_request_ != nullptr;
}
inline bool ClientToHost::has_service_list_request() const {
  return _internal_has_service_list_request();
}
inline void ClientToHost::clear_service_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_list_request_ != nullptr) {
    delete _impl_.service_list_request_;
  }
  _impl_.service_list_request_ = nullptr;
}
inline const ::proto::task_manager::ServiceListRequest& ClientToHost::_internal_service_list_request() const {
  const ::proto::task_manager::ServiceListRequest* p = _impl_.service_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::ServiceListRequest&>(
      ::proto::task_manager::_ServiceListRequest_default_instance_);
}
inline const ::proto::task_manager::ServiceListRequest& ClientToHost::service_list_request() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ClientToHost.service_list_request)
  return _internal_service_list_request();
}
inline void ClientToHost::unsafe_arena_set_allocated_service_list_request(
    ::proto::task_manager::ServiceListRequest* service_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_list_request_);
  }
  _impl_.service_list_request_ = service_list_request;
  if (service_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.ClientToHost.service_list_request)
}
inline ::proto::task_manager::ServiceListRequest* ClientToHost::release_service_list_request() {
  
  ::proto::task_manager::ServiceListRequest* temp = _impl_.service_list_request_;
  _impl_.service_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::ServiceListRequest* ClientToHost::unsafe_arena_release_service_list_request() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ClientToHost.service_list_request)
  
  ::proto::task_manager::ServiceListRequest* temp = _impl_.service_list_request_;
  _impl_.service_list_request_ = nullptr;
  return temp;
}
inline ::proto::task_manager::ServiceListRequest* ClientToHost::_internal_mutable_service_list_request() {
  
  if (_impl_.service_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::ServiceListRequest>(GetArenaForAllocation());
    _impl_.service_list_request_ = p;
  }
  return _impl_.service_list_request_;
}
inline ::proto::task_manager::ServiceListRequest* ClientToHost::mutable_service_list_request() {
  ::proto::task_manager::ServiceListRequest* _msg = _internal_mutable_service_list_request();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ClientToHost.service_list_request)
  return _msg;
}
inline void ClientToHost::set_allocated_service_list_request(::proto::task_manager::ServiceListRequest* service_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_list_request_;
  }
  if (service_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_list_request);
    if (message_arena != submessage_arena) {
      service_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_list_request_ = service_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ClientToHost.service_list_request)
}

// .proto.task_manager.ServiceRequest service_request = 4;
inline bool ClientToHost::_internal_has_service_request() const {
  return this != internal_default_instance() && _impl_.service_request_ != nullptr;
}
inline bool ClientToHost::has_service_request() const {
  return _internal_has_service_request();
}
inline void ClientToHost::clear_service_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_request_ != nullptr) {
    delete _impl_.service_request_;
  }
  _impl_.service_request_ = nullptr;
}
inline const ::proto::task_manager::ServiceRequest& ClientToHost::_internal_service_request() const {
  const ::proto::task_manager::ServiceRequest* p = _impl_.service_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::ServiceRequest&>(
      ::proto::task_manager::_ServiceRequest_default_instance_);
}
inline const ::proto::task_manager::ServiceRequest& ClientToHost::service_request() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ClientToHost.service_request)
  return _internal_service_request();
}
inline void ClientToHost::unsafe_arena_set_allocated_service_request(
    ::proto::task_manager::ServiceRequest* service_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_request_);
  }
  _impl_.service_request_ = service_request;
  if (service_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.ClientToHost.service_request)
}
inline ::proto::task_manager::ServiceRequest* ClientToHost::release_service_request() {
  
  ::proto::task_manager::ServiceRequest* temp = _impl_.service_request_;
  _impl_.service_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::ServiceRequest* ClientToHost::unsafe_arena_release_service_request() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ClientToHost.service_request)
  
  ::proto::task_manager::ServiceRequest* temp = _impl_.service_request_;
  _impl_.service_request_ = nullptr;
  return temp;
}
inline ::proto::task_manager::ServiceRequest* ClientToHost::_internal_mutable_service_request() {
  
  if (_impl_.service_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::ServiceRequest>(GetArenaForAllocation());
    _impl_.service_request_ = p;
  }
  return _impl_.service_request_;
}
inline ::proto::task_manager::ServiceRequest* ClientToHost::mutable_service_request() {
  ::proto::task_manager::ServiceRequest* _msg = _internal_mutable_service_request();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ClientToHost.service_request)
  return _msg;
}
inline void ClientToHost::set_allocated_service_request(::proto::task_manager::ServiceRequest* service_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_request_;
  }
  if (service_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_request);
    if (message_arena != submessage_arena) {
      service_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_request_ = service_request;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ClientToHost.service_request)
}

// .proto.task_manager.UserListRequest user_list_request = 5;
inline bool ClientToHost::_internal_has_user_list_request() const {
  return this != internal_default_instance() && _impl_.user_list_request_ != nullptr;
}
inline bool ClientToHost::has_user_list_request() const {
  return _internal_has_user_list_request();
}
inline void ClientToHost::clear_user_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_list_request_ != nullptr) {
    delete _impl_.user_list_request_;
  }
  _impl_.user_list_request_ = nullptr;
}
inline const ::proto::task_manager::UserListRequest& ClientToHost::_internal_user_list_request() const {
  const ::proto::task_manager::UserListRequest* p = _impl_.user_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::UserListRequest&>(
      ::proto::task_manager::_UserListRequest_default_instance_);
}
inline const ::proto::task_manager::UserListRequest& ClientToHost::user_list_request() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ClientToHost.user_list_request)
  return _internal_user_list_request();
}
inline void ClientToHost::unsafe_arena_set_allocated_user_list_request(
    ::proto::task_manager::UserListRequest* user_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_list_request_);
  }
  _impl_.user_list_request_ = user_list_request;
  if (user_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.ClientToHost.user_list_request)
}
inline ::proto::task_manager::UserListRequest* ClientToHost::release_user_list_request() {
  
  ::proto::task_manager::UserListRequest* temp = _impl_.user_list_request_;
  _impl_.user_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::UserListRequest* ClientToHost::unsafe_arena_release_user_list_request() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ClientToHost.user_list_request)
  
  ::proto::task_manager::UserListRequest* temp = _impl_.user_list_request_;
  _impl_.user_list_request_ = nullptr;
  return temp;
}
inline ::proto::task_manager::UserListRequest* ClientToHost::_internal_mutable_user_list_request() {
  
  if (_impl_.user_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::UserListRequest>(GetArenaForAllocation());
    _impl_.user_list_request_ = p;
  }
  return _impl_.user_list_request_;
}
inline ::proto::task_manager::UserListRequest* ClientToHost::mutable_user_list_request() {
  ::proto::task_manager::UserListRequest* _msg = _internal_mutable_user_list_request();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ClientToHost.user_list_request)
  return _msg;
}
inline void ClientToHost::set_allocated_user_list_request(::proto::task_manager::UserListRequest* user_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_list_request_;
  }
  if (user_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_list_request);
    if (message_arena != submessage_arena) {
      user_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_list_request_ = user_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ClientToHost.user_list_request)
}

// .proto.task_manager.UserRequest user_request = 6;
inline bool ClientToHost::_internal_has_user_request() const {
  return this != internal_default_instance() && _impl_.user_request_ != nullptr;
}
inline bool ClientToHost::has_user_request() const {
  return _internal_has_user_request();
}
inline void ClientToHost::clear_user_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_request_ != nullptr) {
    delete _impl_.user_request_;
  }
  _impl_.user_request_ = nullptr;
}
inline const ::proto::task_manager::UserRequest& ClientToHost::_internal_user_request() const {
  const ::proto::task_manager::UserRequest* p = _impl_.user_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::UserRequest&>(
      ::proto::task_manager::_UserRequest_default_instance_);
}
inline const ::proto::task_manager::UserRequest& ClientToHost::user_request() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.ClientToHost.user_request)
  return _internal_user_request();
}
inline void ClientToHost::unsafe_arena_set_allocated_user_request(
    ::proto::task_manager::UserRequest* user_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_request_);
  }
  _impl_.user_request_ = user_request;
  if (user_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.ClientToHost.user_request)
}
inline ::proto::task_manager::UserRequest* ClientToHost::release_user_request() {
  
  ::proto::task_manager::UserRequest* temp = _impl_.user_request_;
  _impl_.user_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::UserRequest* ClientToHost::unsafe_arena_release_user_request() {
  // @@protoc_insertion_point(field_release:proto.task_manager.ClientToHost.user_request)
  
  ::proto::task_manager::UserRequest* temp = _impl_.user_request_;
  _impl_.user_request_ = nullptr;
  return temp;
}
inline ::proto::task_manager::UserRequest* ClientToHost::_internal_mutable_user_request() {
  
  if (_impl_.user_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::UserRequest>(GetArenaForAllocation());
    _impl_.user_request_ = p;
  }
  return _impl_.user_request_;
}
inline ::proto::task_manager::UserRequest* ClientToHost::mutable_user_request() {
  ::proto::task_manager::UserRequest* _msg = _internal_mutable_user_request();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.ClientToHost.user_request)
  return _msg;
}
inline void ClientToHost::set_allocated_user_request(::proto::task_manager::UserRequest* user_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_request_;
  }
  if (user_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_request);
    if (message_arena != submessage_arena) {
      user_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_request_ = user_request;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.ClientToHost.user_request)
}

// -------------------------------------------------------------------

// HostToClient

// .proto.task_manager.ProcessList process_list = 1;
inline bool HostToClient::_internal_has_process_list() const {
  return this != internal_default_instance() && _impl_.process_list_ != nullptr;
}
inline bool HostToClient::has_process_list() const {
  return _internal_has_process_list();
}
inline void HostToClient::clear_process_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.process_list_ != nullptr) {
    delete _impl_.process_list_;
  }
  _impl_.process_list_ = nullptr;
}
inline const ::proto::task_manager::ProcessList& HostToClient::_internal_process_list() const {
  const ::proto::task_manager::ProcessList* p = _impl_.process_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::ProcessList&>(
      ::proto::task_manager::_ProcessList_default_instance_);
}
inline const ::proto::task_manager::ProcessList& HostToClient::process_list() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.HostToClient.process_list)
  return _internal_process_list();
}
inline void HostToClient::unsafe_arena_set_allocated_process_list(
    ::proto::task_manager::ProcessList* process_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.process_list_);
  }
  _impl_.process_list_ = process_list;
  if (process_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.HostToClient.process_list)
}
inline ::proto::task_manager::ProcessList* HostToClient::release_process_list() {
  
  ::proto::task_manager::ProcessList* temp = _impl_.process_list_;
  _impl_.process_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::ProcessList* HostToClient::unsafe_arena_release_process_list() {
  // @@protoc_insertion_point(field_release:proto.task_manager.HostToClient.process_list)
  
  ::proto::task_manager::ProcessList* temp = _impl_.process_list_;
  _impl_.process_list_ = nullptr;
  return temp;
}
inline ::proto::task_manager::ProcessList* HostToClient::_internal_mutable_process_list() {
  
  if (_impl_.process_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::ProcessList>(GetArenaForAllocation());
    _impl_.process_list_ = p;
  }
  return _impl_.process_list_;
}
inline ::proto::task_manager::ProcessList* HostToClient::mutable_process_list() {
  ::proto::task_manager::ProcessList* _msg = _internal_mutable_process_list();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.HostToClient.process_list)
  return _msg;
}
inline void HostToClient::set_allocated_process_list(::proto::task_manager::ProcessList* process_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.process_list_;
  }
  if (process_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(process_list);
    if (message_arena != submessage_arena) {
      process_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.process_list_ = process_list;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.HostToClient.process_list)
}

// .proto.task_manager.ServiceList service_list = 2;
inline bool HostToClient::_internal_has_service_list() const {
  return this != internal_default_instance() && _impl_.service_list_ != nullptr;
}
inline bool HostToClient::has_service_list() const {
  return _internal_has_service_list();
}
inline void HostToClient::clear_service_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_list_ != nullptr) {
    delete _impl_.service_list_;
  }
  _impl_.service_list_ = nullptr;
}
inline const ::proto::task_manager::ServiceList& HostToClient::_internal_service_list() const {
  const ::proto::task_manager::ServiceList* p = _impl_.service_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::ServiceList&>(
      ::proto::task_manager::_ServiceList_default_instance_);
}
inline const ::proto::task_manager::ServiceList& HostToClient::service_list() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.HostToClient.service_list)
  return _internal_service_list();
}
inline void HostToClient::unsafe_arena_set_allocated_service_list(
    ::proto::task_manager::ServiceList* service_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_list_);
  }
  _impl_.service_list_ = service_list;
  if (service_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.HostToClient.service_list)
}
inline ::proto::task_manager::ServiceList* HostToClient::release_service_list() {
  
  ::proto::task_manager::ServiceList* temp = _impl_.service_list_;
  _impl_.service_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::ServiceList* HostToClient::unsafe_arena_release_service_list() {
  // @@protoc_insertion_point(field_release:proto.task_manager.HostToClient.service_list)
  
  ::proto::task_manager::ServiceList* temp = _impl_.service_list_;
  _impl_.service_list_ = nullptr;
  return temp;
}
inline ::proto::task_manager::ServiceList* HostToClient::_internal_mutable_service_list() {
  
  if (_impl_.service_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::ServiceList>(GetArenaForAllocation());
    _impl_.service_list_ = p;
  }
  return _impl_.service_list_;
}
inline ::proto::task_manager::ServiceList* HostToClient::mutable_service_list() {
  ::proto::task_manager::ServiceList* _msg = _internal_mutable_service_list();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.HostToClient.service_list)
  return _msg;
}
inline void HostToClient::set_allocated_service_list(::proto::task_manager::ServiceList* service_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_list_;
  }
  if (service_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_list);
    if (message_arena != submessage_arena) {
      service_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_list_ = service_list;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.HostToClient.service_list)
}

// .proto.task_manager.UserList user_list = 3;
inline bool HostToClient::_internal_has_user_list() const {
  return this != internal_default_instance() && _impl_.user_list_ != nullptr;
}
inline bool HostToClient::has_user_list() const {
  return _internal_has_user_list();
}
inline void HostToClient::clear_user_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_list_ != nullptr) {
    delete _impl_.user_list_;
  }
  _impl_.user_list_ = nullptr;
}
inline const ::proto::task_manager::UserList& HostToClient::_internal_user_list() const {
  const ::proto::task_manager::UserList* p = _impl_.user_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::task_manager::UserList&>(
      ::proto::task_manager::_UserList_default_instance_);
}
inline const ::proto::task_manager::UserList& HostToClient::user_list() const {
  // @@protoc_insertion_point(field_get:proto.task_manager.HostToClient.user_list)
  return _internal_user_list();
}
inline void HostToClient::unsafe_arena_set_allocated_user_list(
    ::proto::task_manager::UserList* user_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_list_);
  }
  _impl_.user_list_ = user_list;
  if (user_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.task_manager.HostToClient.user_list)
}
inline ::proto::task_manager::UserList* HostToClient::release_user_list() {
  
  ::proto::task_manager::UserList* temp = _impl_.user_list_;
  _impl_.user_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::task_manager::UserList* HostToClient::unsafe_arena_release_user_list() {
  // @@protoc_insertion_point(field_release:proto.task_manager.HostToClient.user_list)
  
  ::proto::task_manager::UserList* temp = _impl_.user_list_;
  _impl_.user_list_ = nullptr;
  return temp;
}
inline ::proto::task_manager::UserList* HostToClient::_internal_mutable_user_list() {
  
  if (_impl_.user_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::task_manager::UserList>(GetArenaForAllocation());
    _impl_.user_list_ = p;
  }
  return _impl_.user_list_;
}
inline ::proto::task_manager::UserList* HostToClient::mutable_user_list() {
  ::proto::task_manager::UserList* _msg = _internal_mutable_user_list();
  // @@protoc_insertion_point(field_mutable:proto.task_manager.HostToClient.user_list)
  return _msg;
}
inline void HostToClient::set_allocated_user_list(::proto::task_manager::UserList* user_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_list_;
  }
  if (user_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_list);
    if (message_arena != submessage_arena) {
      user_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_list_ = user_list;
  // @@protoc_insertion_point(field_set_allocated:proto.task_manager.HostToClient.user_list)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace task_manager
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::task_manager::ProcessListRequest_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::task_manager::Service_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::task_manager::Service_StartupType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::task_manager::ServiceRequest_Command> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::task_manager::User_ConnectState> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::task_manager::UserRequest_Command> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_task_5fmanager_2eproto
