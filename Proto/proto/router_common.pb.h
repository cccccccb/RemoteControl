// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_5fcommon_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class PeerConnection;
struct PeerConnectionDefaultTypeInternal;
extern PeerConnectionDefaultTypeInternal _PeerConnection_default_instance_;
class PeerConnectionRequest;
struct PeerConnectionRequestDefaultTypeInternal;
extern PeerConnectionRequestDefaultTypeInternal _PeerConnectionRequest_default_instance_;
class RelayCredentials;
struct RelayCredentialsDefaultTypeInternal;
extern RelayCredentialsDefaultTypeInternal _RelayCredentials_default_instance_;
class RelayKey;
struct RelayKeyDefaultTypeInternal;
extern RelayKeyDefaultTypeInternal _RelayKey_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::PeerConnection* Arena::CreateMaybeMessage<::proto::PeerConnection>(Arena*);
template<> ::proto::PeerConnectionRequest* Arena::CreateMaybeMessage<::proto::PeerConnectionRequest>(Arena*);
template<> ::proto::RelayCredentials* Arena::CreateMaybeMessage<::proto::RelayCredentials>(Arena*);
template<> ::proto::RelayKey* Arena::CreateMaybeMessage<::proto::RelayKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum RelayKey_Type : int {
  RelayKey_Type_TYPE_UNKNOWN = 0,
  RelayKey_Type_TYPE_X25519 = 1,
  RelayKey_Type_RelayKey_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RelayKey_Type_RelayKey_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RelayKey_Type_IsValid(int value);
constexpr RelayKey_Type RelayKey_Type_Type_MIN = RelayKey_Type_TYPE_UNKNOWN;
constexpr RelayKey_Type RelayKey_Type_Type_MAX = RelayKey_Type_TYPE_X25519;
constexpr int RelayKey_Type_Type_ARRAYSIZE = RelayKey_Type_Type_MAX + 1;

const std::string& RelayKey_Type_Name(RelayKey_Type value);
template<typename T>
inline const std::string& RelayKey_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RelayKey_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RelayKey_Type_Name.");
  return RelayKey_Type_Name(static_cast<RelayKey_Type>(enum_t_value));
}
bool RelayKey_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RelayKey_Type* value);
enum RelayKey_Encryption : int {
  RelayKey_Encryption_ENCRYPTION_UNKNOWN = 0,
  RelayKey_Encryption_ENCRYPTION_CHACHA20_POLY1305 = 1,
  RelayKey_Encryption_RelayKey_Encryption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RelayKey_Encryption_RelayKey_Encryption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RelayKey_Encryption_IsValid(int value);
constexpr RelayKey_Encryption RelayKey_Encryption_Encryption_MIN = RelayKey_Encryption_ENCRYPTION_UNKNOWN;
constexpr RelayKey_Encryption RelayKey_Encryption_Encryption_MAX = RelayKey_Encryption_ENCRYPTION_CHACHA20_POLY1305;
constexpr int RelayKey_Encryption_Encryption_ARRAYSIZE = RelayKey_Encryption_Encryption_MAX + 1;

const std::string& RelayKey_Encryption_Name(RelayKey_Encryption value);
template<typename T>
inline const std::string& RelayKey_Encryption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RelayKey_Encryption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RelayKey_Encryption_Name.");
  return RelayKey_Encryption_Name(static_cast<RelayKey_Encryption>(enum_t_value));
}
bool RelayKey_Encryption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RelayKey_Encryption* value);
enum PeerConnection_PeerStatus : int {
  PeerConnection_PeerStatus_PEER_STATUS_UNKNOWN = 0,
  PeerConnection_PeerStatus_PEER_STATUS_ACTIVE = 1,
  PeerConnection_PeerStatus_PEER_STATUS_FINISHED = 2,
  PeerConnection_PeerStatus_PeerConnection_PeerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeerConnection_PeerStatus_PeerConnection_PeerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PeerConnection_PeerStatus_IsValid(int value);
constexpr PeerConnection_PeerStatus PeerConnection_PeerStatus_PeerStatus_MIN = PeerConnection_PeerStatus_PEER_STATUS_UNKNOWN;
constexpr PeerConnection_PeerStatus PeerConnection_PeerStatus_PeerStatus_MAX = PeerConnection_PeerStatus_PEER_STATUS_FINISHED;
constexpr int PeerConnection_PeerStatus_PeerStatus_ARRAYSIZE = PeerConnection_PeerStatus_PeerStatus_MAX + 1;

const std::string& PeerConnection_PeerStatus_Name(PeerConnection_PeerStatus value);
template<typename T>
inline const std::string& PeerConnection_PeerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerConnection_PeerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerConnection_PeerStatus_Name.");
  return PeerConnection_PeerStatus_Name(static_cast<PeerConnection_PeerStatus>(enum_t_value));
}
bool PeerConnection_PeerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerConnection_PeerStatus* value);
enum RouterChannelId : int {
  ROUTER_CHANNEL_ID_SESSION = 0,
  RouterChannelId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouterChannelId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouterChannelId_IsValid(int value);
constexpr RouterChannelId RouterChannelId_MIN = ROUTER_CHANNEL_ID_SESSION;
constexpr RouterChannelId RouterChannelId_MAX = ROUTER_CHANNEL_ID_SESSION;
constexpr int RouterChannelId_ARRAYSIZE = RouterChannelId_MAX + 1;

const std::string& RouterChannelId_Name(RouterChannelId value);
template<typename T>
inline const std::string& RouterChannelId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouterChannelId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouterChannelId_Name.");
  return RouterChannelId_Name(static_cast<RouterChannelId>(enum_t_value));
}
bool RouterChannelId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouterChannelId* value);
enum RouterSession : int {
  ROUTER_SESSION_UNKNOWN = 0,
  ROUTER_SESSION_ADMIN = 1,
  ROUTER_SESSION_CLIENT = 2,
  ROUTER_SESSION_HOST = 4,
  ROUTER_SESSION_RELAY = 8,
  RouterSession_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouterSession_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouterSession_IsValid(int value);
constexpr RouterSession RouterSession_MIN = ROUTER_SESSION_UNKNOWN;
constexpr RouterSession RouterSession_MAX = ROUTER_SESSION_RELAY;
constexpr int RouterSession_ARRAYSIZE = RouterSession_MAX + 1;

const std::string& RouterSession_Name(RouterSession value);
template<typename T>
inline const std::string& RouterSession_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouterSession>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouterSession_Name.");
  return RouterSession_Name(static_cast<RouterSession>(enum_t_value));
}
bool RouterSession_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouterSession* value);
enum PeerConnectionRequestType : int {
  PEER_CONNECTION_REQUEST_UNKNOWN = 0,
  PEER_CONNECTION_REQUEST_DISCONNECT = 1,
  PeerConnectionRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeerConnectionRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PeerConnectionRequestType_IsValid(int value);
constexpr PeerConnectionRequestType PeerConnectionRequestType_MIN = PEER_CONNECTION_REQUEST_UNKNOWN;
constexpr PeerConnectionRequestType PeerConnectionRequestType_MAX = PEER_CONNECTION_REQUEST_DISCONNECT;
constexpr int PeerConnectionRequestType_ARRAYSIZE = PeerConnectionRequestType_MAX + 1;

const std::string& PeerConnectionRequestType_Name(PeerConnectionRequestType value);
template<typename T>
inline const std::string& PeerConnectionRequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerConnectionRequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerConnectionRequestType_Name.");
  return PeerConnectionRequestType_Name(static_cast<PeerConnectionRequestType>(enum_t_value));
}
bool PeerConnectionRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerConnectionRequestType* value);
// ===================================================================

class RelayKey final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayKey) */ {
 public:
  inline RelayKey() : RelayKey(nullptr) {}
  ~RelayKey() override;
  explicit PROTOBUF_CONSTEXPR RelayKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayKey(const RelayKey& from);
  RelayKey(RelayKey&& from) noexcept
    : RelayKey() {
    *this = ::std::move(from);
  }

  inline RelayKey& operator=(const RelayKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayKey& operator=(RelayKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelayKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayKey* internal_default_instance() {
    return reinterpret_cast<const RelayKey*>(
               &_RelayKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RelayKey& a, RelayKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelayKey& from);
  void MergeFrom(const RelayKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelayKey";
  }
  protected:
  explicit RelayKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RelayKey_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    RelayKey_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_X25519 =
    RelayKey_Type_TYPE_X25519;
  static inline bool Type_IsValid(int value) {
    return RelayKey_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RelayKey_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RelayKey_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RelayKey_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RelayKey_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return RelayKey_Type_Parse(name, value);
  }

  typedef RelayKey_Encryption Encryption;
  static constexpr Encryption ENCRYPTION_UNKNOWN =
    RelayKey_Encryption_ENCRYPTION_UNKNOWN;
  static constexpr Encryption ENCRYPTION_CHACHA20_POLY1305 =
    RelayKey_Encryption_ENCRYPTION_CHACHA20_POLY1305;
  static inline bool Encryption_IsValid(int value) {
    return RelayKey_Encryption_IsValid(value);
  }
  static constexpr Encryption Encryption_MIN =
    RelayKey_Encryption_Encryption_MIN;
  static constexpr Encryption Encryption_MAX =
    RelayKey_Encryption_Encryption_MAX;
  static constexpr int Encryption_ARRAYSIZE =
    RelayKey_Encryption_Encryption_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Encryption_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Encryption>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Encryption_Name.");
    return RelayKey_Encryption_Name(enum_t_value);
  }
  static inline bool Encryption_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Encryption* value) {
    return RelayKey_Encryption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 4,
    kIvFieldNumber = 5,
    kKeyIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kEncryptionFieldNumber = 3,
  };
  // bytes public_key = 4;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes iv = 5;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // uint32 key_id = 1;
  void clear_key_id();
  uint32_t key_id() const;
  void set_key_id(uint32_t value);
  private:
  uint32_t _internal_key_id() const;
  void _internal_set_key_id(uint32_t value);
  public:

  // .proto.RelayKey.Type type = 2;
  void clear_type();
  ::proto::RelayKey_Type type() const;
  void set_type(::proto::RelayKey_Type value);
  private:
  ::proto::RelayKey_Type _internal_type() const;
  void _internal_set_type(::proto::RelayKey_Type value);
  public:

  // .proto.RelayKey.Encryption encryption = 3;
  void clear_encryption();
  ::proto::RelayKey_Encryption encryption() const;
  void set_encryption(::proto::RelayKey_Encryption value);
  private:
  ::proto::RelayKey_Encryption _internal_encryption() const;
  void _internal_set_encryption(::proto::RelayKey_Encryption value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelayKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    uint32_t key_id_;
    int type_;
    int encryption_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class RelayCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayCredentials) */ {
 public:
  inline RelayCredentials() : RelayCredentials(nullptr) {}
  ~RelayCredentials() override;
  explicit PROTOBUF_CONSTEXPR RelayCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayCredentials(const RelayCredentials& from);
  RelayCredentials(RelayCredentials&& from) noexcept
    : RelayCredentials() {
    *this = ::std::move(from);
  }

  inline RelayCredentials& operator=(const RelayCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayCredentials& operator=(RelayCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelayCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayCredentials* internal_default_instance() {
    return reinterpret_cast<const RelayCredentials*>(
               &_RelayCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RelayCredentials& a, RelayCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayCredentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelayCredentials& from);
  void MergeFrom(const RelayCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelayCredentials";
  }
  protected:
  explicit RelayCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kSecretFieldNumber = 4,
    kKeyFieldNumber = 3,
    kPortFieldNumber = 2,
  };
  // string host = 1;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // bytes secret = 4;
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // .proto.RelayKey key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::RelayKey& key() const;
  PROTOBUF_NODISCARD ::proto::RelayKey* release_key();
  ::proto::RelayKey* mutable_key();
  void set_allocated_key(::proto::RelayKey* key);
  private:
  const ::proto::RelayKey& _internal_key() const;
  ::proto::RelayKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::RelayKey* key);
  ::proto::RelayKey* unsafe_arena_release_key();

  // uint32 port = 2;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelayCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::proto::RelayKey* key_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class PeerConnection final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.PeerConnection) */ {
 public:
  inline PeerConnection() : PeerConnection(nullptr) {}
  ~PeerConnection() override;
  explicit PROTOBUF_CONSTEXPR PeerConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerConnection(const PeerConnection& from);
  PeerConnection(PeerConnection&& from) noexcept
    : PeerConnection() {
    *this = ::std::move(from);
  }

  inline PeerConnection& operator=(const PeerConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerConnection& operator=(PeerConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PeerConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerConnection* internal_default_instance() {
    return reinterpret_cast<const PeerConnection*>(
               &_PeerConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PeerConnection& a, PeerConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerConnection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PeerConnection& from);
  void MergeFrom(const PeerConnection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PeerConnection";
  }
  protected:
  explicit PeerConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PeerConnection_PeerStatus PeerStatus;
  static constexpr PeerStatus PEER_STATUS_UNKNOWN =
    PeerConnection_PeerStatus_PEER_STATUS_UNKNOWN;
  static constexpr PeerStatus PEER_STATUS_ACTIVE =
    PeerConnection_PeerStatus_PEER_STATUS_ACTIVE;
  static constexpr PeerStatus PEER_STATUS_FINISHED =
    PeerConnection_PeerStatus_PEER_STATUS_FINISHED;
  static inline bool PeerStatus_IsValid(int value) {
    return PeerConnection_PeerStatus_IsValid(value);
  }
  static constexpr PeerStatus PeerStatus_MIN =
    PeerConnection_PeerStatus_PeerStatus_MIN;
  static constexpr PeerStatus PeerStatus_MAX =
    PeerConnection_PeerStatus_PeerStatus_MAX;
  static constexpr int PeerStatus_ARRAYSIZE =
    PeerConnection_PeerStatus_PeerStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PeerStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PeerStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PeerStatus_Name.");
    return PeerConnection_PeerStatus_Name(enum_t_value);
  }
  static inline bool PeerStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PeerStatus* value) {
    return PeerConnection_PeerStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientAddressFieldNumber = 3,
    kClientUserNameFieldNumber = 4,
    kHostAddressFieldNumber = 5,
    kSessionIdFieldNumber = 1,
    kHostIdFieldNumber = 6,
    kBytesTransferredFieldNumber = 7,
    kDurationFieldNumber = 8,
    kIdleTimeFieldNumber = 9,
    kStatusFieldNumber = 2,
  };
  // string client_address = 3;
  void clear_client_address();
  const std::string& client_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_address();
  PROTOBUF_NODISCARD std::string* release_client_address();
  void set_allocated_client_address(std::string* client_address);
  private:
  const std::string& _internal_client_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_address(const std::string& value);
  std::string* _internal_mutable_client_address();
  public:

  // string client_user_name = 4;
  void clear_client_user_name();
  const std::string& client_user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_user_name();
  PROTOBUF_NODISCARD std::string* release_client_user_name();
  void set_allocated_client_user_name(std::string* client_user_name);
  private:
  const std::string& _internal_client_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_user_name(const std::string& value);
  std::string* _internal_mutable_client_user_name();
  public:

  // string host_address = 5;
  void clear_host_address();
  const std::string& host_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_address();
  PROTOBUF_NODISCARD std::string* release_host_address();
  void set_allocated_host_address(std::string* host_address);
  private:
  const std::string& _internal_host_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_address(const std::string& value);
  std::string* _internal_mutable_host_address();
  public:

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 host_id = 6;
  void clear_host_id();
  uint64_t host_id() const;
  void set_host_id(uint64_t value);
  private:
  uint64_t _internal_host_id() const;
  void _internal_set_host_id(uint64_t value);
  public:

  // int64 bytes_transferred = 7;
  void clear_bytes_transferred();
  int64_t bytes_transferred() const;
  void set_bytes_transferred(int64_t value);
  private:
  int64_t _internal_bytes_transferred() const;
  void _internal_set_bytes_transferred(int64_t value);
  public:

  // int64 duration = 8;
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // int64 idle_time = 9;
  void clear_idle_time();
  int64_t idle_time() const;
  void set_idle_time(int64_t value);
  private:
  int64_t _internal_idle_time() const;
  void _internal_set_idle_time(int64_t value);
  public:

  // .proto.PeerConnection.PeerStatus status = 2;
  void clear_status();
  ::proto::PeerConnection_PeerStatus status() const;
  void set_status(::proto::PeerConnection_PeerStatus value);
  private:
  ::proto::PeerConnection_PeerStatus _internal_status() const;
  void _internal_set_status(::proto::PeerConnection_PeerStatus value);
  public:

  // @@protoc_insertion_point(class_scope:proto.PeerConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_address_;
    uint64_t session_id_;
    uint64_t host_id_;
    int64_t bytes_transferred_;
    int64_t duration_;
    int64_t idle_time_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class PeerConnectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.PeerConnectionRequest) */ {
 public:
  inline PeerConnectionRequest() : PeerConnectionRequest(nullptr) {}
  ~PeerConnectionRequest() override;
  explicit PROTOBUF_CONSTEXPR PeerConnectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerConnectionRequest(const PeerConnectionRequest& from);
  PeerConnectionRequest(PeerConnectionRequest&& from) noexcept
    : PeerConnectionRequest() {
    *this = ::std::move(from);
  }

  inline PeerConnectionRequest& operator=(const PeerConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerConnectionRequest& operator=(PeerConnectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PeerConnectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const PeerConnectionRequest*>(
               &_PeerConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PeerConnectionRequest& a, PeerConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerConnectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerConnectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerConnectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerConnectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PeerConnectionRequest& from);
  void MergeFrom(const PeerConnectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerConnectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PeerConnectionRequest";
  }
  protected:
  explicit PeerConnectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelaySessionIdFieldNumber = 1,
    kPeerSessionIdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // int64 relay_session_id = 1;
  void clear_relay_session_id();
  int64_t relay_session_id() const;
  void set_relay_session_id(int64_t value);
  private:
  int64_t _internal_relay_session_id() const;
  void _internal_set_relay_session_id(int64_t value);
  public:

  // uint64 peer_session_id = 3;
  void clear_peer_session_id();
  uint64_t peer_session_id() const;
  void set_peer_session_id(uint64_t value);
  private:
  uint64_t _internal_peer_session_id() const;
  void _internal_set_peer_session_id(uint64_t value);
  public:

  // .proto.PeerConnectionRequestType type = 2;
  void clear_type();
  ::proto::PeerConnectionRequestType type() const;
  void set_type(::proto::PeerConnectionRequestType value);
  private:
  ::proto::PeerConnectionRequestType _internal_type() const;
  void _internal_set_type(::proto::PeerConnectionRequestType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.PeerConnectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t relay_session_id_;
    uint64_t peer_session_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RelayKey

// uint32 key_id = 1;
inline void RelayKey::clear_key_id() {
  _impl_.key_id_ = 0u;
}
inline uint32_t RelayKey::_internal_key_id() const {
  return _impl_.key_id_;
}
inline uint32_t RelayKey::key_id() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.key_id)
  return _internal_key_id();
}
inline void RelayKey::_internal_set_key_id(uint32_t value) {
  
  _impl_.key_id_ = value;
}
inline void RelayKey::set_key_id(uint32_t value) {
  _internal_set_key_id(value);
  // @@protoc_insertion_point(field_set:proto.RelayKey.key_id)
}

// .proto.RelayKey.Type type = 2;
inline void RelayKey::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::RelayKey_Type RelayKey::_internal_type() const {
  return static_cast< ::proto::RelayKey_Type >(_impl_.type_);
}
inline ::proto::RelayKey_Type RelayKey::type() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.type)
  return _internal_type();
}
inline void RelayKey::_internal_set_type(::proto::RelayKey_Type value) {
  
  _impl_.type_ = value;
}
inline void RelayKey::set_type(::proto::RelayKey_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.RelayKey.type)
}

// .proto.RelayKey.Encryption encryption = 3;
inline void RelayKey::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::proto::RelayKey_Encryption RelayKey::_internal_encryption() const {
  return static_cast< ::proto::RelayKey_Encryption >(_impl_.encryption_);
}
inline ::proto::RelayKey_Encryption RelayKey::encryption() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.encryption)
  return _internal_encryption();
}
inline void RelayKey::_internal_set_encryption(::proto::RelayKey_Encryption value) {
  
  _impl_.encryption_ = value;
}
inline void RelayKey::set_encryption(::proto::RelayKey_Encryption value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:proto.RelayKey.encryption)
}

// bytes public_key = 4;
inline void RelayKey::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& RelayKey::public_key() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelayKey::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RelayKey.public_key)
}
inline std::string* RelayKey::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:proto.RelayKey.public_key)
  return _s;
}
inline const std::string& RelayKey::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void RelayKey::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RelayKey::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RelayKey::release_public_key() {
  // @@protoc_insertion_point(field_release:proto.RelayKey.public_key)
  return _impl_.public_key_.Release();
}
inline void RelayKey::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RelayKey.public_key)
}

// bytes iv = 5;
inline void RelayKey::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& RelayKey::iv() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelayKey::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RelayKey.iv)
}
inline std::string* RelayKey::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.RelayKey.iv)
  return _s;
}
inline const std::string& RelayKey::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void RelayKey::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* RelayKey::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* RelayKey::release_iv() {
  // @@protoc_insertion_point(field_release:proto.RelayKey.iv)
  return _impl_.iv_.Release();
}
inline void RelayKey::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RelayKey.iv)
}

// -------------------------------------------------------------------

// RelayCredentials

// string host = 1;
inline void RelayCredentials::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& RelayCredentials::host() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelayCredentials::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RelayCredentials.host)
}
inline std::string* RelayCredentials::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:proto.RelayCredentials.host)
  return _s;
}
inline const std::string& RelayCredentials::_internal_host() const {
  return _impl_.host_.Get();
}
inline void RelayCredentials::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* RelayCredentials::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* RelayCredentials::release_host() {
  // @@protoc_insertion_point(field_release:proto.RelayCredentials.host)
  return _impl_.host_.Release();
}
inline void RelayCredentials::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RelayCredentials.host)
}

// uint32 port = 2;
inline void RelayCredentials::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t RelayCredentials::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t RelayCredentials::port() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.port)
  return _internal_port();
}
inline void RelayCredentials::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void RelayCredentials::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:proto.RelayCredentials.port)
}

// .proto.RelayKey key = 3;
inline bool RelayCredentials::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool RelayCredentials::has_key() const {
  return _internal_has_key();
}
inline void RelayCredentials::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::proto::RelayKey& RelayCredentials::_internal_key() const {
  const ::proto::RelayKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RelayKey&>(
      ::proto::_RelayKey_default_instance_);
}
inline const ::proto::RelayKey& RelayCredentials::key() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.key)
  return _internal_key();
}
inline void RelayCredentials::unsafe_arena_set_allocated_key(
    ::proto::RelayKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RelayCredentials.key)
}
inline ::proto::RelayKey* RelayCredentials::release_key() {
  
  ::proto::RelayKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RelayKey* RelayCredentials::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.RelayCredentials.key)
  
  ::proto::RelayKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::RelayKey* RelayCredentials::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RelayKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::RelayKey* RelayCredentials::mutable_key() {
  ::proto::RelayKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.RelayCredentials.key)
  return _msg;
}
inline void RelayCredentials::set_allocated_key(::proto::RelayKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.RelayCredentials.key)
}

// bytes secret = 4;
inline void RelayCredentials::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& RelayCredentials::secret() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelayCredentials::set_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RelayCredentials.secret)
}
inline std::string* RelayCredentials::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:proto.RelayCredentials.secret)
  return _s;
}
inline const std::string& RelayCredentials::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void RelayCredentials::_internal_set_secret(const std::string& value) {
  
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* RelayCredentials::_internal_mutable_secret() {
  
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* RelayCredentials::release_secret() {
  // @@protoc_insertion_point(field_release:proto.RelayCredentials.secret)
  return _impl_.secret_.Release();
}
inline void RelayCredentials::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RelayCredentials.secret)
}

// -------------------------------------------------------------------

// PeerConnection

// uint64 session_id = 1;
inline void PeerConnection::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t PeerConnection::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t PeerConnection::session_id() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.session_id)
  return _internal_session_id();
}
inline void PeerConnection::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void PeerConnection::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnection.session_id)
}

// .proto.PeerConnection.PeerStatus status = 2;
inline void PeerConnection::clear_status() {
  _impl_.status_ = 0;
}
inline ::proto::PeerConnection_PeerStatus PeerConnection::_internal_status() const {
  return static_cast< ::proto::PeerConnection_PeerStatus >(_impl_.status_);
}
inline ::proto::PeerConnection_PeerStatus PeerConnection::status() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.status)
  return _internal_status();
}
inline void PeerConnection::_internal_set_status(::proto::PeerConnection_PeerStatus value) {
  
  _impl_.status_ = value;
}
inline void PeerConnection::set_status(::proto::PeerConnection_PeerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnection.status)
}

// string client_address = 3;
inline void PeerConnection::clear_client_address() {
  _impl_.client_address_.ClearToEmpty();
}
inline const std::string& PeerConnection::client_address() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.client_address)
  return _internal_client_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerConnection::set_client_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PeerConnection.client_address)
}
inline std::string* PeerConnection::mutable_client_address() {
  std::string* _s = _internal_mutable_client_address();
  // @@protoc_insertion_point(field_mutable:proto.PeerConnection.client_address)
  return _s;
}
inline const std::string& PeerConnection::_internal_client_address() const {
  return _impl_.client_address_.Get();
}
inline void PeerConnection::_internal_set_client_address(const std::string& value) {
  
  _impl_.client_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerConnection::_internal_mutable_client_address() {
  
  return _impl_.client_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerConnection::release_client_address() {
  // @@protoc_insertion_point(field_release:proto.PeerConnection.client_address)
  return _impl_.client_address_.Release();
}
inline void PeerConnection::set_allocated_client_address(std::string* client_address) {
  if (client_address != nullptr) {
    
  } else {
    
  }
  _impl_.client_address_.SetAllocated(client_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_address_.IsDefault()) {
    _impl_.client_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PeerConnection.client_address)
}

// string client_user_name = 4;
inline void PeerConnection::clear_client_user_name() {
  _impl_.client_user_name_.ClearToEmpty();
}
inline const std::string& PeerConnection::client_user_name() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.client_user_name)
  return _internal_client_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerConnection::set_client_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PeerConnection.client_user_name)
}
inline std::string* PeerConnection::mutable_client_user_name() {
  std::string* _s = _internal_mutable_client_user_name();
  // @@protoc_insertion_point(field_mutable:proto.PeerConnection.client_user_name)
  return _s;
}
inline const std::string& PeerConnection::_internal_client_user_name() const {
  return _impl_.client_user_name_.Get();
}
inline void PeerConnection::_internal_set_client_user_name(const std::string& value) {
  
  _impl_.client_user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerConnection::_internal_mutable_client_user_name() {
  
  return _impl_.client_user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerConnection::release_client_user_name() {
  // @@protoc_insertion_point(field_release:proto.PeerConnection.client_user_name)
  return _impl_.client_user_name_.Release();
}
inline void PeerConnection::set_allocated_client_user_name(std::string* client_user_name) {
  if (client_user_name != nullptr) {
    
  } else {
    
  }
  _impl_.client_user_name_.SetAllocated(client_user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_user_name_.IsDefault()) {
    _impl_.client_user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PeerConnection.client_user_name)
}

// string host_address = 5;
inline void PeerConnection::clear_host_address() {
  _impl_.host_address_.ClearToEmpty();
}
inline const std::string& PeerConnection::host_address() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.host_address)
  return _internal_host_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerConnection::set_host_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PeerConnection.host_address)
}
inline std::string* PeerConnection::mutable_host_address() {
  std::string* _s = _internal_mutable_host_address();
  // @@protoc_insertion_point(field_mutable:proto.PeerConnection.host_address)
  return _s;
}
inline const std::string& PeerConnection::_internal_host_address() const {
  return _impl_.host_address_.Get();
}
inline void PeerConnection::_internal_set_host_address(const std::string& value) {
  
  _impl_.host_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerConnection::_internal_mutable_host_address() {
  
  return _impl_.host_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerConnection::release_host_address() {
  // @@protoc_insertion_point(field_release:proto.PeerConnection.host_address)
  return _impl_.host_address_.Release();
}
inline void PeerConnection::set_allocated_host_address(std::string* host_address) {
  if (host_address != nullptr) {
    
  } else {
    
  }
  _impl_.host_address_.SetAllocated(host_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_address_.IsDefault()) {
    _impl_.host_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PeerConnection.host_address)
}

// fixed64 host_id = 6;
inline void PeerConnection::clear_host_id() {
  _impl_.host_id_ = uint64_t{0u};
}
inline uint64_t PeerConnection::_internal_host_id() const {
  return _impl_.host_id_;
}
inline uint64_t PeerConnection::host_id() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.host_id)
  return _internal_host_id();
}
inline void PeerConnection::_internal_set_host_id(uint64_t value) {
  
  _impl_.host_id_ = value;
}
inline void PeerConnection::set_host_id(uint64_t value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnection.host_id)
}

// int64 bytes_transferred = 7;
inline void PeerConnection::clear_bytes_transferred() {
  _impl_.bytes_transferred_ = int64_t{0};
}
inline int64_t PeerConnection::_internal_bytes_transferred() const {
  return _impl_.bytes_transferred_;
}
inline int64_t PeerConnection::bytes_transferred() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.bytes_transferred)
  return _internal_bytes_transferred();
}
inline void PeerConnection::_internal_set_bytes_transferred(int64_t value) {
  
  _impl_.bytes_transferred_ = value;
}
inline void PeerConnection::set_bytes_transferred(int64_t value) {
  _internal_set_bytes_transferred(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnection.bytes_transferred)
}

// int64 duration = 8;
inline void PeerConnection::clear_duration() {
  _impl_.duration_ = int64_t{0};
}
inline int64_t PeerConnection::_internal_duration() const {
  return _impl_.duration_;
}
inline int64_t PeerConnection::duration() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.duration)
  return _internal_duration();
}
inline void PeerConnection::_internal_set_duration(int64_t value) {
  
  _impl_.duration_ = value;
}
inline void PeerConnection::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnection.duration)
}

// int64 idle_time = 9;
inline void PeerConnection::clear_idle_time() {
  _impl_.idle_time_ = int64_t{0};
}
inline int64_t PeerConnection::_internal_idle_time() const {
  return _impl_.idle_time_;
}
inline int64_t PeerConnection::idle_time() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnection.idle_time)
  return _internal_idle_time();
}
inline void PeerConnection::_internal_set_idle_time(int64_t value) {
  
  _impl_.idle_time_ = value;
}
inline void PeerConnection::set_idle_time(int64_t value) {
  _internal_set_idle_time(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnection.idle_time)
}

// -------------------------------------------------------------------

// PeerConnectionRequest

// int64 relay_session_id = 1;
inline void PeerConnectionRequest::clear_relay_session_id() {
  _impl_.relay_session_id_ = int64_t{0};
}
inline int64_t PeerConnectionRequest::_internal_relay_session_id() const {
  return _impl_.relay_session_id_;
}
inline int64_t PeerConnectionRequest::relay_session_id() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnectionRequest.relay_session_id)
  return _internal_relay_session_id();
}
inline void PeerConnectionRequest::_internal_set_relay_session_id(int64_t value) {
  
  _impl_.relay_session_id_ = value;
}
inline void PeerConnectionRequest::set_relay_session_id(int64_t value) {
  _internal_set_relay_session_id(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnectionRequest.relay_session_id)
}

// .proto.PeerConnectionRequestType type = 2;
inline void PeerConnectionRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::PeerConnectionRequestType PeerConnectionRequest::_internal_type() const {
  return static_cast< ::proto::PeerConnectionRequestType >(_impl_.type_);
}
inline ::proto::PeerConnectionRequestType PeerConnectionRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnectionRequest.type)
  return _internal_type();
}
inline void PeerConnectionRequest::_internal_set_type(::proto::PeerConnectionRequestType value) {
  
  _impl_.type_ = value;
}
inline void PeerConnectionRequest::set_type(::proto::PeerConnectionRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnectionRequest.type)
}

// uint64 peer_session_id = 3;
inline void PeerConnectionRequest::clear_peer_session_id() {
  _impl_.peer_session_id_ = uint64_t{0u};
}
inline uint64_t PeerConnectionRequest::_internal_peer_session_id() const {
  return _impl_.peer_session_id_;
}
inline uint64_t PeerConnectionRequest::peer_session_id() const {
  // @@protoc_insertion_point(field_get:proto.PeerConnectionRequest.peer_session_id)
  return _internal_peer_session_id();
}
inline void PeerConnectionRequest::_internal_set_peer_session_id(uint64_t value) {
  
  _impl_.peer_session_id_ = value;
}
inline void PeerConnectionRequest::set_peer_session_id(uint64_t value) {
  _internal_set_peer_session_id(value);
  // @@protoc_insertion_point(field_set:proto.PeerConnectionRequest.peer_session_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::RelayKey_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::RelayKey_Encryption> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::PeerConnection_PeerStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::RouterChannelId> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::RouterSession> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::PeerConnectionRequestType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_5fcommon_2eproto
