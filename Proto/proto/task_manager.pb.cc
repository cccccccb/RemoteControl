// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task_manager.proto

#include "task_manager.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
namespace task_manager {
PROTOBUF_CONSTEXPR Process::Process(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.process_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.process_id_)*/uint64_t{0u}
  , /*decltype(_impl_.session_id_)*/uint64_t{0u}
  , /*decltype(_impl_.mem_working_set_)*/int64_t{0}
  , /*decltype(_impl_.mem_peak_working_set_)*/int64_t{0}
  , /*decltype(_impl_.cpu_usage_)*/0
  , /*decltype(_impl_.thread_count_)*/0u
  , /*decltype(_impl_.mem_working_set_delta_)*/int64_t{0}
  , /*decltype(_impl_.mem_private_working_set_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessDefaultTypeInternal() {}
  union {
    Process _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessDefaultTypeInternal _Process_default_instance_;
PROTOBUF_CONSTEXPR ProcessList::ProcessList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.process_)*/{}
  , /*decltype(_impl_.cpu_usage_)*/0
  , /*decltype(_impl_.memory_usage_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessListDefaultTypeInternal() {}
  union {
    ProcessList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessListDefaultTypeInternal _ProcessList_default_instance_;
PROTOBUF_CONSTEXPR ProcessListRequest::ProcessListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessListRequestDefaultTypeInternal() {}
  union {
    ProcessListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessListRequestDefaultTypeInternal _ProcessListRequest_default_instance_;
PROTOBUF_CONSTEXPR EndProcessRequest::EndProcessRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pid_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EndProcessRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndProcessRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndProcessRequestDefaultTypeInternal() {}
  union {
    EndProcessRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndProcessRequestDefaultTypeInternal _EndProcessRequest_default_instance_;
PROTOBUF_CONSTEXPR Service::Service(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.startup_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceDefaultTypeInternal() {}
  union {
    Service _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceDefaultTypeInternal _Service_default_instance_;
PROTOBUF_CONSTEXPR ServiceList::ServiceList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.service_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServiceListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceListDefaultTypeInternal() {}
  union {
    ServiceList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceListDefaultTypeInternal _ServiceList_default_instance_;
PROTOBUF_CONSTEXPR ServiceListRequest::ServiceListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dummy_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServiceListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceListRequestDefaultTypeInternal() {}
  union {
    ServiceListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceListRequestDefaultTypeInternal _ServiceListRequest_default_instance_;
PROTOBUF_CONSTEXPR ServiceRequest::ServiceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServiceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceRequestDefaultTypeInternal() {}
  union {
    ServiceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceRequestDefaultTypeInternal _ServiceRequest_default_instance_;
PROTOBUF_CONSTEXPR User::User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_.connect_state_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefaultTypeInternal() {}
  union {
    User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefaultTypeInternal _User_default_instance_;
PROTOBUF_CONSTEXPR UserList::UserList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserListDefaultTypeInternal() {}
  union {
    UserList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserListDefaultTypeInternal _UserList_default_instance_;
PROTOBUF_CONSTEXPR UserListRequest::UserListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dummy_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserListRequestDefaultTypeInternal() {}
  union {
    UserListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserListRequestDefaultTypeInternal _UserListRequest_default_instance_;
PROTOBUF_CONSTEXPR UserRequest::UserRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_.command_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserRequestDefaultTypeInternal() {}
  union {
    UserRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserRequestDefaultTypeInternal _UserRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientToHost::ClientToHost(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.process_list_request_)*/nullptr
  , /*decltype(_impl_.end_process_request_)*/nullptr
  , /*decltype(_impl_.service_list_request_)*/nullptr
  , /*decltype(_impl_.service_request_)*/nullptr
  , /*decltype(_impl_.user_list_request_)*/nullptr
  , /*decltype(_impl_.user_request_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientToHostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientToHostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientToHostDefaultTypeInternal() {}
  union {
    ClientToHost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToHostDefaultTypeInternal _ClientToHost_default_instance_;
PROTOBUF_CONSTEXPR HostToClient::HostToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.process_list_)*/nullptr
  , /*decltype(_impl_.service_list_)*/nullptr
  , /*decltype(_impl_.user_list_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostToClientDefaultTypeInternal() {}
  union {
    HostToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostToClientDefaultTypeInternal _HostToClient_default_instance_;
}  // namespace task_manager
}  // namespace proto
namespace proto {
namespace task_manager {
bool ProcessListRequest_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProcessListRequest_Flags_strings[2] = {};

static const char ProcessListRequest_Flags_names[] =
  "NONE"
  "RESET_CACHE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProcessListRequest_Flags_entries[] = {
  { {ProcessListRequest_Flags_names + 0, 4}, 0 },
  { {ProcessListRequest_Flags_names + 4, 11}, 1 },
};

static const int ProcessListRequest_Flags_entries_by_number[] = {
  0, // 0 -> NONE
  1, // 1 -> RESET_CACHE
};

const std::string& ProcessListRequest_Flags_Name(
    ProcessListRequest_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProcessListRequest_Flags_entries,
          ProcessListRequest_Flags_entries_by_number,
          2, ProcessListRequest_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProcessListRequest_Flags_entries,
      ProcessListRequest_Flags_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProcessListRequest_Flags_strings[idx].get();
}
bool ProcessListRequest_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessListRequest_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProcessListRequest_Flags_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ProcessListRequest_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ProcessListRequest_Flags ProcessListRequest::NONE;
constexpr ProcessListRequest_Flags ProcessListRequest::RESET_CACHE;
constexpr ProcessListRequest_Flags ProcessListRequest::Flags_MIN;
constexpr ProcessListRequest_Flags ProcessListRequest::Flags_MAX;
constexpr int ProcessListRequest::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Service_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Service_Status_strings[8] = {};

static const char Service_Status_names[] =
  "STATUS_CONTINUE_PENDING"
  "STATUS_PAUSED"
  "STATUS_PAUSE_PENDING"
  "STATUS_RUNNING"
  "STATUS_START_PENDING"
  "STATUS_STOPPED"
  "STATUS_STOP_PENDING"
  "STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Service_Status_entries[] = {
  { {Service_Status_names + 0, 23}, 1 },
  { {Service_Status_names + 23, 13}, 3 },
  { {Service_Status_names + 36, 20}, 2 },
  { {Service_Status_names + 56, 14}, 4 },
  { {Service_Status_names + 70, 20}, 5 },
  { {Service_Status_names + 90, 14}, 7 },
  { {Service_Status_names + 104, 19}, 6 },
  { {Service_Status_names + 123, 14}, 0 },
};

static const int Service_Status_entries_by_number[] = {
  7, // 0 -> STATUS_UNKNOWN
  0, // 1 -> STATUS_CONTINUE_PENDING
  2, // 2 -> STATUS_PAUSE_PENDING
  1, // 3 -> STATUS_PAUSED
  3, // 4 -> STATUS_RUNNING
  4, // 5 -> STATUS_START_PENDING
  6, // 6 -> STATUS_STOP_PENDING
  5, // 7 -> STATUS_STOPPED
};

const std::string& Service_Status_Name(
    Service_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Service_Status_entries,
          Service_Status_entries_by_number,
          8, Service_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Service_Status_entries,
      Service_Status_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Service_Status_strings[idx].get();
}
bool Service_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Service_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Service_Status_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<Service_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Service_Status Service::STATUS_UNKNOWN;
constexpr Service_Status Service::STATUS_CONTINUE_PENDING;
constexpr Service_Status Service::STATUS_PAUSE_PENDING;
constexpr Service_Status Service::STATUS_PAUSED;
constexpr Service_Status Service::STATUS_RUNNING;
constexpr Service_Status Service::STATUS_START_PENDING;
constexpr Service_Status Service::STATUS_STOP_PENDING;
constexpr Service_Status Service::STATUS_STOPPED;
constexpr Service_Status Service::Status_MIN;
constexpr Service_Status Service::Status_MAX;
constexpr int Service::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Service_StartupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Service_StartupType_strings[6] = {};

static const char Service_StartupType_names[] =
  "STARTUP_TYPE_AUTO_START"
  "STARTUP_TYPE_BOOT_START"
  "STARTUP_TYPE_DEMAND_START"
  "STARTUP_TYPE_DISABLED"
  "STARTUP_TYPE_SYSTEM_START"
  "STARTUP_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Service_StartupType_entries[] = {
  { {Service_StartupType_names + 0, 23}, 1 },
  { {Service_StartupType_names + 23, 23}, 4 },
  { {Service_StartupType_names + 46, 25}, 2 },
  { {Service_StartupType_names + 71, 21}, 3 },
  { {Service_StartupType_names + 92, 25}, 5 },
  { {Service_StartupType_names + 117, 20}, 0 },
};

static const int Service_StartupType_entries_by_number[] = {
  5, // 0 -> STARTUP_TYPE_UNKNOWN
  0, // 1 -> STARTUP_TYPE_AUTO_START
  2, // 2 -> STARTUP_TYPE_DEMAND_START
  3, // 3 -> STARTUP_TYPE_DISABLED
  1, // 4 -> STARTUP_TYPE_BOOT_START
  4, // 5 -> STARTUP_TYPE_SYSTEM_START
};

const std::string& Service_StartupType_Name(
    Service_StartupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Service_StartupType_entries,
          Service_StartupType_entries_by_number,
          6, Service_StartupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Service_StartupType_entries,
      Service_StartupType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Service_StartupType_strings[idx].get();
}
bool Service_StartupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Service_StartupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Service_StartupType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Service_StartupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Service_StartupType Service::STARTUP_TYPE_UNKNOWN;
constexpr Service_StartupType Service::STARTUP_TYPE_AUTO_START;
constexpr Service_StartupType Service::STARTUP_TYPE_DEMAND_START;
constexpr Service_StartupType Service::STARTUP_TYPE_DISABLED;
constexpr Service_StartupType Service::STARTUP_TYPE_BOOT_START;
constexpr Service_StartupType Service::STARTUP_TYPE_SYSTEM_START;
constexpr Service_StartupType Service::StartupType_MIN;
constexpr Service_StartupType Service::StartupType_MAX;
constexpr int Service::StartupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceRequest_Command_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceRequest_Command_strings[3] = {};

static const char ServiceRequest_Command_names[] =
  "COMMAND_START"
  "COMMAND_STOP"
  "COMMAND_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceRequest_Command_entries[] = {
  { {ServiceRequest_Command_names + 0, 13}, 1 },
  { {ServiceRequest_Command_names + 13, 12}, 2 },
  { {ServiceRequest_Command_names + 25, 15}, 0 },
};

static const int ServiceRequest_Command_entries_by_number[] = {
  2, // 0 -> COMMAND_UNKNOWN
  0, // 1 -> COMMAND_START
  1, // 2 -> COMMAND_STOP
};

const std::string& ServiceRequest_Command_Name(
    ServiceRequest_Command value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceRequest_Command_entries,
          ServiceRequest_Command_entries_by_number,
          3, ServiceRequest_Command_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceRequest_Command_entries,
      ServiceRequest_Command_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceRequest_Command_strings[idx].get();
}
bool ServiceRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceRequest_Command* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceRequest_Command_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ServiceRequest_Command>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceRequest_Command ServiceRequest::COMMAND_UNKNOWN;
constexpr ServiceRequest_Command ServiceRequest::COMMAND_START;
constexpr ServiceRequest_Command ServiceRequest::COMMAND_STOP;
constexpr ServiceRequest_Command ServiceRequest::Command_MIN;
constexpr ServiceRequest_Command ServiceRequest::Command_MAX;
constexpr int ServiceRequest::Command_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool User_ConnectState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> User_ConnectState_strings[11] = {};

static const char User_ConnectState_names[] =
  "CONNECT_STATE_ACTIVE"
  "CONNECT_STATE_CONNECTED"
  "CONNECT_STATE_CONNECT_QUERY"
  "CONNECT_STATE_DISCONNECTED"
  "CONNECT_STATE_DOWN"
  "CONNECT_STATE_IDLE"
  "CONNECT_STATE_INIT"
  "CONNECT_STATE_LISTEN"
  "CONNECT_STATE_RESET"
  "CONNECT_STATE_SHADOW"
  "CONNECT_STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry User_ConnectState_entries[] = {
  { {User_ConnectState_names + 0, 20}, 1 },
  { {User_ConnectState_names + 20, 23}, 2 },
  { {User_ConnectState_names + 43, 27}, 3 },
  { {User_ConnectState_names + 70, 26}, 5 },
  { {User_ConnectState_names + 96, 18}, 9 },
  { {User_ConnectState_names + 114, 18}, 6 },
  { {User_ConnectState_names + 132, 18}, 10 },
  { {User_ConnectState_names + 150, 20}, 7 },
  { {User_ConnectState_names + 170, 19}, 8 },
  { {User_ConnectState_names + 189, 20}, 4 },
  { {User_ConnectState_names + 209, 21}, 0 },
};

static const int User_ConnectState_entries_by_number[] = {
  10, // 0 -> CONNECT_STATE_UNKNOWN
  0, // 1 -> CONNECT_STATE_ACTIVE
  1, // 2 -> CONNECT_STATE_CONNECTED
  2, // 3 -> CONNECT_STATE_CONNECT_QUERY
  9, // 4 -> CONNECT_STATE_SHADOW
  3, // 5 -> CONNECT_STATE_DISCONNECTED
  5, // 6 -> CONNECT_STATE_IDLE
  7, // 7 -> CONNECT_STATE_LISTEN
  8, // 8 -> CONNECT_STATE_RESET
  4, // 9 -> CONNECT_STATE_DOWN
  6, // 10 -> CONNECT_STATE_INIT
};

const std::string& User_ConnectState_Name(
    User_ConnectState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          User_ConnectState_entries,
          User_ConnectState_entries_by_number,
          11, User_ConnectState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      User_ConnectState_entries,
      User_ConnectState_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     User_ConnectState_strings[idx].get();
}
bool User_ConnectState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, User_ConnectState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      User_ConnectState_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<User_ConnectState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr User_ConnectState User::CONNECT_STATE_UNKNOWN;
constexpr User_ConnectState User::CONNECT_STATE_ACTIVE;
constexpr User_ConnectState User::CONNECT_STATE_CONNECTED;
constexpr User_ConnectState User::CONNECT_STATE_CONNECT_QUERY;
constexpr User_ConnectState User::CONNECT_STATE_SHADOW;
constexpr User_ConnectState User::CONNECT_STATE_DISCONNECTED;
constexpr User_ConnectState User::CONNECT_STATE_IDLE;
constexpr User_ConnectState User::CONNECT_STATE_LISTEN;
constexpr User_ConnectState User::CONNECT_STATE_RESET;
constexpr User_ConnectState User::CONNECT_STATE_DOWN;
constexpr User_ConnectState User::CONNECT_STATE_INIT;
constexpr User_ConnectState User::ConnectState_MIN;
constexpr User_ConnectState User::ConnectState_MAX;
constexpr int User::ConnectState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UserRequest_Command_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserRequest_Command_strings[3] = {};

static const char UserRequest_Command_names[] =
  "COMMAND_DISCONNECT"
  "COMMAND_LOGOFF"
  "COMMAND_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserRequest_Command_entries[] = {
  { {UserRequest_Command_names + 0, 18}, 1 },
  { {UserRequest_Command_names + 18, 14}, 2 },
  { {UserRequest_Command_names + 32, 15}, 0 },
};

static const int UserRequest_Command_entries_by_number[] = {
  2, // 0 -> COMMAND_UNKNOWN
  0, // 1 -> COMMAND_DISCONNECT
  1, // 2 -> COMMAND_LOGOFF
};

const std::string& UserRequest_Command_Name(
    UserRequest_Command value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserRequest_Command_entries,
          UserRequest_Command_entries_by_number,
          3, UserRequest_Command_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserRequest_Command_entries,
      UserRequest_Command_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserRequest_Command_strings[idx].get();
}
bool UserRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserRequest_Command* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserRequest_Command_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UserRequest_Command>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserRequest_Command UserRequest::COMMAND_UNKNOWN;
constexpr UserRequest_Command UserRequest::COMMAND_DISCONNECT;
constexpr UserRequest_Command UserRequest::COMMAND_LOGOFF;
constexpr UserRequest_Command UserRequest::Command_MIN;
constexpr UserRequest_Command UserRequest::Command_MAX;
constexpr int UserRequest::Command_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Process::_Internal {
 public:
};

Process::Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.Process)
}
Process::Process(const Process& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Process* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.process_name_){}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.file_path_){}
    , decltype(_impl_.process_id_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.mem_working_set_){}
    , decltype(_impl_.mem_peak_working_set_){}
    , decltype(_impl_.cpu_usage_){}
    , decltype(_impl_.thread_count_){}
    , decltype(_impl_.mem_working_set_delta_){}
    , decltype(_impl_.mem_private_working_set_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.process_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.process_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_process_name().empty()) {
    _this->_impl_.process_name_.Set(from._internal_process_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_name().empty()) {
    _this->_impl_.user_name_.Set(from._internal_user_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_path().empty()) {
    _this->_impl_.file_path_.Set(from._internal_file_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.process_id_, &from._impl_.process_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mem_private_working_set_) -
    reinterpret_cast<char*>(&_impl_.process_id_)) + sizeof(_impl_.mem_private_working_set_));
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.Process)
}

inline void Process::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.process_name_){}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.file_path_){}
    , decltype(_impl_.process_id_){uint64_t{0u}}
    , decltype(_impl_.session_id_){uint64_t{0u}}
    , decltype(_impl_.mem_working_set_){int64_t{0}}
    , decltype(_impl_.mem_peak_working_set_){int64_t{0}}
    , decltype(_impl_.cpu_usage_){0}
    , decltype(_impl_.thread_count_){0u}
    , decltype(_impl_.mem_working_set_delta_){int64_t{0}}
    , decltype(_impl_.mem_private_working_set_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.process_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.process_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Process::~Process() {
  // @@protoc_insertion_point(destructor:proto.task_manager.Process)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Process::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.process_name_.Destroy();
  _impl_.user_name_.Destroy();
  _impl_.file_path_.Destroy();
}

void Process::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Process::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.Process)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.process_name_.ClearToEmpty();
  _impl_.user_name_.ClearToEmpty();
  _impl_.file_path_.ClearToEmpty();
  ::memset(&_impl_.process_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mem_private_working_set_) -
      reinterpret_cast<char*>(&_impl_.process_id_)) + sizeof(_impl_.mem_private_working_set_));
  _internal_metadata_.Clear<std::string>();
}

const char* Process::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 process_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.process_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string process_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_process_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string user_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string file_path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_file_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 cpu_usage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.cpu_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 mem_working_set = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.mem_working_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 mem_peak_working_set = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.mem_peak_working_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 mem_working_set_delta = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.mem_working_set_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 mem_private_working_set = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.mem_private_working_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 thread_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.thread_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Process::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.Process)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 process_id = 1;
  if (this->_internal_process_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_process_id(), target);
  }

  // uint64 session_id = 2;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_session_id(), target);
  }

  // string process_name = 3;
  if (!this->_internal_process_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_process_name().data(), static_cast<int>(this->_internal_process_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.Process.process_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_process_name(), target);
  }

  // string user_name = 4;
  if (!this->_internal_user_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.Process.user_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user_name(), target);
  }

  // string file_path = 5;
  if (!this->_internal_file_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_path().data(), static_cast<int>(this->_internal_file_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.Process.file_path");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_file_path(), target);
  }

  // int32 cpu_usage = 6;
  if (this->_internal_cpu_usage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_cpu_usage(), target);
  }

  // int64 mem_working_set = 7;
  if (this->_internal_mem_working_set() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_mem_working_set(), target);
  }

  // int64 mem_peak_working_set = 8;
  if (this->_internal_mem_peak_working_set() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_mem_peak_working_set(), target);
  }

  // int64 mem_working_set_delta = 9;
  if (this->_internal_mem_working_set_delta() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_mem_working_set_delta(), target);
  }

  // int64 mem_private_working_set = 10;
  if (this->_internal_mem_private_working_set() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_mem_private_working_set(), target);
  }

  // uint32 thread_count = 11;
  if (this->_internal_thread_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_thread_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.Process)
  return target;
}

size_t Process::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.Process)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string process_name = 3;
  if (!this->_internal_process_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_process_name());
  }

  // string user_name = 4;
  if (!this->_internal_user_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  // string file_path = 5;
  if (!this->_internal_file_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_path());
  }

  // uint64 process_id = 1;
  if (this->_internal_process_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_process_id());
  }

  // uint64 session_id = 2;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_session_id());
  }

  // int64 mem_working_set = 7;
  if (this->_internal_mem_working_set() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_mem_working_set());
  }

  // int64 mem_peak_working_set = 8;
  if (this->_internal_mem_peak_working_set() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_mem_peak_working_set());
  }

  // int32 cpu_usage = 6;
  if (this->_internal_cpu_usage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_usage());
  }

  // uint32 thread_count = 11;
  if (this->_internal_thread_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_thread_count());
  }

  // int64 mem_working_set_delta = 9;
  if (this->_internal_mem_working_set_delta() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_mem_working_set_delta());
  }

  // int64 mem_private_working_set = 10;
  if (this->_internal_mem_private_working_set() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_mem_private_working_set());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Process::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Process*>(
      &from));
}

void Process::MergeFrom(const Process& from) {
  Process* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.Process)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_process_name().empty()) {
    _this->_internal_set_process_name(from._internal_process_name());
  }
  if (!from._internal_user_name().empty()) {
    _this->_internal_set_user_name(from._internal_user_name());
  }
  if (!from._internal_file_path().empty()) {
    _this->_internal_set_file_path(from._internal_file_path());
  }
  if (from._internal_process_id() != 0) {
    _this->_internal_set_process_id(from._internal_process_id());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_mem_working_set() != 0) {
    _this->_internal_set_mem_working_set(from._internal_mem_working_set());
  }
  if (from._internal_mem_peak_working_set() != 0) {
    _this->_internal_set_mem_peak_working_set(from._internal_mem_peak_working_set());
  }
  if (from._internal_cpu_usage() != 0) {
    _this->_internal_set_cpu_usage(from._internal_cpu_usage());
  }
  if (from._internal_thread_count() != 0) {
    _this->_internal_set_thread_count(from._internal_thread_count());
  }
  if (from._internal_mem_working_set_delta() != 0) {
    _this->_internal_set_mem_working_set_delta(from._internal_mem_working_set_delta());
  }
  if (from._internal_mem_private_working_set() != 0) {
    _this->_internal_set_mem_private_working_set(from._internal_mem_private_working_set());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Process::CopyFrom(const Process& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.Process)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Process::IsInitialized() const {
  return true;
}

void Process::InternalSwap(Process* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.process_name_, lhs_arena,
      &other->_impl_.process_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_path_, lhs_arena,
      &other->_impl_.file_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Process, _impl_.mem_private_working_set_)
      + sizeof(Process::_impl_.mem_private_working_set_)
      - PROTOBUF_FIELD_OFFSET(Process, _impl_.process_id_)>(
          reinterpret_cast<char*>(&_impl_.process_id_),
          reinterpret_cast<char*>(&other->_impl_.process_id_));
}

std::string Process::GetTypeName() const {
  return "proto.task_manager.Process";
}


// ===================================================================

class ProcessList::_Internal {
 public:
};

ProcessList::ProcessList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.ProcessList)
}
ProcessList::ProcessList(const ProcessList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ProcessList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.process_){from._impl_.process_}
    , decltype(_impl_.cpu_usage_){}
    , decltype(_impl_.memory_usage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.cpu_usage_, &from._impl_.cpu_usage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.memory_usage_) -
    reinterpret_cast<char*>(&_impl_.cpu_usage_)) + sizeof(_impl_.memory_usage_));
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.ProcessList)
}

inline void ProcessList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.process_){arena}
    , decltype(_impl_.cpu_usage_){0}
    , decltype(_impl_.memory_usage_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProcessList::~ProcessList() {
  // @@protoc_insertion_point(destructor:proto.task_manager.ProcessList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.process_.~RepeatedPtrField();
}

void ProcessList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.ProcessList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.process_.Clear();
  ::memset(&_impl_.cpu_usage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.memory_usage_) -
      reinterpret_cast<char*>(&_impl_.cpu_usage_)) + sizeof(_impl_.memory_usage_));
  _internal_metadata_.Clear<std::string>();
}

const char* ProcessList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.task_manager.Process process = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_process(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 cpu_usage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.cpu_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 memory_usage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.memory_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.ProcessList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.task_manager.Process process = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_process_size()); i < n; i++) {
    const auto& repfield = this->_internal_process(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 cpu_usage = 2;
  if (this->_internal_cpu_usage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cpu_usage(), target);
  }

  // int32 memory_usage = 3;
  if (this->_internal_memory_usage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_memory_usage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.ProcessList)
  return target;
}

size_t ProcessList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.ProcessList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.task_manager.Process process = 1;
  total_size += 1UL * this->_internal_process_size();
  for (const auto& msg : this->_impl_.process_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 cpu_usage = 2;
  if (this->_internal_cpu_usage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_usage());
  }

  // int32 memory_usage = 3;
  if (this->_internal_memory_usage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_memory_usage());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProcessList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProcessList*>(
      &from));
}

void ProcessList::MergeFrom(const ProcessList& from) {
  ProcessList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.ProcessList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.process_.MergeFrom(from._impl_.process_);
  if (from._internal_cpu_usage() != 0) {
    _this->_internal_set_cpu_usage(from._internal_cpu_usage());
  }
  if (from._internal_memory_usage() != 0) {
    _this->_internal_set_memory_usage(from._internal_memory_usage());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessList::CopyFrom(const ProcessList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.ProcessList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessList::IsInitialized() const {
  return true;
}

void ProcessList::InternalSwap(ProcessList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.process_.InternalSwap(&other->_impl_.process_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessList, _impl_.memory_usage_)
      + sizeof(ProcessList::_impl_.memory_usage_)
      - PROTOBUF_FIELD_OFFSET(ProcessList, _impl_.cpu_usage_)>(
          reinterpret_cast<char*>(&_impl_.cpu_usage_),
          reinterpret_cast<char*>(&other->_impl_.cpu_usage_));
}

std::string ProcessList::GetTypeName() const {
  return "proto.task_manager.ProcessList";
}


// ===================================================================

class ProcessListRequest::_Internal {
 public:
};

ProcessListRequest::ProcessListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.ProcessListRequest)
}
ProcessListRequest::ProcessListRequest(const ProcessListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ProcessListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.flags_ = from._impl_.flags_;
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.ProcessListRequest)
}

inline void ProcessListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flags_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProcessListRequest::~ProcessListRequest() {
  // @@protoc_insertion_point(destructor:proto.task_manager.ProcessListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProcessListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.ProcessListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flags_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* ProcessListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.ProcessListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.ProcessListRequest)
  return target;
}

size_t ProcessListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.ProcessListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProcessListRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProcessListRequest*>(
      &from));
}

void ProcessListRequest::MergeFrom(const ProcessListRequest& from) {
  ProcessListRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.ProcessListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessListRequest::CopyFrom(const ProcessListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.ProcessListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessListRequest::IsInitialized() const {
  return true;
}

void ProcessListRequest::InternalSwap(ProcessListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flags_, other->_impl_.flags_);
}

std::string ProcessListRequest::GetTypeName() const {
  return "proto.task_manager.ProcessListRequest";
}


// ===================================================================

class EndProcessRequest::_Internal {
 public:
};

EndProcessRequest::EndProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.EndProcessRequest)
}
EndProcessRequest::EndProcessRequest(const EndProcessRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EndProcessRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.pid_ = from._impl_.pid_;
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.EndProcessRequest)
}

inline void EndProcessRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EndProcessRequest::~EndProcessRequest() {
  // @@protoc_insertion_point(destructor:proto.task_manager.EndProcessRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndProcessRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndProcessRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EndProcessRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.EndProcessRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pid_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* EndProcessRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndProcessRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.EndProcessRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 pid = 1;
  if (this->_internal_pid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.EndProcessRequest)
  return target;
}

size_t EndProcessRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.EndProcessRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 pid = 1;
  if (this->_internal_pid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndProcessRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EndProcessRequest*>(
      &from));
}

void EndProcessRequest::MergeFrom(const EndProcessRequest& from) {
  EndProcessRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.EndProcessRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pid() != 0) {
    _this->_internal_set_pid(from._internal_pid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndProcessRequest::CopyFrom(const EndProcessRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.EndProcessRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndProcessRequest::IsInitialized() const {
  return true;
}

void EndProcessRequest::InternalSwap(EndProcessRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pid_, other->_impl_.pid_);
}

std::string EndProcessRequest::GetTypeName() const {
  return "proto.task_manager.EndProcessRequest";
}


// ===================================================================

class Service::_Internal {
 public:
};

Service::Service(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.Service)
}
Service::Service(const Service& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Service* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.startup_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.startup_type_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.startup_type_));
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.Service)
}

inline void Service::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.startup_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Service::~Service() {
  // @@protoc_insertion_point(destructor:proto.task_manager.Service)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Service::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.display_name_.Destroy();
  _impl_.description_.Destroy();
}

void Service::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Service::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.Service)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.display_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  ::memset(&_impl_.status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.startup_type_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.startup_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* Service::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string display_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.Service.Status status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::proto::task_manager::Service_Status>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.Service.StartupType startup_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_startup_type(static_cast<::proto::task_manager::Service_StartupType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Service::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.Service)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.Service.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.Service.display_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_display_name(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.Service.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // .proto.task_manager.Service.Status status = 4;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // .proto.task_manager.Service.StartupType startup_type = 5;
  if (this->_internal_startup_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_startup_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.Service)
  return target;
}

size_t Service::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.Service)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_display_name());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .proto.task_manager.Service.Status status = 4;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // .proto.task_manager.Service.StartupType startup_type = 5;
  if (this->_internal_startup_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_startup_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Service::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Service*>(
      &from));
}

void Service::MergeFrom(const Service& from) {
  Service* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.Service)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_startup_type() != 0) {
    _this->_internal_set_startup_type(from._internal_startup_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Service::CopyFrom(const Service& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.Service)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Service::IsInitialized() const {
  return true;
}

void Service::InternalSwap(Service* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Service, _impl_.startup_type_)
      + sizeof(Service::_impl_.startup_type_)
      - PROTOBUF_FIELD_OFFSET(Service, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string Service::GetTypeName() const {
  return "proto.task_manager.Service";
}


// ===================================================================

class ServiceList::_Internal {
 public:
};

ServiceList::ServiceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.ServiceList)
}
ServiceList::ServiceList(const ServiceList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServiceList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){from._impl_.service_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.ServiceList)
}

inline void ServiceList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServiceList::~ServiceList() {
  // @@protoc_insertion_point(destructor:proto.task_manager.ServiceList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_.~RepeatedPtrField();
}

void ServiceList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.ServiceList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.task_manager.Service service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_service(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.ServiceList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.task_manager.Service service = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_service_size()); i < n; i++) {
    const auto& repfield = this->_internal_service(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.ServiceList)
  return target;
}

size_t ServiceList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.ServiceList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.task_manager.Service service = 1;
  total_size += 1UL * this->_internal_service_size();
  for (const auto& msg : this->_impl_.service_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceList*>(
      &from));
}

void ServiceList::MergeFrom(const ServiceList& from) {
  ServiceList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.ServiceList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.service_.MergeFrom(from._impl_.service_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceList::CopyFrom(const ServiceList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.ServiceList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceList::IsInitialized() const {
  return true;
}

void ServiceList::InternalSwap(ServiceList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.service_.InternalSwap(&other->_impl_.service_);
}

std::string ServiceList::GetTypeName() const {
  return "proto.task_manager.ServiceList";
}


// ===================================================================

class ServiceListRequest::_Internal {
 public:
};

ServiceListRequest::ServiceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.ServiceListRequest)
}
ServiceListRequest::ServiceListRequest(const ServiceListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServiceListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dummy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.dummy_ = from._impl_.dummy_;
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.ServiceListRequest)
}

inline void ServiceListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dummy_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServiceListRequest::~ServiceListRequest() {
  // @@protoc_insertion_point(destructor:proto.task_manager.ServiceListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.ServiceListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dummy_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 dummy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.dummy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.ServiceListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 dummy = 1;
  if (this->_internal_dummy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dummy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.ServiceListRequest)
  return target;
}

size_t ServiceListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.ServiceListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 dummy = 1;
  if (this->_internal_dummy() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dummy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceListRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceListRequest*>(
      &from));
}

void ServiceListRequest::MergeFrom(const ServiceListRequest& from) {
  ServiceListRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.ServiceListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dummy() != 0) {
    _this->_internal_set_dummy(from._internal_dummy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceListRequest::CopyFrom(const ServiceListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.ServiceListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceListRequest::IsInitialized() const {
  return true;
}

void ServiceListRequest::InternalSwap(ServiceListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.dummy_, other->_impl_.dummy_);
}

std::string ServiceListRequest::GetTypeName() const {
  return "proto.task_manager.ServiceListRequest";
}


// ===================================================================

class ServiceRequest::_Internal {
 public:
};

ServiceRequest::ServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.ServiceRequest)
}
ServiceRequest::ServiceRequest(const ServiceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServiceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.command_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.command_ = from._impl_.command_;
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.ServiceRequest)
}

inline void ServiceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.command_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceRequest::~ServiceRequest() {
  // @@protoc_insertion_point(destructor:proto.task_manager.ServiceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ServiceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.ServiceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.command_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.ServiceRequest.Command command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_command(static_cast<::proto::task_manager::ServiceRequest_Command>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.ServiceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.ServiceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .proto.task_manager.ServiceRequest.Command command = 2;
  if (this->_internal_command() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.ServiceRequest)
  return target;
}

size_t ServiceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.ServiceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .proto.task_manager.ServiceRequest.Command command = 2;
  if (this->_internal_command() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_command());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceRequest*>(
      &from));
}

void ServiceRequest::MergeFrom(const ServiceRequest& from) {
  ServiceRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.ServiceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_command() != 0) {
    _this->_internal_set_command(from._internal_command());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceRequest::CopyFrom(const ServiceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.ServiceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceRequest::IsInitialized() const {
  return true;
}

void ServiceRequest::InternalSwap(ServiceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.command_, other->_impl_.command_);
}

std::string ServiceRequest::GetTypeName() const {
  return "proto.task_manager.ServiceRequest";
}


// ===================================================================

class User::_Internal {
 public:
};

User::User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.User)
}
User::User(const User& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_name_){}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.session_name_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.connect_state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_name().empty()) {
    _this->_impl_.user_name_.Set(from._internal_user_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client_name().empty()) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.session_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_session_name().empty()) {
    _this->_impl_.session_name_.Set(from._internal_session_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.session_id_, &from._impl_.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.connect_state_) -
    reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.connect_state_));
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.User)
}

inline void User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_name_){}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.session_name_){}
    , decltype(_impl_.session_id_){0u}
    , decltype(_impl_.connect_state_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.session_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

User::~User() {
  // @@protoc_insertion_point(destructor:proto.task_manager.User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.client_name_.Destroy();
  _impl_.session_name_.Destroy();
}

void User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void User::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_name_.ClearToEmpty();
  _impl_.client_name_.ClearToEmpty();
  _impl_.session_name_.ClearToEmpty();
  ::memset(&_impl_.session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.connect_state_) -
      reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.connect_state_));
  _internal_metadata_.Clear<std::string>();
}

const char* User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string client_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string session_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_session_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.User.ConnectState connect_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_connect_state(static_cast<::proto::task_manager::User_ConnectState>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_name = 1;
  if (!this->_internal_user_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.User.user_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_name(), target);
  }

  // uint32 session_id = 2;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_session_id(), target);
  }

  // string client_name = 3;
  if (!this->_internal_client_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client_name().data(), static_cast<int>(this->_internal_client_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.User.client_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_client_name(), target);
  }

  // string session_name = 4;
  if (!this->_internal_session_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_session_name().data(), static_cast<int>(this->_internal_session_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.task_manager.User.session_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_session_name(), target);
  }

  // .proto.task_manager.User.ConnectState connect_state = 5;
  if (this->_internal_connect_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_connect_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.User)
  return target;
}

size_t User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_name = 1;
  if (!this->_internal_user_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  // string client_name = 3;
  if (!this->_internal_client_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_name());
  }

  // string session_name = 4;
  if (!this->_internal_session_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_session_name());
  }

  // uint32 session_id = 2;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  // .proto.task_manager.User.ConnectState connect_state = 5;
  if (this->_internal_connect_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_connect_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void User::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const User*>(
      &from));
}

void User::MergeFrom(const User& from) {
  User* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_name().empty()) {
    _this->_internal_set_user_name(from._internal_user_name());
  }
  if (!from._internal_client_name().empty()) {
    _this->_internal_set_client_name(from._internal_client_name());
  }
  if (!from._internal_session_name().empty()) {
    _this->_internal_set_session_name(from._internal_session_name());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_connect_state() != 0) {
    _this->_internal_set_connect_state(from._internal_connect_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void User::CopyFrom(const User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  return true;
}

void User::InternalSwap(User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_name_, lhs_arena,
      &other->_impl_.client_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.session_name_, lhs_arena,
      &other->_impl_.session_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(User, _impl_.connect_state_)
      + sizeof(User::_impl_.connect_state_)
      - PROTOBUF_FIELD_OFFSET(User, _impl_.session_id_)>(
          reinterpret_cast<char*>(&_impl_.session_id_),
          reinterpret_cast<char*>(&other->_impl_.session_id_));
}

std::string User::GetTypeName() const {
  return "proto.task_manager.User";
}


// ===================================================================

class UserList::_Internal {
 public:
};

UserList::UserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.UserList)
}
UserList::UserList(const UserList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){from._impl_.user_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.UserList)
}

inline void UserList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserList::~UserList() {
  // @@protoc_insertion_point(destructor:proto.task_manager.UserList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.~RepeatedPtrField();
}

void UserList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.UserList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.task_manager.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.UserList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.task_manager.User user = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_user_size()); i < n; i++) {
    const auto& repfield = this->_internal_user(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.UserList)
  return target;
}

size_t UserList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.UserList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.task_manager.User user = 1;
  total_size += 1UL * this->_internal_user_size();
  for (const auto& msg : this->_impl_.user_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserList*>(
      &from));
}

void UserList::MergeFrom(const UserList& from) {
  UserList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.UserList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_.MergeFrom(from._impl_.user_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserList::CopyFrom(const UserList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.UserList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserList::IsInitialized() const {
  return true;
}

void UserList::InternalSwap(UserList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.user_.InternalSwap(&other->_impl_.user_);
}

std::string UserList::GetTypeName() const {
  return "proto.task_manager.UserList";
}


// ===================================================================

class UserListRequest::_Internal {
 public:
};

UserListRequest::UserListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.UserListRequest)
}
UserListRequest::UserListRequest(const UserListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dummy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.dummy_ = from._impl_.dummy_;
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.UserListRequest)
}

inline void UserListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dummy_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserListRequest::~UserListRequest() {
  // @@protoc_insertion_point(destructor:proto.task_manager.UserListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.UserListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dummy_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* UserListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 dummy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.dummy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.UserListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 dummy = 1;
  if (this->_internal_dummy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dummy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.UserListRequest)
  return target;
}

size_t UserListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.UserListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 dummy = 1;
  if (this->_internal_dummy() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dummy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserListRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserListRequest*>(
      &from));
}

void UserListRequest::MergeFrom(const UserListRequest& from) {
  UserListRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.UserListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dummy() != 0) {
    _this->_internal_set_dummy(from._internal_dummy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserListRequest::CopyFrom(const UserListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.UserListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserListRequest::IsInitialized() const {
  return true;
}

void UserListRequest::InternalSwap(UserListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.dummy_, other->_impl_.dummy_);
}

std::string UserListRequest::GetTypeName() const {
  return "proto.task_manager.UserListRequest";
}


// ===================================================================

class UserRequest::_Internal {
 public:
};

UserRequest::UserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.UserRequest)
}
UserRequest::UserRequest(const UserRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.session_id_){}
    , decltype(_impl_.command_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.session_id_, &from._impl_.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.command_) -
    reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.command_));
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.UserRequest)
}

inline void UserRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.session_id_){0u}
    , decltype(_impl_.command_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserRequest::~UserRequest() {
  // @@protoc_insertion_point(destructor:proto.task_manager.UserRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.UserRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.command_) -
      reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.command_));
  _internal_metadata_.Clear<std::string>();
}

const char* UserRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.UserRequest.Command command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_command(static_cast<::proto::task_manager::UserRequest_Command>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.UserRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 session_id = 1;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // .proto.task_manager.UserRequest.Command command = 2;
  if (this->_internal_command() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.UserRequest)
  return target;
}

size_t UserRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.UserRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 session_id = 1;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  // .proto.task_manager.UserRequest.Command command = 2;
  if (this->_internal_command() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_command());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserRequest*>(
      &from));
}

void UserRequest::MergeFrom(const UserRequest& from) {
  UserRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.UserRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_command() != 0) {
    _this->_internal_set_command(from._internal_command());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserRequest::CopyFrom(const UserRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.UserRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserRequest::IsInitialized() const {
  return true;
}

void UserRequest::InternalSwap(UserRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserRequest, _impl_.command_)
      + sizeof(UserRequest::_impl_.command_)
      - PROTOBUF_FIELD_OFFSET(UserRequest, _impl_.session_id_)>(
          reinterpret_cast<char*>(&_impl_.session_id_),
          reinterpret_cast<char*>(&other->_impl_.session_id_));
}

std::string UserRequest::GetTypeName() const {
  return "proto.task_manager.UserRequest";
}


// ===================================================================

class ClientToHost::_Internal {
 public:
  static const ::proto::task_manager::ProcessListRequest& process_list_request(const ClientToHost* msg);
  static const ::proto::task_manager::EndProcessRequest& end_process_request(const ClientToHost* msg);
  static const ::proto::task_manager::ServiceListRequest& service_list_request(const ClientToHost* msg);
  static const ::proto::task_manager::ServiceRequest& service_request(const ClientToHost* msg);
  static const ::proto::task_manager::UserListRequest& user_list_request(const ClientToHost* msg);
  static const ::proto::task_manager::UserRequest& user_request(const ClientToHost* msg);
};

const ::proto::task_manager::ProcessListRequest&
ClientToHost::_Internal::process_list_request(const ClientToHost* msg) {
  return *msg->_impl_.process_list_request_;
}
const ::proto::task_manager::EndProcessRequest&
ClientToHost::_Internal::end_process_request(const ClientToHost* msg) {
  return *msg->_impl_.end_process_request_;
}
const ::proto::task_manager::ServiceListRequest&
ClientToHost::_Internal::service_list_request(const ClientToHost* msg) {
  return *msg->_impl_.service_list_request_;
}
const ::proto::task_manager::ServiceRequest&
ClientToHost::_Internal::service_request(const ClientToHost* msg) {
  return *msg->_impl_.service_request_;
}
const ::proto::task_manager::UserListRequest&
ClientToHost::_Internal::user_list_request(const ClientToHost* msg) {
  return *msg->_impl_.user_list_request_;
}
const ::proto::task_manager::UserRequest&
ClientToHost::_Internal::user_request(const ClientToHost* msg) {
  return *msg->_impl_.user_request_;
}
ClientToHost::ClientToHost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.ClientToHost)
}
ClientToHost::ClientToHost(const ClientToHost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientToHost* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.process_list_request_){nullptr}
    , decltype(_impl_.end_process_request_){nullptr}
    , decltype(_impl_.service_list_request_){nullptr}
    , decltype(_impl_.service_request_){nullptr}
    , decltype(_impl_.user_list_request_){nullptr}
    , decltype(_impl_.user_request_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_process_list_request()) {
    _this->_impl_.process_list_request_ = new ::proto::task_manager::ProcessListRequest(*from._impl_.process_list_request_);
  }
  if (from._internal_has_end_process_request()) {
    _this->_impl_.end_process_request_ = new ::proto::task_manager::EndProcessRequest(*from._impl_.end_process_request_);
  }
  if (from._internal_has_service_list_request()) {
    _this->_impl_.service_list_request_ = new ::proto::task_manager::ServiceListRequest(*from._impl_.service_list_request_);
  }
  if (from._internal_has_service_request()) {
    _this->_impl_.service_request_ = new ::proto::task_manager::ServiceRequest(*from._impl_.service_request_);
  }
  if (from._internal_has_user_list_request()) {
    _this->_impl_.user_list_request_ = new ::proto::task_manager::UserListRequest(*from._impl_.user_list_request_);
  }
  if (from._internal_has_user_request()) {
    _this->_impl_.user_request_ = new ::proto::task_manager::UserRequest(*from._impl_.user_request_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.ClientToHost)
}

inline void ClientToHost::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.process_list_request_){nullptr}
    , decltype(_impl_.end_process_request_){nullptr}
    , decltype(_impl_.service_list_request_){nullptr}
    , decltype(_impl_.service_request_){nullptr}
    , decltype(_impl_.user_list_request_){nullptr}
    , decltype(_impl_.user_request_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ClientToHost::~ClientToHost() {
  // @@protoc_insertion_point(destructor:proto.task_manager.ClientToHost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientToHost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.process_list_request_;
  if (this != internal_default_instance()) delete _impl_.end_process_request_;
  if (this != internal_default_instance()) delete _impl_.service_list_request_;
  if (this != internal_default_instance()) delete _impl_.service_request_;
  if (this != internal_default_instance()) delete _impl_.user_list_request_;
  if (this != internal_default_instance()) delete _impl_.user_request_;
}

void ClientToHost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientToHost::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.ClientToHost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.process_list_request_ != nullptr) {
    delete _impl_.process_list_request_;
  }
  _impl_.process_list_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.end_process_request_ != nullptr) {
    delete _impl_.end_process_request_;
  }
  _impl_.end_process_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.service_list_request_ != nullptr) {
    delete _impl_.service_list_request_;
  }
  _impl_.service_list_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.service_request_ != nullptr) {
    delete _impl_.service_request_;
  }
  _impl_.service_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.user_list_request_ != nullptr) {
    delete _impl_.user_list_request_;
  }
  _impl_.user_list_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.user_request_ != nullptr) {
    delete _impl_.user_request_;
  }
  _impl_.user_request_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ClientToHost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.task_manager.ProcessListRequest process_list_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_process_list_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.EndProcessRequest end_process_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_process_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.ServiceListRequest service_list_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_list_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.ServiceRequest service_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.UserListRequest user_list_request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_list_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.UserRequest user_request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientToHost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.ClientToHost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.task_manager.ProcessListRequest process_list_request = 1;
  if (this->_internal_has_process_list_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::process_list_request(this),
        _Internal::process_list_request(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.EndProcessRequest end_process_request = 2;
  if (this->_internal_has_end_process_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end_process_request(this),
        _Internal::end_process_request(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.ServiceListRequest service_list_request = 3;
  if (this->_internal_has_service_list_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::service_list_request(this),
        _Internal::service_list_request(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.ServiceRequest service_request = 4;
  if (this->_internal_has_service_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::service_request(this),
        _Internal::service_request(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.UserListRequest user_list_request = 5;
  if (this->_internal_has_user_list_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::user_list_request(this),
        _Internal::user_list_request(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.UserRequest user_request = 6;
  if (this->_internal_has_user_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::user_request(this),
        _Internal::user_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.ClientToHost)
  return target;
}

size_t ClientToHost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.ClientToHost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.task_manager.ProcessListRequest process_list_request = 1;
  if (this->_internal_has_process_list_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.process_list_request_);
  }

  // .proto.task_manager.EndProcessRequest end_process_request = 2;
  if (this->_internal_has_end_process_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.end_process_request_);
  }

  // .proto.task_manager.ServiceListRequest service_list_request = 3;
  if (this->_internal_has_service_list_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.service_list_request_);
  }

  // .proto.task_manager.ServiceRequest service_request = 4;
  if (this->_internal_has_service_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.service_request_);
  }

  // .proto.task_manager.UserListRequest user_list_request = 5;
  if (this->_internal_has_user_list_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_list_request_);
  }

  // .proto.task_manager.UserRequest user_request = 6;
  if (this->_internal_has_user_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_request_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToHost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientToHost*>(
      &from));
}

void ClientToHost::MergeFrom(const ClientToHost& from) {
  ClientToHost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.ClientToHost)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_process_list_request()) {
    _this->_internal_mutable_process_list_request()->::proto::task_manager::ProcessListRequest::MergeFrom(
        from._internal_process_list_request());
  }
  if (from._internal_has_end_process_request()) {
    _this->_internal_mutable_end_process_request()->::proto::task_manager::EndProcessRequest::MergeFrom(
        from._internal_end_process_request());
  }
  if (from._internal_has_service_list_request()) {
    _this->_internal_mutable_service_list_request()->::proto::task_manager::ServiceListRequest::MergeFrom(
        from._internal_service_list_request());
  }
  if (from._internal_has_service_request()) {
    _this->_internal_mutable_service_request()->::proto::task_manager::ServiceRequest::MergeFrom(
        from._internal_service_request());
  }
  if (from._internal_has_user_list_request()) {
    _this->_internal_mutable_user_list_request()->::proto::task_manager::UserListRequest::MergeFrom(
        from._internal_user_list_request());
  }
  if (from._internal_has_user_request()) {
    _this->_internal_mutable_user_request()->::proto::task_manager::UserRequest::MergeFrom(
        from._internal_user_request());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToHost::CopyFrom(const ClientToHost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.ClientToHost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToHost::IsInitialized() const {
  return true;
}

void ClientToHost::InternalSwap(ClientToHost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientToHost, _impl_.user_request_)
      + sizeof(ClientToHost::_impl_.user_request_)
      - PROTOBUF_FIELD_OFFSET(ClientToHost, _impl_.process_list_request_)>(
          reinterpret_cast<char*>(&_impl_.process_list_request_),
          reinterpret_cast<char*>(&other->_impl_.process_list_request_));
}

std::string ClientToHost::GetTypeName() const {
  return "proto.task_manager.ClientToHost";
}


// ===================================================================

class HostToClient::_Internal {
 public:
  static const ::proto::task_manager::ProcessList& process_list(const HostToClient* msg);
  static const ::proto::task_manager::ServiceList& service_list(const HostToClient* msg);
  static const ::proto::task_manager::UserList& user_list(const HostToClient* msg);
};

const ::proto::task_manager::ProcessList&
HostToClient::_Internal::process_list(const HostToClient* msg) {
  return *msg->_impl_.process_list_;
}
const ::proto::task_manager::ServiceList&
HostToClient::_Internal::service_list(const HostToClient* msg) {
  return *msg->_impl_.service_list_;
}
const ::proto::task_manager::UserList&
HostToClient::_Internal::user_list(const HostToClient* msg) {
  return *msg->_impl_.user_list_;
}
HostToClient::HostToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.task_manager.HostToClient)
}
HostToClient::HostToClient(const HostToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.process_list_){nullptr}
    , decltype(_impl_.service_list_){nullptr}
    , decltype(_impl_.user_list_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_process_list()) {
    _this->_impl_.process_list_ = new ::proto::task_manager::ProcessList(*from._impl_.process_list_);
  }
  if (from._internal_has_service_list()) {
    _this->_impl_.service_list_ = new ::proto::task_manager::ServiceList(*from._impl_.service_list_);
  }
  if (from._internal_has_user_list()) {
    _this->_impl_.user_list_ = new ::proto::task_manager::UserList(*from._impl_.user_list_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.task_manager.HostToClient)
}

inline void HostToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.process_list_){nullptr}
    , decltype(_impl_.service_list_){nullptr}
    , decltype(_impl_.user_list_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HostToClient::~HostToClient() {
  // @@protoc_insertion_point(destructor:proto.task_manager.HostToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.process_list_;
  if (this != internal_default_instance()) delete _impl_.service_list_;
  if (this != internal_default_instance()) delete _impl_.user_list_;
}

void HostToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.task_manager.HostToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.process_list_ != nullptr) {
    delete _impl_.process_list_;
  }
  _impl_.process_list_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.service_list_ != nullptr) {
    delete _impl_.service_list_;
  }
  _impl_.service_list_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.user_list_ != nullptr) {
    delete _impl_.user_list_;
  }
  _impl_.user_list_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* HostToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.task_manager.ProcessList process_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_process_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.ServiceList service_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.task_manager.UserList user_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.task_manager.HostToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.task_manager.ProcessList process_list = 1;
  if (this->_internal_has_process_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::process_list(this),
        _Internal::process_list(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.ServiceList service_list = 2;
  if (this->_internal_has_service_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::service_list(this),
        _Internal::service_list(this).GetCachedSize(), target, stream);
  }

  // .proto.task_manager.UserList user_list = 3;
  if (this->_internal_has_user_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::user_list(this),
        _Internal::user_list(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.task_manager.HostToClient)
  return target;
}

size_t HostToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.task_manager.HostToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.task_manager.ProcessList process_list = 1;
  if (this->_internal_has_process_list()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.process_list_);
  }

  // .proto.task_manager.ServiceList service_list = 2;
  if (this->_internal_has_service_list()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.service_list_);
  }

  // .proto.task_manager.UserList user_list = 3;
  if (this->_internal_has_user_list()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_list_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostToClient::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostToClient*>(
      &from));
}

void HostToClient::MergeFrom(const HostToClient& from) {
  HostToClient* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.task_manager.HostToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_process_list()) {
    _this->_internal_mutable_process_list()->::proto::task_manager::ProcessList::MergeFrom(
        from._internal_process_list());
  }
  if (from._internal_has_service_list()) {
    _this->_internal_mutable_service_list()->::proto::task_manager::ServiceList::MergeFrom(
        from._internal_service_list());
  }
  if (from._internal_has_user_list()) {
    _this->_internal_mutable_user_list()->::proto::task_manager::UserList::MergeFrom(
        from._internal_user_list());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostToClient::CopyFrom(const HostToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.task_manager.HostToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostToClient::IsInitialized() const {
  return true;
}

void HostToClient::InternalSwap(HostToClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HostToClient, _impl_.user_list_)
      + sizeof(HostToClient::_impl_.user_list_)
      - PROTOBUF_FIELD_OFFSET(HostToClient, _impl_.process_list_)>(
          reinterpret_cast<char*>(&_impl_.process_list_),
          reinterpret_cast<char*>(&other->_impl_.process_list_));
}

std::string HostToClient::GetTypeName() const {
  return "proto.task_manager.HostToClient";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace task_manager
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::task_manager::Process*
Arena::CreateMaybeMessage< ::proto::task_manager::Process >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::Process >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::ProcessList*
Arena::CreateMaybeMessage< ::proto::task_manager::ProcessList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::ProcessList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::ProcessListRequest*
Arena::CreateMaybeMessage< ::proto::task_manager::ProcessListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::ProcessListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::EndProcessRequest*
Arena::CreateMaybeMessage< ::proto::task_manager::EndProcessRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::EndProcessRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::Service*
Arena::CreateMaybeMessage< ::proto::task_manager::Service >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::Service >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::ServiceList*
Arena::CreateMaybeMessage< ::proto::task_manager::ServiceList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::ServiceList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::ServiceListRequest*
Arena::CreateMaybeMessage< ::proto::task_manager::ServiceListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::ServiceListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::ServiceRequest*
Arena::CreateMaybeMessage< ::proto::task_manager::ServiceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::ServiceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::User*
Arena::CreateMaybeMessage< ::proto::task_manager::User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::User >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::UserList*
Arena::CreateMaybeMessage< ::proto::task_manager::UserList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::UserList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::UserListRequest*
Arena::CreateMaybeMessage< ::proto::task_manager::UserListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::UserListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::UserRequest*
Arena::CreateMaybeMessage< ::proto::task_manager::UserRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::UserRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::ClientToHost*
Arena::CreateMaybeMessage< ::proto::task_manager::ClientToHost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::ClientToHost >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::task_manager::HostToClient*
Arena::CreateMaybeMessage< ::proto::task_manager::HostToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::task_manager::HostToClient >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
