// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: host_internal.proto

#include "host_internal.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
namespace internal {
PROTOBUF_CONSTEXPR CredentialsRequest::CredentialsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CredentialsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CredentialsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CredentialsRequestDefaultTypeInternal() {}
  union {
    CredentialsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CredentialsRequestDefaultTypeInternal _CredentialsRequest_default_instance_;
PROTOBUF_CONSTEXPR Credentials::Credentials(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CredentialsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CredentialsDefaultTypeInternal() {}
  union {
    Credentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CredentialsDefaultTypeInternal _Credentials_default_instance_;
PROTOBUF_CONSTEXPR ConnectEvent::ConnectEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.computer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConnectEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectEventDefaultTypeInternal() {}
  union {
    ConnectEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectEventDefaultTypeInternal _ConnectEvent_default_instance_;
PROTOBUF_CONSTEXPR DisconnectEvent::DisconnectEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DisconnectEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisconnectEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisconnectEventDefaultTypeInternal() {}
  union {
    DisconnectEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisconnectEventDefaultTypeInternal _DisconnectEvent_default_instance_;
PROTOBUF_CONSTEXPR RouterState::RouterState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_port_)*/0u
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RouterStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouterStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouterStateDefaultTypeInternal() {}
  union {
    RouterState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouterStateDefaultTypeInternal _RouterState_default_instance_;
PROTOBUF_CONSTEXPR ConnectConfirmationRequest::ConnectConfirmationRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.computer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.timeout_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConnectConfirmationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectConfirmationRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectConfirmationRequestDefaultTypeInternal() {}
  union {
    ConnectConfirmationRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectConfirmationRequestDefaultTypeInternal _ConnectConfirmationRequest_default_instance_;
PROTOBUF_CONSTEXPR ConnectConfirmation::ConnectConfirmation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.accept_connection_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConnectConfirmationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectConfirmationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectConfirmationDefaultTypeInternal() {}
  union {
    ConnectConfirmation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectConfirmationDefaultTypeInternal _ConnectConfirmation_default_instance_;
PROTOBUF_CONSTEXPR ServiceControl::ServiceControl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ServiceControlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceControlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceControlDefaultTypeInternal() {}
  union {
    ServiceControl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceControlDefaultTypeInternal _ServiceControl_default_instance_;
PROTOBUF_CONSTEXPR VideoRecordingState::VideoRecordingState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.computer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.started_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VideoRecordingStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoRecordingStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoRecordingStateDefaultTypeInternal() {}
  union {
    VideoRecordingState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoRecordingStateDefaultTypeInternal _VideoRecordingState_default_instance_;
PROTOBUF_CONSTEXPR UiToService::UiToService(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.credentials_request_)*/nullptr
  , /*decltype(_impl_.connect_confirmation_)*/nullptr
  , /*decltype(_impl_.control_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UiToServiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UiToServiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UiToServiceDefaultTypeInternal() {}
  union {
    UiToService _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UiToServiceDefaultTypeInternal _UiToService_default_instance_;
PROTOBUF_CONSTEXPR ServiceToUi::ServiceToUi(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.router_state_)*/nullptr
  , /*decltype(_impl_.credentials_)*/nullptr
  , /*decltype(_impl_.connect_event_)*/nullptr
  , /*decltype(_impl_.disconnect_event_)*/nullptr
  , /*decltype(_impl_.connect_confirmation_request_)*/nullptr
  , /*decltype(_impl_.video_recording_state_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServiceToUiDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceToUiDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceToUiDefaultTypeInternal() {}
  union {
    ServiceToUi _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceToUiDefaultTypeInternal _ServiceToUi_default_instance_;
}  // namespace internal
}  // namespace proto
namespace proto {
namespace internal {
bool CredentialsRequest_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CredentialsRequest_Type_strings[3] = {};

static const char CredentialsRequest_Type_names[] =
  "NEW_PASSWORD"
  "REFRESH"
  "UNKNOWN_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CredentialsRequest_Type_entries[] = {
  { {CredentialsRequest_Type_names + 0, 12}, 2 },
  { {CredentialsRequest_Type_names + 12, 7}, 1 },
  { {CredentialsRequest_Type_names + 19, 12}, 0 },
};

static const int CredentialsRequest_Type_entries_by_number[] = {
  2, // 0 -> UNKNOWN_TYPE
  1, // 1 -> REFRESH
  0, // 2 -> NEW_PASSWORD
};

const std::string& CredentialsRequest_Type_Name(
    CredentialsRequest_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CredentialsRequest_Type_entries,
          CredentialsRequest_Type_entries_by_number,
          3, CredentialsRequest_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CredentialsRequest_Type_entries,
      CredentialsRequest_Type_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CredentialsRequest_Type_strings[idx].get();
}
bool CredentialsRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CredentialsRequest_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CredentialsRequest_Type_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CredentialsRequest_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CredentialsRequest_Type CredentialsRequest::UNKNOWN_TYPE;
constexpr CredentialsRequest_Type CredentialsRequest::REFRESH;
constexpr CredentialsRequest_Type CredentialsRequest::NEW_PASSWORD;
constexpr CredentialsRequest_Type CredentialsRequest::Type_MIN;
constexpr CredentialsRequest_Type CredentialsRequest::Type_MAX;
constexpr int CredentialsRequest::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RouterState_State_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RouterState_State_strings[5] = {};

static const char RouterState_State_names[] =
  "CONNECTED"
  "CONNECTING"
  "DISABLED"
  "FAILED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RouterState_State_entries[] = {
  { {RouterState_State_names + 0, 9}, 3 },
  { {RouterState_State_names + 9, 10}, 2 },
  { {RouterState_State_names + 19, 8}, 1 },
  { {RouterState_State_names + 27, 6}, 4 },
  { {RouterState_State_names + 33, 7}, 0 },
};

static const int RouterState_State_entries_by_number[] = {
  4, // 0 -> UNKNOWN
  2, // 1 -> DISABLED
  1, // 2 -> CONNECTING
  0, // 3 -> CONNECTED
  3, // 4 -> FAILED
};

const std::string& RouterState_State_Name(
    RouterState_State value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RouterState_State_entries,
          RouterState_State_entries_by_number,
          5, RouterState_State_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RouterState_State_entries,
      RouterState_State_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RouterState_State_strings[idx].get();
}
bool RouterState_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouterState_State* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RouterState_State_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<RouterState_State>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RouterState_State RouterState::UNKNOWN;
constexpr RouterState_State RouterState::DISABLED;
constexpr RouterState_State RouterState::CONNECTING;
constexpr RouterState_State RouterState::CONNECTED;
constexpr RouterState_State RouterState::FAILED;
constexpr RouterState_State RouterState::State_MIN;
constexpr RouterState_State RouterState::State_MAX;
constexpr int RouterState::State_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceControl_Code_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceControl_Code_strings[6] = {};

static const char ServiceControl_Code_names[] =
  "CODE_KILL"
  "CODE_LOCK_KEYBOARD"
  "CODE_LOCK_MOUSE"
  "CODE_PAUSE"
  "CODE_UNKNOWN"
  "CODE_VOICE_CHAT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceControl_Code_entries[] = {
  { {ServiceControl_Code_names + 0, 9}, 1 },
  { {ServiceControl_Code_names + 9, 18}, 4 },
  { {ServiceControl_Code_names + 27, 15}, 3 },
  { {ServiceControl_Code_names + 42, 10}, 2 },
  { {ServiceControl_Code_names + 52, 12}, 0 },
  { {ServiceControl_Code_names + 64, 15}, 5 },
};

static const int ServiceControl_Code_entries_by_number[] = {
  4, // 0 -> CODE_UNKNOWN
  0, // 1 -> CODE_KILL
  3, // 2 -> CODE_PAUSE
  2, // 3 -> CODE_LOCK_MOUSE
  1, // 4 -> CODE_LOCK_KEYBOARD
  5, // 5 -> CODE_VOICE_CHAT
};

const std::string& ServiceControl_Code_Name(
    ServiceControl_Code value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceControl_Code_entries,
          ServiceControl_Code_entries_by_number,
          6, ServiceControl_Code_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceControl_Code_entries,
      ServiceControl_Code_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceControl_Code_strings[idx].get();
}
bool ServiceControl_Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceControl_Code* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceControl_Code_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ServiceControl_Code>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceControl_Code ServiceControl::CODE_UNKNOWN;
constexpr ServiceControl_Code ServiceControl::CODE_KILL;
constexpr ServiceControl_Code ServiceControl::CODE_PAUSE;
constexpr ServiceControl_Code ServiceControl::CODE_LOCK_MOUSE;
constexpr ServiceControl_Code ServiceControl::CODE_LOCK_KEYBOARD;
constexpr ServiceControl_Code ServiceControl::CODE_VOICE_CHAT;
constexpr ServiceControl_Code ServiceControl::Code_MIN;
constexpr ServiceControl_Code ServiceControl::Code_MAX;
constexpr int ServiceControl::Code_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class CredentialsRequest::_Internal {
 public:
};

CredentialsRequest::CredentialsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.CredentialsRequest)
}
CredentialsRequest::CredentialsRequest(const CredentialsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CredentialsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:proto.internal.CredentialsRequest)
}

inline void CredentialsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CredentialsRequest::~CredentialsRequest() {
  // @@protoc_insertion_point(destructor:proto.internal.CredentialsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CredentialsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CredentialsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CredentialsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.CredentialsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* CredentialsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.internal.CredentialsRequest.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::proto::internal::CredentialsRequest_Type>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CredentialsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.CredentialsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.internal.CredentialsRequest.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.CredentialsRequest)
  return target;
}

size_t CredentialsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.CredentialsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.internal.CredentialsRequest.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CredentialsRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CredentialsRequest*>(
      &from));
}

void CredentialsRequest::MergeFrom(const CredentialsRequest& from) {
  CredentialsRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.CredentialsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CredentialsRequest::CopyFrom(const CredentialsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.CredentialsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CredentialsRequest::IsInitialized() const {
  return true;
}

void CredentialsRequest::InternalSwap(CredentialsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string CredentialsRequest::GetTypeName() const {
  return "proto.internal.CredentialsRequest";
}


// ===================================================================

class Credentials::_Internal {
 public:
};

Credentials::Credentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.Credentials)
}
Credentials::Credentials(const Credentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Credentials* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.password_){}
    , decltype(_impl_.host_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.host_id_ = from._impl_.host_id_;
  // @@protoc_insertion_point(copy_constructor:proto.internal.Credentials)
}

inline void Credentials::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.password_){}
    , decltype(_impl_.host_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Credentials::~Credentials() {
  // @@protoc_insertion_point(destructor:proto.internal.Credentials)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Credentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.password_.Destroy();
}

void Credentials::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Credentials::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.Credentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.password_.ClearToEmpty();
  _impl_.host_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Credentials::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 host_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Credentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.Credentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_host_id(), target);
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.Credentials.password");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.Credentials)
  return target;
}

size_t Credentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.Credentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Credentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Credentials*>(
      &from));
}

void Credentials::MergeFrom(const Credentials& from) {
  Credentials* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.Credentials)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (from._internal_host_id() != 0) {
    _this->_internal_set_host_id(from._internal_host_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Credentials::CopyFrom(const Credentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.Credentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Credentials::IsInitialized() const {
  return true;
}

void Credentials::InternalSwap(Credentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  swap(_impl_.host_id_, other->_impl_.host_id_);
}

std::string Credentials::GetTypeName() const {
  return "proto.internal.Credentials";
}


// ===================================================================

class ConnectEvent::_Internal {
 public:
};

ConnectEvent::ConnectEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.ConnectEvent)
}
ConnectEvent::ConnectEvent(const ConnectEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.computer_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.session_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_computer_name().empty()) {
    _this->_impl_.computer_name_.Set(from._internal_computer_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.session_type_));
  // @@protoc_insertion_point(copy_constructor:proto.internal.ConnectEvent)
}

inline void ConnectEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.computer_name_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.session_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectEvent::~ConnectEvent() {
  // @@protoc_insertion_point(destructor:proto.internal.ConnectEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.computer_name_.Destroy();
}

void ConnectEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.ConnectEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.computer_name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.session_type_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.session_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string computer_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_computer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.SessionType session_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::proto::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.ConnectEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // string computer_name = 2;
  if (!this->_internal_computer_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_computer_name().data(), static_cast<int>(this->_internal_computer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.ConnectEvent.computer_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_computer_name(), target);
  }

  // .proto.SessionType session_type = 3;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.ConnectEvent)
  return target;
}

size_t ConnectEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.ConnectEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string computer_name = 2;
  if (!this->_internal_computer_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_computer_name());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // .proto.SessionType session_type = 3;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectEvent*>(
      &from));
}

void ConnectEvent::MergeFrom(const ConnectEvent& from) {
  ConnectEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.ConnectEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_computer_name().empty()) {
    _this->_internal_set_computer_name(from._internal_computer_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectEvent::CopyFrom(const ConnectEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.ConnectEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectEvent::IsInitialized() const {
  return true;
}

void ConnectEvent::InternalSwap(ConnectEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.computer_name_, lhs_arena,
      &other->_impl_.computer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectEvent, _impl_.session_type_)
      + sizeof(ConnectEvent::_impl_.session_type_)
      - PROTOBUF_FIELD_OFFSET(ConnectEvent, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string ConnectEvent::GetTypeName() const {
  return "proto.internal.ConnectEvent";
}


// ===================================================================

class DisconnectEvent::_Internal {
 public:
};

DisconnectEvent::DisconnectEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.DisconnectEvent)
}
DisconnectEvent::DisconnectEvent(const DisconnectEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DisconnectEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:proto.internal.DisconnectEvent)
}

inline void DisconnectEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DisconnectEvent::~DisconnectEvent() {
  // @@protoc_insertion_point(destructor:proto.internal.DisconnectEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DisconnectEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DisconnectEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DisconnectEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.DisconnectEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* DisconnectEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisconnectEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.DisconnectEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.DisconnectEvent)
  return target;
}

size_t DisconnectEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.DisconnectEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DisconnectEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DisconnectEvent*>(
      &from));
}

void DisconnectEvent::MergeFrom(const DisconnectEvent& from) {
  DisconnectEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.DisconnectEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisconnectEvent::CopyFrom(const DisconnectEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.DisconnectEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisconnectEvent::IsInitialized() const {
  return true;
}

void DisconnectEvent::InternalSwap(DisconnectEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

std::string DisconnectEvent::GetTypeName() const {
  return "proto.internal.DisconnectEvent";
}


// ===================================================================

class RouterState::_Internal {
 public:
};

RouterState::RouterState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.RouterState)
}
RouterState::RouterState(const RouterState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RouterState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_name_){}
    , decltype(_impl_.host_port_){}
    , decltype(_impl_.state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host_name().empty()) {
    _this->_impl_.host_name_.Set(from._internal_host_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.host_port_, &from._impl_.host_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) -
    reinterpret_cast<char*>(&_impl_.host_port_)) + sizeof(_impl_.state_));
  // @@protoc_insertion_point(copy_constructor:proto.internal.RouterState)
}

inline void RouterState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_name_){}
    , decltype(_impl_.host_port_){0u}
    , decltype(_impl_.state_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RouterState::~RouterState() {
  // @@protoc_insertion_point(destructor:proto.internal.RouterState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouterState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_name_.Destroy();
}

void RouterState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RouterState::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.RouterState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_name_.ClearToEmpty();
  ::memset(&_impl_.host_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.state_) -
      reinterpret_cast<char*>(&_impl_.host_port_)) + sizeof(_impl_.state_));
  _internal_metadata_.Clear<std::string>();
}

const char* RouterState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string host_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_host_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 host_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.host_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.RouterState.State state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::proto::internal::RouterState_State>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouterState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.RouterState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string host_name = 1;
  if (!this->_internal_host_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host_name().data(), static_cast<int>(this->_internal_host_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.RouterState.host_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_host_name(), target);
  }

  // uint32 host_port = 2;
  if (this->_internal_host_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_host_port(), target);
  }

  // .proto.internal.RouterState.State state = 3;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.RouterState)
  return target;
}

size_t RouterState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.RouterState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string host_name = 1;
  if (!this->_internal_host_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host_name());
  }

  // uint32 host_port = 2;
  if (this->_internal_host_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_host_port());
  }

  // .proto.internal.RouterState.State state = 3;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RouterState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RouterState*>(
      &from));
}

void RouterState::MergeFrom(const RouterState& from) {
  RouterState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.RouterState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_host_name().empty()) {
    _this->_internal_set_host_name(from._internal_host_name());
  }
  if (from._internal_host_port() != 0) {
    _this->_internal_set_host_port(from._internal_host_port());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RouterState::CopyFrom(const RouterState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.RouterState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouterState::IsInitialized() const {
  return true;
}

void RouterState::InternalSwap(RouterState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_name_, lhs_arena,
      &other->_impl_.host_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RouterState, _impl_.state_)
      + sizeof(RouterState::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(RouterState, _impl_.host_port_)>(
          reinterpret_cast<char*>(&_impl_.host_port_),
          reinterpret_cast<char*>(&other->_impl_.host_port_));
}

std::string RouterState::GetTypeName() const {
  return "proto.internal.RouterState";
}


// ===================================================================

class ConnectConfirmationRequest::_Internal {
 public:
};

ConnectConfirmationRequest::ConnectConfirmationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.ConnectConfirmationRequest)
}
ConnectConfirmationRequest::ConnectConfirmationRequest(const ConnectConfirmationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectConfirmationRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_name_){}
    , decltype(_impl_.computer_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.timeout_){}
    , decltype(_impl_.session_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_name().empty()) {
    _this->_impl_.user_name_.Set(from._internal_user_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_computer_name().empty()) {
    _this->_impl_.computer_name_.Set(from._internal_computer_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.session_type_));
  // @@protoc_insertion_point(copy_constructor:proto.internal.ConnectConfirmationRequest)
}

inline void ConnectConfirmationRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_name_){}
    , decltype(_impl_.computer_name_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.timeout_){0u}
    , decltype(_impl_.session_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectConfirmationRequest::~ConnectConfirmationRequest() {
  // @@protoc_insertion_point(destructor:proto.internal.ConnectConfirmationRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectConfirmationRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.Destroy();
  _impl_.computer_name_.Destroy();
}

void ConnectConfirmationRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectConfirmationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.ConnectConfirmationRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_name_.ClearToEmpty();
  _impl_.computer_name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.session_type_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.session_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectConfirmationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 timeout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string computer_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_computer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.SessionType session_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::proto::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectConfirmationRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.ConnectConfirmationRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // uint32 timeout = 2;
  if (this->_internal_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timeout(), target);
  }

  // string user_name = 3;
  if (!this->_internal_user_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.ConnectConfirmationRequest.user_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_name(), target);
  }

  // string computer_name = 4;
  if (!this->_internal_computer_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_computer_name().data(), static_cast<int>(this->_internal_computer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.ConnectConfirmationRequest.computer_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_computer_name(), target);
  }

  // .proto.SessionType session_type = 5;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_session_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.ConnectConfirmationRequest)
  return target;
}

size_t ConnectConfirmationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.ConnectConfirmationRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_name = 3;
  if (!this->_internal_user_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  // string computer_name = 4;
  if (!this->_internal_computer_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_computer_name());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // uint32 timeout = 2;
  if (this->_internal_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timeout());
  }

  // .proto.SessionType session_type = 5;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectConfirmationRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectConfirmationRequest*>(
      &from));
}

void ConnectConfirmationRequest::MergeFrom(const ConnectConfirmationRequest& from) {
  ConnectConfirmationRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.ConnectConfirmationRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_name().empty()) {
    _this->_internal_set_user_name(from._internal_user_name());
  }
  if (!from._internal_computer_name().empty()) {
    _this->_internal_set_computer_name(from._internal_computer_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_timeout() != 0) {
    _this->_internal_set_timeout(from._internal_timeout());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectConfirmationRequest::CopyFrom(const ConnectConfirmationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.ConnectConfirmationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectConfirmationRequest::IsInitialized() const {
  return true;
}

void ConnectConfirmationRequest::InternalSwap(ConnectConfirmationRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.computer_name_, lhs_arena,
      &other->_impl_.computer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectConfirmationRequest, _impl_.session_type_)
      + sizeof(ConnectConfirmationRequest::_impl_.session_type_)
      - PROTOBUF_FIELD_OFFSET(ConnectConfirmationRequest, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string ConnectConfirmationRequest::GetTypeName() const {
  return "proto.internal.ConnectConfirmationRequest";
}


// ===================================================================

class ConnectConfirmation::_Internal {
 public:
};

ConnectConfirmation::ConnectConfirmation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.ConnectConfirmation)
}
ConnectConfirmation::ConnectConfirmation(const ConnectConfirmation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectConfirmation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.accept_connection_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.accept_connection_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.accept_connection_));
  // @@protoc_insertion_point(copy_constructor:proto.internal.ConnectConfirmation)
}

inline void ConnectConfirmation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , decltype(_impl_.accept_connection_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConnectConfirmation::~ConnectConfirmation() {
  // @@protoc_insertion_point(destructor:proto.internal.ConnectConfirmation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectConfirmation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectConfirmation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectConfirmation::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.ConnectConfirmation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.accept_connection_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.accept_connection_));
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectConfirmation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool accept_connection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accept_connection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectConfirmation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.ConnectConfirmation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // bool accept_connection = 2;
  if (this->_internal_accept_connection() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_accept_connection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.ConnectConfirmation)
  return target;
}

size_t ConnectConfirmation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.ConnectConfirmation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // bool accept_connection = 2;
  if (this->_internal_accept_connection() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectConfirmation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectConfirmation*>(
      &from));
}

void ConnectConfirmation::MergeFrom(const ConnectConfirmation& from) {
  ConnectConfirmation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.ConnectConfirmation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_accept_connection() != 0) {
    _this->_internal_set_accept_connection(from._internal_accept_connection());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectConfirmation::CopyFrom(const ConnectConfirmation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.ConnectConfirmation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectConfirmation::IsInitialized() const {
  return true;
}

void ConnectConfirmation::InternalSwap(ConnectConfirmation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectConfirmation, _impl_.accept_connection_)
      + sizeof(ConnectConfirmation::_impl_.accept_connection_)
      - PROTOBUF_FIELD_OFFSET(ConnectConfirmation, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string ConnectConfirmation::GetTypeName() const {
  return "proto.internal.ConnectConfirmation";
}


// ===================================================================

class ServiceControl::_Internal {
 public:
};

ServiceControl::ServiceControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.ServiceControl)
}
ServiceControl::ServiceControl(const ServiceControl& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServiceControl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.code_ = from._impl_.code_;
  clear_has_value();
  switch (from.value_case()) {
    case kSignedInteger: {
      _this->_internal_set_signed_integer(from._internal_signed_integer());
      break;
    }
    case kUnsignedInteger: {
      _this->_internal_set_unsigned_integer(from._internal_unsigned_integer());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case kUtf8String: {
      _this->_internal_set_utf8_string(from._internal_utf8_string());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.internal.ServiceControl)
}

inline void ServiceControl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){0}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_value();
}

ServiceControl::~ServiceControl() {
  // @@protoc_insertion_point(destructor:proto.internal.ServiceControl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceControl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void ServiceControl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceControl::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:proto.internal.ServiceControl)
  switch (value_case()) {
    case kSignedInteger: {
      // No need to clear
      break;
    }
    case kUnsignedInteger: {
      // No need to clear
      break;
    }
    case kBoolean: {
      // No need to clear
      break;
    }
    case kUtf8String: {
      _impl_.value_.utf8_string_.Destroy();
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}


void ServiceControl::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.ServiceControl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.code_ = 0;
  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceControl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.internal.ServiceControl.Code code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_code(static_cast<::proto::internal::ServiceControl_Code>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 signed_integer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_signed_integer(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 unsigned_integer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_unsigned_integer(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool boolean = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_boolean(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string utf8_string = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_utf8_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceControl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.ServiceControl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.internal.ServiceControl.Code code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_code(), target);
  }

  // int64 signed_integer = 2;
  if (_internal_has_signed_integer()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_signed_integer(), target);
  }

  // uint64 unsigned_integer = 3;
  if (_internal_has_unsigned_integer()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_unsigned_integer(), target);
  }

  // bool boolean = 4;
  if (_internal_has_boolean()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_boolean(), target);
  }

  // string utf8_string = 5;
  if (_internal_has_utf8_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_utf8_string().data(), static_cast<int>(this->_internal_utf8_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.ServiceControl.utf8_string");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_utf8_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.ServiceControl)
  return target;
}

size_t ServiceControl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.ServiceControl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.internal.ServiceControl.Code code = 1;
  if (this->_internal_code() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_code());
  }

  switch (value_case()) {
    // int64 signed_integer = 2;
    case kSignedInteger: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_signed_integer());
      break;
    }
    // uint64 unsigned_integer = 3;
    case kUnsignedInteger: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_unsigned_integer());
      break;
    }
    // bool boolean = 4;
    case kBoolean: {
      total_size += 1 + 1;
      break;
    }
    // string utf8_string = 5;
    case kUtf8String: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_utf8_string());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceControl::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceControl*>(
      &from));
}

void ServiceControl::MergeFrom(const ServiceControl& from) {
  ServiceControl* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.ServiceControl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  switch (from.value_case()) {
    case kSignedInteger: {
      _this->_internal_set_signed_integer(from._internal_signed_integer());
      break;
    }
    case kUnsignedInteger: {
      _this->_internal_set_unsigned_integer(from._internal_unsigned_integer());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case kUtf8String: {
      _this->_internal_set_utf8_string(from._internal_utf8_string());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceControl::CopyFrom(const ServiceControl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.ServiceControl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceControl::IsInitialized() const {
  return true;
}

void ServiceControl::InternalSwap(ServiceControl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.code_, other->_impl_.code_);
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ServiceControl::GetTypeName() const {
  return "proto.internal.ServiceControl";
}


// ===================================================================

class VideoRecordingState::_Internal {
 public:
};

VideoRecordingState::VideoRecordingState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.VideoRecordingState)
}
VideoRecordingState::VideoRecordingState(const VideoRecordingState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VideoRecordingState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.computer_name_){}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.started_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_computer_name().empty()) {
    _this->_impl_.computer_name_.Set(from._internal_computer_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_name().empty()) {
    _this->_impl_.user_name_.Set(from._internal_user_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.started_ = from._impl_.started_;
  // @@protoc_insertion_point(copy_constructor:proto.internal.VideoRecordingState)
}

inline void VideoRecordingState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.computer_name_){}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.started_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VideoRecordingState::~VideoRecordingState() {
  // @@protoc_insertion_point(destructor:proto.internal.VideoRecordingState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoRecordingState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.computer_name_.Destroy();
  _impl_.user_name_.Destroy();
}

void VideoRecordingState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoRecordingState::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.VideoRecordingState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.computer_name_.ClearToEmpty();
  _impl_.user_name_.ClearToEmpty();
  _impl_.started_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* VideoRecordingState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string computer_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_computer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool started = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoRecordingState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.VideoRecordingState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string computer_name = 1;
  if (!this->_internal_computer_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_computer_name().data(), static_cast<int>(this->_internal_computer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.VideoRecordingState.computer_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_computer_name(), target);
  }

  // string user_name = 2;
  if (!this->_internal_user_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.internal.VideoRecordingState.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  // bool started = 3;
  if (this->_internal_started() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_started(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.VideoRecordingState)
  return target;
}

size_t VideoRecordingState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.VideoRecordingState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string computer_name = 1;
  if (!this->_internal_computer_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_computer_name());
  }

  // string user_name = 2;
  if (!this->_internal_user_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  // bool started = 3;
  if (this->_internal_started() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoRecordingState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoRecordingState*>(
      &from));
}

void VideoRecordingState::MergeFrom(const VideoRecordingState& from) {
  VideoRecordingState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.VideoRecordingState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_computer_name().empty()) {
    _this->_internal_set_computer_name(from._internal_computer_name());
  }
  if (!from._internal_user_name().empty()) {
    _this->_internal_set_user_name(from._internal_user_name());
  }
  if (from._internal_started() != 0) {
    _this->_internal_set_started(from._internal_started());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoRecordingState::CopyFrom(const VideoRecordingState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.VideoRecordingState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoRecordingState::IsInitialized() const {
  return true;
}

void VideoRecordingState::InternalSwap(VideoRecordingState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.computer_name_, lhs_arena,
      &other->_impl_.computer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  swap(_impl_.started_, other->_impl_.started_);
}

std::string VideoRecordingState::GetTypeName() const {
  return "proto.internal.VideoRecordingState";
}


// ===================================================================

class UiToService::_Internal {
 public:
  static const ::proto::internal::CredentialsRequest& credentials_request(const UiToService* msg);
  static const ::proto::internal::ConnectConfirmation& connect_confirmation(const UiToService* msg);
  static const ::proto::internal::ServiceControl& control(const UiToService* msg);
};

const ::proto::internal::CredentialsRequest&
UiToService::_Internal::credentials_request(const UiToService* msg) {
  return *msg->_impl_.credentials_request_;
}
const ::proto::internal::ConnectConfirmation&
UiToService::_Internal::connect_confirmation(const UiToService* msg) {
  return *msg->_impl_.connect_confirmation_;
}
const ::proto::internal::ServiceControl&
UiToService::_Internal::control(const UiToService* msg) {
  return *msg->_impl_.control_;
}
UiToService::UiToService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.UiToService)
}
UiToService::UiToService(const UiToService& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UiToService* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.credentials_request_){nullptr}
    , decltype(_impl_.connect_confirmation_){nullptr}
    , decltype(_impl_.control_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_credentials_request()) {
    _this->_impl_.credentials_request_ = new ::proto::internal::CredentialsRequest(*from._impl_.credentials_request_);
  }
  if (from._internal_has_connect_confirmation()) {
    _this->_impl_.connect_confirmation_ = new ::proto::internal::ConnectConfirmation(*from._impl_.connect_confirmation_);
  }
  if (from._internal_has_control()) {
    _this->_impl_.control_ = new ::proto::internal::ServiceControl(*from._impl_.control_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.internal.UiToService)
}

inline void UiToService::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.credentials_request_){nullptr}
    , decltype(_impl_.connect_confirmation_){nullptr}
    , decltype(_impl_.control_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UiToService::~UiToService() {
  // @@protoc_insertion_point(destructor:proto.internal.UiToService)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UiToService::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.credentials_request_;
  if (this != internal_default_instance()) delete _impl_.connect_confirmation_;
  if (this != internal_default_instance()) delete _impl_.control_;
}

void UiToService::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UiToService::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.UiToService)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.credentials_request_ != nullptr) {
    delete _impl_.credentials_request_;
  }
  _impl_.credentials_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.connect_confirmation_ != nullptr) {
    delete _impl_.connect_confirmation_;
  }
  _impl_.connect_confirmation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* UiToService::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.internal.CredentialsRequest credentials_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_credentials_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.ConnectConfirmation connect_confirmation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_confirmation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.ServiceControl control = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_control(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UiToService::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.UiToService)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.internal.CredentialsRequest credentials_request = 1;
  if (this->_internal_has_credentials_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::credentials_request(this),
        _Internal::credentials_request(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.ConnectConfirmation connect_confirmation = 2;
  if (this->_internal_has_connect_confirmation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connect_confirmation(this),
        _Internal::connect_confirmation(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.ServiceControl control = 3;
  if (this->_internal_has_control()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::control(this),
        _Internal::control(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.UiToService)
  return target;
}

size_t UiToService::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.UiToService)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.internal.CredentialsRequest credentials_request = 1;
  if (this->_internal_has_credentials_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.credentials_request_);
  }

  // .proto.internal.ConnectConfirmation connect_confirmation = 2;
  if (this->_internal_has_connect_confirmation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connect_confirmation_);
  }

  // .proto.internal.ServiceControl control = 3;
  if (this->_internal_has_control()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.control_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UiToService::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UiToService*>(
      &from));
}

void UiToService::MergeFrom(const UiToService& from) {
  UiToService* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.UiToService)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_credentials_request()) {
    _this->_internal_mutable_credentials_request()->::proto::internal::CredentialsRequest::MergeFrom(
        from._internal_credentials_request());
  }
  if (from._internal_has_connect_confirmation()) {
    _this->_internal_mutable_connect_confirmation()->::proto::internal::ConnectConfirmation::MergeFrom(
        from._internal_connect_confirmation());
  }
  if (from._internal_has_control()) {
    _this->_internal_mutable_control()->::proto::internal::ServiceControl::MergeFrom(
        from._internal_control());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UiToService::CopyFrom(const UiToService& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.UiToService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UiToService::IsInitialized() const {
  return true;
}

void UiToService::InternalSwap(UiToService* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UiToService, _impl_.control_)
      + sizeof(UiToService::_impl_.control_)
      - PROTOBUF_FIELD_OFFSET(UiToService, _impl_.credentials_request_)>(
          reinterpret_cast<char*>(&_impl_.credentials_request_),
          reinterpret_cast<char*>(&other->_impl_.credentials_request_));
}

std::string UiToService::GetTypeName() const {
  return "proto.internal.UiToService";
}


// ===================================================================

class ServiceToUi::_Internal {
 public:
  static const ::proto::internal::RouterState& router_state(const ServiceToUi* msg);
  static const ::proto::internal::Credentials& credentials(const ServiceToUi* msg);
  static const ::proto::internal::ConnectEvent& connect_event(const ServiceToUi* msg);
  static const ::proto::internal::DisconnectEvent& disconnect_event(const ServiceToUi* msg);
  static const ::proto::internal::ConnectConfirmationRequest& connect_confirmation_request(const ServiceToUi* msg);
  static const ::proto::internal::VideoRecordingState& video_recording_state(const ServiceToUi* msg);
};

const ::proto::internal::RouterState&
ServiceToUi::_Internal::router_state(const ServiceToUi* msg) {
  return *msg->_impl_.router_state_;
}
const ::proto::internal::Credentials&
ServiceToUi::_Internal::credentials(const ServiceToUi* msg) {
  return *msg->_impl_.credentials_;
}
const ::proto::internal::ConnectEvent&
ServiceToUi::_Internal::connect_event(const ServiceToUi* msg) {
  return *msg->_impl_.connect_event_;
}
const ::proto::internal::DisconnectEvent&
ServiceToUi::_Internal::disconnect_event(const ServiceToUi* msg) {
  return *msg->_impl_.disconnect_event_;
}
const ::proto::internal::ConnectConfirmationRequest&
ServiceToUi::_Internal::connect_confirmation_request(const ServiceToUi* msg) {
  return *msg->_impl_.connect_confirmation_request_;
}
const ::proto::internal::VideoRecordingState&
ServiceToUi::_Internal::video_recording_state(const ServiceToUi* msg) {
  return *msg->_impl_.video_recording_state_;
}
ServiceToUi::ServiceToUi(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.internal.ServiceToUi)
}
ServiceToUi::ServiceToUi(const ServiceToUi& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServiceToUi* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.router_state_){nullptr}
    , decltype(_impl_.credentials_){nullptr}
    , decltype(_impl_.connect_event_){nullptr}
    , decltype(_impl_.disconnect_event_){nullptr}
    , decltype(_impl_.connect_confirmation_request_){nullptr}
    , decltype(_impl_.video_recording_state_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_router_state()) {
    _this->_impl_.router_state_ = new ::proto::internal::RouterState(*from._impl_.router_state_);
  }
  if (from._internal_has_credentials()) {
    _this->_impl_.credentials_ = new ::proto::internal::Credentials(*from._impl_.credentials_);
  }
  if (from._internal_has_connect_event()) {
    _this->_impl_.connect_event_ = new ::proto::internal::ConnectEvent(*from._impl_.connect_event_);
  }
  if (from._internal_has_disconnect_event()) {
    _this->_impl_.disconnect_event_ = new ::proto::internal::DisconnectEvent(*from._impl_.disconnect_event_);
  }
  if (from._internal_has_connect_confirmation_request()) {
    _this->_impl_.connect_confirmation_request_ = new ::proto::internal::ConnectConfirmationRequest(*from._impl_.connect_confirmation_request_);
  }
  if (from._internal_has_video_recording_state()) {
    _this->_impl_.video_recording_state_ = new ::proto::internal::VideoRecordingState(*from._impl_.video_recording_state_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.internal.ServiceToUi)
}

inline void ServiceToUi::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.router_state_){nullptr}
    , decltype(_impl_.credentials_){nullptr}
    , decltype(_impl_.connect_event_){nullptr}
    , decltype(_impl_.disconnect_event_){nullptr}
    , decltype(_impl_.connect_confirmation_request_){nullptr}
    , decltype(_impl_.video_recording_state_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServiceToUi::~ServiceToUi() {
  // @@protoc_insertion_point(destructor:proto.internal.ServiceToUi)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceToUi::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.router_state_;
  if (this != internal_default_instance()) delete _impl_.credentials_;
  if (this != internal_default_instance()) delete _impl_.connect_event_;
  if (this != internal_default_instance()) delete _impl_.disconnect_event_;
  if (this != internal_default_instance()) delete _impl_.connect_confirmation_request_;
  if (this != internal_default_instance()) delete _impl_.video_recording_state_;
}

void ServiceToUi::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceToUi::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.internal.ServiceToUi)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.router_state_ != nullptr) {
    delete _impl_.router_state_;
  }
  _impl_.router_state_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.credentials_ != nullptr) {
    delete _impl_.credentials_;
  }
  _impl_.credentials_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.connect_event_ != nullptr) {
    delete _impl_.connect_event_;
  }
  _impl_.connect_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.disconnect_event_ != nullptr) {
    delete _impl_.disconnect_event_;
  }
  _impl_.disconnect_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.connect_confirmation_request_ != nullptr) {
    delete _impl_.connect_confirmation_request_;
  }
  _impl_.connect_confirmation_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.video_recording_state_ != nullptr) {
    delete _impl_.video_recording_state_;
  }
  _impl_.video_recording_state_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceToUi::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.internal.RouterState router_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_router_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.Credentials credentials = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.ConnectEvent connect_event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.DisconnectEvent disconnect_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_disconnect_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.ConnectConfirmationRequest connect_confirmation_request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_confirmation_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.internal.VideoRecordingState video_recording_state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_recording_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceToUi::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.internal.ServiceToUi)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.internal.RouterState router_state = 1;
  if (this->_internal_has_router_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::router_state(this),
        _Internal::router_state(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.Credentials credentials = 2;
  if (this->_internal_has_credentials()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::credentials(this),
        _Internal::credentials(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.ConnectEvent connect_event = 3;
  if (this->_internal_has_connect_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::connect_event(this),
        _Internal::connect_event(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.DisconnectEvent disconnect_event = 4;
  if (this->_internal_has_disconnect_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::disconnect_event(this),
        _Internal::disconnect_event(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.ConnectConfirmationRequest connect_confirmation_request = 5;
  if (this->_internal_has_connect_confirmation_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::connect_confirmation_request(this),
        _Internal::connect_confirmation_request(this).GetCachedSize(), target, stream);
  }

  // .proto.internal.VideoRecordingState video_recording_state = 6;
  if (this->_internal_has_video_recording_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::video_recording_state(this),
        _Internal::video_recording_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.internal.ServiceToUi)
  return target;
}

size_t ServiceToUi::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.internal.ServiceToUi)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.internal.RouterState router_state = 1;
  if (this->_internal_has_router_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.router_state_);
  }

  // .proto.internal.Credentials credentials = 2;
  if (this->_internal_has_credentials()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.credentials_);
  }

  // .proto.internal.ConnectEvent connect_event = 3;
  if (this->_internal_has_connect_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connect_event_);
  }

  // .proto.internal.DisconnectEvent disconnect_event = 4;
  if (this->_internal_has_disconnect_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.disconnect_event_);
  }

  // .proto.internal.ConnectConfirmationRequest connect_confirmation_request = 5;
  if (this->_internal_has_connect_confirmation_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connect_confirmation_request_);
  }

  // .proto.internal.VideoRecordingState video_recording_state = 6;
  if (this->_internal_has_video_recording_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_recording_state_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceToUi::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceToUi*>(
      &from));
}

void ServiceToUi::MergeFrom(const ServiceToUi& from) {
  ServiceToUi* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.internal.ServiceToUi)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_router_state()) {
    _this->_internal_mutable_router_state()->::proto::internal::RouterState::MergeFrom(
        from._internal_router_state());
  }
  if (from._internal_has_credentials()) {
    _this->_internal_mutable_credentials()->::proto::internal::Credentials::MergeFrom(
        from._internal_credentials());
  }
  if (from._internal_has_connect_event()) {
    _this->_internal_mutable_connect_event()->::proto::internal::ConnectEvent::MergeFrom(
        from._internal_connect_event());
  }
  if (from._internal_has_disconnect_event()) {
    _this->_internal_mutable_disconnect_event()->::proto::internal::DisconnectEvent::MergeFrom(
        from._internal_disconnect_event());
  }
  if (from._internal_has_connect_confirmation_request()) {
    _this->_internal_mutable_connect_confirmation_request()->::proto::internal::ConnectConfirmationRequest::MergeFrom(
        from._internal_connect_confirmation_request());
  }
  if (from._internal_has_video_recording_state()) {
    _this->_internal_mutable_video_recording_state()->::proto::internal::VideoRecordingState::MergeFrom(
        from._internal_video_recording_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceToUi::CopyFrom(const ServiceToUi& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.internal.ServiceToUi)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceToUi::IsInitialized() const {
  return true;
}

void ServiceToUi::InternalSwap(ServiceToUi* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceToUi, _impl_.video_recording_state_)
      + sizeof(ServiceToUi::_impl_.video_recording_state_)
      - PROTOBUF_FIELD_OFFSET(ServiceToUi, _impl_.router_state_)>(
          reinterpret_cast<char*>(&_impl_.router_state_),
          reinterpret_cast<char*>(&other->_impl_.router_state_));
}

std::string ServiceToUi::GetTypeName() const {
  return "proto.internal.ServiceToUi";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace internal
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::internal::CredentialsRequest*
Arena::CreateMaybeMessage< ::proto::internal::CredentialsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::CredentialsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::Credentials*
Arena::CreateMaybeMessage< ::proto::internal::Credentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::Credentials >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::ConnectEvent*
Arena::CreateMaybeMessage< ::proto::internal::ConnectEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::ConnectEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::DisconnectEvent*
Arena::CreateMaybeMessage< ::proto::internal::DisconnectEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::DisconnectEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::RouterState*
Arena::CreateMaybeMessage< ::proto::internal::RouterState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::RouterState >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::ConnectConfirmationRequest*
Arena::CreateMaybeMessage< ::proto::internal::ConnectConfirmationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::ConnectConfirmationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::ConnectConfirmation*
Arena::CreateMaybeMessage< ::proto::internal::ConnectConfirmation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::ConnectConfirmation >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::ServiceControl*
Arena::CreateMaybeMessage< ::proto::internal::ServiceControl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::ServiceControl >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::VideoRecordingState*
Arena::CreateMaybeMessage< ::proto::internal::VideoRecordingState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::VideoRecordingState >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::UiToService*
Arena::CreateMaybeMessage< ::proto::internal::UiToService >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::UiToService >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::internal::ServiceToUi*
Arena::CreateMaybeMessage< ::proto::internal::ServiceToUi >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::internal::ServiceToUi >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
