// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: desktop.proto

#include "desktop.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
PROTOBUF_CONSTEXPR KeyEvent::KeyEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.usb_keycode_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyEventDefaultTypeInternal() {}
  union {
    KeyEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
PROTOBUF_CONSTEXPR TextEvent::TextEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TextEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextEventDefaultTypeInternal() {}
  union {
    TextEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextEventDefaultTypeInternal _TextEvent_default_instance_;
PROTOBUF_CONSTEXPR MouseEvent::MouseEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MouseEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MouseEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MouseEventDefaultTypeInternal() {}
  union {
    MouseEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
PROTOBUF_CONSTEXPR ClipboardEvent::ClipboardEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mime_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClipboardEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClipboardEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClipboardEventDefaultTypeInternal() {}
  union {
    ClipboardEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClipboardEventDefaultTypeInternal _ClipboardEvent_default_instance_;
PROTOBUF_CONSTEXPR CursorShape::CursorShape(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.hotspot_x_)*/0
  , /*decltype(_impl_.hotspot_y_)*/0
  , /*decltype(_impl_.dpi_x_)*/0
  , /*decltype(_impl_.dpi_y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CursorShapeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CursorShapeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CursorShapeDefaultTypeInternal() {}
  union {
    CursorShape _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CursorShapeDefaultTypeInternal _CursorShape_default_instance_;
PROTOBUF_CONSTEXPR CursorPosition::CursorPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CursorPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CursorPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CursorPositionDefaultTypeInternal() {}
  union {
    CursorPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CursorPositionDefaultTypeInternal _CursorPosition_default_instance_;
PROTOBUF_CONSTEXPR Size::Size(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SizeDefaultTypeInternal() {}
  union {
    Size _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SizeDefaultTypeInternal _Size_default_instance_;
PROTOBUF_CONSTEXPR Rect::Rect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectDefaultTypeInternal() {}
  union {
    Rect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectDefaultTypeInternal _Rect_default_instance_;
PROTOBUF_CONSTEXPR PixelFormat::PixelFormat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bits_per_pixel_)*/0u
  , /*decltype(_impl_.red_max_)*/0u
  , /*decltype(_impl_.green_max_)*/0u
  , /*decltype(_impl_.blue_max_)*/0u
  , /*decltype(_impl_.red_shift_)*/0u
  , /*decltype(_impl_.green_shift_)*/0u
  , /*decltype(_impl_.blue_shift_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PixelFormatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PixelFormatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PixelFormatDefaultTypeInternal() {}
  union {
    PixelFormat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PixelFormatDefaultTypeInternal _PixelFormat_default_instance_;
PROTOBUF_CONSTEXPR VideoPacketFormat::VideoPacketFormat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.video_rect_)*/nullptr
  , /*decltype(_impl_.pixel_format_)*/nullptr
  , /*decltype(_impl_.screen_size_)*/nullptr
  , /*decltype(_impl_.capturer_type_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VideoPacketFormatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoPacketFormatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoPacketFormatDefaultTypeInternal() {}
  union {
    VideoPacketFormat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoPacketFormatDefaultTypeInternal _VideoPacketFormat_default_instance_;
PROTOBUF_CONSTEXPR VideoPacket::VideoPacket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dirty_rect_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.format_)*/nullptr
  , /*decltype(_impl_.encoding_)*/0
  , /*decltype(_impl_.error_code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VideoPacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoPacketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoPacketDefaultTypeInternal() {}
  union {
    VideoPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoPacketDefaultTypeInternal _VideoPacket_default_instance_;
PROTOBUF_CONSTEXPR AudioPacket::AudioPacket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.timestamp_)*/0
  , /*decltype(_impl_.encoding_)*/0
  , /*decltype(_impl_.sampling_rate_)*/0
  , /*decltype(_impl_.bytes_per_sample_)*/0
  , /*decltype(_impl_.channels_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioPacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioPacketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioPacketDefaultTypeInternal() {}
  union {
    AudioPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioPacketDefaultTypeInternal _AudioPacket_default_instance_;
PROTOBUF_CONSTEXPR DesktopExtension::DesktopExtension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DesktopExtensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DesktopExtensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DesktopExtensionDefaultTypeInternal() {}
  union {
    DesktopExtension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DesktopExtensionDefaultTypeInternal _DesktopExtension_default_instance_;
PROTOBUF_CONSTEXPR DesktopCapabilities_Flag::DesktopCapabilities_Flag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DesktopCapabilities_FlagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DesktopCapabilities_FlagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DesktopCapabilities_FlagDefaultTypeInternal() {}
  union {
    DesktopCapabilities_Flag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DesktopCapabilities_FlagDefaultTypeInternal _DesktopCapabilities_Flag_default_instance_;
PROTOBUF_CONSTEXPR DesktopCapabilities::DesktopCapabilities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flag_)*/{}
  , /*decltype(_impl_.extensions_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.video_encodings_)*/0u
  , /*decltype(_impl_.audio_encodings_)*/0u
  , /*decltype(_impl_.os_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DesktopCapabilitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DesktopCapabilitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DesktopCapabilitiesDefaultTypeInternal() {}
  union {
    DesktopCapabilities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DesktopCapabilitiesDefaultTypeInternal _DesktopCapabilities_default_instance_;
PROTOBUF_CONSTEXPR DesktopConfig::DesktopConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pixel_format_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.video_encoding_)*/0
  , /*decltype(_impl_.update_interval_)*/0u
  , /*decltype(_impl_.compress_ratio_)*/0u
  , /*decltype(_impl_.scale_factor_)*/0u
  , /*decltype(_impl_.audio_encoding_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DesktopConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DesktopConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DesktopConfigDefaultTypeInternal() {}
  union {
    DesktopConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DesktopConfigDefaultTypeInternal _DesktopConfig_default_instance_;
PROTOBUF_CONSTEXPR HostToClient::HostToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.video_packet_)*/nullptr
  , /*decltype(_impl_.audio_packet_)*/nullptr
  , /*decltype(_impl_.cursor_shape_)*/nullptr
  , /*decltype(_impl_.clipboard_event_)*/nullptr
  , /*decltype(_impl_.extension_)*/nullptr
  , /*decltype(_impl_.capabilities_)*/nullptr
  , /*decltype(_impl_.cursor_position_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostToClientDefaultTypeInternal() {}
  union {
    HostToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostToClientDefaultTypeInternal _HostToClient_default_instance_;
PROTOBUF_CONSTEXPR ClientToHost::ClientToHost(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mouse_event_)*/nullptr
  , /*decltype(_impl_.key_event_)*/nullptr
  , /*decltype(_impl_.text_event_)*/nullptr
  , /*decltype(_impl_.clipboard_event_)*/nullptr
  , /*decltype(_impl_.extension_)*/nullptr
  , /*decltype(_impl_.config_)*/nullptr
  , /*decltype(_impl_.audio_packet_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientToHostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientToHostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientToHostDefaultTypeInternal() {}
  union {
    ClientToHost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToHostDefaultTypeInternal _ClientToHost_default_instance_;
}  // namespace proto
namespace proto {
bool KeyEvent_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KeyEvent_Flags_strings[4] = {};

static const char KeyEvent_Flags_names[] =
  "CAPSLOCK"
  "NUMLOCK"
  "PRESSED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KeyEvent_Flags_entries[] = {
  { {KeyEvent_Flags_names + 0, 8}, 1 },
  { {KeyEvent_Flags_names + 8, 7}, 2 },
  { {KeyEvent_Flags_names + 15, 7}, 4 },
  { {KeyEvent_Flags_names + 22, 7}, 0 },
};

static const int KeyEvent_Flags_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  0, // 1 -> CAPSLOCK
  1, // 2 -> NUMLOCK
  2, // 4 -> PRESSED
};

const std::string& KeyEvent_Flags_Name(
    KeyEvent_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KeyEvent_Flags_entries,
          KeyEvent_Flags_entries_by_number,
          4, KeyEvent_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KeyEvent_Flags_entries,
      KeyEvent_Flags_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KeyEvent_Flags_strings[idx].get();
}
bool KeyEvent_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyEvent_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KeyEvent_Flags_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<KeyEvent_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr KeyEvent_Flags KeyEvent::UNKNOWN;
constexpr KeyEvent_Flags KeyEvent::CAPSLOCK;
constexpr KeyEvent_Flags KeyEvent::NUMLOCK;
constexpr KeyEvent_Flags KeyEvent::PRESSED;
constexpr KeyEvent_Flags KeyEvent::Flags_MIN;
constexpr KeyEvent_Flags KeyEvent::Flags_MAX;
constexpr int KeyEvent::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool MouseEvent_ButtonMask_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MouseEvent_ButtonMask_strings[8] = {};

static const char MouseEvent_ButtonMask_names[] =
  "BACK_BUTTON"
  "EMPTY"
  "FORWARD_BUTTON"
  "LEFT_BUTTON"
  "MIDDLE_BUTTON"
  "RIGHT_BUTTON"
  "WHEEL_DOWN"
  "WHEEL_UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MouseEvent_ButtonMask_entries[] = {
  { {MouseEvent_ButtonMask_names + 0, 11}, 32 },
  { {MouseEvent_ButtonMask_names + 11, 5}, 0 },
  { {MouseEvent_ButtonMask_names + 16, 14}, 64 },
  { {MouseEvent_ButtonMask_names + 30, 11}, 1 },
  { {MouseEvent_ButtonMask_names + 41, 13}, 2 },
  { {MouseEvent_ButtonMask_names + 54, 12}, 4 },
  { {MouseEvent_ButtonMask_names + 66, 10}, 16 },
  { {MouseEvent_ButtonMask_names + 76, 8}, 8 },
};

static const int MouseEvent_ButtonMask_entries_by_number[] = {
  1, // 0 -> EMPTY
  3, // 1 -> LEFT_BUTTON
  4, // 2 -> MIDDLE_BUTTON
  5, // 4 -> RIGHT_BUTTON
  7, // 8 -> WHEEL_UP
  6, // 16 -> WHEEL_DOWN
  0, // 32 -> BACK_BUTTON
  2, // 64 -> FORWARD_BUTTON
};

const std::string& MouseEvent_ButtonMask_Name(
    MouseEvent_ButtonMask value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MouseEvent_ButtonMask_entries,
          MouseEvent_ButtonMask_entries_by_number,
          8, MouseEvent_ButtonMask_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MouseEvent_ButtonMask_entries,
      MouseEvent_ButtonMask_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MouseEvent_ButtonMask_strings[idx].get();
}
bool MouseEvent_ButtonMask_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MouseEvent_ButtonMask* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MouseEvent_ButtonMask_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<MouseEvent_ButtonMask>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MouseEvent_ButtonMask MouseEvent::EMPTY;
constexpr MouseEvent_ButtonMask MouseEvent::LEFT_BUTTON;
constexpr MouseEvent_ButtonMask MouseEvent::MIDDLE_BUTTON;
constexpr MouseEvent_ButtonMask MouseEvent::RIGHT_BUTTON;
constexpr MouseEvent_ButtonMask MouseEvent::WHEEL_UP;
constexpr MouseEvent_ButtonMask MouseEvent::WHEEL_DOWN;
constexpr MouseEvent_ButtonMask MouseEvent::BACK_BUTTON;
constexpr MouseEvent_ButtonMask MouseEvent::FORWARD_BUTTON;
constexpr MouseEvent_ButtonMask MouseEvent::ButtonMask_MIN;
constexpr MouseEvent_ButtonMask MouseEvent::ButtonMask_MAX;
constexpr int MouseEvent::ButtonMask_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CursorShape_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 64:
    case 128:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CursorShape_Flags_strings[3] = {};

static const char CursorShape_Flags_names[] =
  "CACHE"
  "RESET_CACHE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CursorShape_Flags_entries[] = {
  { {CursorShape_Flags_names + 0, 5}, 128 },
  { {CursorShape_Flags_names + 5, 11}, 64 },
  { {CursorShape_Flags_names + 16, 7}, 0 },
};

static const int CursorShape_Flags_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  1, // 64 -> RESET_CACHE
  0, // 128 -> CACHE
};

const std::string& CursorShape_Flags_Name(
    CursorShape_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CursorShape_Flags_entries,
          CursorShape_Flags_entries_by_number,
          3, CursorShape_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CursorShape_Flags_entries,
      CursorShape_Flags_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CursorShape_Flags_strings[idx].get();
}
bool CursorShape_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CursorShape_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CursorShape_Flags_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CursorShape_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CursorShape_Flags CursorShape::UNKNOWN;
constexpr CursorShape_Flags CursorShape::RESET_CACHE;
constexpr CursorShape_Flags CursorShape::CACHE;
constexpr CursorShape_Flags CursorShape::Flags_MIN;
constexpr CursorShape_Flags CursorShape::Flags_MAX;
constexpr int CursorShape::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AudioPacket_SamplingRate_IsValid(int value) {
  switch (value) {
    case 0:
    case 44100:
    case 48000:
    case 96000:
    case 192000:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioPacket_SamplingRate_strings[5] = {};

static const char AudioPacket_SamplingRate_names[] =
  "SAMPLING_RATE_192000"
  "SAMPLING_RATE_44100"
  "SAMPLING_RATE_48000"
  "SAMPLING_RATE_96000"
  "SAMPLING_RATE_INVALID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioPacket_SamplingRate_entries[] = {
  { {AudioPacket_SamplingRate_names + 0, 20}, 192000 },
  { {AudioPacket_SamplingRate_names + 20, 19}, 44100 },
  { {AudioPacket_SamplingRate_names + 39, 19}, 48000 },
  { {AudioPacket_SamplingRate_names + 58, 19}, 96000 },
  { {AudioPacket_SamplingRate_names + 77, 21}, 0 },
};

static const int AudioPacket_SamplingRate_entries_by_number[] = {
  4, // 0 -> SAMPLING_RATE_INVALID
  1, // 44100 -> SAMPLING_RATE_44100
  2, // 48000 -> SAMPLING_RATE_48000
  3, // 96000 -> SAMPLING_RATE_96000
  0, // 192000 -> SAMPLING_RATE_192000
};

const std::string& AudioPacket_SamplingRate_Name(
    AudioPacket_SamplingRate value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioPacket_SamplingRate_entries,
          AudioPacket_SamplingRate_entries_by_number,
          5, AudioPacket_SamplingRate_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioPacket_SamplingRate_entries,
      AudioPacket_SamplingRate_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioPacket_SamplingRate_strings[idx].get();
}
bool AudioPacket_SamplingRate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPacket_SamplingRate* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioPacket_SamplingRate_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AudioPacket_SamplingRate>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioPacket_SamplingRate AudioPacket::SAMPLING_RATE_INVALID;
constexpr AudioPacket_SamplingRate AudioPacket::SAMPLING_RATE_44100;
constexpr AudioPacket_SamplingRate AudioPacket::SAMPLING_RATE_48000;
constexpr AudioPacket_SamplingRate AudioPacket::SAMPLING_RATE_96000;
constexpr AudioPacket_SamplingRate AudioPacket::SAMPLING_RATE_192000;
constexpr AudioPacket_SamplingRate AudioPacket::SamplingRate_MIN;
constexpr AudioPacket_SamplingRate AudioPacket::SamplingRate_MAX;
constexpr int AudioPacket::SamplingRate_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AudioPacket_BytesPerSample_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioPacket_BytesPerSample_strings[2] = {};

static const char AudioPacket_BytesPerSample_names[] =
  "BYTES_PER_SAMPLE_2"
  "BYTES_PER_SAMPLE_INVALID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioPacket_BytesPerSample_entries[] = {
  { {AudioPacket_BytesPerSample_names + 0, 18}, 2 },
  { {AudioPacket_BytesPerSample_names + 18, 24}, 0 },
};

static const int AudioPacket_BytesPerSample_entries_by_number[] = {
  1, // 0 -> BYTES_PER_SAMPLE_INVALID
  0, // 2 -> BYTES_PER_SAMPLE_2
};

const std::string& AudioPacket_BytesPerSample_Name(
    AudioPacket_BytesPerSample value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioPacket_BytesPerSample_entries,
          AudioPacket_BytesPerSample_entries_by_number,
          2, AudioPacket_BytesPerSample_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioPacket_BytesPerSample_entries,
      AudioPacket_BytesPerSample_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioPacket_BytesPerSample_strings[idx].get();
}
bool AudioPacket_BytesPerSample_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPacket_BytesPerSample* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioPacket_BytesPerSample_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<AudioPacket_BytesPerSample>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioPacket_BytesPerSample AudioPacket::BYTES_PER_SAMPLE_INVALID;
constexpr AudioPacket_BytesPerSample AudioPacket::BYTES_PER_SAMPLE_2;
constexpr AudioPacket_BytesPerSample AudioPacket::BytesPerSample_MIN;
constexpr AudioPacket_BytesPerSample AudioPacket::BytesPerSample_MAX;
constexpr int AudioPacket::BytesPerSample_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AudioPacket_Channels_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioPacket_Channels_strings[9] = {};

static const char AudioPacket_Channels_names[] =
  "CHANNELS_4_0"
  "CHANNELS_4_1"
  "CHANNELS_5_1"
  "CHANNELS_6_1"
  "CHANNELS_7_1"
  "CHANNELS_INVALID"
  "CHANNELS_MONO"
  "CHANNELS_STEREO"
  "CHANNELS_SURROUND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioPacket_Channels_entries[] = {
  { {AudioPacket_Channels_names + 0, 12}, 4 },
  { {AudioPacket_Channels_names + 12, 12}, 5 },
  { {AudioPacket_Channels_names + 24, 12}, 6 },
  { {AudioPacket_Channels_names + 36, 12}, 7 },
  { {AudioPacket_Channels_names + 48, 12}, 8 },
  { {AudioPacket_Channels_names + 60, 16}, 0 },
  { {AudioPacket_Channels_names + 76, 13}, 1 },
  { {AudioPacket_Channels_names + 89, 15}, 2 },
  { {AudioPacket_Channels_names + 104, 17}, 3 },
};

static const int AudioPacket_Channels_entries_by_number[] = {
  5, // 0 -> CHANNELS_INVALID
  6, // 1 -> CHANNELS_MONO
  7, // 2 -> CHANNELS_STEREO
  8, // 3 -> CHANNELS_SURROUND
  0, // 4 -> CHANNELS_4_0
  1, // 5 -> CHANNELS_4_1
  2, // 6 -> CHANNELS_5_1
  3, // 7 -> CHANNELS_6_1
  4, // 8 -> CHANNELS_7_1
};

const std::string& AudioPacket_Channels_Name(
    AudioPacket_Channels value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioPacket_Channels_entries,
          AudioPacket_Channels_entries_by_number,
          9, AudioPacket_Channels_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioPacket_Channels_entries,
      AudioPacket_Channels_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioPacket_Channels_strings[idx].get();
}
bool AudioPacket_Channels_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPacket_Channels* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioPacket_Channels_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<AudioPacket_Channels>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioPacket_Channels AudioPacket::CHANNELS_INVALID;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_MONO;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_STEREO;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_SURROUND;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_4_0;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_4_1;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_5_1;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_6_1;
constexpr AudioPacket_Channels AudioPacket::CHANNELS_7_1;
constexpr AudioPacket_Channels AudioPacket::Channels_MIN;
constexpr AudioPacket_Channels AudioPacket::Channels_MAX;
constexpr int AudioPacket::Channels_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DesktopCapabilities_OsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DesktopCapabilities_OsType_strings[3] = {};

static const char DesktopCapabilities_OsType_names[] =
  "OS_TYPE_LINUX"
  "OS_TYPE_MACOSX"
  "OS_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DesktopCapabilities_OsType_entries[] = {
  { {DesktopCapabilities_OsType_names + 0, 13}, 1 },
  { {DesktopCapabilities_OsType_names + 13, 14}, 2 },
  { {DesktopCapabilities_OsType_names + 27, 15}, 0 },
};

static const int DesktopCapabilities_OsType_entries_by_number[] = {
  2, // 0 -> OS_TYPE_WINDOWS
  0, // 1 -> OS_TYPE_LINUX
  1, // 2 -> OS_TYPE_MACOSX
};

const std::string& DesktopCapabilities_OsType_Name(
    DesktopCapabilities_OsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DesktopCapabilities_OsType_entries,
          DesktopCapabilities_OsType_entries_by_number,
          3, DesktopCapabilities_OsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DesktopCapabilities_OsType_entries,
      DesktopCapabilities_OsType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DesktopCapabilities_OsType_strings[idx].get();
}
bool DesktopCapabilities_OsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DesktopCapabilities_OsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DesktopCapabilities_OsType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DesktopCapabilities_OsType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DesktopCapabilities_OsType DesktopCapabilities::OS_TYPE_WINDOWS;
constexpr DesktopCapabilities_OsType DesktopCapabilities::OS_TYPE_LINUX;
constexpr DesktopCapabilities_OsType DesktopCapabilities::OS_TYPE_MACOSX;
constexpr DesktopCapabilities_OsType DesktopCapabilities::OsType_MIN;
constexpr DesktopCapabilities_OsType DesktopCapabilities::OsType_MAX;
constexpr int DesktopCapabilities::OsType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VideoEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VideoEncoding_strings[4] = {};

static const char VideoEncoding_names[] =
  "VIDEO_ENCODING_UNKNOWN"
  "VIDEO_ENCODING_VP8"
  "VIDEO_ENCODING_VP9"
  "VIDEO_ENCODING_ZSTD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VideoEncoding_entries[] = {
  { {VideoEncoding_names + 0, 22}, 0 },
  { {VideoEncoding_names + 22, 18}, 2 },
  { {VideoEncoding_names + 40, 18}, 4 },
  { {VideoEncoding_names + 58, 19}, 1 },
};

static const int VideoEncoding_entries_by_number[] = {
  0, // 0 -> VIDEO_ENCODING_UNKNOWN
  3, // 1 -> VIDEO_ENCODING_ZSTD
  1, // 2 -> VIDEO_ENCODING_VP8
  2, // 4 -> VIDEO_ENCODING_VP9
};

const std::string& VideoEncoding_Name(
    VideoEncoding value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VideoEncoding_entries,
          VideoEncoding_entries_by_number,
          4, VideoEncoding_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VideoEncoding_entries,
      VideoEncoding_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VideoEncoding_strings[idx].get();
}
bool VideoEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoEncoding* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VideoEncoding_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<VideoEncoding>(int_value);
  }
  return success;
}
bool VideoErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VideoErrorCode_strings[4] = {};

static const char VideoErrorCode_names[] =
  "VIDEO_ERROR_CODE_OK"
  "VIDEO_ERROR_CODE_PAUSED"
  "VIDEO_ERROR_CODE_PERMANENT"
  "VIDEO_ERROR_CODE_TEMPORARY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VideoErrorCode_entries[] = {
  { {VideoErrorCode_names + 0, 19}, 0 },
  { {VideoErrorCode_names + 19, 23}, 1 },
  { {VideoErrorCode_names + 42, 26}, 3 },
  { {VideoErrorCode_names + 68, 26}, 2 },
};

static const int VideoErrorCode_entries_by_number[] = {
  0, // 0 -> VIDEO_ERROR_CODE_OK
  1, // 1 -> VIDEO_ERROR_CODE_PAUSED
  3, // 2 -> VIDEO_ERROR_CODE_TEMPORARY
  2, // 3 -> VIDEO_ERROR_CODE_PERMANENT
};

const std::string& VideoErrorCode_Name(
    VideoErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VideoErrorCode_entries,
          VideoErrorCode_entries_by_number,
          4, VideoErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VideoErrorCode_entries,
      VideoErrorCode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VideoErrorCode_strings[idx].get();
}
bool VideoErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VideoErrorCode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<VideoErrorCode>(int_value);
  }
  return success;
}
bool AudioEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioEncoding_strings[4] = {};

static const char AudioEncoding_names[] =
  "AUDIO_ENCODING_DEFAULT"
  "AUDIO_ENCODING_OPUS"
  "AUDIO_ENCODING_RAW"
  "AUDIO_ENCODING_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioEncoding_entries[] = {
  { {AudioEncoding_names + 0, 22}, 1 },
  { {AudioEncoding_names + 22, 19}, 3 },
  { {AudioEncoding_names + 41, 18}, 2 },
  { {AudioEncoding_names + 59, 22}, 0 },
};

static const int AudioEncoding_entries_by_number[] = {
  3, // 0 -> AUDIO_ENCODING_UNKNOWN
  0, // 1 -> AUDIO_ENCODING_DEFAULT
  2, // 2 -> AUDIO_ENCODING_RAW
  1, // 3 -> AUDIO_ENCODING_OPUS
};

const std::string& AudioEncoding_Name(
    AudioEncoding value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioEncoding_entries,
          AudioEncoding_entries_by_number,
          4, AudioEncoding_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioEncoding_entries,
      AudioEncoding_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioEncoding_strings[idx].get();
}
bool AudioEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioEncoding* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioEncoding_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AudioEncoding>(int_value);
  }
  return success;
}
bool DesktopFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DesktopFlags_strings[10] = {};

static const char DesktopFlags_names[] =
  "BLOCK_REMOTE_INPUT"
  "CLEAR_CLIPBOARD"
  "CURSOR_POSITION"
  "DISABLE_DESKTOP_EFFECTS"
  "DISABLE_DESKTOP_WALLPAPER"
  "DISABLE_FONT_SMOOTHING"
  "ENABLE_CLIPBOARD"
  "ENABLE_CURSOR_SHAPE"
  "LOCK_AT_DISCONNECT"
  "NO_FLAGS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DesktopFlags_entries[] = {
  { {DesktopFlags_names + 0, 18}, 32 },
  { {DesktopFlags_names + 18, 15}, 256 },
  { {DesktopFlags_names + 33, 15}, 128 },
  { {DesktopFlags_names + 48, 23}, 4 },
  { {DesktopFlags_names + 71, 25}, 8 },
  { {DesktopFlags_names + 96, 22}, 16 },
  { {DesktopFlags_names + 118, 16}, 2 },
  { {DesktopFlags_names + 134, 19}, 1 },
  { {DesktopFlags_names + 153, 18}, 64 },
  { {DesktopFlags_names + 171, 8}, 0 },
};

static const int DesktopFlags_entries_by_number[] = {
  9, // 0 -> NO_FLAGS
  7, // 1 -> ENABLE_CURSOR_SHAPE
  6, // 2 -> ENABLE_CLIPBOARD
  3, // 4 -> DISABLE_DESKTOP_EFFECTS
  4, // 8 -> DISABLE_DESKTOP_WALLPAPER
  5, // 16 -> DISABLE_FONT_SMOOTHING
  0, // 32 -> BLOCK_REMOTE_INPUT
  8, // 64 -> LOCK_AT_DISCONNECT
  2, // 128 -> CURSOR_POSITION
  1, // 256 -> CLEAR_CLIPBOARD
};

const std::string& DesktopFlags_Name(
    DesktopFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DesktopFlags_entries,
          DesktopFlags_entries_by_number,
          10, DesktopFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DesktopFlags_entries,
      DesktopFlags_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DesktopFlags_strings[idx].get();
}
bool DesktopFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DesktopFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DesktopFlags_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<DesktopFlags>(int_value);
  }
  return success;
}

// ===================================================================

class KeyEvent::_Internal {
 public:
};

KeyEvent::KeyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.KeyEvent)
}
KeyEvent::KeyEvent(const KeyEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KeyEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.usb_keycode_){}
    , decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.usb_keycode_, &from._impl_.usb_keycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.usb_keycode_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:proto.KeyEvent)
}

inline void KeyEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.usb_keycode_){0u}
    , decltype(_impl_.flags_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KeyEvent::~KeyEvent() {
  // @@protoc_insertion_point(destructor:proto.KeyEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeyEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.KeyEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.usb_keycode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.flags_) -
      reinterpret_cast<char*>(&_impl_.usb_keycode_)) + sizeof(_impl_.flags_));
  _internal_metadata_.Clear<std::string>();
}

const char* KeyEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 usb_keycode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.usb_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.KeyEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 usb_keycode = 1;
  if (this->_internal_usb_keycode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_usb_keycode(), target);
  }

  // uint32 flags = 2;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.KeyEvent)
  return target;
}

size_t KeyEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.KeyEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 usb_keycode = 1;
  if (this->_internal_usb_keycode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_usb_keycode());
  }

  // uint32 flags = 2;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeyEvent*>(
      &from));
}

void KeyEvent::MergeFrom(const KeyEvent& from) {
  KeyEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.KeyEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_usb_keycode() != 0) {
    _this->_internal_set_usb_keycode(from._internal_usb_keycode());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyEvent::CopyFrom(const KeyEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.KeyEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyEvent::IsInitialized() const {
  return true;
}

void KeyEvent::InternalSwap(KeyEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyEvent, _impl_.flags_)
      + sizeof(KeyEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(KeyEvent, _impl_.usb_keycode_)>(
          reinterpret_cast<char*>(&_impl_.usb_keycode_),
          reinterpret_cast<char*>(&other->_impl_.usb_keycode_));
}

std::string KeyEvent::GetTypeName() const {
  return "proto.KeyEvent";
}


// ===================================================================

class TextEvent::_Internal {
 public:
};

TextEvent::TextEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TextEvent)
}
TextEvent::TextEvent(const TextEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TextEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.TextEvent)
}

inline void TextEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TextEvent::~TextEvent() {
  // @@protoc_insertion_point(destructor:proto.TextEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void TextEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TextEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* TextEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TextEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.TextEvent.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TextEvent)
  return target;
}

size_t TextEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TextEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextEvent*>(
      &from));
}

void TextEvent::MergeFrom(const TextEvent& from) {
  TextEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TextEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextEvent::CopyFrom(const TextEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TextEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextEvent::IsInitialized() const {
  return true;
}

void TextEvent::InternalSwap(TextEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
}

std::string TextEvent::GetTypeName() const {
  return "proto.TextEvent";
}


// ===================================================================

class MouseEvent::_Internal {
 public:
};

MouseEvent::MouseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.MouseEvent)
}
MouseEvent::MouseEvent(const MouseEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MouseEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mask_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.mask_, &from._impl_.mask_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:proto.MouseEvent)
}

inline void MouseEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mask_){0u}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MouseEvent::~MouseEvent() {
  // @@protoc_insertion_point(destructor:proto.MouseEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MouseEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MouseEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MouseEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.MouseEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.mask_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<std::string>();
}

const char* MouseEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 mask = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MouseEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.MouseEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 mask = 1;
  if (this->_internal_mask() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mask(), target);
  }

  // int32 x = 2;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // int32 y = 3;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.MouseEvent)
  return target;
}

size_t MouseEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.MouseEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 mask = 1;
  if (this->_internal_mask() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
  }

  // int32 x = 2;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  // int32 y = 3;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MouseEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MouseEvent*>(
      &from));
}

void MouseEvent::MergeFrom(const MouseEvent& from) {
  MouseEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.MouseEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mask() != 0) {
    _this->_internal_set_mask(from._internal_mask());
  }
  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MouseEvent::CopyFrom(const MouseEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.MouseEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MouseEvent::IsInitialized() const {
  return true;
}

void MouseEvent::InternalSwap(MouseEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MouseEvent, _impl_.y_)
      + sizeof(MouseEvent::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(MouseEvent, _impl_.mask_)>(
          reinterpret_cast<char*>(&_impl_.mask_),
          reinterpret_cast<char*>(&other->_impl_.mask_));
}

std::string MouseEvent::GetTypeName() const {
  return "proto.MouseEvent";
}


// ===================================================================

class ClipboardEvent::_Internal {
 public:
};

ClipboardEvent::ClipboardEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ClipboardEvent)
}
ClipboardEvent::ClipboardEvent(const ClipboardEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClipboardEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mime_type_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mime_type().empty()) {
    _this->_impl_.mime_type_.Set(from._internal_mime_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.ClipboardEvent)
}

inline void ClipboardEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mime_type_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClipboardEvent::~ClipboardEvent() {
  // @@protoc_insertion_point(destructor:proto.ClipboardEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClipboardEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mime_type_.Destroy();
  _impl_.data_.Destroy();
}

void ClipboardEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClipboardEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ClipboardEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mime_type_.ClearToEmpty();
  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* ClipboardEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mime_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mime_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClipboardEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ClipboardEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mime_type = 1;
  if (!this->_internal_mime_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mime_type().data(), static_cast<int>(this->_internal_mime_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.ClipboardEvent.mime_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mime_type(), target);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ClipboardEvent)
  return target;
}

size_t ClipboardEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ClipboardEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mime_type = 1;
  if (!this->_internal_mime_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mime_type());
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClipboardEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClipboardEvent*>(
      &from));
}

void ClipboardEvent::MergeFrom(const ClipboardEvent& from) {
  ClipboardEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ClipboardEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mime_type().empty()) {
    _this->_internal_set_mime_type(from._internal_mime_type());
  }
  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClipboardEvent::CopyFrom(const ClipboardEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ClipboardEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClipboardEvent::IsInitialized() const {
  return true;
}

void ClipboardEvent::InternalSwap(ClipboardEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mime_type_, lhs_arena,
      &other->_impl_.mime_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

std::string ClipboardEvent::GetTypeName() const {
  return "proto.ClipboardEvent";
}


// ===================================================================

class CursorShape::_Internal {
 public:
};

CursorShape::CursorShape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.CursorShape)
}
CursorShape::CursorShape(const CursorShape& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CursorShape* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.hotspot_x_){}
    , decltype(_impl_.hotspot_y_){}
    , decltype(_impl_.dpi_x_){}
    , decltype(_impl_.dpi_y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dpi_y_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.dpi_y_));
  // @@protoc_insertion_point(copy_constructor:proto.CursorShape)
}

inline void CursorShape::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.hotspot_x_){0}
    , decltype(_impl_.hotspot_y_){0}
    , decltype(_impl_.dpi_x_){0}
    , decltype(_impl_.dpi_y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CursorShape::~CursorShape() {
  // @@protoc_insertion_point(destructor:proto.CursorShape)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CursorShape::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CursorShape::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CursorShape::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.CursorShape)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dpi_y_) -
      reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.dpi_y_));
  _internal_metadata_.Clear<std::string>();
}

const char* CursorShape::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 hotspot_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.hotspot_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 hotspot_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.hotspot_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dpi_x = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.dpi_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dpi_y = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.dpi_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CursorShape::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.CursorShape)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  // int32 width = 2;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_width(), target);
  }

  // int32 height = 3;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_height(), target);
  }

  // int32 hotspot_x = 4;
  if (this->_internal_hotspot_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_hotspot_x(), target);
  }

  // int32 hotspot_y = 5;
  if (this->_internal_hotspot_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_hotspot_y(), target);
  }

  // bytes data = 6;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_data(), target);
  }

  // int32 dpi_x = 7;
  if (this->_internal_dpi_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_dpi_x(), target);
  }

  // int32 dpi_y = 8;
  if (this->_internal_dpi_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_dpi_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.CursorShape)
  return target;
}

size_t CursorShape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.CursorShape)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 6;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  // int32 width = 2;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 height = 3;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  // int32 hotspot_x = 4;
  if (this->_internal_hotspot_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hotspot_x());
  }

  // int32 hotspot_y = 5;
  if (this->_internal_hotspot_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hotspot_y());
  }

  // int32 dpi_x = 7;
  if (this->_internal_dpi_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dpi_x());
  }

  // int32 dpi_y = 8;
  if (this->_internal_dpi_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dpi_y());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CursorShape::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CursorShape*>(
      &from));
}

void CursorShape::MergeFrom(const CursorShape& from) {
  CursorShape* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.CursorShape)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_hotspot_x() != 0) {
    _this->_internal_set_hotspot_x(from._internal_hotspot_x());
  }
  if (from._internal_hotspot_y() != 0) {
    _this->_internal_set_hotspot_y(from._internal_hotspot_y());
  }
  if (from._internal_dpi_x() != 0) {
    _this->_internal_set_dpi_x(from._internal_dpi_x());
  }
  if (from._internal_dpi_y() != 0) {
    _this->_internal_set_dpi_y(from._internal_dpi_y());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CursorShape::CopyFrom(const CursorShape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.CursorShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CursorShape::IsInitialized() const {
  return true;
}

void CursorShape::InternalSwap(CursorShape* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CursorShape, _impl_.dpi_y_)
      + sizeof(CursorShape::_impl_.dpi_y_)
      - PROTOBUF_FIELD_OFFSET(CursorShape, _impl_.flags_)>(
          reinterpret_cast<char*>(&_impl_.flags_),
          reinterpret_cast<char*>(&other->_impl_.flags_));
}

std::string CursorShape::GetTypeName() const {
  return "proto.CursorShape";
}


// ===================================================================

class CursorPosition::_Internal {
 public:
};

CursorPosition::CursorPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.CursorPosition)
}
CursorPosition::CursorPosition(const CursorPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CursorPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:proto.CursorPosition)
}

inline void CursorPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CursorPosition::~CursorPosition() {
  // @@protoc_insertion_point(destructor:proto.CursorPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CursorPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CursorPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CursorPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.CursorPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<std::string>();
}

const char* CursorPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CursorPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.CursorPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.CursorPosition)
  return target;
}

size_t CursorPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.CursorPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CursorPosition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CursorPosition*>(
      &from));
}

void CursorPosition::MergeFrom(const CursorPosition& from) {
  CursorPosition* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.CursorPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CursorPosition::CopyFrom(const CursorPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.CursorPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CursorPosition::IsInitialized() const {
  return true;
}

void CursorPosition::InternalSwap(CursorPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CursorPosition, _impl_.y_)
      + sizeof(CursorPosition::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(CursorPosition, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string CursorPosition::GetTypeName() const {
  return "proto.CursorPosition";
}


// ===================================================================

class Size::_Internal {
 public:
};

Size::Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.Size)
}
Size::Size(const Size& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Size* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:proto.Size)
}

inline void Size::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Size::~Size() {
  // @@protoc_insertion_point(destructor:proto.Size)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Size::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Size::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Size::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Size)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<std::string>();
}

const char* Size::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Size::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Size)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.Size)
  return target;
}

size_t Size::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Size)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 width = 1;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 height = 2;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Size::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Size*>(
      &from));
}

void Size::MergeFrom(const Size& from) {
  Size* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.Size)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Size::CopyFrom(const Size& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Size)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Size::IsInitialized() const {
  return true;
}

void Size::InternalSwap(Size* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Size, _impl_.height_)
      + sizeof(Size::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(Size, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

std::string Size::GetTypeName() const {
  return "proto.Size";
}


// ===================================================================

class Rect::_Internal {
 public:
};

Rect::Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.Rect)
}
Rect::Rect(const Rect& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Rect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:proto.Rect)
}

inline void Rect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Rect::~Rect() {
  // @@protoc_insertion_point(destructor:proto.Rect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Rect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Rect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Rect::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Rect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<std::string>();
}

const char* Rect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Rect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // int32 width = 3;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_width(), target);
  }

  // int32 height = 4;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.Rect)
  return target;
}

size_t Rect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Rect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  // int32 width = 3;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 height = 4;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Rect::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Rect*>(
      &from));
}

void Rect::MergeFrom(const Rect& from) {
  Rect* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.Rect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Rect::CopyFrom(const Rect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Rect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  return true;
}

void Rect::InternalSwap(Rect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Rect, _impl_.height_)
      + sizeof(Rect::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(Rect, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string Rect::GetTypeName() const {
  return "proto.Rect";
}


// ===================================================================

class PixelFormat::_Internal {
 public:
};

PixelFormat::PixelFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.PixelFormat)
}
PixelFormat::PixelFormat(const PixelFormat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PixelFormat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bits_per_pixel_){}
    , decltype(_impl_.red_max_){}
    , decltype(_impl_.green_max_){}
    , decltype(_impl_.blue_max_){}
    , decltype(_impl_.red_shift_){}
    , decltype(_impl_.green_shift_){}
    , decltype(_impl_.blue_shift_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.bits_per_pixel_, &from._impl_.bits_per_pixel_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blue_shift_) -
    reinterpret_cast<char*>(&_impl_.bits_per_pixel_)) + sizeof(_impl_.blue_shift_));
  // @@protoc_insertion_point(copy_constructor:proto.PixelFormat)
}

inline void PixelFormat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bits_per_pixel_){0u}
    , decltype(_impl_.red_max_){0u}
    , decltype(_impl_.green_max_){0u}
    , decltype(_impl_.blue_max_){0u}
    , decltype(_impl_.red_shift_){0u}
    , decltype(_impl_.green_shift_){0u}
    , decltype(_impl_.blue_shift_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PixelFormat::~PixelFormat() {
  // @@protoc_insertion_point(destructor:proto.PixelFormat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PixelFormat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PixelFormat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PixelFormat::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.PixelFormat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.bits_per_pixel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.blue_shift_) -
      reinterpret_cast<char*>(&_impl_.bits_per_pixel_)) + sizeof(_impl_.blue_shift_));
  _internal_metadata_.Clear<std::string>();
}

const char* PixelFormat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 bits_per_pixel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.bits_per_pixel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 red_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.red_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 green_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.green_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 blue_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.blue_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 red_shift = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.red_shift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 green_shift = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.green_shift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 blue_shift = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.blue_shift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PixelFormat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.PixelFormat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 bits_per_pixel = 1;
  if (this->_internal_bits_per_pixel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bits_per_pixel(), target);
  }

  // uint32 red_max = 2;
  if (this->_internal_red_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_red_max(), target);
  }

  // uint32 green_max = 3;
  if (this->_internal_green_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_green_max(), target);
  }

  // uint32 blue_max = 4;
  if (this->_internal_blue_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_blue_max(), target);
  }

  // uint32 red_shift = 5;
  if (this->_internal_red_shift() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_red_shift(), target);
  }

  // uint32 green_shift = 6;
  if (this->_internal_green_shift() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_green_shift(), target);
  }

  // uint32 blue_shift = 7;
  if (this->_internal_blue_shift() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_blue_shift(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.PixelFormat)
  return target;
}

size_t PixelFormat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.PixelFormat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 bits_per_pixel = 1;
  if (this->_internal_bits_per_pixel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bits_per_pixel());
  }

  // uint32 red_max = 2;
  if (this->_internal_red_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_red_max());
  }

  // uint32 green_max = 3;
  if (this->_internal_green_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_green_max());
  }

  // uint32 blue_max = 4;
  if (this->_internal_blue_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blue_max());
  }

  // uint32 red_shift = 5;
  if (this->_internal_red_shift() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_red_shift());
  }

  // uint32 green_shift = 6;
  if (this->_internal_green_shift() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_green_shift());
  }

  // uint32 blue_shift = 7;
  if (this->_internal_blue_shift() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blue_shift());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PixelFormat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PixelFormat*>(
      &from));
}

void PixelFormat::MergeFrom(const PixelFormat& from) {
  PixelFormat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.PixelFormat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_bits_per_pixel() != 0) {
    _this->_internal_set_bits_per_pixel(from._internal_bits_per_pixel());
  }
  if (from._internal_red_max() != 0) {
    _this->_internal_set_red_max(from._internal_red_max());
  }
  if (from._internal_green_max() != 0) {
    _this->_internal_set_green_max(from._internal_green_max());
  }
  if (from._internal_blue_max() != 0) {
    _this->_internal_set_blue_max(from._internal_blue_max());
  }
  if (from._internal_red_shift() != 0) {
    _this->_internal_set_red_shift(from._internal_red_shift());
  }
  if (from._internal_green_shift() != 0) {
    _this->_internal_set_green_shift(from._internal_green_shift());
  }
  if (from._internal_blue_shift() != 0) {
    _this->_internal_set_blue_shift(from._internal_blue_shift());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PixelFormat::CopyFrom(const PixelFormat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.PixelFormat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PixelFormat::IsInitialized() const {
  return true;
}

void PixelFormat::InternalSwap(PixelFormat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PixelFormat, _impl_.blue_shift_)
      + sizeof(PixelFormat::_impl_.blue_shift_)
      - PROTOBUF_FIELD_OFFSET(PixelFormat, _impl_.bits_per_pixel_)>(
          reinterpret_cast<char*>(&_impl_.bits_per_pixel_),
          reinterpret_cast<char*>(&other->_impl_.bits_per_pixel_));
}

std::string PixelFormat::GetTypeName() const {
  return "proto.PixelFormat";
}


// ===================================================================

class VideoPacketFormat::_Internal {
 public:
  static const ::proto::Rect& video_rect(const VideoPacketFormat* msg);
  static const ::proto::PixelFormat& pixel_format(const VideoPacketFormat* msg);
  static const ::proto::Size& screen_size(const VideoPacketFormat* msg);
};

const ::proto::Rect&
VideoPacketFormat::_Internal::video_rect(const VideoPacketFormat* msg) {
  return *msg->_impl_.video_rect_;
}
const ::proto::PixelFormat&
VideoPacketFormat::_Internal::pixel_format(const VideoPacketFormat* msg) {
  return *msg->_impl_.pixel_format_;
}
const ::proto::Size&
VideoPacketFormat::_Internal::screen_size(const VideoPacketFormat* msg) {
  return *msg->_impl_.screen_size_;
}
VideoPacketFormat::VideoPacketFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.VideoPacketFormat)
}
VideoPacketFormat::VideoPacketFormat(const VideoPacketFormat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VideoPacketFormat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.video_rect_){nullptr}
    , decltype(_impl_.pixel_format_){nullptr}
    , decltype(_impl_.screen_size_){nullptr}
    , decltype(_impl_.capturer_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_video_rect()) {
    _this->_impl_.video_rect_ = new ::proto::Rect(*from._impl_.video_rect_);
  }
  if (from._internal_has_pixel_format()) {
    _this->_impl_.pixel_format_ = new ::proto::PixelFormat(*from._impl_.pixel_format_);
  }
  if (from._internal_has_screen_size()) {
    _this->_impl_.screen_size_ = new ::proto::Size(*from._impl_.screen_size_);
  }
  _this->_impl_.capturer_type_ = from._impl_.capturer_type_;
  // @@protoc_insertion_point(copy_constructor:proto.VideoPacketFormat)
}

inline void VideoPacketFormat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.video_rect_){nullptr}
    , decltype(_impl_.pixel_format_){nullptr}
    , decltype(_impl_.screen_size_){nullptr}
    , decltype(_impl_.capturer_type_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VideoPacketFormat::~VideoPacketFormat() {
  // @@protoc_insertion_point(destructor:proto.VideoPacketFormat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoPacketFormat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.video_rect_;
  if (this != internal_default_instance()) delete _impl_.pixel_format_;
  if (this != internal_default_instance()) delete _impl_.screen_size_;
}

void VideoPacketFormat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoPacketFormat::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.VideoPacketFormat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.video_rect_ != nullptr) {
    delete _impl_.video_rect_;
  }
  _impl_.video_rect_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pixel_format_ != nullptr) {
    delete _impl_.pixel_format_;
  }
  _impl_.pixel_format_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.screen_size_ != nullptr) {
    delete _impl_.screen_size_;
  }
  _impl_.screen_size_ = nullptr;
  _impl_.capturer_type_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* VideoPacketFormat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.Rect video_rect = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_rect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.PixelFormat pixel_format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pixel_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.Size screen_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_screen_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 capturer_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.capturer_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoPacketFormat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.VideoPacketFormat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.Rect video_rect = 1;
  if (this->_internal_has_video_rect()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::video_rect(this),
        _Internal::video_rect(this).GetCachedSize(), target, stream);
  }

  // .proto.PixelFormat pixel_format = 2;
  if (this->_internal_has_pixel_format()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pixel_format(this),
        _Internal::pixel_format(this).GetCachedSize(), target, stream);
  }

  // .proto.Size screen_size = 3;
  if (this->_internal_has_screen_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::screen_size(this),
        _Internal::screen_size(this).GetCachedSize(), target, stream);
  }

  // uint32 capturer_type = 4;
  if (this->_internal_capturer_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_capturer_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.VideoPacketFormat)
  return target;
}

size_t VideoPacketFormat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.VideoPacketFormat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.Rect video_rect = 1;
  if (this->_internal_has_video_rect()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_rect_);
  }

  // .proto.PixelFormat pixel_format = 2;
  if (this->_internal_has_pixel_format()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pixel_format_);
  }

  // .proto.Size screen_size = 3;
  if (this->_internal_has_screen_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.screen_size_);
  }

  // uint32 capturer_type = 4;
  if (this->_internal_capturer_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capturer_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoPacketFormat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoPacketFormat*>(
      &from));
}

void VideoPacketFormat::MergeFrom(const VideoPacketFormat& from) {
  VideoPacketFormat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.VideoPacketFormat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_video_rect()) {
    _this->_internal_mutable_video_rect()->::proto::Rect::MergeFrom(
        from._internal_video_rect());
  }
  if (from._internal_has_pixel_format()) {
    _this->_internal_mutable_pixel_format()->::proto::PixelFormat::MergeFrom(
        from._internal_pixel_format());
  }
  if (from._internal_has_screen_size()) {
    _this->_internal_mutable_screen_size()->::proto::Size::MergeFrom(
        from._internal_screen_size());
  }
  if (from._internal_capturer_type() != 0) {
    _this->_internal_set_capturer_type(from._internal_capturer_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoPacketFormat::CopyFrom(const VideoPacketFormat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.VideoPacketFormat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoPacketFormat::IsInitialized() const {
  return true;
}

void VideoPacketFormat::InternalSwap(VideoPacketFormat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoPacketFormat, _impl_.capturer_type_)
      + sizeof(VideoPacketFormat::_impl_.capturer_type_)
      - PROTOBUF_FIELD_OFFSET(VideoPacketFormat, _impl_.video_rect_)>(
          reinterpret_cast<char*>(&_impl_.video_rect_),
          reinterpret_cast<char*>(&other->_impl_.video_rect_));
}

std::string VideoPacketFormat::GetTypeName() const {
  return "proto.VideoPacketFormat";
}


// ===================================================================

class VideoPacket::_Internal {
 public:
  static const ::proto::VideoPacketFormat& format(const VideoPacket* msg);
};

const ::proto::VideoPacketFormat&
VideoPacket::_Internal::format(const VideoPacket* msg) {
  return *msg->_impl_.format_;
}
VideoPacket::VideoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.VideoPacket)
}
VideoPacket::VideoPacket(const VideoPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VideoPacket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dirty_rect_){from._impl_.dirty_rect_}
    , decltype(_impl_.data_){}
    , decltype(_impl_.format_){nullptr}
    , decltype(_impl_.encoding_){}
    , decltype(_impl_.error_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_format()) {
    _this->_impl_.format_ = new ::proto::VideoPacketFormat(*from._impl_.format_);
  }
  ::memcpy(&_impl_.encoding_, &from._impl_.encoding_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_code_) -
    reinterpret_cast<char*>(&_impl_.encoding_)) + sizeof(_impl_.error_code_));
  // @@protoc_insertion_point(copy_constructor:proto.VideoPacket)
}

inline void VideoPacket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dirty_rect_){arena}
    , decltype(_impl_.data_){}
    , decltype(_impl_.format_){nullptr}
    , decltype(_impl_.encoding_){0}
    , decltype(_impl_.error_code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VideoPacket::~VideoPacket() {
  // @@protoc_insertion_point(destructor:proto.VideoPacket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dirty_rect_.~RepeatedPtrField();
  _impl_.data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.format_;
}

void VideoPacket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.VideoPacket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dirty_rect_.Clear();
  _impl_.data_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.format_ != nullptr) {
    delete _impl_.format_;
  }
  _impl_.format_ = nullptr;
  ::memset(&_impl_.encoding_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.error_code_) -
      reinterpret_cast<char*>(&_impl_.encoding_)) + sizeof(_impl_.error_code_));
  _internal_metadata_.Clear<std::string>();
}

const char* VideoPacket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.VideoEncoding encoding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_encoding(static_cast<::proto::VideoEncoding>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.VideoPacketFormat format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.Rect dirty_rect = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dirty_rect(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.VideoErrorCode error_code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_code(static_cast<::proto::VideoErrorCode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoPacket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.VideoPacket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.VideoEncoding encoding = 1;
  if (this->_internal_encoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_encoding(), target);
  }

  // .proto.VideoPacketFormat format = 2;
  if (this->_internal_has_format()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::format(this),
        _Internal::format(this).GetCachedSize(), target, stream);
  }

  // repeated .proto.Rect dirty_rect = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dirty_rect_size()); i < n; i++) {
    const auto& repfield = this->_internal_dirty_rect(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  // .proto.VideoErrorCode error_code = 5;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_error_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.VideoPacket)
  return target;
}

size_t VideoPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.VideoPacket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.Rect dirty_rect = 3;
  total_size += 1UL * this->_internal_dirty_rect_size();
  for (const auto& msg : this->_impl_.dirty_rect_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // .proto.VideoPacketFormat format = 2;
  if (this->_internal_has_format()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.format_);
  }

  // .proto.VideoEncoding encoding = 1;
  if (this->_internal_encoding() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_encoding());
  }

  // .proto.VideoErrorCode error_code = 5;
  if (this->_internal_error_code() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoPacket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoPacket*>(
      &from));
}

void VideoPacket::MergeFrom(const VideoPacket& from) {
  VideoPacket* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.VideoPacket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dirty_rect_.MergeFrom(from._impl_.dirty_rect_);
  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_has_format()) {
    _this->_internal_mutable_format()->::proto::VideoPacketFormat::MergeFrom(
        from._internal_format());
  }
  if (from._internal_encoding() != 0) {
    _this->_internal_set_encoding(from._internal_encoding());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoPacket::CopyFrom(const VideoPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.VideoPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoPacket::IsInitialized() const {
  return true;
}

void VideoPacket::InternalSwap(VideoPacket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dirty_rect_.InternalSwap(&other->_impl_.dirty_rect_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoPacket, _impl_.error_code_)
      + sizeof(VideoPacket::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(VideoPacket, _impl_.format_)>(
          reinterpret_cast<char*>(&_impl_.format_),
          reinterpret_cast<char*>(&other->_impl_.format_));
}

std::string VideoPacket::GetTypeName() const {
  return "proto.VideoPacket";
}


// ===================================================================

class AudioPacket::_Internal {
 public:
};

AudioPacket::AudioPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.AudioPacket)
}
AudioPacket::AudioPacket(const AudioPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AudioPacket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.encoding_){}
    , decltype(_impl_.sampling_rate_){}
    , decltype(_impl_.bytes_per_sample_){}
    , decltype(_impl_.channels_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.channels_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.channels_));
  // @@protoc_insertion_point(copy_constructor:proto.AudioPacket)
}

inline void AudioPacket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , decltype(_impl_.timestamp_){0}
    , decltype(_impl_.encoding_){0}
    , decltype(_impl_.sampling_rate_){0}
    , decltype(_impl_.bytes_per_sample_){0}
    , decltype(_impl_.channels_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioPacket::~AudioPacket() {
  // @@protoc_insertion_point(destructor:proto.AudioPacket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedPtrField();
}

void AudioPacket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.AudioPacket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.channels_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.channels_));
  _internal_metadata_.Clear<std::string>();
}

const char* AudioPacket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_data();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioEncoding encoding = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_encoding(static_cast<::proto::AudioEncoding>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioPacket.SamplingRate sampling_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sampling_rate(static_cast<::proto::AudioPacket_SamplingRate>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioPacket.BytesPerSample bytes_per_sample = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_bytes_per_sample(static_cast<::proto::AudioPacket_BytesPerSample>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioPacket.Channels channels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_channels(static_cast<::proto::AudioPacket_Channels>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioPacket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.AudioPacket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timestamp(), target);
  }

  // repeated bytes data = 2;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    const auto& s = this->_internal_data(i);
    target = stream->WriteBytes(2, s, target);
  }

  // .proto.AudioEncoding encoding = 3;
  if (this->_internal_encoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_encoding(), target);
  }

  // .proto.AudioPacket.SamplingRate sampling_rate = 4;
  if (this->_internal_sampling_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_sampling_rate(), target);
  }

  // .proto.AudioPacket.BytesPerSample bytes_per_sample = 5;
  if (this->_internal_bytes_per_sample() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_bytes_per_sample(), target);
  }

  // .proto.AudioPacket.Channels channels = 6;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.AudioPacket)
  return target;
}

size_t AudioPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.AudioPacket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes data = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.data_.size());
  for (int i = 0, n = _impl_.data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.data_.Get(i));
  }

  // int32 timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timestamp());
  }

  // .proto.AudioEncoding encoding = 3;
  if (this->_internal_encoding() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_encoding());
  }

  // .proto.AudioPacket.SamplingRate sampling_rate = 4;
  if (this->_internal_sampling_rate() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_sampling_rate());
  }

  // .proto.AudioPacket.BytesPerSample bytes_per_sample = 5;
  if (this->_internal_bytes_per_sample() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_bytes_per_sample());
  }

  // .proto.AudioPacket.Channels channels = 6;
  if (this->_internal_channels() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_channels());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioPacket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioPacket*>(
      &from));
}

void AudioPacket::MergeFrom(const AudioPacket& from) {
  AudioPacket* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.AudioPacket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_encoding() != 0) {
    _this->_internal_set_encoding(from._internal_encoding());
  }
  if (from._internal_sampling_rate() != 0) {
    _this->_internal_set_sampling_rate(from._internal_sampling_rate());
  }
  if (from._internal_bytes_per_sample() != 0) {
    _this->_internal_set_bytes_per_sample(from._internal_bytes_per_sample());
  }
  if (from._internal_channels() != 0) {
    _this->_internal_set_channels(from._internal_channels());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioPacket::CopyFrom(const AudioPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.AudioPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioPacket::IsInitialized() const {
  return true;
}

void AudioPacket::InternalSwap(AudioPacket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioPacket, _impl_.channels_)
      + sizeof(AudioPacket::_impl_.channels_)
      - PROTOBUF_FIELD_OFFSET(AudioPacket, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string AudioPacket::GetTypeName() const {
  return "proto.AudioPacket";
}


// ===================================================================

class DesktopExtension::_Internal {
 public:
};

DesktopExtension::DesktopExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DesktopExtension)
}
DesktopExtension::DesktopExtension(const DesktopExtension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DesktopExtension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.DesktopExtension)
}

inline void DesktopExtension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DesktopExtension::~DesktopExtension() {
  // @@protoc_insertion_point(destructor:proto.DesktopExtension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DesktopExtension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.data_.Destroy();
}

void DesktopExtension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DesktopExtension::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DesktopExtension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* DesktopExtension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DesktopExtension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DesktopExtension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.DesktopExtension.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DesktopExtension)
  return target;
}

size_t DesktopExtension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DesktopExtension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DesktopExtension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DesktopExtension*>(
      &from));
}

void DesktopExtension::MergeFrom(const DesktopExtension& from) {
  DesktopExtension* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DesktopExtension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DesktopExtension::CopyFrom(const DesktopExtension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DesktopExtension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DesktopExtension::IsInitialized() const {
  return true;
}

void DesktopExtension::InternalSwap(DesktopExtension* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

std::string DesktopExtension::GetTypeName() const {
  return "proto.DesktopExtension";
}


// ===================================================================

class DesktopCapabilities_Flag::_Internal {
 public:
};

DesktopCapabilities_Flag::DesktopCapabilities_Flag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DesktopCapabilities.Flag)
}
DesktopCapabilities_Flag::DesktopCapabilities_Flag(const DesktopCapabilities_Flag& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DesktopCapabilities_Flag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:proto.DesktopCapabilities.Flag)
}

inline void DesktopCapabilities_Flag::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DesktopCapabilities_Flag::~DesktopCapabilities_Flag() {
  // @@protoc_insertion_point(destructor:proto.DesktopCapabilities.Flag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DesktopCapabilities_Flag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DesktopCapabilities_Flag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DesktopCapabilities_Flag::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DesktopCapabilities.Flag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.value_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* DesktopCapabilities_Flag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DesktopCapabilities_Flag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DesktopCapabilities.Flag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.DesktopCapabilities.Flag.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool value = 2;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DesktopCapabilities.Flag)
  return target;
}

size_t DesktopCapabilities_Flag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DesktopCapabilities.Flag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool value = 2;
  if (this->_internal_value() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DesktopCapabilities_Flag::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DesktopCapabilities_Flag*>(
      &from));
}

void DesktopCapabilities_Flag::MergeFrom(const DesktopCapabilities_Flag& from) {
  DesktopCapabilities_Flag* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DesktopCapabilities.Flag)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DesktopCapabilities_Flag::CopyFrom(const DesktopCapabilities_Flag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DesktopCapabilities.Flag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DesktopCapabilities_Flag::IsInitialized() const {
  return true;
}

void DesktopCapabilities_Flag::InternalSwap(DesktopCapabilities_Flag* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

std::string DesktopCapabilities_Flag::GetTypeName() const {
  return "proto.DesktopCapabilities.Flag";
}


// ===================================================================

class DesktopCapabilities::_Internal {
 public:
};

DesktopCapabilities::DesktopCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DesktopCapabilities)
}
DesktopCapabilities::DesktopCapabilities(const DesktopCapabilities& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DesktopCapabilities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){from._impl_.flag_}
    , decltype(_impl_.extensions_){}
    , decltype(_impl_.video_encodings_){}
    , decltype(_impl_.audio_encodings_){}
    , decltype(_impl_.os_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.extensions_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extensions_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_extensions().empty()) {
    _this->_impl_.extensions_.Set(from._internal_extensions(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.video_encodings_, &from._impl_.video_encodings_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.os_type_) -
    reinterpret_cast<char*>(&_impl_.video_encodings_)) + sizeof(_impl_.os_type_));
  // @@protoc_insertion_point(copy_constructor:proto.DesktopCapabilities)
}

inline void DesktopCapabilities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){arena}
    , decltype(_impl_.extensions_){}
    , decltype(_impl_.video_encodings_){0u}
    , decltype(_impl_.audio_encodings_){0u}
    , decltype(_impl_.os_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.extensions_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extensions_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DesktopCapabilities::~DesktopCapabilities() {
  // @@protoc_insertion_point(destructor:proto.DesktopCapabilities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DesktopCapabilities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.flag_.~RepeatedPtrField();
  _impl_.extensions_.Destroy();
}

void DesktopCapabilities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DesktopCapabilities::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DesktopCapabilities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flag_.Clear();
  _impl_.extensions_.ClearToEmpty();
  ::memset(&_impl_.video_encodings_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.os_type_) -
      reinterpret_cast<char*>(&_impl_.video_encodings_)) + sizeof(_impl_.os_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* DesktopCapabilities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string extensions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_extensions();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 video_encodings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.video_encodings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 audio_encodings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.audio_encodings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.DesktopCapabilities.OsType os_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_os_type(static_cast<::proto::DesktopCapabilities_OsType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.DesktopCapabilities.Flag flag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_flag(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DesktopCapabilities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DesktopCapabilities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string extensions = 1;
  if (!this->_internal_extensions().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_extensions().data(), static_cast<int>(this->_internal_extensions().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.DesktopCapabilities.extensions");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_extensions(), target);
  }

  // uint32 video_encodings = 2;
  if (this->_internal_video_encodings() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_video_encodings(), target);
  }

  // uint32 audio_encodings = 3;
  if (this->_internal_audio_encodings() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_audio_encodings(), target);
  }

  // .proto.DesktopCapabilities.OsType os_type = 4;
  if (this->_internal_os_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_os_type(), target);
  }

  // repeated .proto.DesktopCapabilities.Flag flag = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_flag_size()); i < n; i++) {
    const auto& repfield = this->_internal_flag(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DesktopCapabilities)
  return target;
}

size_t DesktopCapabilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DesktopCapabilities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.DesktopCapabilities.Flag flag = 5;
  total_size += 1UL * this->_internal_flag_size();
  for (const auto& msg : this->_impl_.flag_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string extensions = 1;
  if (!this->_internal_extensions().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_extensions());
  }

  // uint32 video_encodings = 2;
  if (this->_internal_video_encodings() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_video_encodings());
  }

  // uint32 audio_encodings = 3;
  if (this->_internal_audio_encodings() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_audio_encodings());
  }

  // .proto.DesktopCapabilities.OsType os_type = 4;
  if (this->_internal_os_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_os_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DesktopCapabilities::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DesktopCapabilities*>(
      &from));
}

void DesktopCapabilities::MergeFrom(const DesktopCapabilities& from) {
  DesktopCapabilities* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DesktopCapabilities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.flag_.MergeFrom(from._impl_.flag_);
  if (!from._internal_extensions().empty()) {
    _this->_internal_set_extensions(from._internal_extensions());
  }
  if (from._internal_video_encodings() != 0) {
    _this->_internal_set_video_encodings(from._internal_video_encodings());
  }
  if (from._internal_audio_encodings() != 0) {
    _this->_internal_set_audio_encodings(from._internal_audio_encodings());
  }
  if (from._internal_os_type() != 0) {
    _this->_internal_set_os_type(from._internal_os_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DesktopCapabilities::CopyFrom(const DesktopCapabilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DesktopCapabilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DesktopCapabilities::IsInitialized() const {
  return true;
}

void DesktopCapabilities::InternalSwap(DesktopCapabilities* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.flag_.InternalSwap(&other->_impl_.flag_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extensions_, lhs_arena,
      &other->_impl_.extensions_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DesktopCapabilities, _impl_.os_type_)
      + sizeof(DesktopCapabilities::_impl_.os_type_)
      - PROTOBUF_FIELD_OFFSET(DesktopCapabilities, _impl_.video_encodings_)>(
          reinterpret_cast<char*>(&_impl_.video_encodings_),
          reinterpret_cast<char*>(&other->_impl_.video_encodings_));
}

std::string DesktopCapabilities::GetTypeName() const {
  return "proto.DesktopCapabilities";
}


// ===================================================================

class DesktopConfig::_Internal {
 public:
  static const ::proto::PixelFormat& pixel_format(const DesktopConfig* msg);
};

const ::proto::PixelFormat&
DesktopConfig::_Internal::pixel_format(const DesktopConfig* msg) {
  return *msg->_impl_.pixel_format_;
}
DesktopConfig::DesktopConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DesktopConfig)
}
DesktopConfig::DesktopConfig(const DesktopConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DesktopConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pixel_format_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.video_encoding_){}
    , decltype(_impl_.update_interval_){}
    , decltype(_impl_.compress_ratio_){}
    , decltype(_impl_.scale_factor_){}
    , decltype(_impl_.audio_encoding_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_pixel_format()) {
    _this->_impl_.pixel_format_ = new ::proto::PixelFormat(*from._impl_.pixel_format_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.audio_encoding_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.audio_encoding_));
  // @@protoc_insertion_point(copy_constructor:proto.DesktopConfig)
}

inline void DesktopConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pixel_format_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.video_encoding_){0}
    , decltype(_impl_.update_interval_){0u}
    , decltype(_impl_.compress_ratio_){0u}
    , decltype(_impl_.scale_factor_){0u}
    , decltype(_impl_.audio_encoding_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DesktopConfig::~DesktopConfig() {
  // @@protoc_insertion_point(destructor:proto.DesktopConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DesktopConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pixel_format_;
}

void DesktopConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DesktopConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DesktopConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pixel_format_ != nullptr) {
    delete _impl_.pixel_format_;
  }
  _impl_.pixel_format_ = nullptr;
  ::memset(&_impl_.flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.audio_encoding_) -
      reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.audio_encoding_));
  _internal_metadata_.Clear<std::string>();
}

const char* DesktopConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.VideoEncoding video_encoding = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_video_encoding(static_cast<::proto::VideoEncoding>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.PixelFormat pixel_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pixel_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 update_interval = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 compress_ratio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.compress_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 scale_factor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioEncoding audio_encoding = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_audio_encoding(static_cast<::proto::AudioEncoding>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DesktopConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DesktopConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  // .proto.VideoEncoding video_encoding = 2;
  if (this->_internal_video_encoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_video_encoding(), target);
  }

  // .proto.PixelFormat pixel_format = 3;
  if (this->_internal_has_pixel_format()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pixel_format(this),
        _Internal::pixel_format(this).GetCachedSize(), target, stream);
  }

  // uint32 update_interval = 4;
  if (this->_internal_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_update_interval(), target);
  }

  // uint32 compress_ratio = 5;
  if (this->_internal_compress_ratio() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_compress_ratio(), target);
  }

  // uint32 scale_factor = 6;
  if (this->_internal_scale_factor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_scale_factor(), target);
  }

  // .proto.AudioEncoding audio_encoding = 7;
  if (this->_internal_audio_encoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_audio_encoding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DesktopConfig)
  return target;
}

size_t DesktopConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DesktopConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.PixelFormat pixel_format = 3;
  if (this->_internal_has_pixel_format()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pixel_format_);
  }

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  // .proto.VideoEncoding video_encoding = 2;
  if (this->_internal_video_encoding() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_video_encoding());
  }

  // uint32 update_interval = 4;
  if (this->_internal_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_update_interval());
  }

  // uint32 compress_ratio = 5;
  if (this->_internal_compress_ratio() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_compress_ratio());
  }

  // uint32 scale_factor = 6;
  if (this->_internal_scale_factor() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scale_factor());
  }

  // .proto.AudioEncoding audio_encoding = 7;
  if (this->_internal_audio_encoding() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_audio_encoding());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DesktopConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DesktopConfig*>(
      &from));
}

void DesktopConfig::MergeFrom(const DesktopConfig& from) {
  DesktopConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DesktopConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pixel_format()) {
    _this->_internal_mutable_pixel_format()->::proto::PixelFormat::MergeFrom(
        from._internal_pixel_format());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_video_encoding() != 0) {
    _this->_internal_set_video_encoding(from._internal_video_encoding());
  }
  if (from._internal_update_interval() != 0) {
    _this->_internal_set_update_interval(from._internal_update_interval());
  }
  if (from._internal_compress_ratio() != 0) {
    _this->_internal_set_compress_ratio(from._internal_compress_ratio());
  }
  if (from._internal_scale_factor() != 0) {
    _this->_internal_set_scale_factor(from._internal_scale_factor());
  }
  if (from._internal_audio_encoding() != 0) {
    _this->_internal_set_audio_encoding(from._internal_audio_encoding());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DesktopConfig::CopyFrom(const DesktopConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DesktopConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DesktopConfig::IsInitialized() const {
  return true;
}

void DesktopConfig::InternalSwap(DesktopConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DesktopConfig, _impl_.audio_encoding_)
      + sizeof(DesktopConfig::_impl_.audio_encoding_)
      - PROTOBUF_FIELD_OFFSET(DesktopConfig, _impl_.pixel_format_)>(
          reinterpret_cast<char*>(&_impl_.pixel_format_),
          reinterpret_cast<char*>(&other->_impl_.pixel_format_));
}

std::string DesktopConfig::GetTypeName() const {
  return "proto.DesktopConfig";
}


// ===================================================================

class HostToClient::_Internal {
 public:
  static const ::proto::VideoPacket& video_packet(const HostToClient* msg);
  static const ::proto::AudioPacket& audio_packet(const HostToClient* msg);
  static const ::proto::CursorShape& cursor_shape(const HostToClient* msg);
  static const ::proto::ClipboardEvent& clipboard_event(const HostToClient* msg);
  static const ::proto::DesktopExtension& extension(const HostToClient* msg);
  static const ::proto::DesktopCapabilities& capabilities(const HostToClient* msg);
  static const ::proto::CursorPosition& cursor_position(const HostToClient* msg);
};

const ::proto::VideoPacket&
HostToClient::_Internal::video_packet(const HostToClient* msg) {
  return *msg->_impl_.video_packet_;
}
const ::proto::AudioPacket&
HostToClient::_Internal::audio_packet(const HostToClient* msg) {
  return *msg->_impl_.audio_packet_;
}
const ::proto::CursorShape&
HostToClient::_Internal::cursor_shape(const HostToClient* msg) {
  return *msg->_impl_.cursor_shape_;
}
const ::proto::ClipboardEvent&
HostToClient::_Internal::clipboard_event(const HostToClient* msg) {
  return *msg->_impl_.clipboard_event_;
}
const ::proto::DesktopExtension&
HostToClient::_Internal::extension(const HostToClient* msg) {
  return *msg->_impl_.extension_;
}
const ::proto::DesktopCapabilities&
HostToClient::_Internal::capabilities(const HostToClient* msg) {
  return *msg->_impl_.capabilities_;
}
const ::proto::CursorPosition&
HostToClient::_Internal::cursor_position(const HostToClient* msg) {
  return *msg->_impl_.cursor_position_;
}
HostToClient::HostToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.HostToClient)
}
HostToClient::HostToClient(const HostToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.video_packet_){nullptr}
    , decltype(_impl_.audio_packet_){nullptr}
    , decltype(_impl_.cursor_shape_){nullptr}
    , decltype(_impl_.clipboard_event_){nullptr}
    , decltype(_impl_.extension_){nullptr}
    , decltype(_impl_.capabilities_){nullptr}
    , decltype(_impl_.cursor_position_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_video_packet()) {
    _this->_impl_.video_packet_ = new ::proto::VideoPacket(*from._impl_.video_packet_);
  }
  if (from._internal_has_audio_packet()) {
    _this->_impl_.audio_packet_ = new ::proto::AudioPacket(*from._impl_.audio_packet_);
  }
  if (from._internal_has_cursor_shape()) {
    _this->_impl_.cursor_shape_ = new ::proto::CursorShape(*from._impl_.cursor_shape_);
  }
  if (from._internal_has_clipboard_event()) {
    _this->_impl_.clipboard_event_ = new ::proto::ClipboardEvent(*from._impl_.clipboard_event_);
  }
  if (from._internal_has_extension()) {
    _this->_impl_.extension_ = new ::proto::DesktopExtension(*from._impl_.extension_);
  }
  if (from._internal_has_capabilities()) {
    _this->_impl_.capabilities_ = new ::proto::DesktopCapabilities(*from._impl_.capabilities_);
  }
  if (from._internal_has_cursor_position()) {
    _this->_impl_.cursor_position_ = new ::proto::CursorPosition(*from._impl_.cursor_position_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.HostToClient)
}

inline void HostToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.video_packet_){nullptr}
    , decltype(_impl_.audio_packet_){nullptr}
    , decltype(_impl_.cursor_shape_){nullptr}
    , decltype(_impl_.clipboard_event_){nullptr}
    , decltype(_impl_.extension_){nullptr}
    , decltype(_impl_.capabilities_){nullptr}
    , decltype(_impl_.cursor_position_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HostToClient::~HostToClient() {
  // @@protoc_insertion_point(destructor:proto.HostToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.video_packet_;
  if (this != internal_default_instance()) delete _impl_.audio_packet_;
  if (this != internal_default_instance()) delete _impl_.cursor_shape_;
  if (this != internal_default_instance()) delete _impl_.clipboard_event_;
  if (this != internal_default_instance()) delete _impl_.extension_;
  if (this != internal_default_instance()) delete _impl_.capabilities_;
  if (this != internal_default_instance()) delete _impl_.cursor_position_;
}

void HostToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.HostToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.video_packet_ != nullptr) {
    delete _impl_.video_packet_;
  }
  _impl_.video_packet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.audio_packet_ != nullptr) {
    delete _impl_.audio_packet_;
  }
  _impl_.audio_packet_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.cursor_shape_ != nullptr) {
    delete _impl_.cursor_shape_;
  }
  _impl_.cursor_shape_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.clipboard_event_ != nullptr) {
    delete _impl_.clipboard_event_;
  }
  _impl_.clipboard_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.extension_ != nullptr) {
    delete _impl_.extension_;
  }
  _impl_.extension_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.capabilities_ != nullptr) {
    delete _impl_.capabilities_;
  }
  _impl_.capabilities_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.cursor_position_ != nullptr) {
    delete _impl_.cursor_position_;
  }
  _impl_.cursor_position_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* HostToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.VideoPacket video_packet = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioPacket audio_packet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.CursorShape cursor_shape = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cursor_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ClipboardEvent clipboard_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_clipboard_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.DesktopExtension extension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.DesktopCapabilities capabilities = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_capabilities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.CursorPosition cursor_position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_cursor_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.HostToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.VideoPacket video_packet = 1;
  if (this->_internal_has_video_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::video_packet(this),
        _Internal::video_packet(this).GetCachedSize(), target, stream);
  }

  // .proto.AudioPacket audio_packet = 2;
  if (this->_internal_has_audio_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::audio_packet(this),
        _Internal::audio_packet(this).GetCachedSize(), target, stream);
  }

  // .proto.CursorShape cursor_shape = 3;
  if (this->_internal_has_cursor_shape()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cursor_shape(this),
        _Internal::cursor_shape(this).GetCachedSize(), target, stream);
  }

  // .proto.ClipboardEvent clipboard_event = 4;
  if (this->_internal_has_clipboard_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::clipboard_event(this),
        _Internal::clipboard_event(this).GetCachedSize(), target, stream);
  }

  // .proto.DesktopExtension extension = 5;
  if (this->_internal_has_extension()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::extension(this),
        _Internal::extension(this).GetCachedSize(), target, stream);
  }

  // .proto.DesktopCapabilities capabilities = 6;
  if (this->_internal_has_capabilities()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::capabilities(this),
        _Internal::capabilities(this).GetCachedSize(), target, stream);
  }

  // .proto.CursorPosition cursor_position = 7;
  if (this->_internal_has_cursor_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::cursor_position(this),
        _Internal::cursor_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.HostToClient)
  return target;
}

size_t HostToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.HostToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.VideoPacket video_packet = 1;
  if (this->_internal_has_video_packet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_packet_);
  }

  // .proto.AudioPacket audio_packet = 2;
  if (this->_internal_has_audio_packet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_packet_);
  }

  // .proto.CursorShape cursor_shape = 3;
  if (this->_internal_has_cursor_shape()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cursor_shape_);
  }

  // .proto.ClipboardEvent clipboard_event = 4;
  if (this->_internal_has_clipboard_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.clipboard_event_);
  }

  // .proto.DesktopExtension extension = 5;
  if (this->_internal_has_extension()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.extension_);
  }

  // .proto.DesktopCapabilities capabilities = 6;
  if (this->_internal_has_capabilities()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.capabilities_);
  }

  // .proto.CursorPosition cursor_position = 7;
  if (this->_internal_has_cursor_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cursor_position_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostToClient::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostToClient*>(
      &from));
}

void HostToClient::MergeFrom(const HostToClient& from) {
  HostToClient* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.HostToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_video_packet()) {
    _this->_internal_mutable_video_packet()->::proto::VideoPacket::MergeFrom(
        from._internal_video_packet());
  }
  if (from._internal_has_audio_packet()) {
    _this->_internal_mutable_audio_packet()->::proto::AudioPacket::MergeFrom(
        from._internal_audio_packet());
  }
  if (from._internal_has_cursor_shape()) {
    _this->_internal_mutable_cursor_shape()->::proto::CursorShape::MergeFrom(
        from._internal_cursor_shape());
  }
  if (from._internal_has_clipboard_event()) {
    _this->_internal_mutable_clipboard_event()->::proto::ClipboardEvent::MergeFrom(
        from._internal_clipboard_event());
  }
  if (from._internal_has_extension()) {
    _this->_internal_mutable_extension()->::proto::DesktopExtension::MergeFrom(
        from._internal_extension());
  }
  if (from._internal_has_capabilities()) {
    _this->_internal_mutable_capabilities()->::proto::DesktopCapabilities::MergeFrom(
        from._internal_capabilities());
  }
  if (from._internal_has_cursor_position()) {
    _this->_internal_mutable_cursor_position()->::proto::CursorPosition::MergeFrom(
        from._internal_cursor_position());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostToClient::CopyFrom(const HostToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.HostToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostToClient::IsInitialized() const {
  return true;
}

void HostToClient::InternalSwap(HostToClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HostToClient, _impl_.cursor_position_)
      + sizeof(HostToClient::_impl_.cursor_position_)
      - PROTOBUF_FIELD_OFFSET(HostToClient, _impl_.video_packet_)>(
          reinterpret_cast<char*>(&_impl_.video_packet_),
          reinterpret_cast<char*>(&other->_impl_.video_packet_));
}

std::string HostToClient::GetTypeName() const {
  return "proto.HostToClient";
}


// ===================================================================

class ClientToHost::_Internal {
 public:
  static const ::proto::MouseEvent& mouse_event(const ClientToHost* msg);
  static const ::proto::KeyEvent& key_event(const ClientToHost* msg);
  static const ::proto::TextEvent& text_event(const ClientToHost* msg);
  static const ::proto::ClipboardEvent& clipboard_event(const ClientToHost* msg);
  static const ::proto::DesktopExtension& extension(const ClientToHost* msg);
  static const ::proto::DesktopConfig& config(const ClientToHost* msg);
  static const ::proto::AudioPacket& audio_packet(const ClientToHost* msg);
};

const ::proto::MouseEvent&
ClientToHost::_Internal::mouse_event(const ClientToHost* msg) {
  return *msg->_impl_.mouse_event_;
}
const ::proto::KeyEvent&
ClientToHost::_Internal::key_event(const ClientToHost* msg) {
  return *msg->_impl_.key_event_;
}
const ::proto::TextEvent&
ClientToHost::_Internal::text_event(const ClientToHost* msg) {
  return *msg->_impl_.text_event_;
}
const ::proto::ClipboardEvent&
ClientToHost::_Internal::clipboard_event(const ClientToHost* msg) {
  return *msg->_impl_.clipboard_event_;
}
const ::proto::DesktopExtension&
ClientToHost::_Internal::extension(const ClientToHost* msg) {
  return *msg->_impl_.extension_;
}
const ::proto::DesktopConfig&
ClientToHost::_Internal::config(const ClientToHost* msg) {
  return *msg->_impl_.config_;
}
const ::proto::AudioPacket&
ClientToHost::_Internal::audio_packet(const ClientToHost* msg) {
  return *msg->_impl_.audio_packet_;
}
ClientToHost::ClientToHost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ClientToHost)
}
ClientToHost::ClientToHost(const ClientToHost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientToHost* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mouse_event_){nullptr}
    , decltype(_impl_.key_event_){nullptr}
    , decltype(_impl_.text_event_){nullptr}
    , decltype(_impl_.clipboard_event_){nullptr}
    , decltype(_impl_.extension_){nullptr}
    , decltype(_impl_.config_){nullptr}
    , decltype(_impl_.audio_packet_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_mouse_event()) {
    _this->_impl_.mouse_event_ = new ::proto::MouseEvent(*from._impl_.mouse_event_);
  }
  if (from._internal_has_key_event()) {
    _this->_impl_.key_event_ = new ::proto::KeyEvent(*from._impl_.key_event_);
  }
  if (from._internal_has_text_event()) {
    _this->_impl_.text_event_ = new ::proto::TextEvent(*from._impl_.text_event_);
  }
  if (from._internal_has_clipboard_event()) {
    _this->_impl_.clipboard_event_ = new ::proto::ClipboardEvent(*from._impl_.clipboard_event_);
  }
  if (from._internal_has_extension()) {
    _this->_impl_.extension_ = new ::proto::DesktopExtension(*from._impl_.extension_);
  }
  if (from._internal_has_config()) {
    _this->_impl_.config_ = new ::proto::DesktopConfig(*from._impl_.config_);
  }
  if (from._internal_has_audio_packet()) {
    _this->_impl_.audio_packet_ = new ::proto::AudioPacket(*from._impl_.audio_packet_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.ClientToHost)
}

inline void ClientToHost::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mouse_event_){nullptr}
    , decltype(_impl_.key_event_){nullptr}
    , decltype(_impl_.text_event_){nullptr}
    , decltype(_impl_.clipboard_event_){nullptr}
    , decltype(_impl_.extension_){nullptr}
    , decltype(_impl_.config_){nullptr}
    , decltype(_impl_.audio_packet_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ClientToHost::~ClientToHost() {
  // @@protoc_insertion_point(destructor:proto.ClientToHost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientToHost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mouse_event_;
  if (this != internal_default_instance()) delete _impl_.key_event_;
  if (this != internal_default_instance()) delete _impl_.text_event_;
  if (this != internal_default_instance()) delete _impl_.clipboard_event_;
  if (this != internal_default_instance()) delete _impl_.extension_;
  if (this != internal_default_instance()) delete _impl_.config_;
  if (this != internal_default_instance()) delete _impl_.audio_packet_;
}

void ClientToHost::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientToHost::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ClientToHost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.mouse_event_ != nullptr) {
    delete _impl_.mouse_event_;
  }
  _impl_.mouse_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.key_event_ != nullptr) {
    delete _impl_.key_event_;
  }
  _impl_.key_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.text_event_ != nullptr) {
    delete _impl_.text_event_;
  }
  _impl_.text_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.clipboard_event_ != nullptr) {
    delete _impl_.clipboard_event_;
  }
  _impl_.clipboard_event_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.extension_ != nullptr) {
    delete _impl_.extension_;
  }
  _impl_.extension_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.audio_packet_ != nullptr) {
    delete _impl_.audio_packet_;
  }
  _impl_.audio_packet_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* ClientToHost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.MouseEvent mouse_event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mouse_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.KeyEvent key_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.TextEvent text_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ClipboardEvent clipboard_event = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_clipboard_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.DesktopExtension extension = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.DesktopConfig config = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AudioPacket audio_packet = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientToHost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ClientToHost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.MouseEvent mouse_event = 1;
  if (this->_internal_has_mouse_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mouse_event(this),
        _Internal::mouse_event(this).GetCachedSize(), target, stream);
  }

  // .proto.KeyEvent key_event = 2;
  if (this->_internal_has_key_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key_event(this),
        _Internal::key_event(this).GetCachedSize(), target, stream);
  }

  // .proto.TextEvent text_event = 4;
  if (this->_internal_has_text_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::text_event(this),
        _Internal::text_event(this).GetCachedSize(), target, stream);
  }

  // .proto.ClipboardEvent clipboard_event = 5;
  if (this->_internal_has_clipboard_event()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::clipboard_event(this),
        _Internal::clipboard_event(this).GetCachedSize(), target, stream);
  }

  // .proto.DesktopExtension extension = 6;
  if (this->_internal_has_extension()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::extension(this),
        _Internal::extension(this).GetCachedSize(), target, stream);
  }

  // .proto.DesktopConfig config = 7;
  if (this->_internal_has_config()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  // .proto.AudioPacket audio_packet = 8;
  if (this->_internal_has_audio_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::audio_packet(this),
        _Internal::audio_packet(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ClientToHost)
  return target;
}

size_t ClientToHost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ClientToHost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.MouseEvent mouse_event = 1;
  if (this->_internal_has_mouse_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mouse_event_);
  }

  // .proto.KeyEvent key_event = 2;
  if (this->_internal_has_key_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_event_);
  }

  // .proto.TextEvent text_event = 4;
  if (this->_internal_has_text_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.text_event_);
  }

  // .proto.ClipboardEvent clipboard_event = 5;
  if (this->_internal_has_clipboard_event()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.clipboard_event_);
  }

  // .proto.DesktopExtension extension = 6;
  if (this->_internal_has_extension()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.extension_);
  }

  // .proto.DesktopConfig config = 7;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.config_);
  }

  // .proto.AudioPacket audio_packet = 8;
  if (this->_internal_has_audio_packet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_packet_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToHost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientToHost*>(
      &from));
}

void ClientToHost::MergeFrom(const ClientToHost& from) {
  ClientToHost* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ClientToHost)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mouse_event()) {
    _this->_internal_mutable_mouse_event()->::proto::MouseEvent::MergeFrom(
        from._internal_mouse_event());
  }
  if (from._internal_has_key_event()) {
    _this->_internal_mutable_key_event()->::proto::KeyEvent::MergeFrom(
        from._internal_key_event());
  }
  if (from._internal_has_text_event()) {
    _this->_internal_mutable_text_event()->::proto::TextEvent::MergeFrom(
        from._internal_text_event());
  }
  if (from._internal_has_clipboard_event()) {
    _this->_internal_mutable_clipboard_event()->::proto::ClipboardEvent::MergeFrom(
        from._internal_clipboard_event());
  }
  if (from._internal_has_extension()) {
    _this->_internal_mutable_extension()->::proto::DesktopExtension::MergeFrom(
        from._internal_extension());
  }
  if (from._internal_has_config()) {
    _this->_internal_mutable_config()->::proto::DesktopConfig::MergeFrom(
        from._internal_config());
  }
  if (from._internal_has_audio_packet()) {
    _this->_internal_mutable_audio_packet()->::proto::AudioPacket::MergeFrom(
        from._internal_audio_packet());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToHost::CopyFrom(const ClientToHost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ClientToHost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToHost::IsInitialized() const {
  return true;
}

void ClientToHost::InternalSwap(ClientToHost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientToHost, _impl_.audio_packet_)
      + sizeof(ClientToHost::_impl_.audio_packet_)
      - PROTOBUF_FIELD_OFFSET(ClientToHost, _impl_.mouse_event_)>(
          reinterpret_cast<char*>(&_impl_.mouse_event_),
          reinterpret_cast<char*>(&other->_impl_.mouse_event_));
}

std::string ClientToHost::GetTypeName() const {
  return "proto.ClientToHost";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::KeyEvent*
Arena::CreateMaybeMessage< ::proto::KeyEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::KeyEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TextEvent*
Arena::CreateMaybeMessage< ::proto::TextEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TextEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::MouseEvent*
Arena::CreateMaybeMessage< ::proto::MouseEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::MouseEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ClipboardEvent*
Arena::CreateMaybeMessage< ::proto::ClipboardEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ClipboardEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::CursorShape*
Arena::CreateMaybeMessage< ::proto::CursorShape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::CursorShape >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::CursorPosition*
Arena::CreateMaybeMessage< ::proto::CursorPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::CursorPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::Size*
Arena::CreateMaybeMessage< ::proto::Size >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::Size >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::Rect*
Arena::CreateMaybeMessage< ::proto::Rect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::Rect >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::PixelFormat*
Arena::CreateMaybeMessage< ::proto::PixelFormat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::PixelFormat >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::VideoPacketFormat*
Arena::CreateMaybeMessage< ::proto::VideoPacketFormat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::VideoPacketFormat >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::VideoPacket*
Arena::CreateMaybeMessage< ::proto::VideoPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::VideoPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::AudioPacket*
Arena::CreateMaybeMessage< ::proto::AudioPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::AudioPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DesktopExtension*
Arena::CreateMaybeMessage< ::proto::DesktopExtension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DesktopExtension >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DesktopCapabilities_Flag*
Arena::CreateMaybeMessage< ::proto::DesktopCapabilities_Flag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DesktopCapabilities_Flag >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DesktopCapabilities*
Arena::CreateMaybeMessage< ::proto::DesktopCapabilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DesktopCapabilities >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DesktopConfig*
Arena::CreateMaybeMessage< ::proto::DesktopConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DesktopConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::HostToClient*
Arena::CreateMaybeMessage< ::proto::HostToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::HostToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ClientToHost*
Arena::CreateMaybeMessage< ::proto::ClientToHost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ClientToHost >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
