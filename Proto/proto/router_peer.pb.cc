// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_peer.proto

#include "router_peer.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
PROTOBUF_CONSTEXPR HostIdRequest::HostIdRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostIdRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostIdRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostIdRequestDefaultTypeInternal() {}
  union {
    HostIdRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostIdRequestDefaultTypeInternal _HostIdRequest_default_instance_;
PROTOBUF_CONSTEXPR ResetHostId::ResetHostId(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResetHostIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetHostIdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetHostIdDefaultTypeInternal() {}
  union {
    ResetHostId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetHostIdDefaultTypeInternal _ResetHostId_default_instance_;
PROTOBUF_CONSTEXPR HostIdResponse::HostIdResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_id_)*/uint64_t{0u}
  , /*decltype(_impl_.error_code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostIdResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostIdResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostIdResponseDefaultTypeInternal() {}
  union {
    HostIdResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostIdResponseDefaultTypeInternal _HostIdResponse_default_instance_;
PROTOBUF_CONSTEXPR ConnectionRequest::ConnectionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConnectionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionRequestDefaultTypeInternal() {}
  union {
    ConnectionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionRequestDefaultTypeInternal _ConnectionRequest_default_instance_;
PROTOBUF_CONSTEXPR HostOfferData::HostOfferData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostOfferDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostOfferDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostOfferDataDefaultTypeInternal() {}
  union {
    HostOfferData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostOfferDataDefaultTypeInternal _HostOfferData_default_instance_;
PROTOBUF_CONSTEXPR ConnectionOffer::ConnectionOffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.relay_)*/nullptr
  , /*decltype(_impl_.host_data_)*/nullptr
  , /*decltype(_impl_.peer_role_)*/0
  , /*decltype(_impl_.error_code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConnectionOfferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionOfferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionOfferDefaultTypeInternal() {}
  union {
    ConnectionOffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionOfferDefaultTypeInternal _ConnectionOffer_default_instance_;
PROTOBUF_CONSTEXPR CheckHostStatus::CheckHostStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckHostStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckHostStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckHostStatusDefaultTypeInternal() {}
  union {
    CheckHostStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckHostStatusDefaultTypeInternal _CheckHostStatus_default_instance_;
PROTOBUF_CONSTEXPR HostStatus::HostStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostStatusDefaultTypeInternal() {}
  union {
    HostStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostStatusDefaultTypeInternal _HostStatus_default_instance_;
PROTOBUF_CONSTEXPR RouterToPeer::RouterToPeer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_id_response_)*/nullptr
  , /*decltype(_impl_.connection_offer_)*/nullptr
  , /*decltype(_impl_.host_status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RouterToPeerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouterToPeerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouterToPeerDefaultTypeInternal() {}
  union {
    RouterToPeer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouterToPeerDefaultTypeInternal _RouterToPeer_default_instance_;
PROTOBUF_CONSTEXPR PeerToRouter::PeerToRouter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.connection_request_)*/nullptr
  , /*decltype(_impl_.host_id_request_)*/nullptr
  , /*decltype(_impl_.reset_host_id_)*/nullptr
  , /*decltype(_impl_.check_host_status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PeerToRouterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeerToRouterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeerToRouterDefaultTypeInternal() {}
  union {
    PeerToRouter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeerToRouterDefaultTypeInternal _PeerToRouter_default_instance_;
}  // namespace proto
namespace proto {
bool HostIdRequest_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HostIdRequest_Type_strings[3] = {};

static const char HostIdRequest_Type_names[] =
  "EXISTING_ID"
  "NEW_ID"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HostIdRequest_Type_entries[] = {
  { {HostIdRequest_Type_names + 0, 11}, 2 },
  { {HostIdRequest_Type_names + 11, 6}, 1 },
  { {HostIdRequest_Type_names + 17, 7}, 0 },
};

static const int HostIdRequest_Type_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  1, // 1 -> NEW_ID
  0, // 2 -> EXISTING_ID
};

const std::string& HostIdRequest_Type_Name(
    HostIdRequest_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HostIdRequest_Type_entries,
          HostIdRequest_Type_entries_by_number,
          3, HostIdRequest_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HostIdRequest_Type_entries,
      HostIdRequest_Type_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HostIdRequest_Type_strings[idx].get();
}
bool HostIdRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostIdRequest_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HostIdRequest_Type_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HostIdRequest_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr HostIdRequest_Type HostIdRequest::UNKNOWN;
constexpr HostIdRequest_Type HostIdRequest::NEW_ID;
constexpr HostIdRequest_Type HostIdRequest::EXISTING_ID;
constexpr HostIdRequest_Type HostIdRequest::Type_MIN;
constexpr HostIdRequest_Type HostIdRequest::Type_MAX;
constexpr int HostIdRequest::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool HostIdResponse_ErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HostIdResponse_ErrorCode_strings[3] = {};

static const char HostIdResponse_ErrorCode_names[] =
  "NO_HOST_FOUND"
  "SUCCESS"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HostIdResponse_ErrorCode_entries[] = {
  { {HostIdResponse_ErrorCode_names + 0, 13}, 2 },
  { {HostIdResponse_ErrorCode_names + 13, 7}, 0 },
  { {HostIdResponse_ErrorCode_names + 20, 7}, 1 },
};

static const int HostIdResponse_ErrorCode_entries_by_number[] = {
  1, // 0 -> SUCCESS
  2, // 1 -> UNKNOWN
  0, // 2 -> NO_HOST_FOUND
};

const std::string& HostIdResponse_ErrorCode_Name(
    HostIdResponse_ErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HostIdResponse_ErrorCode_entries,
          HostIdResponse_ErrorCode_entries_by_number,
          3, HostIdResponse_ErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HostIdResponse_ErrorCode_entries,
      HostIdResponse_ErrorCode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HostIdResponse_ErrorCode_strings[idx].get();
}
bool HostIdResponse_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostIdResponse_ErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HostIdResponse_ErrorCode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HostIdResponse_ErrorCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr HostIdResponse_ErrorCode HostIdResponse::SUCCESS;
constexpr HostIdResponse_ErrorCode HostIdResponse::UNKNOWN;
constexpr HostIdResponse_ErrorCode HostIdResponse::NO_HOST_FOUND;
constexpr HostIdResponse_ErrorCode HostIdResponse::ErrorCode_MIN;
constexpr HostIdResponse_ErrorCode HostIdResponse::ErrorCode_MAX;
constexpr int HostIdResponse::ErrorCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionOffer_PeerRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionOffer_PeerRole_strings[2] = {};

static const char ConnectionOffer_PeerRole_names[] =
  "CLIENT"
  "HOST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionOffer_PeerRole_entries[] = {
  { {ConnectionOffer_PeerRole_names + 0, 6}, 1 },
  { {ConnectionOffer_PeerRole_names + 6, 4}, 0 },
};

static const int ConnectionOffer_PeerRole_entries_by_number[] = {
  1, // 0 -> HOST
  0, // 1 -> CLIENT
};

const std::string& ConnectionOffer_PeerRole_Name(
    ConnectionOffer_PeerRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionOffer_PeerRole_entries,
          ConnectionOffer_PeerRole_entries_by_number,
          2, ConnectionOffer_PeerRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionOffer_PeerRole_entries,
      ConnectionOffer_PeerRole_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionOffer_PeerRole_strings[idx].get();
}
bool ConnectionOffer_PeerRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionOffer_PeerRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionOffer_PeerRole_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionOffer_PeerRole>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionOffer_PeerRole ConnectionOffer::HOST;
constexpr ConnectionOffer_PeerRole ConnectionOffer::CLIENT;
constexpr ConnectionOffer_PeerRole ConnectionOffer::PeerRole_MIN;
constexpr ConnectionOffer_PeerRole ConnectionOffer::PeerRole_MAX;
constexpr int ConnectionOffer::PeerRole_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionOffer_ErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionOffer_ErrorCode_strings[5] = {};

static const char ConnectionOffer_ErrorCode_names[] =
  "ACCESS_DENIED"
  "KEY_POOL_EMPTY"
  "PEER_NOT_FOUND"
  "SUCCESS"
  "UNKNOWN_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionOffer_ErrorCode_entries[] = {
  { {ConnectionOffer_ErrorCode_names + 0, 13}, 3 },
  { {ConnectionOffer_ErrorCode_names + 13, 14}, 4 },
  { {ConnectionOffer_ErrorCode_names + 27, 14}, 2 },
  { {ConnectionOffer_ErrorCode_names + 41, 7}, 0 },
  { {ConnectionOffer_ErrorCode_names + 48, 13}, 1 },
};

static const int ConnectionOffer_ErrorCode_entries_by_number[] = {
  3, // 0 -> SUCCESS
  4, // 1 -> UNKNOWN_ERROR
  2, // 2 -> PEER_NOT_FOUND
  0, // 3 -> ACCESS_DENIED
  1, // 4 -> KEY_POOL_EMPTY
};

const std::string& ConnectionOffer_ErrorCode_Name(
    ConnectionOffer_ErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionOffer_ErrorCode_entries,
          ConnectionOffer_ErrorCode_entries_by_number,
          5, ConnectionOffer_ErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionOffer_ErrorCode_entries,
      ConnectionOffer_ErrorCode_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionOffer_ErrorCode_strings[idx].get();
}
bool ConnectionOffer_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionOffer_ErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionOffer_ErrorCode_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionOffer_ErrorCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionOffer_ErrorCode ConnectionOffer::SUCCESS;
constexpr ConnectionOffer_ErrorCode ConnectionOffer::UNKNOWN_ERROR;
constexpr ConnectionOffer_ErrorCode ConnectionOffer::PEER_NOT_FOUND;
constexpr ConnectionOffer_ErrorCode ConnectionOffer::ACCESS_DENIED;
constexpr ConnectionOffer_ErrorCode ConnectionOffer::KEY_POOL_EMPTY;
constexpr ConnectionOffer_ErrorCode ConnectionOffer::ErrorCode_MIN;
constexpr ConnectionOffer_ErrorCode ConnectionOffer::ErrorCode_MAX;
constexpr int ConnectionOffer::ErrorCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool HostStatus_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HostStatus_Status_strings[3] = {};

static const char HostStatus_Status_names[] =
  "STATUS_OFFLINE"
  "STATUS_ONLINE"
  "STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HostStatus_Status_entries[] = {
  { {HostStatus_Status_names + 0, 14}, 1 },
  { {HostStatus_Status_names + 14, 13}, 2 },
  { {HostStatus_Status_names + 27, 14}, 0 },
};

static const int HostStatus_Status_entries_by_number[] = {
  2, // 0 -> STATUS_UNKNOWN
  0, // 1 -> STATUS_OFFLINE
  1, // 2 -> STATUS_ONLINE
};

const std::string& HostStatus_Status_Name(
    HostStatus_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HostStatus_Status_entries,
          HostStatus_Status_entries_by_number,
          3, HostStatus_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HostStatus_Status_entries,
      HostStatus_Status_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HostStatus_Status_strings[idx].get();
}
bool HostStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostStatus_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HostStatus_Status_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HostStatus_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr HostStatus_Status HostStatus::STATUS_UNKNOWN;
constexpr HostStatus_Status HostStatus::STATUS_OFFLINE;
constexpr HostStatus_Status HostStatus::STATUS_ONLINE;
constexpr HostStatus_Status HostStatus::Status_MIN;
constexpr HostStatus_Status HostStatus::Status_MAX;
constexpr int HostStatus::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class HostIdRequest::_Internal {
 public:
};

HostIdRequest::HostIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.HostIdRequest)
}
HostIdRequest::HostIdRequest(const HostIdRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostIdRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:proto.HostIdRequest)
}

inline void HostIdRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostIdRequest::~HostIdRequest() {
  // @@protoc_insertion_point(destructor:proto.HostIdRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostIdRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void HostIdRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostIdRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.HostIdRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* HostIdRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.HostIdRequest.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::proto::HostIdRequest_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostIdRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.HostIdRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.HostIdRequest.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.HostIdRequest)
  return target;
}

size_t HostIdRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.HostIdRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // .proto.HostIdRequest.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostIdRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostIdRequest*>(
      &from));
}

void HostIdRequest::MergeFrom(const HostIdRequest& from) {
  HostIdRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.HostIdRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostIdRequest::CopyFrom(const HostIdRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.HostIdRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostIdRequest::IsInitialized() const {
  return true;
}

void HostIdRequest::InternalSwap(HostIdRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string HostIdRequest::GetTypeName() const {
  return "proto.HostIdRequest";
}


// ===================================================================

class ResetHostId::_Internal {
 public:
};

ResetHostId::ResetHostId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ResetHostId)
}
ResetHostId::ResetHostId(const ResetHostId& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ResetHostId* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.host_id_ = from._impl_.host_id_;
  // @@protoc_insertion_point(copy_constructor:proto.ResetHostId)
}

inline void ResetHostId::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResetHostId::~ResetHostId() {
  // @@protoc_insertion_point(destructor:proto.ResetHostId)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetHostId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResetHostId::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResetHostId::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ResetHostId)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* ResetHostId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 host_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetHostId::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ResetHostId)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_host_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ResetHostId)
  return target;
}

size_t ResetHostId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ResetHostId)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResetHostId::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ResetHostId*>(
      &from));
}

void ResetHostId::MergeFrom(const ResetHostId& from) {
  ResetHostId* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ResetHostId)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_host_id() != 0) {
    _this->_internal_set_host_id(from._internal_host_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResetHostId::CopyFrom(const ResetHostId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ResetHostId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetHostId::IsInitialized() const {
  return true;
}

void ResetHostId::InternalSwap(ResetHostId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.host_id_, other->_impl_.host_id_);
}

std::string ResetHostId::GetTypeName() const {
  return "proto.ResetHostId";
}


// ===================================================================

class HostIdResponse::_Internal {
 public:
};

HostIdResponse::HostIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.HostIdResponse)
}
HostIdResponse::HostIdResponse(const HostIdResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostIdResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.host_id_){}
    , decltype(_impl_.error_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.host_id_, &from._impl_.host_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_code_) -
    reinterpret_cast<char*>(&_impl_.host_id_)) + sizeof(_impl_.error_code_));
  // @@protoc_insertion_point(copy_constructor:proto.HostIdResponse)
}

inline void HostIdResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.host_id_){uint64_t{0u}}
    , decltype(_impl_.error_code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostIdResponse::~HostIdResponse() {
  // @@protoc_insertion_point(destructor:proto.HostIdResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostIdResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void HostIdResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostIdResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.HostIdResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  ::memset(&_impl_.host_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.error_code_) -
      reinterpret_cast<char*>(&_impl_.host_id_)) + sizeof(_impl_.error_code_));
  _internal_metadata_.Clear<std::string>();
}

const char* HostIdResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 host_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.HostIdResponse.ErrorCode error_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_code(static_cast<::proto::HostIdResponse_ErrorCode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostIdResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.HostIdResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_host_id(), target);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // .proto.HostIdResponse.ErrorCode error_code = 3;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.HostIdResponse)
  return target;
}

size_t HostIdResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.HostIdResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    total_size += 1 + 8;
  }

  // .proto.HostIdResponse.ErrorCode error_code = 3;
  if (this->_internal_error_code() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostIdResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostIdResponse*>(
      &from));
}

void HostIdResponse::MergeFrom(const HostIdResponse& from) {
  HostIdResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.HostIdResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_host_id() != 0) {
    _this->_internal_set_host_id(from._internal_host_id());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostIdResponse::CopyFrom(const HostIdResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.HostIdResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostIdResponse::IsInitialized() const {
  return true;
}

void HostIdResponse::InternalSwap(HostIdResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HostIdResponse, _impl_.error_code_)
      + sizeof(HostIdResponse::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(HostIdResponse, _impl_.host_id_)>(
          reinterpret_cast<char*>(&_impl_.host_id_),
          reinterpret_cast<char*>(&other->_impl_.host_id_));
}

std::string HostIdResponse::GetTypeName() const {
  return "proto.HostIdResponse";
}


// ===================================================================

class ConnectionRequest::_Internal {
 public:
};

ConnectionRequest::ConnectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ConnectionRequest)
}
ConnectionRequest::ConnectionRequest(const ConnectionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.host_id_ = from._impl_.host_id_;
  // @@protoc_insertion_point(copy_constructor:proto.ConnectionRequest)
}

inline void ConnectionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConnectionRequest::~ConnectionRequest() {
  // @@protoc_insertion_point(destructor:proto.ConnectionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ConnectionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 host_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ConnectionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_host_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ConnectionRequest)
  return target;
}

size_t ConnectionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ConnectionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionRequest*>(
      &from));
}

void ConnectionRequest::MergeFrom(const ConnectionRequest& from) {
  ConnectionRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ConnectionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_host_id() != 0) {
    _this->_internal_set_host_id(from._internal_host_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionRequest::CopyFrom(const ConnectionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ConnectionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionRequest::IsInitialized() const {
  return true;
}

void ConnectionRequest::InternalSwap(ConnectionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.host_id_, other->_impl_.host_id_);
}

std::string ConnectionRequest::GetTypeName() const {
  return "proto.ConnectionRequest";
}


// ===================================================================

class HostOfferData::_Internal {
 public:
};

HostOfferData::HostOfferData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.HostOfferData)
}
HostOfferData::HostOfferData(const HostOfferData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostOfferData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.host_id_ = from._impl_.host_id_;
  // @@protoc_insertion_point(copy_constructor:proto.HostOfferData)
}

inline void HostOfferData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HostOfferData::~HostOfferData() {
  // @@protoc_insertion_point(destructor:proto.HostOfferData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostOfferData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HostOfferData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostOfferData::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.HostOfferData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* HostOfferData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 host_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostOfferData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.HostOfferData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_host_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.HostOfferData)
  return target;
}

size_t HostOfferData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.HostOfferData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostOfferData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostOfferData*>(
      &from));
}

void HostOfferData::MergeFrom(const HostOfferData& from) {
  HostOfferData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.HostOfferData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_host_id() != 0) {
    _this->_internal_set_host_id(from._internal_host_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostOfferData::CopyFrom(const HostOfferData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.HostOfferData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostOfferData::IsInitialized() const {
  return true;
}

void HostOfferData::InternalSwap(HostOfferData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.host_id_, other->_impl_.host_id_);
}

std::string HostOfferData::GetTypeName() const {
  return "proto.HostOfferData";
}


// ===================================================================

class ConnectionOffer::_Internal {
 public:
  static const ::proto::RelayCredentials& relay(const ConnectionOffer* msg);
  static const ::proto::HostOfferData& host_data(const ConnectionOffer* msg);
};

const ::proto::RelayCredentials&
ConnectionOffer::_Internal::relay(const ConnectionOffer* msg) {
  return *msg->_impl_.relay_;
}
const ::proto::HostOfferData&
ConnectionOffer::_Internal::host_data(const ConnectionOffer* msg) {
  return *msg->_impl_.host_data_;
}
void ConnectionOffer::clear_relay() {
  if (GetArenaForAllocation() == nullptr && _impl_.relay_ != nullptr) {
    delete _impl_.relay_;
  }
  _impl_.relay_ = nullptr;
}
ConnectionOffer::ConnectionOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ConnectionOffer)
}
ConnectionOffer::ConnectionOffer(const ConnectionOffer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionOffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.relay_){nullptr}
    , decltype(_impl_.host_data_){nullptr}
    , decltype(_impl_.peer_role_){}
    , decltype(_impl_.error_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_relay()) {
    _this->_impl_.relay_ = new ::proto::RelayCredentials(*from._impl_.relay_);
  }
  if (from._internal_has_host_data()) {
    _this->_impl_.host_data_ = new ::proto::HostOfferData(*from._impl_.host_data_);
  }
  ::memcpy(&_impl_.peer_role_, &from._impl_.peer_role_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_code_) -
    reinterpret_cast<char*>(&_impl_.peer_role_)) + sizeof(_impl_.error_code_));
  // @@protoc_insertion_point(copy_constructor:proto.ConnectionOffer)
}

inline void ConnectionOffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.relay_){nullptr}
    , decltype(_impl_.host_data_){nullptr}
    , decltype(_impl_.peer_role_){0}
    , decltype(_impl_.error_code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConnectionOffer::~ConnectionOffer() {
  // @@protoc_insertion_point(destructor:proto.ConnectionOffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionOffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.relay_;
  if (this != internal_default_instance()) delete _impl_.host_data_;
}

void ConnectionOffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionOffer::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ConnectionOffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.relay_ != nullptr) {
    delete _impl_.relay_;
  }
  _impl_.relay_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.host_data_ != nullptr) {
    delete _impl_.host_data_;
  }
  _impl_.host_data_ = nullptr;
  ::memset(&_impl_.peer_role_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.error_code_) -
      reinterpret_cast<char*>(&_impl_.peer_role_)) + sizeof(_impl_.error_code_));
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionOffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.ConnectionOffer.PeerRole peer_role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_peer_role(static_cast<::proto::ConnectionOffer_PeerRole>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.ConnectionOffer.ErrorCode error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_code(static_cast<::proto::ConnectionOffer_ErrorCode>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.RelayCredentials relay = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_relay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.HostOfferData host_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionOffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ConnectionOffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.ConnectionOffer.PeerRole peer_role = 1;
  if (this->_internal_peer_role() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_peer_role(), target);
  }

  // .proto.ConnectionOffer.ErrorCode error_code = 2;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_error_code(), target);
  }

  // .proto.RelayCredentials relay = 3;
  if (this->_internal_has_relay()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::relay(this),
        _Internal::relay(this).GetCachedSize(), target, stream);
  }

  // .proto.HostOfferData host_data = 4;
  if (this->_internal_has_host_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::host_data(this),
        _Internal::host_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ConnectionOffer)
  return target;
}

size_t ConnectionOffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ConnectionOffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.RelayCredentials relay = 3;
  if (this->_internal_has_relay()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.relay_);
  }

  // .proto.HostOfferData host_data = 4;
  if (this->_internal_has_host_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.host_data_);
  }

  // .proto.ConnectionOffer.PeerRole peer_role = 1;
  if (this->_internal_peer_role() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_peer_role());
  }

  // .proto.ConnectionOffer.ErrorCode error_code = 2;
  if (this->_internal_error_code() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionOffer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionOffer*>(
      &from));
}

void ConnectionOffer::MergeFrom(const ConnectionOffer& from) {
  ConnectionOffer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ConnectionOffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_relay()) {
    _this->_internal_mutable_relay()->::proto::RelayCredentials::MergeFrom(
        from._internal_relay());
  }
  if (from._internal_has_host_data()) {
    _this->_internal_mutable_host_data()->::proto::HostOfferData::MergeFrom(
        from._internal_host_data());
  }
  if (from._internal_peer_role() != 0) {
    _this->_internal_set_peer_role(from._internal_peer_role());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionOffer::CopyFrom(const ConnectionOffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ConnectionOffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionOffer::IsInitialized() const {
  return true;
}

void ConnectionOffer::InternalSwap(ConnectionOffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionOffer, _impl_.error_code_)
      + sizeof(ConnectionOffer::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(ConnectionOffer, _impl_.relay_)>(
          reinterpret_cast<char*>(&_impl_.relay_),
          reinterpret_cast<char*>(&other->_impl_.relay_));
}

std::string ConnectionOffer::GetTypeName() const {
  return "proto.ConnectionOffer";
}


// ===================================================================

class CheckHostStatus::_Internal {
 public:
};

CheckHostStatus::CheckHostStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.CheckHostStatus)
}
CheckHostStatus::CheckHostStatus(const CheckHostStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckHostStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.host_id_ = from._impl_.host_id_;
  // @@protoc_insertion_point(copy_constructor:proto.CheckHostStatus)
}

inline void CheckHostStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CheckHostStatus::~CheckHostStatus() {
  // @@protoc_insertion_point(destructor:proto.CheckHostStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckHostStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CheckHostStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckHostStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.CheckHostStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* CheckHostStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 host_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckHostStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.CheckHostStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_host_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.CheckHostStatus)
  return target;
}

size_t CheckHostStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.CheckHostStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 host_id = 1;
  if (this->_internal_host_id() != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckHostStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckHostStatus*>(
      &from));
}

void CheckHostStatus::MergeFrom(const CheckHostStatus& from) {
  CheckHostStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.CheckHostStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_host_id() != 0) {
    _this->_internal_set_host_id(from._internal_host_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckHostStatus::CopyFrom(const CheckHostStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.CheckHostStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckHostStatus::IsInitialized() const {
  return true;
}

void CheckHostStatus::InternalSwap(CheckHostStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.host_id_, other->_impl_.host_id_);
}

std::string CheckHostStatus::GetTypeName() const {
  return "proto.CheckHostStatus";
}


// ===================================================================

class HostStatus::_Internal {
 public:
};

HostStatus::HostStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.HostStatus)
}
HostStatus::HostStatus(const HostStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HostStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:proto.HostStatus)
}

inline void HostStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HostStatus::~HostStatus() {
  // @@protoc_insertion_point(destructor:proto.HostStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HostStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.HostStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* HostStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.HostStatus.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::proto::HostStatus_Status>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.HostStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.HostStatus.Status status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.HostStatus)
  return target;
}

size_t HostStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.HostStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.HostStatus.Status status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostStatus*>(
      &from));
}

void HostStatus::MergeFrom(const HostStatus& from) {
  HostStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.HostStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostStatus::CopyFrom(const HostStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.HostStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostStatus::IsInitialized() const {
  return true;
}

void HostStatus::InternalSwap(HostStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.status_, other->_impl_.status_);
}

std::string HostStatus::GetTypeName() const {
  return "proto.HostStatus";
}


// ===================================================================

class RouterToPeer::_Internal {
 public:
  static const ::proto::HostIdResponse& host_id_response(const RouterToPeer* msg);
  static const ::proto::ConnectionOffer& connection_offer(const RouterToPeer* msg);
  static const ::proto::HostStatus& host_status(const RouterToPeer* msg);
};

const ::proto::HostIdResponse&
RouterToPeer::_Internal::host_id_response(const RouterToPeer* msg) {
  return *msg->_impl_.host_id_response_;
}
const ::proto::ConnectionOffer&
RouterToPeer::_Internal::connection_offer(const RouterToPeer* msg) {
  return *msg->_impl_.connection_offer_;
}
const ::proto::HostStatus&
RouterToPeer::_Internal::host_status(const RouterToPeer* msg) {
  return *msg->_impl_.host_status_;
}
RouterToPeer::RouterToPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.RouterToPeer)
}
RouterToPeer::RouterToPeer(const RouterToPeer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RouterToPeer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_response_){nullptr}
    , decltype(_impl_.connection_offer_){nullptr}
    , decltype(_impl_.host_status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_host_id_response()) {
    _this->_impl_.host_id_response_ = new ::proto::HostIdResponse(*from._impl_.host_id_response_);
  }
  if (from._internal_has_connection_offer()) {
    _this->_impl_.connection_offer_ = new ::proto::ConnectionOffer(*from._impl_.connection_offer_);
  }
  if (from._internal_has_host_status()) {
    _this->_impl_.host_status_ = new ::proto::HostStatus(*from._impl_.host_status_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.RouterToPeer)
}

inline void RouterToPeer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_id_response_){nullptr}
    , decltype(_impl_.connection_offer_){nullptr}
    , decltype(_impl_.host_status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RouterToPeer::~RouterToPeer() {
  // @@protoc_insertion_point(destructor:proto.RouterToPeer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouterToPeer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.host_id_response_;
  if (this != internal_default_instance()) delete _impl_.connection_offer_;
  if (this != internal_default_instance()) delete _impl_.host_status_;
}

void RouterToPeer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RouterToPeer::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.RouterToPeer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.host_id_response_ != nullptr) {
    delete _impl_.host_id_response_;
  }
  _impl_.host_id_response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.connection_offer_ != nullptr) {
    delete _impl_.connection_offer_;
  }
  _impl_.connection_offer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.host_status_ != nullptr) {
    delete _impl_.host_status_;
  }
  _impl_.host_status_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* RouterToPeer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.HostIdResponse host_id_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_id_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ConnectionOffer connection_offer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_offer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.HostStatus host_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouterToPeer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.RouterToPeer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.HostIdResponse host_id_response = 1;
  if (this->_internal_has_host_id_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::host_id_response(this),
        _Internal::host_id_response(this).GetCachedSize(), target, stream);
  }

  // .proto.ConnectionOffer connection_offer = 2;
  if (this->_internal_has_connection_offer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connection_offer(this),
        _Internal::connection_offer(this).GetCachedSize(), target, stream);
  }

  // .proto.HostStatus host_status = 3;
  if (this->_internal_has_host_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::host_status(this),
        _Internal::host_status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.RouterToPeer)
  return target;
}

size_t RouterToPeer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.RouterToPeer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.HostIdResponse host_id_response = 1;
  if (this->_internal_has_host_id_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.host_id_response_);
  }

  // .proto.ConnectionOffer connection_offer = 2;
  if (this->_internal_has_connection_offer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connection_offer_);
  }

  // .proto.HostStatus host_status = 3;
  if (this->_internal_has_host_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.host_status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RouterToPeer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RouterToPeer*>(
      &from));
}

void RouterToPeer::MergeFrom(const RouterToPeer& from) {
  RouterToPeer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.RouterToPeer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_host_id_response()) {
    _this->_internal_mutable_host_id_response()->::proto::HostIdResponse::MergeFrom(
        from._internal_host_id_response());
  }
  if (from._internal_has_connection_offer()) {
    _this->_internal_mutable_connection_offer()->::proto::ConnectionOffer::MergeFrom(
        from._internal_connection_offer());
  }
  if (from._internal_has_host_status()) {
    _this->_internal_mutable_host_status()->::proto::HostStatus::MergeFrom(
        from._internal_host_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RouterToPeer::CopyFrom(const RouterToPeer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.RouterToPeer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouterToPeer::IsInitialized() const {
  return true;
}

void RouterToPeer::InternalSwap(RouterToPeer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RouterToPeer, _impl_.host_status_)
      + sizeof(RouterToPeer::_impl_.host_status_)
      - PROTOBUF_FIELD_OFFSET(RouterToPeer, _impl_.host_id_response_)>(
          reinterpret_cast<char*>(&_impl_.host_id_response_),
          reinterpret_cast<char*>(&other->_impl_.host_id_response_));
}

std::string RouterToPeer::GetTypeName() const {
  return "proto.RouterToPeer";
}


// ===================================================================

class PeerToRouter::_Internal {
 public:
  static const ::proto::ConnectionRequest& connection_request(const PeerToRouter* msg);
  static const ::proto::HostIdRequest& host_id_request(const PeerToRouter* msg);
  static const ::proto::ResetHostId& reset_host_id(const PeerToRouter* msg);
  static const ::proto::CheckHostStatus& check_host_status(const PeerToRouter* msg);
};

const ::proto::ConnectionRequest&
PeerToRouter::_Internal::connection_request(const PeerToRouter* msg) {
  return *msg->_impl_.connection_request_;
}
const ::proto::HostIdRequest&
PeerToRouter::_Internal::host_id_request(const PeerToRouter* msg) {
  return *msg->_impl_.host_id_request_;
}
const ::proto::ResetHostId&
PeerToRouter::_Internal::reset_host_id(const PeerToRouter* msg) {
  return *msg->_impl_.reset_host_id_;
}
const ::proto::CheckHostStatus&
PeerToRouter::_Internal::check_host_status(const PeerToRouter* msg) {
  return *msg->_impl_.check_host_status_;
}
PeerToRouter::PeerToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.PeerToRouter)
}
PeerToRouter::PeerToRouter(const PeerToRouter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PeerToRouter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.connection_request_){nullptr}
    , decltype(_impl_.host_id_request_){nullptr}
    , decltype(_impl_.reset_host_id_){nullptr}
    , decltype(_impl_.check_host_status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_connection_request()) {
    _this->_impl_.connection_request_ = new ::proto::ConnectionRequest(*from._impl_.connection_request_);
  }
  if (from._internal_has_host_id_request()) {
    _this->_impl_.host_id_request_ = new ::proto::HostIdRequest(*from._impl_.host_id_request_);
  }
  if (from._internal_has_reset_host_id()) {
    _this->_impl_.reset_host_id_ = new ::proto::ResetHostId(*from._impl_.reset_host_id_);
  }
  if (from._internal_has_check_host_status()) {
    _this->_impl_.check_host_status_ = new ::proto::CheckHostStatus(*from._impl_.check_host_status_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.PeerToRouter)
}

inline void PeerToRouter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.connection_request_){nullptr}
    , decltype(_impl_.host_id_request_){nullptr}
    , decltype(_impl_.reset_host_id_){nullptr}
    , decltype(_impl_.check_host_status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PeerToRouter::~PeerToRouter() {
  // @@protoc_insertion_point(destructor:proto.PeerToRouter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PeerToRouter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.connection_request_;
  if (this != internal_default_instance()) delete _impl_.host_id_request_;
  if (this != internal_default_instance()) delete _impl_.reset_host_id_;
  if (this != internal_default_instance()) delete _impl_.check_host_status_;
}

void PeerToRouter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PeerToRouter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.PeerToRouter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.connection_request_ != nullptr) {
    delete _impl_.connection_request_;
  }
  _impl_.connection_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.host_id_request_ != nullptr) {
    delete _impl_.host_id_request_;
  }
  _impl_.host_id_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.reset_host_id_ != nullptr) {
    delete _impl_.reset_host_id_;
  }
  _impl_.reset_host_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.check_host_status_ != nullptr) {
    delete _impl_.check_host_status_;
  }
  _impl_.check_host_status_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* PeerToRouter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.ConnectionRequest connection_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.HostIdRequest host_id_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_id_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ResetHostId reset_host_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_reset_host_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.CheckHostStatus check_host_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_host_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PeerToRouter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.PeerToRouter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.ConnectionRequest connection_request = 1;
  if (this->_internal_has_connection_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::connection_request(this),
        _Internal::connection_request(this).GetCachedSize(), target, stream);
  }

  // .proto.HostIdRequest host_id_request = 2;
  if (this->_internal_has_host_id_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::host_id_request(this),
        _Internal::host_id_request(this).GetCachedSize(), target, stream);
  }

  // .proto.ResetHostId reset_host_id = 3;
  if (this->_internal_has_reset_host_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::reset_host_id(this),
        _Internal::reset_host_id(this).GetCachedSize(), target, stream);
  }

  // .proto.CheckHostStatus check_host_status = 4;
  if (this->_internal_has_check_host_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::check_host_status(this),
        _Internal::check_host_status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.PeerToRouter)
  return target;
}

size_t PeerToRouter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.PeerToRouter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.ConnectionRequest connection_request = 1;
  if (this->_internal_has_connection_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connection_request_);
  }

  // .proto.HostIdRequest host_id_request = 2;
  if (this->_internal_has_host_id_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.host_id_request_);
  }

  // .proto.ResetHostId reset_host_id = 3;
  if (this->_internal_has_reset_host_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reset_host_id_);
  }

  // .proto.CheckHostStatus check_host_status = 4;
  if (this->_internal_has_check_host_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.check_host_status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PeerToRouter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PeerToRouter*>(
      &from));
}

void PeerToRouter::MergeFrom(const PeerToRouter& from) {
  PeerToRouter* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.PeerToRouter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_connection_request()) {
    _this->_internal_mutable_connection_request()->::proto::ConnectionRequest::MergeFrom(
        from._internal_connection_request());
  }
  if (from._internal_has_host_id_request()) {
    _this->_internal_mutable_host_id_request()->::proto::HostIdRequest::MergeFrom(
        from._internal_host_id_request());
  }
  if (from._internal_has_reset_host_id()) {
    _this->_internal_mutable_reset_host_id()->::proto::ResetHostId::MergeFrom(
        from._internal_reset_host_id());
  }
  if (from._internal_has_check_host_status()) {
    _this->_internal_mutable_check_host_status()->::proto::CheckHostStatus::MergeFrom(
        from._internal_check_host_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PeerToRouter::CopyFrom(const PeerToRouter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.PeerToRouter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerToRouter::IsInitialized() const {
  return true;
}

void PeerToRouter::InternalSwap(PeerToRouter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PeerToRouter, _impl_.check_host_status_)
      + sizeof(PeerToRouter::_impl_.check_host_status_)
      - PROTOBUF_FIELD_OFFSET(PeerToRouter, _impl_.connection_request_)>(
          reinterpret_cast<char*>(&_impl_.connection_request_),
          reinterpret_cast<char*>(&other->_impl_.connection_request_));
}

std::string PeerToRouter::GetTypeName() const {
  return "proto.PeerToRouter";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::HostIdRequest*
Arena::CreateMaybeMessage< ::proto::HostIdRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::HostIdRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ResetHostId*
Arena::CreateMaybeMessage< ::proto::ResetHostId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ResetHostId >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::HostIdResponse*
Arena::CreateMaybeMessage< ::proto::HostIdResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::HostIdResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ConnectionRequest*
Arena::CreateMaybeMessage< ::proto::ConnectionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ConnectionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::HostOfferData*
Arena::CreateMaybeMessage< ::proto::HostOfferData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::HostOfferData >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ConnectionOffer*
Arena::CreateMaybeMessage< ::proto::ConnectionOffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ConnectionOffer >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::CheckHostStatus*
Arena::CreateMaybeMessage< ::proto::CheckHostStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::CheckHostStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::HostStatus*
Arena::CreateMaybeMessage< ::proto::HostStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::HostStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::RouterToPeer*
Arena::CreateMaybeMessage< ::proto::RouterToPeer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::RouterToPeer >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::PeerToRouter*
Arena::CreateMaybeMessage< ::proto::PeerToRouter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::PeerToRouter >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
