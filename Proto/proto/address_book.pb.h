// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: address_book.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_address_5fbook_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_address_5fbook_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
#include "desktop.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_address_5fbook_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_address_5fbook_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
namespace address_book {
class Computer;
struct ComputerDefaultTypeInternal;
extern ComputerDefaultTypeInternal _Computer_default_instance_;
class ComputerGroup;
struct ComputerGroupDefaultTypeInternal;
extern ComputerGroupDefaultTypeInternal _ComputerGroup_default_instance_;
class ComputerGroupConfig;
struct ComputerGroupConfigDefaultTypeInternal;
extern ComputerGroupConfigDefaultTypeInternal _ComputerGroupConfig_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class InheritConfig;
struct InheritConfigDefaultTypeInternal;
extern InheritConfigDefaultTypeInternal _InheritConfig_default_instance_;
class Router;
struct RouterDefaultTypeInternal;
extern RouterDefaultTypeInternal _Router_default_instance_;
class SessionConfig;
struct SessionConfigDefaultTypeInternal;
extern SessionConfigDefaultTypeInternal _SessionConfig_default_instance_;
}  // namespace address_book
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::address_book::Computer* Arena::CreateMaybeMessage<::proto::address_book::Computer>(Arena*);
template<> ::proto::address_book::ComputerGroup* Arena::CreateMaybeMessage<::proto::address_book::ComputerGroup>(Arena*);
template<> ::proto::address_book::ComputerGroupConfig* Arena::CreateMaybeMessage<::proto::address_book::ComputerGroupConfig>(Arena*);
template<> ::proto::address_book::Data* Arena::CreateMaybeMessage<::proto::address_book::Data>(Arena*);
template<> ::proto::address_book::File* Arena::CreateMaybeMessage<::proto::address_book::File>(Arena*);
template<> ::proto::address_book::InheritConfig* Arena::CreateMaybeMessage<::proto::address_book::InheritConfig>(Arena*);
template<> ::proto::address_book::Router* Arena::CreateMaybeMessage<::proto::address_book::Router>(Arena*);
template<> ::proto::address_book::SessionConfig* Arena::CreateMaybeMessage<::proto::address_book::SessionConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace address_book {

enum EncryptionType : int {
  ENCRYPTION_TYPE_UNKNOWN = 0,
  ENCRYPTION_TYPE_NONE = 1,
  ENCRYPTION_TYPE_XCHACHA20_POLY1305 = 2,
  ENCRYPTION_TYPE_CHACHA20_POLY1305 = 3,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncryptionType_IsValid(int value);
constexpr EncryptionType EncryptionType_MIN = ENCRYPTION_TYPE_UNKNOWN;
constexpr EncryptionType EncryptionType_MAX = ENCRYPTION_TYPE_CHACHA20_POLY1305;
constexpr int EncryptionType_ARRAYSIZE = EncryptionType_MAX + 1;

const std::string& EncryptionType_Name(EncryptionType value);
template<typename T>
inline const std::string& EncryptionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionType_Name.");
  return EncryptionType_Name(static_cast<EncryptionType>(enum_t_value));
}
bool EncryptionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionType* value);
// ===================================================================

class SessionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.SessionConfig) */ {
 public:
  inline SessionConfig() : SessionConfig(nullptr) {}
  ~SessionConfig() override;
  explicit PROTOBUF_CONSTEXPR SessionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionConfig(const SessionConfig& from);
  SessionConfig(SessionConfig&& from) noexcept
    : SessionConfig() {
    *this = ::std::move(from);
  }

  inline SessionConfig& operator=(const SessionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionConfig& operator=(SessionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionConfig* internal_default_instance() {
    return reinterpret_cast<const SessionConfig*>(
               &_SessionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SessionConfig& a, SessionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionConfig& from);
  void MergeFrom(const SessionConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.SessionConfig";
  }
  protected:
  explicit SessionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDesktopManageFieldNumber = 1,
    kDesktopViewFieldNumber = 2,
  };
  // .proto.DesktopConfig desktop_manage = 1;
  bool has_desktop_manage() const;
  private:
  bool _internal_has_desktop_manage() const;
  public:
  void clear_desktop_manage();
  const ::proto::DesktopConfig& desktop_manage() const;
  PROTOBUF_NODISCARD ::proto::DesktopConfig* release_desktop_manage();
  ::proto::DesktopConfig* mutable_desktop_manage();
  void set_allocated_desktop_manage(::proto::DesktopConfig* desktop_manage);
  private:
  const ::proto::DesktopConfig& _internal_desktop_manage() const;
  ::proto::DesktopConfig* _internal_mutable_desktop_manage();
  public:
  void unsafe_arena_set_allocated_desktop_manage(
      ::proto::DesktopConfig* desktop_manage);
  ::proto::DesktopConfig* unsafe_arena_release_desktop_manage();

  // .proto.DesktopConfig desktop_view = 2;
  bool has_desktop_view() const;
  private:
  bool _internal_has_desktop_view() const;
  public:
  void clear_desktop_view();
  const ::proto::DesktopConfig& desktop_view() const;
  PROTOBUF_NODISCARD ::proto::DesktopConfig* release_desktop_view();
  ::proto::DesktopConfig* mutable_desktop_view();
  void set_allocated_desktop_view(::proto::DesktopConfig* desktop_view);
  private:
  const ::proto::DesktopConfig& _internal_desktop_view() const;
  ::proto::DesktopConfig* _internal_mutable_desktop_view();
  public:
  void unsafe_arena_set_allocated_desktop_view(
      ::proto::DesktopConfig* desktop_view);
  ::proto::DesktopConfig* unsafe_arena_release_desktop_view();

  // @@protoc_insertion_point(class_scope:proto.address_book.SessionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::DesktopConfig* desktop_manage_;
    ::proto::DesktopConfig* desktop_view_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class InheritConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.InheritConfig) */ {
 public:
  inline InheritConfig() : InheritConfig(nullptr) {}
  ~InheritConfig() override;
  explicit PROTOBUF_CONSTEXPR InheritConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InheritConfig(const InheritConfig& from);
  InheritConfig(InheritConfig&& from) noexcept
    : InheritConfig() {
    *this = ::std::move(from);
  }

  inline InheritConfig& operator=(const InheritConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InheritConfig& operator=(InheritConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const InheritConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const InheritConfig* internal_default_instance() {
    return reinterpret_cast<const InheritConfig*>(
               &_InheritConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InheritConfig& a, InheritConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InheritConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InheritConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InheritConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InheritConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InheritConfig& from);
  void MergeFrom(const InheritConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InheritConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.InheritConfig";
  }
  protected:
  explicit InheritConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCredentialsFieldNumber = 1,
    kDesktopManageFieldNumber = 2,
    kDesktopViewFieldNumber = 3,
  };
  // bool credentials = 1;
  void clear_credentials();
  bool credentials() const;
  void set_credentials(bool value);
  private:
  bool _internal_credentials() const;
  void _internal_set_credentials(bool value);
  public:

  // bool desktop_manage = 2;
  void clear_desktop_manage();
  bool desktop_manage() const;
  void set_desktop_manage(bool value);
  private:
  bool _internal_desktop_manage() const;
  void _internal_set_desktop_manage(bool value);
  public:

  // bool desktop_view = 3;
  void clear_desktop_view();
  bool desktop_view() const;
  void set_desktop_view(bool value);
  private:
  bool _internal_desktop_view() const;
  void _internal_set_desktop_view(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.address_book.InheritConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool credentials_;
    bool desktop_manage_;
    bool desktop_view_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class Computer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.Computer) */ {
 public:
  inline Computer() : Computer(nullptr) {}
  ~Computer() override;
  explicit PROTOBUF_CONSTEXPR Computer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Computer(const Computer& from);
  Computer(Computer&& from) noexcept
    : Computer() {
    *this = ::std::move(from);
  }

  inline Computer& operator=(const Computer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Computer& operator=(Computer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Computer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Computer* internal_default_instance() {
    return reinterpret_cast<const Computer*>(
               &_Computer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Computer& a, Computer& b) {
    a.Swap(&b);
  }
  inline void Swap(Computer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Computer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Computer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Computer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Computer& from);
  void MergeFrom(const Computer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Computer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.Computer";
  }
  protected:
  explicit Computer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kCommentFieldNumber = 5,
    kAddressFieldNumber = 6,
    kUsernameFieldNumber = 8,
    kPasswordFieldNumber = 9,
    kInheritFieldNumber = 12,
    kSessionConfigFieldNumber = 17,
    kCreateTimeFieldNumber = 1,
    kModifyTimeFieldNumber = 2,
    kPortFieldNumber = 7,
    kSessionTypeFieldNumber = 16,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string comment = 5;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string address = 6;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string username = 8;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 9;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .proto.address_book.InheritConfig inherit = 12;
  bool has_inherit() const;
  private:
  bool _internal_has_inherit() const;
  public:
  void clear_inherit();
  const ::proto::address_book::InheritConfig& inherit() const;
  PROTOBUF_NODISCARD ::proto::address_book::InheritConfig* release_inherit();
  ::proto::address_book::InheritConfig* mutable_inherit();
  void set_allocated_inherit(::proto::address_book::InheritConfig* inherit);
  private:
  const ::proto::address_book::InheritConfig& _internal_inherit() const;
  ::proto::address_book::InheritConfig* _internal_mutable_inherit();
  public:
  void unsafe_arena_set_allocated_inherit(
      ::proto::address_book::InheritConfig* inherit);
  ::proto::address_book::InheritConfig* unsafe_arena_release_inherit();

  // .proto.address_book.SessionConfig session_config = 17;
  bool has_session_config() const;
  private:
  bool _internal_has_session_config() const;
  public:
  void clear_session_config();
  const ::proto::address_book::SessionConfig& session_config() const;
  PROTOBUF_NODISCARD ::proto::address_book::SessionConfig* release_session_config();
  ::proto::address_book::SessionConfig* mutable_session_config();
  void set_allocated_session_config(::proto::address_book::SessionConfig* session_config);
  private:
  const ::proto::address_book::SessionConfig& _internal_session_config() const;
  ::proto::address_book::SessionConfig* _internal_mutable_session_config();
  public:
  void unsafe_arena_set_allocated_session_config(
      ::proto::address_book::SessionConfig* session_config);
  ::proto::address_book::SessionConfig* unsafe_arena_release_session_config();

  // int64 create_time = 1;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // int64 modify_time = 2;
  void clear_modify_time();
  int64_t modify_time() const;
  void set_modify_time(int64_t value);
  private:
  int64_t _internal_modify_time() const;
  void _internal_set_modify_time(int64_t value);
  public:

  // uint32 port = 7;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // .proto.SessionType session_type = 16;
  void clear_session_type();
  ::proto::SessionType session_type() const;
  void set_session_type(::proto::SessionType value);
  private:
  ::proto::SessionType _internal_session_type() const;
  void _internal_set_session_type(::proto::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.address_book.Computer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::proto::address_book::InheritConfig* inherit_;
    ::proto::address_book::SessionConfig* session_config_;
    int64_t create_time_;
    int64_t modify_time_;
    uint32_t port_;
    int session_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class ComputerGroupConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.ComputerGroupConfig) */ {
 public:
  inline ComputerGroupConfig() : ComputerGroupConfig(nullptr) {}
  ~ComputerGroupConfig() override;
  explicit PROTOBUF_CONSTEXPR ComputerGroupConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputerGroupConfig(const ComputerGroupConfig& from);
  ComputerGroupConfig(ComputerGroupConfig&& from) noexcept
    : ComputerGroupConfig() {
    *this = ::std::move(from);
  }

  inline ComputerGroupConfig& operator=(const ComputerGroupConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputerGroupConfig& operator=(ComputerGroupConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ComputerGroupConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputerGroupConfig* internal_default_instance() {
    return reinterpret_cast<const ComputerGroupConfig*>(
               &_ComputerGroupConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ComputerGroupConfig& a, ComputerGroupConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputerGroupConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputerGroupConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputerGroupConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputerGroupConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ComputerGroupConfig& from);
  void MergeFrom(const ComputerGroupConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputerGroupConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.ComputerGroupConfig";
  }
  protected:
  explicit ComputerGroupConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kInheritFieldNumber = 1,
    kSessionConfigFieldNumber = 21,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .proto.address_book.InheritConfig inherit = 1;
  bool has_inherit() const;
  private:
  bool _internal_has_inherit() const;
  public:
  void clear_inherit();
  const ::proto::address_book::InheritConfig& inherit() const;
  PROTOBUF_NODISCARD ::proto::address_book::InheritConfig* release_inherit();
  ::proto::address_book::InheritConfig* mutable_inherit();
  void set_allocated_inherit(::proto::address_book::InheritConfig* inherit);
  private:
  const ::proto::address_book::InheritConfig& _internal_inherit() const;
  ::proto::address_book::InheritConfig* _internal_mutable_inherit();
  public:
  void unsafe_arena_set_allocated_inherit(
      ::proto::address_book::InheritConfig* inherit);
  ::proto::address_book::InheritConfig* unsafe_arena_release_inherit();

  // .proto.address_book.SessionConfig session_config = 21;
  bool has_session_config() const;
  private:
  bool _internal_has_session_config() const;
  public:
  void clear_session_config();
  const ::proto::address_book::SessionConfig& session_config() const;
  PROTOBUF_NODISCARD ::proto::address_book::SessionConfig* release_session_config();
  ::proto::address_book::SessionConfig* mutable_session_config();
  void set_allocated_session_config(::proto::address_book::SessionConfig* session_config);
  private:
  const ::proto::address_book::SessionConfig& _internal_session_config() const;
  ::proto::address_book::SessionConfig* _internal_mutable_session_config();
  public:
  void unsafe_arena_set_allocated_session_config(
      ::proto::address_book::SessionConfig* session_config);
  ::proto::address_book::SessionConfig* unsafe_arena_release_session_config();

  // @@protoc_insertion_point(class_scope:proto.address_book.ComputerGroupConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::proto::address_book::InheritConfig* inherit_;
    ::proto::address_book::SessionConfig* session_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class ComputerGroup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.ComputerGroup) */ {
 public:
  inline ComputerGroup() : ComputerGroup(nullptr) {}
  ~ComputerGroup() override;
  explicit PROTOBUF_CONSTEXPR ComputerGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputerGroup(const ComputerGroup& from);
  ComputerGroup(ComputerGroup&& from) noexcept
    : ComputerGroup() {
    *this = ::std::move(from);
  }

  inline ComputerGroup& operator=(const ComputerGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputerGroup& operator=(ComputerGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ComputerGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputerGroup* internal_default_instance() {
    return reinterpret_cast<const ComputerGroup*>(
               &_ComputerGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ComputerGroup& a, ComputerGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputerGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputerGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputerGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputerGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ComputerGroup& from);
  void MergeFrom(const ComputerGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputerGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.ComputerGroup";
  }
  protected:
  explicit ComputerGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComputerFieldNumber = 3,
    kComputerGroupFieldNumber = 4,
    kNameFieldNumber = 5,
    kCommentFieldNumber = 6,
    kConfigFieldNumber = 21,
    kCreateTimeFieldNumber = 1,
    kModifyTimeFieldNumber = 2,
    kExpandedFieldNumber = 7,
  };
  // repeated .proto.address_book.Computer computer = 3;
  int computer_size() const;
  private:
  int _internal_computer_size() const;
  public:
  void clear_computer();
  ::proto::address_book::Computer* mutable_computer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::Computer >*
      mutable_computer();
  private:
  const ::proto::address_book::Computer& _internal_computer(int index) const;
  ::proto::address_book::Computer* _internal_add_computer();
  public:
  const ::proto::address_book::Computer& computer(int index) const;
  ::proto::address_book::Computer* add_computer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::Computer >&
      computer() const;

  // repeated .proto.address_book.ComputerGroup computer_group = 4;
  int computer_group_size() const;
  private:
  int _internal_computer_group_size() const;
  public:
  void clear_computer_group();
  ::proto::address_book::ComputerGroup* mutable_computer_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::ComputerGroup >*
      mutable_computer_group();
  private:
  const ::proto::address_book::ComputerGroup& _internal_computer_group(int index) const;
  ::proto::address_book::ComputerGroup* _internal_add_computer_group();
  public:
  const ::proto::address_book::ComputerGroup& computer_group(int index) const;
  ::proto::address_book::ComputerGroup* add_computer_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::ComputerGroup >&
      computer_group() const;

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .proto.address_book.ComputerGroupConfig config = 21;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::proto::address_book::ComputerGroupConfig& config() const;
  PROTOBUF_NODISCARD ::proto::address_book::ComputerGroupConfig* release_config();
  ::proto::address_book::ComputerGroupConfig* mutable_config();
  void set_allocated_config(::proto::address_book::ComputerGroupConfig* config);
  private:
  const ::proto::address_book::ComputerGroupConfig& _internal_config() const;
  ::proto::address_book::ComputerGroupConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::proto::address_book::ComputerGroupConfig* config);
  ::proto::address_book::ComputerGroupConfig* unsafe_arena_release_config();

  // int64 create_time = 1;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // int64 modify_time = 2;
  void clear_modify_time();
  int64_t modify_time() const;
  void set_modify_time(int64_t value);
  private:
  int64_t _internal_modify_time() const;
  void _internal_set_modify_time(int64_t value);
  public:

  // bool expanded = 7;
  void clear_expanded();
  bool expanded() const;
  void set_expanded(bool value);
  private:
  bool _internal_expanded() const;
  void _internal_set_expanded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.address_book.ComputerGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::Computer > computer_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::ComputerGroup > computer_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::proto::address_book::ComputerGroupConfig* config_;
    int64_t create_time_;
    int64_t modify_time_;
    bool expanded_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class Router final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.Router) */ {
 public:
  inline Router() : Router(nullptr) {}
  ~Router() override;
  explicit PROTOBUF_CONSTEXPR Router(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Router(const Router& from);
  Router(Router&& from) noexcept
    : Router() {
    *this = ::std::move(from);
  }

  inline Router& operator=(const Router& from) {
    CopyFrom(from);
    return *this;
  }
  inline Router& operator=(Router&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Router& default_instance() {
    return *internal_default_instance();
  }
  static inline const Router* internal_default_instance() {
    return reinterpret_cast<const Router*>(
               &_Router_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Router& a, Router& b) {
    a.Swap(&b);
  }
  inline void Swap(Router* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Router* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Router* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Router>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Router& from);
  void MergeFrom(const Router& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Router* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.Router";
  }
  protected:
  explicit Router(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kUsernameFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kPortFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // uint32 port = 2;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.address_book.Router)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuidFieldNumber = 6,
    kRootGroupFieldNumber = 2,
    kRouterFieldNumber = 5,
    kEnableRouterFieldNumber = 4,
  };
  // string guid = 6;
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // .proto.address_book.ComputerGroup root_group = 2;
  bool has_root_group() const;
  private:
  bool _internal_has_root_group() const;
  public:
  void clear_root_group();
  const ::proto::address_book::ComputerGroup& root_group() const;
  PROTOBUF_NODISCARD ::proto::address_book::ComputerGroup* release_root_group();
  ::proto::address_book::ComputerGroup* mutable_root_group();
  void set_allocated_root_group(::proto::address_book::ComputerGroup* root_group);
  private:
  const ::proto::address_book::ComputerGroup& _internal_root_group() const;
  ::proto::address_book::ComputerGroup* _internal_mutable_root_group();
  public:
  void unsafe_arena_set_allocated_root_group(
      ::proto::address_book::ComputerGroup* root_group);
  ::proto::address_book::ComputerGroup* unsafe_arena_release_root_group();

  // .proto.address_book.Router router = 5;
  bool has_router() const;
  private:
  bool _internal_has_router() const;
  public:
  void clear_router();
  const ::proto::address_book::Router& router() const;
  PROTOBUF_NODISCARD ::proto::address_book::Router* release_router();
  ::proto::address_book::Router* mutable_router();
  void set_allocated_router(::proto::address_book::Router* router);
  private:
  const ::proto::address_book::Router& _internal_router() const;
  ::proto::address_book::Router* _internal_mutable_router();
  public:
  void unsafe_arena_set_allocated_router(
      ::proto::address_book::Router* router);
  ::proto::address_book::Router* unsafe_arena_release_router();

  // bool enable_router = 4;
  void clear_enable_router();
  bool enable_router() const;
  void set_enable_router(bool value);
  private:
  bool _internal_enable_router() const;
  void _internal_set_enable_router(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.address_book.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
    ::proto::address_book::ComputerGroup* root_group_;
    ::proto::address_book::Router* router_;
    bool enable_router_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// -------------------------------------------------------------------

class File final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.address_book.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit PROTOBUF_CONSTEXPR File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.address_book.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashingSaltFieldNumber = 3,
    kDataFieldNumber = 9,
    kEncryptionTypeFieldNumber = 1,
  };
  // bytes hashing_salt = 3;
  void clear_hashing_salt();
  const std::string& hashing_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashing_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashing_salt();
  PROTOBUF_NODISCARD std::string* release_hashing_salt();
  void set_allocated_hashing_salt(std::string* hashing_salt);
  private:
  const std::string& _internal_hashing_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashing_salt(const std::string& value);
  std::string* _internal_mutable_hashing_salt();
  public:

  // bytes data = 9;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .proto.address_book.EncryptionType encryption_type = 1;
  void clear_encryption_type();
  ::proto::address_book::EncryptionType encryption_type() const;
  void set_encryption_type(::proto::address_book::EncryptionType value);
  private:
  ::proto::address_book::EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::proto::address_book::EncryptionType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.address_book.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashing_salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int encryption_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_address_5fbook_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SessionConfig

// .proto.DesktopConfig desktop_manage = 1;
inline bool SessionConfig::_internal_has_desktop_manage() const {
  return this != internal_default_instance() && _impl_.desktop_manage_ != nullptr;
}
inline bool SessionConfig::has_desktop_manage() const {
  return _internal_has_desktop_manage();
}
inline const ::proto::DesktopConfig& SessionConfig::_internal_desktop_manage() const {
  const ::proto::DesktopConfig* p = _impl_.desktop_manage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DesktopConfig&>(
      ::proto::_DesktopConfig_default_instance_);
}
inline const ::proto::DesktopConfig& SessionConfig::desktop_manage() const {
  // @@protoc_insertion_point(field_get:proto.address_book.SessionConfig.desktop_manage)
  return _internal_desktop_manage();
}
inline void SessionConfig::unsafe_arena_set_allocated_desktop_manage(
    ::proto::DesktopConfig* desktop_manage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desktop_manage_);
  }
  _impl_.desktop_manage_ = desktop_manage;
  if (desktop_manage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.SessionConfig.desktop_manage)
}
inline ::proto::DesktopConfig* SessionConfig::release_desktop_manage() {
  
  ::proto::DesktopConfig* temp = _impl_.desktop_manage_;
  _impl_.desktop_manage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DesktopConfig* SessionConfig::unsafe_arena_release_desktop_manage() {
  // @@protoc_insertion_point(field_release:proto.address_book.SessionConfig.desktop_manage)
  
  ::proto::DesktopConfig* temp = _impl_.desktop_manage_;
  _impl_.desktop_manage_ = nullptr;
  return temp;
}
inline ::proto::DesktopConfig* SessionConfig::_internal_mutable_desktop_manage() {
  
  if (_impl_.desktop_manage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DesktopConfig>(GetArenaForAllocation());
    _impl_.desktop_manage_ = p;
  }
  return _impl_.desktop_manage_;
}
inline ::proto::DesktopConfig* SessionConfig::mutable_desktop_manage() {
  ::proto::DesktopConfig* _msg = _internal_mutable_desktop_manage();
  // @@protoc_insertion_point(field_mutable:proto.address_book.SessionConfig.desktop_manage)
  return _msg;
}
inline void SessionConfig::set_allocated_desktop_manage(::proto::DesktopConfig* desktop_manage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desktop_manage_);
  }
  if (desktop_manage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desktop_manage));
    if (message_arena != submessage_arena) {
      desktop_manage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desktop_manage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.desktop_manage_ = desktop_manage;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.SessionConfig.desktop_manage)
}

// .proto.DesktopConfig desktop_view = 2;
inline bool SessionConfig::_internal_has_desktop_view() const {
  return this != internal_default_instance() && _impl_.desktop_view_ != nullptr;
}
inline bool SessionConfig::has_desktop_view() const {
  return _internal_has_desktop_view();
}
inline const ::proto::DesktopConfig& SessionConfig::_internal_desktop_view() const {
  const ::proto::DesktopConfig* p = _impl_.desktop_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DesktopConfig&>(
      ::proto::_DesktopConfig_default_instance_);
}
inline const ::proto::DesktopConfig& SessionConfig::desktop_view() const {
  // @@protoc_insertion_point(field_get:proto.address_book.SessionConfig.desktop_view)
  return _internal_desktop_view();
}
inline void SessionConfig::unsafe_arena_set_allocated_desktop_view(
    ::proto::DesktopConfig* desktop_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desktop_view_);
  }
  _impl_.desktop_view_ = desktop_view;
  if (desktop_view) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.SessionConfig.desktop_view)
}
inline ::proto::DesktopConfig* SessionConfig::release_desktop_view() {
  
  ::proto::DesktopConfig* temp = _impl_.desktop_view_;
  _impl_.desktop_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DesktopConfig* SessionConfig::unsafe_arena_release_desktop_view() {
  // @@protoc_insertion_point(field_release:proto.address_book.SessionConfig.desktop_view)
  
  ::proto::DesktopConfig* temp = _impl_.desktop_view_;
  _impl_.desktop_view_ = nullptr;
  return temp;
}
inline ::proto::DesktopConfig* SessionConfig::_internal_mutable_desktop_view() {
  
  if (_impl_.desktop_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DesktopConfig>(GetArenaForAllocation());
    _impl_.desktop_view_ = p;
  }
  return _impl_.desktop_view_;
}
inline ::proto::DesktopConfig* SessionConfig::mutable_desktop_view() {
  ::proto::DesktopConfig* _msg = _internal_mutable_desktop_view();
  // @@protoc_insertion_point(field_mutable:proto.address_book.SessionConfig.desktop_view)
  return _msg;
}
inline void SessionConfig::set_allocated_desktop_view(::proto::DesktopConfig* desktop_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.desktop_view_);
  }
  if (desktop_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desktop_view));
    if (message_arena != submessage_arena) {
      desktop_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desktop_view, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.desktop_view_ = desktop_view;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.SessionConfig.desktop_view)
}

// -------------------------------------------------------------------

// InheritConfig

// bool credentials = 1;
inline void InheritConfig::clear_credentials() {
  _impl_.credentials_ = false;
}
inline bool InheritConfig::_internal_credentials() const {
  return _impl_.credentials_;
}
inline bool InheritConfig::credentials() const {
  // @@protoc_insertion_point(field_get:proto.address_book.InheritConfig.credentials)
  return _internal_credentials();
}
inline void InheritConfig::_internal_set_credentials(bool value) {
  
  _impl_.credentials_ = value;
}
inline void InheritConfig::set_credentials(bool value) {
  _internal_set_credentials(value);
  // @@protoc_insertion_point(field_set:proto.address_book.InheritConfig.credentials)
}

// bool desktop_manage = 2;
inline void InheritConfig::clear_desktop_manage() {
  _impl_.desktop_manage_ = false;
}
inline bool InheritConfig::_internal_desktop_manage() const {
  return _impl_.desktop_manage_;
}
inline bool InheritConfig::desktop_manage() const {
  // @@protoc_insertion_point(field_get:proto.address_book.InheritConfig.desktop_manage)
  return _internal_desktop_manage();
}
inline void InheritConfig::_internal_set_desktop_manage(bool value) {
  
  _impl_.desktop_manage_ = value;
}
inline void InheritConfig::set_desktop_manage(bool value) {
  _internal_set_desktop_manage(value);
  // @@protoc_insertion_point(field_set:proto.address_book.InheritConfig.desktop_manage)
}

// bool desktop_view = 3;
inline void InheritConfig::clear_desktop_view() {
  _impl_.desktop_view_ = false;
}
inline bool InheritConfig::_internal_desktop_view() const {
  return _impl_.desktop_view_;
}
inline bool InheritConfig::desktop_view() const {
  // @@protoc_insertion_point(field_get:proto.address_book.InheritConfig.desktop_view)
  return _internal_desktop_view();
}
inline void InheritConfig::_internal_set_desktop_view(bool value) {
  
  _impl_.desktop_view_ = value;
}
inline void InheritConfig::set_desktop_view(bool value) {
  _internal_set_desktop_view(value);
  // @@protoc_insertion_point(field_set:proto.address_book.InheritConfig.desktop_view)
}

// -------------------------------------------------------------------

// Computer

// int64 create_time = 1;
inline void Computer::clear_create_time() {
  _impl_.create_time_ = int64_t{0};
}
inline int64_t Computer::_internal_create_time() const {
  return _impl_.create_time_;
}
inline int64_t Computer::create_time() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.create_time)
  return _internal_create_time();
}
inline void Computer::_internal_set_create_time(int64_t value) {
  
  _impl_.create_time_ = value;
}
inline void Computer::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.create_time)
}

// int64 modify_time = 2;
inline void Computer::clear_modify_time() {
  _impl_.modify_time_ = int64_t{0};
}
inline int64_t Computer::_internal_modify_time() const {
  return _impl_.modify_time_;
}
inline int64_t Computer::modify_time() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.modify_time)
  return _internal_modify_time();
}
inline void Computer::_internal_set_modify_time(int64_t value) {
  
  _impl_.modify_time_ = value;
}
inline void Computer::set_modify_time(int64_t value) {
  _internal_set_modify_time(value);
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.modify_time)
}

// string name = 4;
inline void Computer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Computer::name() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.name)
}
inline std::string* Computer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.name)
  return _s;
}
inline const std::string& Computer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Computer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_name() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.name)
  return _impl_.name_.Release();
}
inline void Computer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.name)
}

// string comment = 5;
inline void Computer::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Computer::comment() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.comment)
}
inline std::string* Computer::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.comment)
  return _s;
}
inline const std::string& Computer::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Computer::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_comment() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.comment)
  return _impl_.comment_.Release();
}
inline void Computer::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.comment)
}

// string address = 6;
inline void Computer::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Computer::address() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.address)
}
inline std::string* Computer::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.address)
  return _s;
}
inline const std::string& Computer::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Computer::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_address() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.address)
  return _impl_.address_.Release();
}
inline void Computer::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.address)
}

// uint32 port = 7;
inline void Computer::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t Computer::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Computer::port() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.port)
  return _internal_port();
}
inline void Computer::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void Computer::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.port)
}

// string username = 8;
inline void Computer::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Computer::username() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.username)
}
inline std::string* Computer::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.username)
  return _s;
}
inline const std::string& Computer::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Computer::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_username() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.username)
  return _impl_.username_.Release();
}
inline void Computer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.username)
}

// string password = 9;
inline void Computer::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Computer::password() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.password)
}
inline std::string* Computer::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.password)
  return _s;
}
inline const std::string& Computer::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Computer::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_password() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.password)
  return _impl_.password_.Release();
}
inline void Computer::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.password)
}

// .proto.address_book.InheritConfig inherit = 12;
inline bool Computer::_internal_has_inherit() const {
  return this != internal_default_instance() && _impl_.inherit_ != nullptr;
}
inline bool Computer::has_inherit() const {
  return _internal_has_inherit();
}
inline void Computer::clear_inherit() {
  if (GetArenaForAllocation() == nullptr && _impl_.inherit_ != nullptr) {
    delete _impl_.inherit_;
  }
  _impl_.inherit_ = nullptr;
}
inline const ::proto::address_book::InheritConfig& Computer::_internal_inherit() const {
  const ::proto::address_book::InheritConfig* p = _impl_.inherit_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::InheritConfig&>(
      ::proto::address_book::_InheritConfig_default_instance_);
}
inline const ::proto::address_book::InheritConfig& Computer::inherit() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.inherit)
  return _internal_inherit();
}
inline void Computer::unsafe_arena_set_allocated_inherit(
    ::proto::address_book::InheritConfig* inherit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inherit_);
  }
  _impl_.inherit_ = inherit;
  if (inherit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.Computer.inherit)
}
inline ::proto::address_book::InheritConfig* Computer::release_inherit() {
  
  ::proto::address_book::InheritConfig* temp = _impl_.inherit_;
  _impl_.inherit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::InheritConfig* Computer::unsafe_arena_release_inherit() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.inherit)
  
  ::proto::address_book::InheritConfig* temp = _impl_.inherit_;
  _impl_.inherit_ = nullptr;
  return temp;
}
inline ::proto::address_book::InheritConfig* Computer::_internal_mutable_inherit() {
  
  if (_impl_.inherit_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::InheritConfig>(GetArenaForAllocation());
    _impl_.inherit_ = p;
  }
  return _impl_.inherit_;
}
inline ::proto::address_book::InheritConfig* Computer::mutable_inherit() {
  ::proto::address_book::InheritConfig* _msg = _internal_mutable_inherit();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.inherit)
  return _msg;
}
inline void Computer::set_allocated_inherit(::proto::address_book::InheritConfig* inherit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inherit_;
  }
  if (inherit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inherit);
    if (message_arena != submessage_arena) {
      inherit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inherit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inherit_ = inherit;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.inherit)
}

// .proto.SessionType session_type = 16;
inline void Computer::clear_session_type() {
  _impl_.session_type_ = 0;
}
inline ::proto::SessionType Computer::_internal_session_type() const {
  return static_cast< ::proto::SessionType >(_impl_.session_type_);
}
inline ::proto::SessionType Computer::session_type() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.session_type)
  return _internal_session_type();
}
inline void Computer::_internal_set_session_type(::proto::SessionType value) {
  
  _impl_.session_type_ = value;
}
inline void Computer::set_session_type(::proto::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:proto.address_book.Computer.session_type)
}

// .proto.address_book.SessionConfig session_config = 17;
inline bool Computer::_internal_has_session_config() const {
  return this != internal_default_instance() && _impl_.session_config_ != nullptr;
}
inline bool Computer::has_session_config() const {
  return _internal_has_session_config();
}
inline void Computer::clear_session_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_config_ != nullptr) {
    delete _impl_.session_config_;
  }
  _impl_.session_config_ = nullptr;
}
inline const ::proto::address_book::SessionConfig& Computer::_internal_session_config() const {
  const ::proto::address_book::SessionConfig* p = _impl_.session_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::SessionConfig&>(
      ::proto::address_book::_SessionConfig_default_instance_);
}
inline const ::proto::address_book::SessionConfig& Computer::session_config() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Computer.session_config)
  return _internal_session_config();
}
inline void Computer::unsafe_arena_set_allocated_session_config(
    ::proto::address_book::SessionConfig* session_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_config_);
  }
  _impl_.session_config_ = session_config;
  if (session_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.Computer.session_config)
}
inline ::proto::address_book::SessionConfig* Computer::release_session_config() {
  
  ::proto::address_book::SessionConfig* temp = _impl_.session_config_;
  _impl_.session_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::SessionConfig* Computer::unsafe_arena_release_session_config() {
  // @@protoc_insertion_point(field_release:proto.address_book.Computer.session_config)
  
  ::proto::address_book::SessionConfig* temp = _impl_.session_config_;
  _impl_.session_config_ = nullptr;
  return temp;
}
inline ::proto::address_book::SessionConfig* Computer::_internal_mutable_session_config() {
  
  if (_impl_.session_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::SessionConfig>(GetArenaForAllocation());
    _impl_.session_config_ = p;
  }
  return _impl_.session_config_;
}
inline ::proto::address_book::SessionConfig* Computer::mutable_session_config() {
  ::proto::address_book::SessionConfig* _msg = _internal_mutable_session_config();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Computer.session_config)
  return _msg;
}
inline void Computer::set_allocated_session_config(::proto::address_book::SessionConfig* session_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_config_;
  }
  if (session_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_config);
    if (message_arena != submessage_arena) {
      session_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_config_ = session_config;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Computer.session_config)
}

// -------------------------------------------------------------------

// ComputerGroupConfig

// .proto.address_book.InheritConfig inherit = 1;
inline bool ComputerGroupConfig::_internal_has_inherit() const {
  return this != internal_default_instance() && _impl_.inherit_ != nullptr;
}
inline bool ComputerGroupConfig::has_inherit() const {
  return _internal_has_inherit();
}
inline void ComputerGroupConfig::clear_inherit() {
  if (GetArenaForAllocation() == nullptr && _impl_.inherit_ != nullptr) {
    delete _impl_.inherit_;
  }
  _impl_.inherit_ = nullptr;
}
inline const ::proto::address_book::InheritConfig& ComputerGroupConfig::_internal_inherit() const {
  const ::proto::address_book::InheritConfig* p = _impl_.inherit_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::InheritConfig&>(
      ::proto::address_book::_InheritConfig_default_instance_);
}
inline const ::proto::address_book::InheritConfig& ComputerGroupConfig::inherit() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroupConfig.inherit)
  return _internal_inherit();
}
inline void ComputerGroupConfig::unsafe_arena_set_allocated_inherit(
    ::proto::address_book::InheritConfig* inherit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inherit_);
  }
  _impl_.inherit_ = inherit;
  if (inherit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.ComputerGroupConfig.inherit)
}
inline ::proto::address_book::InheritConfig* ComputerGroupConfig::release_inherit() {
  
  ::proto::address_book::InheritConfig* temp = _impl_.inherit_;
  _impl_.inherit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::InheritConfig* ComputerGroupConfig::unsafe_arena_release_inherit() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroupConfig.inherit)
  
  ::proto::address_book::InheritConfig* temp = _impl_.inherit_;
  _impl_.inherit_ = nullptr;
  return temp;
}
inline ::proto::address_book::InheritConfig* ComputerGroupConfig::_internal_mutable_inherit() {
  
  if (_impl_.inherit_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::InheritConfig>(GetArenaForAllocation());
    _impl_.inherit_ = p;
  }
  return _impl_.inherit_;
}
inline ::proto::address_book::InheritConfig* ComputerGroupConfig::mutable_inherit() {
  ::proto::address_book::InheritConfig* _msg = _internal_mutable_inherit();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroupConfig.inherit)
  return _msg;
}
inline void ComputerGroupConfig::set_allocated_inherit(::proto::address_book::InheritConfig* inherit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inherit_;
  }
  if (inherit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inherit);
    if (message_arena != submessage_arena) {
      inherit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inherit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inherit_ = inherit;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroupConfig.inherit)
}

// string username = 2;
inline void ComputerGroupConfig::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ComputerGroupConfig::username() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroupConfig.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputerGroupConfig::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroupConfig.username)
}
inline std::string* ComputerGroupConfig::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroupConfig.username)
  return _s;
}
inline const std::string& ComputerGroupConfig::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ComputerGroupConfig::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputerGroupConfig::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputerGroupConfig::release_username() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroupConfig.username)
  return _impl_.username_.Release();
}
inline void ComputerGroupConfig::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroupConfig.username)
}

// string password = 3;
inline void ComputerGroupConfig::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& ComputerGroupConfig::password() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroupConfig.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputerGroupConfig::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroupConfig.password)
}
inline std::string* ComputerGroupConfig::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroupConfig.password)
  return _s;
}
inline const std::string& ComputerGroupConfig::_internal_password() const {
  return _impl_.password_.Get();
}
inline void ComputerGroupConfig::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputerGroupConfig::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputerGroupConfig::release_password() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroupConfig.password)
  return _impl_.password_.Release();
}
inline void ComputerGroupConfig::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroupConfig.password)
}

// .proto.address_book.SessionConfig session_config = 21;
inline bool ComputerGroupConfig::_internal_has_session_config() const {
  return this != internal_default_instance() && _impl_.session_config_ != nullptr;
}
inline bool ComputerGroupConfig::has_session_config() const {
  return _internal_has_session_config();
}
inline void ComputerGroupConfig::clear_session_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_config_ != nullptr) {
    delete _impl_.session_config_;
  }
  _impl_.session_config_ = nullptr;
}
inline const ::proto::address_book::SessionConfig& ComputerGroupConfig::_internal_session_config() const {
  const ::proto::address_book::SessionConfig* p = _impl_.session_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::SessionConfig&>(
      ::proto::address_book::_SessionConfig_default_instance_);
}
inline const ::proto::address_book::SessionConfig& ComputerGroupConfig::session_config() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroupConfig.session_config)
  return _internal_session_config();
}
inline void ComputerGroupConfig::unsafe_arena_set_allocated_session_config(
    ::proto::address_book::SessionConfig* session_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_config_);
  }
  _impl_.session_config_ = session_config;
  if (session_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.ComputerGroupConfig.session_config)
}
inline ::proto::address_book::SessionConfig* ComputerGroupConfig::release_session_config() {
  
  ::proto::address_book::SessionConfig* temp = _impl_.session_config_;
  _impl_.session_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::SessionConfig* ComputerGroupConfig::unsafe_arena_release_session_config() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroupConfig.session_config)
  
  ::proto::address_book::SessionConfig* temp = _impl_.session_config_;
  _impl_.session_config_ = nullptr;
  return temp;
}
inline ::proto::address_book::SessionConfig* ComputerGroupConfig::_internal_mutable_session_config() {
  
  if (_impl_.session_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::SessionConfig>(GetArenaForAllocation());
    _impl_.session_config_ = p;
  }
  return _impl_.session_config_;
}
inline ::proto::address_book::SessionConfig* ComputerGroupConfig::mutable_session_config() {
  ::proto::address_book::SessionConfig* _msg = _internal_mutable_session_config();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroupConfig.session_config)
  return _msg;
}
inline void ComputerGroupConfig::set_allocated_session_config(::proto::address_book::SessionConfig* session_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_config_;
  }
  if (session_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_config);
    if (message_arena != submessage_arena) {
      session_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_config_ = session_config;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroupConfig.session_config)
}

// -------------------------------------------------------------------

// ComputerGroup

// int64 create_time = 1;
inline void ComputerGroup::clear_create_time() {
  _impl_.create_time_ = int64_t{0};
}
inline int64_t ComputerGroup::_internal_create_time() const {
  return _impl_.create_time_;
}
inline int64_t ComputerGroup::create_time() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.create_time)
  return _internal_create_time();
}
inline void ComputerGroup::_internal_set_create_time(int64_t value) {
  
  _impl_.create_time_ = value;
}
inline void ComputerGroup::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroup.create_time)
}

// int64 modify_time = 2;
inline void ComputerGroup::clear_modify_time() {
  _impl_.modify_time_ = int64_t{0};
}
inline int64_t ComputerGroup::_internal_modify_time() const {
  return _impl_.modify_time_;
}
inline int64_t ComputerGroup::modify_time() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.modify_time)
  return _internal_modify_time();
}
inline void ComputerGroup::_internal_set_modify_time(int64_t value) {
  
  _impl_.modify_time_ = value;
}
inline void ComputerGroup::set_modify_time(int64_t value) {
  _internal_set_modify_time(value);
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroup.modify_time)
}

// repeated .proto.address_book.Computer computer = 3;
inline int ComputerGroup::_internal_computer_size() const {
  return _impl_.computer_.size();
}
inline int ComputerGroup::computer_size() const {
  return _internal_computer_size();
}
inline void ComputerGroup::clear_computer() {
  _impl_.computer_.Clear();
}
inline ::proto::address_book::Computer* ComputerGroup::mutable_computer(int index) {
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroup.computer)
  return _impl_.computer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::Computer >*
ComputerGroup::mutable_computer() {
  // @@protoc_insertion_point(field_mutable_list:proto.address_book.ComputerGroup.computer)
  return &_impl_.computer_;
}
inline const ::proto::address_book::Computer& ComputerGroup::_internal_computer(int index) const {
  return _impl_.computer_.Get(index);
}
inline const ::proto::address_book::Computer& ComputerGroup::computer(int index) const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.computer)
  return _internal_computer(index);
}
inline ::proto::address_book::Computer* ComputerGroup::_internal_add_computer() {
  return _impl_.computer_.Add();
}
inline ::proto::address_book::Computer* ComputerGroup::add_computer() {
  ::proto::address_book::Computer* _add = _internal_add_computer();
  // @@protoc_insertion_point(field_add:proto.address_book.ComputerGroup.computer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::Computer >&
ComputerGroup::computer() const {
  // @@protoc_insertion_point(field_list:proto.address_book.ComputerGroup.computer)
  return _impl_.computer_;
}

// repeated .proto.address_book.ComputerGroup computer_group = 4;
inline int ComputerGroup::_internal_computer_group_size() const {
  return _impl_.computer_group_.size();
}
inline int ComputerGroup::computer_group_size() const {
  return _internal_computer_group_size();
}
inline void ComputerGroup::clear_computer_group() {
  _impl_.computer_group_.Clear();
}
inline ::proto::address_book::ComputerGroup* ComputerGroup::mutable_computer_group(int index) {
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroup.computer_group)
  return _impl_.computer_group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::ComputerGroup >*
ComputerGroup::mutable_computer_group() {
  // @@protoc_insertion_point(field_mutable_list:proto.address_book.ComputerGroup.computer_group)
  return &_impl_.computer_group_;
}
inline const ::proto::address_book::ComputerGroup& ComputerGroup::_internal_computer_group(int index) const {
  return _impl_.computer_group_.Get(index);
}
inline const ::proto::address_book::ComputerGroup& ComputerGroup::computer_group(int index) const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.computer_group)
  return _internal_computer_group(index);
}
inline ::proto::address_book::ComputerGroup* ComputerGroup::_internal_add_computer_group() {
  return _impl_.computer_group_.Add();
}
inline ::proto::address_book::ComputerGroup* ComputerGroup::add_computer_group() {
  ::proto::address_book::ComputerGroup* _add = _internal_add_computer_group();
  // @@protoc_insertion_point(field_add:proto.address_book.ComputerGroup.computer_group)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::address_book::ComputerGroup >&
ComputerGroup::computer_group() const {
  // @@protoc_insertion_point(field_list:proto.address_book.ComputerGroup.computer_group)
  return _impl_.computer_group_;
}

// string name = 5;
inline void ComputerGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ComputerGroup::name() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputerGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroup.name)
}
inline std::string* ComputerGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroup.name)
  return _s;
}
inline const std::string& ComputerGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ComputerGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputerGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputerGroup::release_name() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroup.name)
  return _impl_.name_.Release();
}
inline void ComputerGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroup.name)
}

// string comment = 6;
inline void ComputerGroup::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& ComputerGroup::comment() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputerGroup::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroup.comment)
}
inline std::string* ComputerGroup::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroup.comment)
  return _s;
}
inline const std::string& ComputerGroup::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void ComputerGroup::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputerGroup::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputerGroup::release_comment() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroup.comment)
  return _impl_.comment_.Release();
}
inline void ComputerGroup::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroup.comment)
}

// bool expanded = 7;
inline void ComputerGroup::clear_expanded() {
  _impl_.expanded_ = false;
}
inline bool ComputerGroup::_internal_expanded() const {
  return _impl_.expanded_;
}
inline bool ComputerGroup::expanded() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.expanded)
  return _internal_expanded();
}
inline void ComputerGroup::_internal_set_expanded(bool value) {
  
  _impl_.expanded_ = value;
}
inline void ComputerGroup::set_expanded(bool value) {
  _internal_set_expanded(value);
  // @@protoc_insertion_point(field_set:proto.address_book.ComputerGroup.expanded)
}

// .proto.address_book.ComputerGroupConfig config = 21;
inline bool ComputerGroup::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool ComputerGroup::has_config() const {
  return _internal_has_config();
}
inline void ComputerGroup::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::proto::address_book::ComputerGroupConfig& ComputerGroup::_internal_config() const {
  const ::proto::address_book::ComputerGroupConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::ComputerGroupConfig&>(
      ::proto::address_book::_ComputerGroupConfig_default_instance_);
}
inline const ::proto::address_book::ComputerGroupConfig& ComputerGroup::config() const {
  // @@protoc_insertion_point(field_get:proto.address_book.ComputerGroup.config)
  return _internal_config();
}
inline void ComputerGroup::unsafe_arena_set_allocated_config(
    ::proto::address_book::ComputerGroupConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.ComputerGroup.config)
}
inline ::proto::address_book::ComputerGroupConfig* ComputerGroup::release_config() {
  
  ::proto::address_book::ComputerGroupConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::ComputerGroupConfig* ComputerGroup::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:proto.address_book.ComputerGroup.config)
  
  ::proto::address_book::ComputerGroupConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::proto::address_book::ComputerGroupConfig* ComputerGroup::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::ComputerGroupConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::proto::address_book::ComputerGroupConfig* ComputerGroup::mutable_config() {
  ::proto::address_book::ComputerGroupConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:proto.address_book.ComputerGroup.config)
  return _msg;
}
inline void ComputerGroup::set_allocated_config(::proto::address_book::ComputerGroupConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.ComputerGroup.config)
}

// -------------------------------------------------------------------

// Router

// string address = 1;
inline void Router::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Router::address() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Router.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Router::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Router.address)
}
inline std::string* Router::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Router.address)
  return _s;
}
inline const std::string& Router::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Router::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Router::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Router::release_address() {
  // @@protoc_insertion_point(field_release:proto.address_book.Router.address)
  return _impl_.address_.Release();
}
inline void Router::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Router.address)
}

// uint32 port = 2;
inline void Router::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t Router::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Router::port() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Router.port)
  return _internal_port();
}
inline void Router::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void Router::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:proto.address_book.Router.port)
}

// string username = 3;
inline void Router::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Router::username() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Router.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Router::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Router.username)
}
inline std::string* Router::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Router.username)
  return _s;
}
inline const std::string& Router::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Router::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Router::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Router::release_username() {
  // @@protoc_insertion_point(field_release:proto.address_book.Router.username)
  return _impl_.username_.Release();
}
inline void Router::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Router.username)
}

// string password = 4;
inline void Router::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Router::password() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Router.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Router::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Router.password)
}
inline std::string* Router::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Router.password)
  return _s;
}
inline const std::string& Router::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Router::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Router::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Router::release_password() {
  // @@protoc_insertion_point(field_release:proto.address_book.Router.password)
  return _impl_.password_.Release();
}
inline void Router::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Router.password)
}

// -------------------------------------------------------------------

// Data

// .proto.address_book.ComputerGroup root_group = 2;
inline bool Data::_internal_has_root_group() const {
  return this != internal_default_instance() && _impl_.root_group_ != nullptr;
}
inline bool Data::has_root_group() const {
  return _internal_has_root_group();
}
inline void Data::clear_root_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.root_group_ != nullptr) {
    delete _impl_.root_group_;
  }
  _impl_.root_group_ = nullptr;
}
inline const ::proto::address_book::ComputerGroup& Data::_internal_root_group() const {
  const ::proto::address_book::ComputerGroup* p = _impl_.root_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::ComputerGroup&>(
      ::proto::address_book::_ComputerGroup_default_instance_);
}
inline const ::proto::address_book::ComputerGroup& Data::root_group() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Data.root_group)
  return _internal_root_group();
}
inline void Data::unsafe_arena_set_allocated_root_group(
    ::proto::address_book::ComputerGroup* root_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_group_);
  }
  _impl_.root_group_ = root_group;
  if (root_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.Data.root_group)
}
inline ::proto::address_book::ComputerGroup* Data::release_root_group() {
  
  ::proto::address_book::ComputerGroup* temp = _impl_.root_group_;
  _impl_.root_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::ComputerGroup* Data::unsafe_arena_release_root_group() {
  // @@protoc_insertion_point(field_release:proto.address_book.Data.root_group)
  
  ::proto::address_book::ComputerGroup* temp = _impl_.root_group_;
  _impl_.root_group_ = nullptr;
  return temp;
}
inline ::proto::address_book::ComputerGroup* Data::_internal_mutable_root_group() {
  
  if (_impl_.root_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::ComputerGroup>(GetArenaForAllocation());
    _impl_.root_group_ = p;
  }
  return _impl_.root_group_;
}
inline ::proto::address_book::ComputerGroup* Data::mutable_root_group() {
  ::proto::address_book::ComputerGroup* _msg = _internal_mutable_root_group();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Data.root_group)
  return _msg;
}
inline void Data::set_allocated_root_group(::proto::address_book::ComputerGroup* root_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_group_;
  }
  if (root_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root_group);
    if (message_arena != submessage_arena) {
      root_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.root_group_ = root_group;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Data.root_group)
}

// bool enable_router = 4;
inline void Data::clear_enable_router() {
  _impl_.enable_router_ = false;
}
inline bool Data::_internal_enable_router() const {
  return _impl_.enable_router_;
}
inline bool Data::enable_router() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Data.enable_router)
  return _internal_enable_router();
}
inline void Data::_internal_set_enable_router(bool value) {
  
  _impl_.enable_router_ = value;
}
inline void Data::set_enable_router(bool value) {
  _internal_set_enable_router(value);
  // @@protoc_insertion_point(field_set:proto.address_book.Data.enable_router)
}

// .proto.address_book.Router router = 5;
inline bool Data::_internal_has_router() const {
  return this != internal_default_instance() && _impl_.router_ != nullptr;
}
inline bool Data::has_router() const {
  return _internal_has_router();
}
inline void Data::clear_router() {
  if (GetArenaForAllocation() == nullptr && _impl_.router_ != nullptr) {
    delete _impl_.router_;
  }
  _impl_.router_ = nullptr;
}
inline const ::proto::address_book::Router& Data::_internal_router() const {
  const ::proto::address_book::Router* p = _impl_.router_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::address_book::Router&>(
      ::proto::address_book::_Router_default_instance_);
}
inline const ::proto::address_book::Router& Data::router() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Data.router)
  return _internal_router();
}
inline void Data::unsafe_arena_set_allocated_router(
    ::proto::address_book::Router* router) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.router_);
  }
  _impl_.router_ = router;
  if (router) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.address_book.Data.router)
}
inline ::proto::address_book::Router* Data::release_router() {
  
  ::proto::address_book::Router* temp = _impl_.router_;
  _impl_.router_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::address_book::Router* Data::unsafe_arena_release_router() {
  // @@protoc_insertion_point(field_release:proto.address_book.Data.router)
  
  ::proto::address_book::Router* temp = _impl_.router_;
  _impl_.router_ = nullptr;
  return temp;
}
inline ::proto::address_book::Router* Data::_internal_mutable_router() {
  
  if (_impl_.router_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::address_book::Router>(GetArenaForAllocation());
    _impl_.router_ = p;
  }
  return _impl_.router_;
}
inline ::proto::address_book::Router* Data::mutable_router() {
  ::proto::address_book::Router* _msg = _internal_mutable_router();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Data.router)
  return _msg;
}
inline void Data::set_allocated_router(::proto::address_book::Router* router) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.router_;
  }
  if (router) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(router);
    if (message_arena != submessage_arena) {
      router = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, router, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.router_ = router;
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Data.router)
}

// string guid = 6;
inline void Data::clear_guid() {
  _impl_.guid_.ClearToEmpty();
}
inline const std::string& Data::guid() const {
  // @@protoc_insertion_point(field_get:proto.address_book.Data.guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_guid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.Data.guid)
}
inline std::string* Data::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:proto.address_book.Data.guid)
  return _s;
}
inline const std::string& Data::_internal_guid() const {
  return _impl_.guid_.Get();
}
inline void Data::_internal_set_guid(const std::string& value) {
  
  _impl_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_guid() {
  
  return _impl_.guid_.Mutable(GetArenaForAllocation());
}
inline std::string* Data::release_guid() {
  // @@protoc_insertion_point(field_release:proto.address_book.Data.guid)
  return _impl_.guid_.Release();
}
inline void Data::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    
  } else {
    
  }
  _impl_.guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.guid_.IsDefault()) {
    _impl_.guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.Data.guid)
}

// -------------------------------------------------------------------

// File

// .proto.address_book.EncryptionType encryption_type = 1;
inline void File::clear_encryption_type() {
  _impl_.encryption_type_ = 0;
}
inline ::proto::address_book::EncryptionType File::_internal_encryption_type() const {
  return static_cast< ::proto::address_book::EncryptionType >(_impl_.encryption_type_);
}
inline ::proto::address_book::EncryptionType File::encryption_type() const {
  // @@protoc_insertion_point(field_get:proto.address_book.File.encryption_type)
  return _internal_encryption_type();
}
inline void File::_internal_set_encryption_type(::proto::address_book::EncryptionType value) {
  
  _impl_.encryption_type_ = value;
}
inline void File::set_encryption_type(::proto::address_book::EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:proto.address_book.File.encryption_type)
}

// bytes hashing_salt = 3;
inline void File::clear_hashing_salt() {
  _impl_.hashing_salt_.ClearToEmpty();
}
inline const std::string& File::hashing_salt() const {
  // @@protoc_insertion_point(field_get:proto.address_book.File.hashing_salt)
  return _internal_hashing_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_hashing_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hashing_salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.File.hashing_salt)
}
inline std::string* File::mutable_hashing_salt() {
  std::string* _s = _internal_mutable_hashing_salt();
  // @@protoc_insertion_point(field_mutable:proto.address_book.File.hashing_salt)
  return _s;
}
inline const std::string& File::_internal_hashing_salt() const {
  return _impl_.hashing_salt_.Get();
}
inline void File::_internal_set_hashing_salt(const std::string& value) {
  
  _impl_.hashing_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_hashing_salt() {
  
  return _impl_.hashing_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_hashing_salt() {
  // @@protoc_insertion_point(field_release:proto.address_book.File.hashing_salt)
  return _impl_.hashing_salt_.Release();
}
inline void File::set_allocated_hashing_salt(std::string* hashing_salt) {
  if (hashing_salt != nullptr) {
    
  } else {
    
  }
  _impl_.hashing_salt_.SetAllocated(hashing_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashing_salt_.IsDefault()) {
    _impl_.hashing_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.File.hashing_salt)
}

// bytes data = 9;
inline void File::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& File::data() const {
  // @@protoc_insertion_point(field_get:proto.address_book.File.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.address_book.File.data)
}
inline std::string* File::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.address_book.File.data)
  return _s;
}
inline const std::string& File::_internal_data() const {
  return _impl_.data_.Get();
}
inline void File::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_data() {
  // @@protoc_insertion_point(field_release:proto.address_book.File.data)
  return _impl_.data_.Release();
}
inline void File::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.address_book.File.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace address_book
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::address_book::EncryptionType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_address_5fbook_2eproto
