// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: desktop_internal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_desktop_5finternal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_desktop_5finternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "desktop.pb.h"
#include "desktop_extensions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_desktop_5finternal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_desktop_5finternal_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
namespace internal {
class Configure;
struct ConfigureDefaultTypeInternal;
extern ConfigureDefaultTypeInternal _Configure_default_instance_;
class DesktopControl;
struct DesktopControlDefaultTypeInternal;
extern DesktopControlDefaultTypeInternal _DesktopControl_default_instance_;
class DesktopFrame;
struct DesktopFrameDefaultTypeInternal;
extern DesktopFrameDefaultTypeInternal _DesktopFrame_default_instance_;
class DesktopToService;
struct DesktopToServiceDefaultTypeInternal;
extern DesktopToServiceDefaultTypeInternal _DesktopToService_default_instance_;
class MouseCursor;
struct MouseCursorDefaultTypeInternal;
extern MouseCursorDefaultTypeInternal _MouseCursor_default_instance_;
class NextScreenCapture;
struct NextScreenCaptureDefaultTypeInternal;
extern NextScreenCaptureDefaultTypeInternal _NextScreenCapture_default_instance_;
class ScreenCaptured;
struct ScreenCapturedDefaultTypeInternal;
extern ScreenCapturedDefaultTypeInternal _ScreenCaptured_default_instance_;
class SelectSource;
struct SelectSourceDefaultTypeInternal;
extern SelectSourceDefaultTypeInternal _SelectSource_default_instance_;
class ServiceToDesktop;
struct ServiceToDesktopDefaultTypeInternal;
extern ServiceToDesktopDefaultTypeInternal _ServiceToDesktop_default_instance_;
class SharedBuffer;
struct SharedBufferDefaultTypeInternal;
extern SharedBufferDefaultTypeInternal _SharedBuffer_default_instance_;
}  // namespace internal
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::internal::Configure* Arena::CreateMaybeMessage<::proto::internal::Configure>(Arena*);
template<> ::proto::internal::DesktopControl* Arena::CreateMaybeMessage<::proto::internal::DesktopControl>(Arena*);
template<> ::proto::internal::DesktopFrame* Arena::CreateMaybeMessage<::proto::internal::DesktopFrame>(Arena*);
template<> ::proto::internal::DesktopToService* Arena::CreateMaybeMessage<::proto::internal::DesktopToService>(Arena*);
template<> ::proto::internal::MouseCursor* Arena::CreateMaybeMessage<::proto::internal::MouseCursor>(Arena*);
template<> ::proto::internal::NextScreenCapture* Arena::CreateMaybeMessage<::proto::internal::NextScreenCapture>(Arena*);
template<> ::proto::internal::ScreenCaptured* Arena::CreateMaybeMessage<::proto::internal::ScreenCaptured>(Arena*);
template<> ::proto::internal::SelectSource* Arena::CreateMaybeMessage<::proto::internal::SelectSource>(Arena*);
template<> ::proto::internal::ServiceToDesktop* Arena::CreateMaybeMessage<::proto::internal::ServiceToDesktop>(Arena*);
template<> ::proto::internal::SharedBuffer* Arena::CreateMaybeMessage<::proto::internal::SharedBuffer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace internal {

enum SharedBuffer_Type : int {
  SharedBuffer_Type_CREATE = 0,
  SharedBuffer_Type_RELEASE = 1,
  SharedBuffer_Type_SharedBuffer_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SharedBuffer_Type_SharedBuffer_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SharedBuffer_Type_IsValid(int value);
constexpr SharedBuffer_Type SharedBuffer_Type_Type_MIN = SharedBuffer_Type_CREATE;
constexpr SharedBuffer_Type SharedBuffer_Type_Type_MAX = SharedBuffer_Type_RELEASE;
constexpr int SharedBuffer_Type_Type_ARRAYSIZE = SharedBuffer_Type_Type_MAX + 1;

const std::string& SharedBuffer_Type_Name(SharedBuffer_Type value);
template<typename T>
inline const std::string& SharedBuffer_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SharedBuffer_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SharedBuffer_Type_Name.");
  return SharedBuffer_Type_Name(static_cast<SharedBuffer_Type>(enum_t_value));
}
bool SharedBuffer_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharedBuffer_Type* value);
enum DesktopControl_Action : int {
  DesktopControl_Action_UNKNOWN = 0,
  DesktopControl_Action_DISABLE = 1,
  DesktopControl_Action_ENABLE = 2,
  DesktopControl_Action_LOGOFF = 3,
  DesktopControl_Action_LOCK = 4,
  DesktopControl_Action_DesktopControl_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DesktopControl_Action_DesktopControl_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DesktopControl_Action_IsValid(int value);
constexpr DesktopControl_Action DesktopControl_Action_Action_MIN = DesktopControl_Action_UNKNOWN;
constexpr DesktopControl_Action DesktopControl_Action_Action_MAX = DesktopControl_Action_LOCK;
constexpr int DesktopControl_Action_Action_ARRAYSIZE = DesktopControl_Action_Action_MAX + 1;

const std::string& DesktopControl_Action_Name(DesktopControl_Action value);
template<typename T>
inline const std::string& DesktopControl_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DesktopControl_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DesktopControl_Action_Name.");
  return DesktopControl_Action_Name(static_cast<DesktopControl_Action>(enum_t_value));
}
bool DesktopControl_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DesktopControl_Action* value);
// ===================================================================

class DesktopFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.DesktopFrame) */ {
 public:
  inline DesktopFrame() : DesktopFrame(nullptr) {}
  ~DesktopFrame() override;
  explicit PROTOBUF_CONSTEXPR DesktopFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopFrame(const DesktopFrame& from);
  DesktopFrame(DesktopFrame&& from) noexcept
    : DesktopFrame() {
    *this = ::std::move(from);
  }

  inline DesktopFrame& operator=(const DesktopFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopFrame& operator=(DesktopFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopFrame* internal_default_instance() {
    return reinterpret_cast<const DesktopFrame*>(
               &_DesktopFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DesktopFrame& a, DesktopFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopFrame& from);
  void MergeFrom(const DesktopFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.DesktopFrame";
  }
  protected:
  explicit DesktopFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirtyRectFieldNumber = 5,
    kCapturerTypeFieldNumber = 1,
    kSharedBufferIdFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // repeated .proto.Rect dirty_rect = 5;
  int dirty_rect_size() const;
  private:
  int _internal_dirty_rect_size() const;
  public:
  void clear_dirty_rect();
  ::proto::Rect* mutable_dirty_rect(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >*
      mutable_dirty_rect();
  private:
  const ::proto::Rect& _internal_dirty_rect(int index) const;
  ::proto::Rect* _internal_add_dirty_rect();
  public:
  const ::proto::Rect& dirty_rect(int index) const;
  ::proto::Rect* add_dirty_rect();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >&
      dirty_rect() const;

  // uint32 capturer_type = 1;
  void clear_capturer_type();
  uint32_t capturer_type() const;
  void set_capturer_type(uint32_t value);
  private:
  uint32_t _internal_capturer_type() const;
  void _internal_set_capturer_type(uint32_t value);
  public:

  // int32 shared_buffer_id = 2;
  void clear_shared_buffer_id();
  int32_t shared_buffer_id() const;
  void set_shared_buffer_id(int32_t value);
  private:
  int32_t _internal_shared_buffer_id() const;
  void _internal_set_shared_buffer_id(int32_t value);
  public:

  // int32 width = 3;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.DesktopFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect > dirty_rect_;
    uint32_t capturer_type_;
    int32_t shared_buffer_id_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class MouseCursor final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.MouseCursor) */ {
 public:
  inline MouseCursor() : MouseCursor(nullptr) {}
  ~MouseCursor() override;
  explicit PROTOBUF_CONSTEXPR MouseCursor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MouseCursor(const MouseCursor& from);
  MouseCursor(MouseCursor&& from) noexcept
    : MouseCursor() {
    *this = ::std::move(from);
  }

  inline MouseCursor& operator=(const MouseCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseCursor& operator=(MouseCursor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MouseCursor& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseCursor* internal_default_instance() {
    return reinterpret_cast<const MouseCursor*>(
               &_MouseCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MouseCursor& a, MouseCursor& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseCursor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseCursor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseCursor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseCursor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MouseCursor& from);
  void MergeFrom(const MouseCursor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MouseCursor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.MouseCursor";
  }
  protected:
  explicit MouseCursor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 7,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kHotspotXFieldNumber = 3,
    kHotspotYFieldNumber = 4,
    kDpiXFieldNumber = 5,
    kDpiYFieldNumber = 6,
  };
  // bytes data = 7;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 hotspot_x = 3;
  void clear_hotspot_x();
  int32_t hotspot_x() const;
  void set_hotspot_x(int32_t value);
  private:
  int32_t _internal_hotspot_x() const;
  void _internal_set_hotspot_x(int32_t value);
  public:

  // int32 hotspot_y = 4;
  void clear_hotspot_y();
  int32_t hotspot_y() const;
  void set_hotspot_y(int32_t value);
  private:
  int32_t _internal_hotspot_y() const;
  void _internal_set_hotspot_y(int32_t value);
  public:

  // int32 dpi_x = 5;
  void clear_dpi_x();
  int32_t dpi_x() const;
  void set_dpi_x(int32_t value);
  private:
  int32_t _internal_dpi_x() const;
  void _internal_set_dpi_x(int32_t value);
  public:

  // int32 dpi_y = 6;
  void clear_dpi_y();
  int32_t dpi_y() const;
  void set_dpi_y(int32_t value);
  private:
  int32_t _internal_dpi_y() const;
  void _internal_set_dpi_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.MouseCursor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t width_;
    int32_t height_;
    int32_t hotspot_x_;
    int32_t hotspot_y_;
    int32_t dpi_x_;
    int32_t dpi_y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class SharedBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.SharedBuffer) */ {
 public:
  inline SharedBuffer() : SharedBuffer(nullptr) {}
  ~SharedBuffer() override;
  explicit PROTOBUF_CONSTEXPR SharedBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharedBuffer(const SharedBuffer& from);
  SharedBuffer(SharedBuffer&& from) noexcept
    : SharedBuffer() {
    *this = ::std::move(from);
  }

  inline SharedBuffer& operator=(const SharedBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedBuffer& operator=(SharedBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SharedBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedBuffer* internal_default_instance() {
    return reinterpret_cast<const SharedBuffer*>(
               &_SharedBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SharedBuffer& a, SharedBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(SharedBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharedBuffer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SharedBuffer& from);
  void MergeFrom(const SharedBuffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.SharedBuffer";
  }
  protected:
  explicit SharedBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SharedBuffer_Type Type;
  static constexpr Type CREATE =
    SharedBuffer_Type_CREATE;
  static constexpr Type RELEASE =
    SharedBuffer_Type_RELEASE;
  static inline bool Type_IsValid(int value) {
    return SharedBuffer_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SharedBuffer_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SharedBuffer_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SharedBuffer_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SharedBuffer_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SharedBuffer_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSharedBufferIdFieldNumber = 2,
  };
  // .proto.internal.SharedBuffer.Type type = 1;
  void clear_type();
  ::proto::internal::SharedBuffer_Type type() const;
  void set_type(::proto::internal::SharedBuffer_Type value);
  private:
  ::proto::internal::SharedBuffer_Type _internal_type() const;
  void _internal_set_type(::proto::internal::SharedBuffer_Type value);
  public:

  // int32 shared_buffer_id = 2;
  void clear_shared_buffer_id();
  int32_t shared_buffer_id() const;
  void set_shared_buffer_id(int32_t value);
  private:
  int32_t _internal_shared_buffer_id() const;
  void _internal_set_shared_buffer_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.SharedBuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    int32_t shared_buffer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class ScreenCaptured final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.ScreenCaptured) */ {
 public:
  inline ScreenCaptured() : ScreenCaptured(nullptr) {}
  ~ScreenCaptured() override;
  explicit PROTOBUF_CONSTEXPR ScreenCaptured(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScreenCaptured(const ScreenCaptured& from);
  ScreenCaptured(ScreenCaptured&& from) noexcept
    : ScreenCaptured() {
    *this = ::std::move(from);
  }

  inline ScreenCaptured& operator=(const ScreenCaptured& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScreenCaptured& operator=(ScreenCaptured&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ScreenCaptured& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScreenCaptured* internal_default_instance() {
    return reinterpret_cast<const ScreenCaptured*>(
               &_ScreenCaptured_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ScreenCaptured& a, ScreenCaptured& b) {
    a.Swap(&b);
  }
  inline void Swap(ScreenCaptured* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScreenCaptured* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScreenCaptured* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScreenCaptured>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScreenCaptured& from);
  void MergeFrom(const ScreenCaptured& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScreenCaptured* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.ScreenCaptured";
  }
  protected:
  explicit ScreenCaptured(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 2,
    kMouseCursorFieldNumber = 3,
    kErrorCodeFieldNumber = 1,
  };
  // .proto.internal.DesktopFrame frame = 2;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::proto::internal::DesktopFrame& frame() const;
  PROTOBUF_NODISCARD ::proto::internal::DesktopFrame* release_frame();
  ::proto::internal::DesktopFrame* mutable_frame();
  void set_allocated_frame(::proto::internal::DesktopFrame* frame);
  private:
  const ::proto::internal::DesktopFrame& _internal_frame() const;
  ::proto::internal::DesktopFrame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::proto::internal::DesktopFrame* frame);
  ::proto::internal::DesktopFrame* unsafe_arena_release_frame();

  // .proto.internal.MouseCursor mouse_cursor = 3;
  bool has_mouse_cursor() const;
  private:
  bool _internal_has_mouse_cursor() const;
  public:
  void clear_mouse_cursor();
  const ::proto::internal::MouseCursor& mouse_cursor() const;
  PROTOBUF_NODISCARD ::proto::internal::MouseCursor* release_mouse_cursor();
  ::proto::internal::MouseCursor* mutable_mouse_cursor();
  void set_allocated_mouse_cursor(::proto::internal::MouseCursor* mouse_cursor);
  private:
  const ::proto::internal::MouseCursor& _internal_mouse_cursor() const;
  ::proto::internal::MouseCursor* _internal_mutable_mouse_cursor();
  public:
  void unsafe_arena_set_allocated_mouse_cursor(
      ::proto::internal::MouseCursor* mouse_cursor);
  ::proto::internal::MouseCursor* unsafe_arena_release_mouse_cursor();

  // .proto.VideoErrorCode error_code = 1;
  void clear_error_code();
  ::proto::VideoErrorCode error_code() const;
  void set_error_code(::proto::VideoErrorCode value);
  private:
  ::proto::VideoErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::VideoErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.ScreenCaptured)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::internal::DesktopFrame* frame_;
    ::proto::internal::MouseCursor* mouse_cursor_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class NextScreenCapture final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.NextScreenCapture) */ {
 public:
  inline NextScreenCapture() : NextScreenCapture(nullptr) {}
  ~NextScreenCapture() override;
  explicit PROTOBUF_CONSTEXPR NextScreenCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextScreenCapture(const NextScreenCapture& from);
  NextScreenCapture(NextScreenCapture&& from) noexcept
    : NextScreenCapture() {
    *this = ::std::move(from);
  }

  inline NextScreenCapture& operator=(const NextScreenCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextScreenCapture& operator=(NextScreenCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NextScreenCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextScreenCapture* internal_default_instance() {
    return reinterpret_cast<const NextScreenCapture*>(
               &_NextScreenCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NextScreenCapture& a, NextScreenCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(NextScreenCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextScreenCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextScreenCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextScreenCapture>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NextScreenCapture& from);
  void MergeFrom(const NextScreenCapture& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NextScreenCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.NextScreenCapture";
  }
  protected:
  explicit NextScreenCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIntervalFieldNumber = 1,
  };
  // int64 update_interval = 1;
  void clear_update_interval();
  int64_t update_interval() const;
  void set_update_interval(int64_t value);
  private:
  int64_t _internal_update_interval() const;
  void _internal_set_update_interval(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.NextScreenCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t update_interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class SelectSource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.SelectSource) */ {
 public:
  inline SelectSource() : SelectSource(nullptr) {}
  ~SelectSource() override;
  explicit PROTOBUF_CONSTEXPR SelectSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectSource(const SelectSource& from);
  SelectSource(SelectSource&& from) noexcept
    : SelectSource() {
    *this = ::std::move(from);
  }

  inline SelectSource& operator=(const SelectSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectSource& operator=(SelectSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SelectSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectSource* internal_default_instance() {
    return reinterpret_cast<const SelectSource*>(
               &_SelectSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SelectSource& a, SelectSource& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectSource& from);
  void MergeFrom(const SelectSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.SelectSource";
  }
  protected:
  explicit SelectSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScreenFieldNumber = 1,
  };
  // .proto.Screen screen = 1;
  bool has_screen() const;
  private:
  bool _internal_has_screen() const;
  public:
  void clear_screen();
  const ::proto::Screen& screen() const;
  PROTOBUF_NODISCARD ::proto::Screen* release_screen();
  ::proto::Screen* mutable_screen();
  void set_allocated_screen(::proto::Screen* screen);
  private:
  const ::proto::Screen& _internal_screen() const;
  ::proto::Screen* _internal_mutable_screen();
  public:
  void unsafe_arena_set_allocated_screen(
      ::proto::Screen* screen);
  ::proto::Screen* unsafe_arena_release_screen();

  // @@protoc_insertion_point(class_scope:proto.internal.SelectSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::Screen* screen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Configure final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.Configure) */ {
 public:
  inline Configure() : Configure(nullptr) {}
  ~Configure() override;
  explicit PROTOBUF_CONSTEXPR Configure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Configure(const Configure& from);
  Configure(Configure&& from) noexcept
    : Configure() {
    *this = ::std::move(from);
  }

  inline Configure& operator=(const Configure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Configure& operator=(Configure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Configure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Configure* internal_default_instance() {
    return reinterpret_cast<const Configure*>(
               &_Configure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Configure& a, Configure& b) {
    a.Swap(&b);
  }
  inline void Swap(Configure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Configure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Configure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Configure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Configure& from);
  void MergeFrom(const Configure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Configure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.Configure";
  }
  protected:
  explicit Configure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisableFontSmoothingFieldNumber = 1,
    kDisableWallpaperFieldNumber = 2,
    kDisableEffectsFieldNumber = 3,
    kBlockInputFieldNumber = 4,
    kLockAtDisconnectFieldNumber = 5,
    kClearClipboardFieldNumber = 6,
    kCursorPositionFieldNumber = 7,
  };
  // bool disable_font_smoothing = 1;
  void clear_disable_font_smoothing();
  bool disable_font_smoothing() const;
  void set_disable_font_smoothing(bool value);
  private:
  bool _internal_disable_font_smoothing() const;
  void _internal_set_disable_font_smoothing(bool value);
  public:

  // bool disable_wallpaper = 2;
  void clear_disable_wallpaper();
  bool disable_wallpaper() const;
  void set_disable_wallpaper(bool value);
  private:
  bool _internal_disable_wallpaper() const;
  void _internal_set_disable_wallpaper(bool value);
  public:

  // bool disable_effects = 3;
  void clear_disable_effects();
  bool disable_effects() const;
  void set_disable_effects(bool value);
  private:
  bool _internal_disable_effects() const;
  void _internal_set_disable_effects(bool value);
  public:

  // bool block_input = 4;
  void clear_block_input();
  bool block_input() const;
  void set_block_input(bool value);
  private:
  bool _internal_block_input() const;
  void _internal_set_block_input(bool value);
  public:

  // bool lock_at_disconnect = 5;
  void clear_lock_at_disconnect();
  bool lock_at_disconnect() const;
  void set_lock_at_disconnect(bool value);
  private:
  bool _internal_lock_at_disconnect() const;
  void _internal_set_lock_at_disconnect(bool value);
  public:

  // bool clear_clipboard = 6;
  void clear_clear_clipboard();
  bool clear_clipboard() const;
  void set_clear_clipboard(bool value);
  private:
  bool _internal_clear_clipboard() const;
  void _internal_set_clear_clipboard(bool value);
  public:

  // bool cursor_position = 7;
  void clear_cursor_position();
  bool cursor_position() const;
  void set_cursor_position(bool value);
  private:
  bool _internal_cursor_position() const;
  void _internal_set_cursor_position(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.Configure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool disable_font_smoothing_;
    bool disable_wallpaper_;
    bool disable_effects_;
    bool block_input_;
    bool lock_at_disconnect_;
    bool clear_clipboard_;
    bool cursor_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class DesktopControl final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.DesktopControl) */ {
 public:
  inline DesktopControl() : DesktopControl(nullptr) {}
  ~DesktopControl() override;
  explicit PROTOBUF_CONSTEXPR DesktopControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopControl(const DesktopControl& from);
  DesktopControl(DesktopControl&& from) noexcept
    : DesktopControl() {
    *this = ::std::move(from);
  }

  inline DesktopControl& operator=(const DesktopControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopControl& operator=(DesktopControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopControl* internal_default_instance() {
    return reinterpret_cast<const DesktopControl*>(
               &_DesktopControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DesktopControl& a, DesktopControl& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopControl>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopControl& from);
  void MergeFrom(const DesktopControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.DesktopControl";
  }
  protected:
  explicit DesktopControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DesktopControl_Action Action;
  static constexpr Action UNKNOWN =
    DesktopControl_Action_UNKNOWN;
  static constexpr Action DISABLE =
    DesktopControl_Action_DISABLE;
  static constexpr Action ENABLE =
    DesktopControl_Action_ENABLE;
  static constexpr Action LOGOFF =
    DesktopControl_Action_LOGOFF;
  static constexpr Action LOCK =
    DesktopControl_Action_LOCK;
  static inline bool Action_IsValid(int value) {
    return DesktopControl_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    DesktopControl_Action_Action_MIN;
  static constexpr Action Action_MAX =
    DesktopControl_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    DesktopControl_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return DesktopControl_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return DesktopControl_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // .proto.internal.DesktopControl.Action action = 1;
  void clear_action();
  ::proto::internal::DesktopControl_Action action() const;
  void set_action(::proto::internal::DesktopControl_Action value);
  private:
  ::proto::internal::DesktopControl_Action _internal_action() const;
  void _internal_set_action(::proto::internal::DesktopControl_Action value);
  public:

  // @@protoc_insertion_point(class_scope:proto.internal.DesktopControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class ServiceToDesktop final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.ServiceToDesktop) */ {
 public:
  inline ServiceToDesktop() : ServiceToDesktop(nullptr) {}
  ~ServiceToDesktop() override;
  explicit PROTOBUF_CONSTEXPR ServiceToDesktop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceToDesktop(const ServiceToDesktop& from);
  ServiceToDesktop(ServiceToDesktop&& from) noexcept
    : ServiceToDesktop() {
    *this = ::std::move(from);
  }

  inline ServiceToDesktop& operator=(const ServiceToDesktop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceToDesktop& operator=(ServiceToDesktop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ServiceToDesktop& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceToDesktop* internal_default_instance() {
    return reinterpret_cast<const ServiceToDesktop*>(
               &_ServiceToDesktop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ServiceToDesktop& a, ServiceToDesktop& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceToDesktop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceToDesktop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceToDesktop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceToDesktop>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServiceToDesktop& from);
  void MergeFrom(const ServiceToDesktop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceToDesktop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.ServiceToDesktop";
  }
  protected:
  explicit ServiceToDesktop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 1,
    kConfigureFieldNumber = 2,
    kSelectSourceFieldNumber = 3,
    kNextScreenCaptureFieldNumber = 4,
    kKeyEventFieldNumber = 5,
    kTextEventFieldNumber = 6,
    kMouseEventFieldNumber = 7,
    kClipboardEventFieldNumber = 8,
  };
  // .proto.internal.DesktopControl control = 1;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::proto::internal::DesktopControl& control() const;
  PROTOBUF_NODISCARD ::proto::internal::DesktopControl* release_control();
  ::proto::internal::DesktopControl* mutable_control();
  void set_allocated_control(::proto::internal::DesktopControl* control);
  private:
  const ::proto::internal::DesktopControl& _internal_control() const;
  ::proto::internal::DesktopControl* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::proto::internal::DesktopControl* control);
  ::proto::internal::DesktopControl* unsafe_arena_release_control();

  // .proto.internal.Configure configure = 2;
  bool has_configure() const;
  private:
  bool _internal_has_configure() const;
  public:
  void clear_configure();
  const ::proto::internal::Configure& configure() const;
  PROTOBUF_NODISCARD ::proto::internal::Configure* release_configure();
  ::proto::internal::Configure* mutable_configure();
  void set_allocated_configure(::proto::internal::Configure* configure);
  private:
  const ::proto::internal::Configure& _internal_configure() const;
  ::proto::internal::Configure* _internal_mutable_configure();
  public:
  void unsafe_arena_set_allocated_configure(
      ::proto::internal::Configure* configure);
  ::proto::internal::Configure* unsafe_arena_release_configure();

  // .proto.internal.SelectSource select_source = 3;
  bool has_select_source() const;
  private:
  bool _internal_has_select_source() const;
  public:
  void clear_select_source();
  const ::proto::internal::SelectSource& select_source() const;
  PROTOBUF_NODISCARD ::proto::internal::SelectSource* release_select_source();
  ::proto::internal::SelectSource* mutable_select_source();
  void set_allocated_select_source(::proto::internal::SelectSource* select_source);
  private:
  const ::proto::internal::SelectSource& _internal_select_source() const;
  ::proto::internal::SelectSource* _internal_mutable_select_source();
  public:
  void unsafe_arena_set_allocated_select_source(
      ::proto::internal::SelectSource* select_source);
  ::proto::internal::SelectSource* unsafe_arena_release_select_source();

  // .proto.internal.NextScreenCapture next_screen_capture = 4;
  bool has_next_screen_capture() const;
  private:
  bool _internal_has_next_screen_capture() const;
  public:
  void clear_next_screen_capture();
  const ::proto::internal::NextScreenCapture& next_screen_capture() const;
  PROTOBUF_NODISCARD ::proto::internal::NextScreenCapture* release_next_screen_capture();
  ::proto::internal::NextScreenCapture* mutable_next_screen_capture();
  void set_allocated_next_screen_capture(::proto::internal::NextScreenCapture* next_screen_capture);
  private:
  const ::proto::internal::NextScreenCapture& _internal_next_screen_capture() const;
  ::proto::internal::NextScreenCapture* _internal_mutable_next_screen_capture();
  public:
  void unsafe_arena_set_allocated_next_screen_capture(
      ::proto::internal::NextScreenCapture* next_screen_capture);
  ::proto::internal::NextScreenCapture* unsafe_arena_release_next_screen_capture();

  // .proto.KeyEvent key_event = 5;
  bool has_key_event() const;
  private:
  bool _internal_has_key_event() const;
  public:
  void clear_key_event();
  const ::proto::KeyEvent& key_event() const;
  PROTOBUF_NODISCARD ::proto::KeyEvent* release_key_event();
  ::proto::KeyEvent* mutable_key_event();
  void set_allocated_key_event(::proto::KeyEvent* key_event);
  private:
  const ::proto::KeyEvent& _internal_key_event() const;
  ::proto::KeyEvent* _internal_mutable_key_event();
  public:
  void unsafe_arena_set_allocated_key_event(
      ::proto::KeyEvent* key_event);
  ::proto::KeyEvent* unsafe_arena_release_key_event();

  // .proto.TextEvent text_event = 6;
  bool has_text_event() const;
  private:
  bool _internal_has_text_event() const;
  public:
  void clear_text_event();
  const ::proto::TextEvent& text_event() const;
  PROTOBUF_NODISCARD ::proto::TextEvent* release_text_event();
  ::proto::TextEvent* mutable_text_event();
  void set_allocated_text_event(::proto::TextEvent* text_event);
  private:
  const ::proto::TextEvent& _internal_text_event() const;
  ::proto::TextEvent* _internal_mutable_text_event();
  public:
  void unsafe_arena_set_allocated_text_event(
      ::proto::TextEvent* text_event);
  ::proto::TextEvent* unsafe_arena_release_text_event();

  // .proto.MouseEvent mouse_event = 7;
  bool has_mouse_event() const;
  private:
  bool _internal_has_mouse_event() const;
  public:
  void clear_mouse_event();
  const ::proto::MouseEvent& mouse_event() const;
  PROTOBUF_NODISCARD ::proto::MouseEvent* release_mouse_event();
  ::proto::MouseEvent* mutable_mouse_event();
  void set_allocated_mouse_event(::proto::MouseEvent* mouse_event);
  private:
  const ::proto::MouseEvent& _internal_mouse_event() const;
  ::proto::MouseEvent* _internal_mutable_mouse_event();
  public:
  void unsafe_arena_set_allocated_mouse_event(
      ::proto::MouseEvent* mouse_event);
  ::proto::MouseEvent* unsafe_arena_release_mouse_event();

  // .proto.ClipboardEvent clipboard_event = 8;
  bool has_clipboard_event() const;
  private:
  bool _internal_has_clipboard_event() const;
  public:
  void clear_clipboard_event();
  const ::proto::ClipboardEvent& clipboard_event() const;
  PROTOBUF_NODISCARD ::proto::ClipboardEvent* release_clipboard_event();
  ::proto::ClipboardEvent* mutable_clipboard_event();
  void set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event);
  private:
  const ::proto::ClipboardEvent& _internal_clipboard_event() const;
  ::proto::ClipboardEvent* _internal_mutable_clipboard_event();
  public:
  void unsafe_arena_set_allocated_clipboard_event(
      ::proto::ClipboardEvent* clipboard_event);
  ::proto::ClipboardEvent* unsafe_arena_release_clipboard_event();

  // @@protoc_insertion_point(class_scope:proto.internal.ServiceToDesktop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::internal::DesktopControl* control_;
    ::proto::internal::Configure* configure_;
    ::proto::internal::SelectSource* select_source_;
    ::proto::internal::NextScreenCapture* next_screen_capture_;
    ::proto::KeyEvent* key_event_;
    ::proto::TextEvent* text_event_;
    ::proto::MouseEvent* mouse_event_;
    ::proto::ClipboardEvent* clipboard_event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// -------------------------------------------------------------------

class DesktopToService final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.DesktopToService) */ {
 public:
  inline DesktopToService() : DesktopToService(nullptr) {}
  ~DesktopToService() override;
  explicit PROTOBUF_CONSTEXPR DesktopToService(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopToService(const DesktopToService& from);
  DesktopToService(DesktopToService&& from) noexcept
    : DesktopToService() {
    *this = ::std::move(from);
  }

  inline DesktopToService& operator=(const DesktopToService& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopToService& operator=(DesktopToService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopToService& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopToService* internal_default_instance() {
    return reinterpret_cast<const DesktopToService*>(
               &_DesktopToService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DesktopToService& a, DesktopToService& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopToService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopToService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopToService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopToService>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopToService& from);
  void MergeFrom(const DesktopToService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopToService* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.internal.DesktopToService";
  }
  protected:
  explicit DesktopToService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScreenListFieldNumber = 1,
    kSharedBufferFieldNumber = 2,
    kScreenCapturedFieldNumber = 3,
    kAudioPacketFieldNumber = 4,
    kClipboardEventFieldNumber = 5,
    kCursorPositionFieldNumber = 6,
  };
  // .proto.ScreenList screen_list = 1;
  bool has_screen_list() const;
  private:
  bool _internal_has_screen_list() const;
  public:
  void clear_screen_list();
  const ::proto::ScreenList& screen_list() const;
  PROTOBUF_NODISCARD ::proto::ScreenList* release_screen_list();
  ::proto::ScreenList* mutable_screen_list();
  void set_allocated_screen_list(::proto::ScreenList* screen_list);
  private:
  const ::proto::ScreenList& _internal_screen_list() const;
  ::proto::ScreenList* _internal_mutable_screen_list();
  public:
  void unsafe_arena_set_allocated_screen_list(
      ::proto::ScreenList* screen_list);
  ::proto::ScreenList* unsafe_arena_release_screen_list();

  // .proto.internal.SharedBuffer shared_buffer = 2;
  bool has_shared_buffer() const;
  private:
  bool _internal_has_shared_buffer() const;
  public:
  void clear_shared_buffer();
  const ::proto::internal::SharedBuffer& shared_buffer() const;
  PROTOBUF_NODISCARD ::proto::internal::SharedBuffer* release_shared_buffer();
  ::proto::internal::SharedBuffer* mutable_shared_buffer();
  void set_allocated_shared_buffer(::proto::internal::SharedBuffer* shared_buffer);
  private:
  const ::proto::internal::SharedBuffer& _internal_shared_buffer() const;
  ::proto::internal::SharedBuffer* _internal_mutable_shared_buffer();
  public:
  void unsafe_arena_set_allocated_shared_buffer(
      ::proto::internal::SharedBuffer* shared_buffer);
  ::proto::internal::SharedBuffer* unsafe_arena_release_shared_buffer();

  // .proto.internal.ScreenCaptured screen_captured = 3;
  bool has_screen_captured() const;
  private:
  bool _internal_has_screen_captured() const;
  public:
  void clear_screen_captured();
  const ::proto::internal::ScreenCaptured& screen_captured() const;
  PROTOBUF_NODISCARD ::proto::internal::ScreenCaptured* release_screen_captured();
  ::proto::internal::ScreenCaptured* mutable_screen_captured();
  void set_allocated_screen_captured(::proto::internal::ScreenCaptured* screen_captured);
  private:
  const ::proto::internal::ScreenCaptured& _internal_screen_captured() const;
  ::proto::internal::ScreenCaptured* _internal_mutable_screen_captured();
  public:
  void unsafe_arena_set_allocated_screen_captured(
      ::proto::internal::ScreenCaptured* screen_captured);
  ::proto::internal::ScreenCaptured* unsafe_arena_release_screen_captured();

  // .proto.AudioPacket audio_packet = 4;
  bool has_audio_packet() const;
  private:
  bool _internal_has_audio_packet() const;
  public:
  void clear_audio_packet();
  const ::proto::AudioPacket& audio_packet() const;
  PROTOBUF_NODISCARD ::proto::AudioPacket* release_audio_packet();
  ::proto::AudioPacket* mutable_audio_packet();
  void set_allocated_audio_packet(::proto::AudioPacket* audio_packet);
  private:
  const ::proto::AudioPacket& _internal_audio_packet() const;
  ::proto::AudioPacket* _internal_mutable_audio_packet();
  public:
  void unsafe_arena_set_allocated_audio_packet(
      ::proto::AudioPacket* audio_packet);
  ::proto::AudioPacket* unsafe_arena_release_audio_packet();

  // .proto.ClipboardEvent clipboard_event = 5;
  bool has_clipboard_event() const;
  private:
  bool _internal_has_clipboard_event() const;
  public:
  void clear_clipboard_event();
  const ::proto::ClipboardEvent& clipboard_event() const;
  PROTOBUF_NODISCARD ::proto::ClipboardEvent* release_clipboard_event();
  ::proto::ClipboardEvent* mutable_clipboard_event();
  void set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event);
  private:
  const ::proto::ClipboardEvent& _internal_clipboard_event() const;
  ::proto::ClipboardEvent* _internal_mutable_clipboard_event();
  public:
  void unsafe_arena_set_allocated_clipboard_event(
      ::proto::ClipboardEvent* clipboard_event);
  ::proto::ClipboardEvent* unsafe_arena_release_clipboard_event();

  // .proto.CursorPosition cursor_position = 6;
  bool has_cursor_position() const;
  private:
  bool _internal_has_cursor_position() const;
  public:
  void clear_cursor_position();
  const ::proto::CursorPosition& cursor_position() const;
  PROTOBUF_NODISCARD ::proto::CursorPosition* release_cursor_position();
  ::proto::CursorPosition* mutable_cursor_position();
  void set_allocated_cursor_position(::proto::CursorPosition* cursor_position);
  private:
  const ::proto::CursorPosition& _internal_cursor_position() const;
  ::proto::CursorPosition* _internal_mutable_cursor_position();
  public:
  void unsafe_arena_set_allocated_cursor_position(
      ::proto::CursorPosition* cursor_position);
  ::proto::CursorPosition* unsafe_arena_release_cursor_position();

  // @@protoc_insertion_point(class_scope:proto.internal.DesktopToService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::ScreenList* screen_list_;
    ::proto::internal::SharedBuffer* shared_buffer_;
    ::proto::internal::ScreenCaptured* screen_captured_;
    ::proto::AudioPacket* audio_packet_;
    ::proto::ClipboardEvent* clipboard_event_;
    ::proto::CursorPosition* cursor_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_5finternal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DesktopFrame

// uint32 capturer_type = 1;
inline void DesktopFrame::clear_capturer_type() {
  _impl_.capturer_type_ = 0u;
}
inline uint32_t DesktopFrame::_internal_capturer_type() const {
  return _impl_.capturer_type_;
}
inline uint32_t DesktopFrame::capturer_type() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.capturer_type)
  return _internal_capturer_type();
}
inline void DesktopFrame::_internal_set_capturer_type(uint32_t value) {
  
  _impl_.capturer_type_ = value;
}
inline void DesktopFrame::set_capturer_type(uint32_t value) {
  _internal_set_capturer_type(value);
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.capturer_type)
}

// int32 shared_buffer_id = 2;
inline void DesktopFrame::clear_shared_buffer_id() {
  _impl_.shared_buffer_id_ = 0;
}
inline int32_t DesktopFrame::_internal_shared_buffer_id() const {
  return _impl_.shared_buffer_id_;
}
inline int32_t DesktopFrame::shared_buffer_id() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.shared_buffer_id)
  return _internal_shared_buffer_id();
}
inline void DesktopFrame::_internal_set_shared_buffer_id(int32_t value) {
  
  _impl_.shared_buffer_id_ = value;
}
inline void DesktopFrame::set_shared_buffer_id(int32_t value) {
  _internal_set_shared_buffer_id(value);
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.shared_buffer_id)
}

// int32 width = 3;
inline void DesktopFrame::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t DesktopFrame::_internal_width() const {
  return _impl_.width_;
}
inline int32_t DesktopFrame::width() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.width)
  return _internal_width();
}
inline void DesktopFrame::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void DesktopFrame::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.width)
}

// int32 height = 4;
inline void DesktopFrame::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t DesktopFrame::_internal_height() const {
  return _impl_.height_;
}
inline int32_t DesktopFrame::height() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.height)
  return _internal_height();
}
inline void DesktopFrame::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void DesktopFrame::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.height)
}

// repeated .proto.Rect dirty_rect = 5;
inline int DesktopFrame::_internal_dirty_rect_size() const {
  return _impl_.dirty_rect_.size();
}
inline int DesktopFrame::dirty_rect_size() const {
  return _internal_dirty_rect_size();
}
inline ::proto::Rect* DesktopFrame::mutable_dirty_rect(int index) {
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopFrame.dirty_rect)
  return _impl_.dirty_rect_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >*
DesktopFrame::mutable_dirty_rect() {
  // @@protoc_insertion_point(field_mutable_list:proto.internal.DesktopFrame.dirty_rect)
  return &_impl_.dirty_rect_;
}
inline const ::proto::Rect& DesktopFrame::_internal_dirty_rect(int index) const {
  return _impl_.dirty_rect_.Get(index);
}
inline const ::proto::Rect& DesktopFrame::dirty_rect(int index) const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.dirty_rect)
  return _internal_dirty_rect(index);
}
inline ::proto::Rect* DesktopFrame::_internal_add_dirty_rect() {
  return _impl_.dirty_rect_.Add();
}
inline ::proto::Rect* DesktopFrame::add_dirty_rect() {
  ::proto::Rect* _add = _internal_add_dirty_rect();
  // @@protoc_insertion_point(field_add:proto.internal.DesktopFrame.dirty_rect)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >&
DesktopFrame::dirty_rect() const {
  // @@protoc_insertion_point(field_list:proto.internal.DesktopFrame.dirty_rect)
  return _impl_.dirty_rect_;
}

// -------------------------------------------------------------------

// MouseCursor

// int32 width = 1;
inline void MouseCursor::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t MouseCursor::_internal_width() const {
  return _impl_.width_;
}
inline int32_t MouseCursor::width() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.width)
  return _internal_width();
}
inline void MouseCursor::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void MouseCursor::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.width)
}

// int32 height = 2;
inline void MouseCursor::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t MouseCursor::_internal_height() const {
  return _impl_.height_;
}
inline int32_t MouseCursor::height() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.height)
  return _internal_height();
}
inline void MouseCursor::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void MouseCursor::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.height)
}

// int32 hotspot_x = 3;
inline void MouseCursor::clear_hotspot_x() {
  _impl_.hotspot_x_ = 0;
}
inline int32_t MouseCursor::_internal_hotspot_x() const {
  return _impl_.hotspot_x_;
}
inline int32_t MouseCursor::hotspot_x() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.hotspot_x)
  return _internal_hotspot_x();
}
inline void MouseCursor::_internal_set_hotspot_x(int32_t value) {
  
  _impl_.hotspot_x_ = value;
}
inline void MouseCursor::set_hotspot_x(int32_t value) {
  _internal_set_hotspot_x(value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.hotspot_x)
}

// int32 hotspot_y = 4;
inline void MouseCursor::clear_hotspot_y() {
  _impl_.hotspot_y_ = 0;
}
inline int32_t MouseCursor::_internal_hotspot_y() const {
  return _impl_.hotspot_y_;
}
inline int32_t MouseCursor::hotspot_y() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.hotspot_y)
  return _internal_hotspot_y();
}
inline void MouseCursor::_internal_set_hotspot_y(int32_t value) {
  
  _impl_.hotspot_y_ = value;
}
inline void MouseCursor::set_hotspot_y(int32_t value) {
  _internal_set_hotspot_y(value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.hotspot_y)
}

// int32 dpi_x = 5;
inline void MouseCursor::clear_dpi_x() {
  _impl_.dpi_x_ = 0;
}
inline int32_t MouseCursor::_internal_dpi_x() const {
  return _impl_.dpi_x_;
}
inline int32_t MouseCursor::dpi_x() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.dpi_x)
  return _internal_dpi_x();
}
inline void MouseCursor::_internal_set_dpi_x(int32_t value) {
  
  _impl_.dpi_x_ = value;
}
inline void MouseCursor::set_dpi_x(int32_t value) {
  _internal_set_dpi_x(value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.dpi_x)
}

// int32 dpi_y = 6;
inline void MouseCursor::clear_dpi_y() {
  _impl_.dpi_y_ = 0;
}
inline int32_t MouseCursor::_internal_dpi_y() const {
  return _impl_.dpi_y_;
}
inline int32_t MouseCursor::dpi_y() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.dpi_y)
  return _internal_dpi_y();
}
inline void MouseCursor::_internal_set_dpi_y(int32_t value) {
  
  _impl_.dpi_y_ = value;
}
inline void MouseCursor::set_dpi_y(int32_t value) {
  _internal_set_dpi_y(value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.dpi_y)
}

// bytes data = 7;
inline void MouseCursor::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MouseCursor::data() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MouseCursor::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.data)
}
inline std::string* MouseCursor::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.internal.MouseCursor.data)
  return _s;
}
inline const std::string& MouseCursor::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MouseCursor::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MouseCursor::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* MouseCursor::release_data() {
  // @@protoc_insertion_point(field_release:proto.internal.MouseCursor.data)
  return _impl_.data_.Release();
}
inline void MouseCursor::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.internal.MouseCursor.data)
}

// -------------------------------------------------------------------

// SharedBuffer

// .proto.internal.SharedBuffer.Type type = 1;
inline void SharedBuffer::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::internal::SharedBuffer_Type SharedBuffer::_internal_type() const {
  return static_cast< ::proto::internal::SharedBuffer_Type >(_impl_.type_);
}
inline ::proto::internal::SharedBuffer_Type SharedBuffer::type() const {
  // @@protoc_insertion_point(field_get:proto.internal.SharedBuffer.type)
  return _internal_type();
}
inline void SharedBuffer::_internal_set_type(::proto::internal::SharedBuffer_Type value) {
  
  _impl_.type_ = value;
}
inline void SharedBuffer::set_type(::proto::internal::SharedBuffer_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.internal.SharedBuffer.type)
}

// int32 shared_buffer_id = 2;
inline void SharedBuffer::clear_shared_buffer_id() {
  _impl_.shared_buffer_id_ = 0;
}
inline int32_t SharedBuffer::_internal_shared_buffer_id() const {
  return _impl_.shared_buffer_id_;
}
inline int32_t SharedBuffer::shared_buffer_id() const {
  // @@protoc_insertion_point(field_get:proto.internal.SharedBuffer.shared_buffer_id)
  return _internal_shared_buffer_id();
}
inline void SharedBuffer::_internal_set_shared_buffer_id(int32_t value) {
  
  _impl_.shared_buffer_id_ = value;
}
inline void SharedBuffer::set_shared_buffer_id(int32_t value) {
  _internal_set_shared_buffer_id(value);
  // @@protoc_insertion_point(field_set:proto.internal.SharedBuffer.shared_buffer_id)
}

// -------------------------------------------------------------------

// ScreenCaptured

// .proto.VideoErrorCode error_code = 1;
inline void ScreenCaptured::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::VideoErrorCode ScreenCaptured::_internal_error_code() const {
  return static_cast< ::proto::VideoErrorCode >(_impl_.error_code_);
}
inline ::proto::VideoErrorCode ScreenCaptured::error_code() const {
  // @@protoc_insertion_point(field_get:proto.internal.ScreenCaptured.error_code)
  return _internal_error_code();
}
inline void ScreenCaptured::_internal_set_error_code(::proto::VideoErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void ScreenCaptured::set_error_code(::proto::VideoErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.internal.ScreenCaptured.error_code)
}

// .proto.internal.DesktopFrame frame = 2;
inline bool ScreenCaptured::_internal_has_frame() const {
  return this != internal_default_instance() && _impl_.frame_ != nullptr;
}
inline bool ScreenCaptured::has_frame() const {
  return _internal_has_frame();
}
inline void ScreenCaptured::clear_frame() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_ != nullptr) {
    delete _impl_.frame_;
  }
  _impl_.frame_ = nullptr;
}
inline const ::proto::internal::DesktopFrame& ScreenCaptured::_internal_frame() const {
  const ::proto::internal::DesktopFrame* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::DesktopFrame&>(
      ::proto::internal::_DesktopFrame_default_instance_);
}
inline const ::proto::internal::DesktopFrame& ScreenCaptured::frame() const {
  // @@protoc_insertion_point(field_get:proto.internal.ScreenCaptured.frame)
  return _internal_frame();
}
inline void ScreenCaptured::unsafe_arena_set_allocated_frame(
    ::proto::internal::DesktopFrame* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ScreenCaptured.frame)
}
inline ::proto::internal::DesktopFrame* ScreenCaptured::release_frame() {
  
  ::proto::internal::DesktopFrame* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::DesktopFrame* ScreenCaptured::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:proto.internal.ScreenCaptured.frame)
  
  ::proto::internal::DesktopFrame* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::proto::internal::DesktopFrame* ScreenCaptured::_internal_mutable_frame() {
  
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::DesktopFrame>(GetArenaForAllocation());
    _impl_.frame_ = p;
  }
  return _impl_.frame_;
}
inline ::proto::internal::DesktopFrame* ScreenCaptured::mutable_frame() {
  ::proto::internal::DesktopFrame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:proto.internal.ScreenCaptured.frame)
  return _msg;
}
inline void ScreenCaptured::set_allocated_frame(::proto::internal::DesktopFrame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ScreenCaptured.frame)
}

// .proto.internal.MouseCursor mouse_cursor = 3;
inline bool ScreenCaptured::_internal_has_mouse_cursor() const {
  return this != internal_default_instance() && _impl_.mouse_cursor_ != nullptr;
}
inline bool ScreenCaptured::has_mouse_cursor() const {
  return _internal_has_mouse_cursor();
}
inline void ScreenCaptured::clear_mouse_cursor() {
  if (GetArenaForAllocation() == nullptr && _impl_.mouse_cursor_ != nullptr) {
    delete _impl_.mouse_cursor_;
  }
  _impl_.mouse_cursor_ = nullptr;
}
inline const ::proto::internal::MouseCursor& ScreenCaptured::_internal_mouse_cursor() const {
  const ::proto::internal::MouseCursor* p = _impl_.mouse_cursor_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::MouseCursor&>(
      ::proto::internal::_MouseCursor_default_instance_);
}
inline const ::proto::internal::MouseCursor& ScreenCaptured::mouse_cursor() const {
  // @@protoc_insertion_point(field_get:proto.internal.ScreenCaptured.mouse_cursor)
  return _internal_mouse_cursor();
}
inline void ScreenCaptured::unsafe_arena_set_allocated_mouse_cursor(
    ::proto::internal::MouseCursor* mouse_cursor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mouse_cursor_);
  }
  _impl_.mouse_cursor_ = mouse_cursor;
  if (mouse_cursor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ScreenCaptured.mouse_cursor)
}
inline ::proto::internal::MouseCursor* ScreenCaptured::release_mouse_cursor() {
  
  ::proto::internal::MouseCursor* temp = _impl_.mouse_cursor_;
  _impl_.mouse_cursor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::MouseCursor* ScreenCaptured::unsafe_arena_release_mouse_cursor() {
  // @@protoc_insertion_point(field_release:proto.internal.ScreenCaptured.mouse_cursor)
  
  ::proto::internal::MouseCursor* temp = _impl_.mouse_cursor_;
  _impl_.mouse_cursor_ = nullptr;
  return temp;
}
inline ::proto::internal::MouseCursor* ScreenCaptured::_internal_mutable_mouse_cursor() {
  
  if (_impl_.mouse_cursor_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::MouseCursor>(GetArenaForAllocation());
    _impl_.mouse_cursor_ = p;
  }
  return _impl_.mouse_cursor_;
}
inline ::proto::internal::MouseCursor* ScreenCaptured::mutable_mouse_cursor() {
  ::proto::internal::MouseCursor* _msg = _internal_mutable_mouse_cursor();
  // @@protoc_insertion_point(field_mutable:proto.internal.ScreenCaptured.mouse_cursor)
  return _msg;
}
inline void ScreenCaptured::set_allocated_mouse_cursor(::proto::internal::MouseCursor* mouse_cursor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mouse_cursor_;
  }
  if (mouse_cursor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mouse_cursor);
    if (message_arena != submessage_arena) {
      mouse_cursor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_cursor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mouse_cursor_ = mouse_cursor;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ScreenCaptured.mouse_cursor)
}

// -------------------------------------------------------------------

// NextScreenCapture

// int64 update_interval = 1;
inline void NextScreenCapture::clear_update_interval() {
  _impl_.update_interval_ = int64_t{0};
}
inline int64_t NextScreenCapture::_internal_update_interval() const {
  return _impl_.update_interval_;
}
inline int64_t NextScreenCapture::update_interval() const {
  // @@protoc_insertion_point(field_get:proto.internal.NextScreenCapture.update_interval)
  return _internal_update_interval();
}
inline void NextScreenCapture::_internal_set_update_interval(int64_t value) {
  
  _impl_.update_interval_ = value;
}
inline void NextScreenCapture::set_update_interval(int64_t value) {
  _internal_set_update_interval(value);
  // @@protoc_insertion_point(field_set:proto.internal.NextScreenCapture.update_interval)
}

// -------------------------------------------------------------------

// SelectSource

// .proto.Screen screen = 1;
inline bool SelectSource::_internal_has_screen() const {
  return this != internal_default_instance() && _impl_.screen_ != nullptr;
}
inline bool SelectSource::has_screen() const {
  return _internal_has_screen();
}
inline const ::proto::Screen& SelectSource::_internal_screen() const {
  const ::proto::Screen* p = _impl_.screen_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Screen&>(
      ::proto::_Screen_default_instance_);
}
inline const ::proto::Screen& SelectSource::screen() const {
  // @@protoc_insertion_point(field_get:proto.internal.SelectSource.screen)
  return _internal_screen();
}
inline void SelectSource::unsafe_arena_set_allocated_screen(
    ::proto::Screen* screen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_);
  }
  _impl_.screen_ = screen;
  if (screen) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.SelectSource.screen)
}
inline ::proto::Screen* SelectSource::release_screen() {
  
  ::proto::Screen* temp = _impl_.screen_;
  _impl_.screen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Screen* SelectSource::unsafe_arena_release_screen() {
  // @@protoc_insertion_point(field_release:proto.internal.SelectSource.screen)
  
  ::proto::Screen* temp = _impl_.screen_;
  _impl_.screen_ = nullptr;
  return temp;
}
inline ::proto::Screen* SelectSource::_internal_mutable_screen() {
  
  if (_impl_.screen_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Screen>(GetArenaForAllocation());
    _impl_.screen_ = p;
  }
  return _impl_.screen_;
}
inline ::proto::Screen* SelectSource::mutable_screen() {
  ::proto::Screen* _msg = _internal_mutable_screen();
  // @@protoc_insertion_point(field_mutable:proto.internal.SelectSource.screen)
  return _msg;
}
inline void SelectSource::set_allocated_screen(::proto::Screen* screen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_);
  }
  if (screen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen));
    if (message_arena != submessage_arena) {
      screen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.screen_ = screen;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.SelectSource.screen)
}

// -------------------------------------------------------------------

// Configure

// bool disable_font_smoothing = 1;
inline void Configure::clear_disable_font_smoothing() {
  _impl_.disable_font_smoothing_ = false;
}
inline bool Configure::_internal_disable_font_smoothing() const {
  return _impl_.disable_font_smoothing_;
}
inline bool Configure::disable_font_smoothing() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.disable_font_smoothing)
  return _internal_disable_font_smoothing();
}
inline void Configure::_internal_set_disable_font_smoothing(bool value) {
  
  _impl_.disable_font_smoothing_ = value;
}
inline void Configure::set_disable_font_smoothing(bool value) {
  _internal_set_disable_font_smoothing(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.disable_font_smoothing)
}

// bool disable_wallpaper = 2;
inline void Configure::clear_disable_wallpaper() {
  _impl_.disable_wallpaper_ = false;
}
inline bool Configure::_internal_disable_wallpaper() const {
  return _impl_.disable_wallpaper_;
}
inline bool Configure::disable_wallpaper() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.disable_wallpaper)
  return _internal_disable_wallpaper();
}
inline void Configure::_internal_set_disable_wallpaper(bool value) {
  
  _impl_.disable_wallpaper_ = value;
}
inline void Configure::set_disable_wallpaper(bool value) {
  _internal_set_disable_wallpaper(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.disable_wallpaper)
}

// bool disable_effects = 3;
inline void Configure::clear_disable_effects() {
  _impl_.disable_effects_ = false;
}
inline bool Configure::_internal_disable_effects() const {
  return _impl_.disable_effects_;
}
inline bool Configure::disable_effects() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.disable_effects)
  return _internal_disable_effects();
}
inline void Configure::_internal_set_disable_effects(bool value) {
  
  _impl_.disable_effects_ = value;
}
inline void Configure::set_disable_effects(bool value) {
  _internal_set_disable_effects(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.disable_effects)
}

// bool block_input = 4;
inline void Configure::clear_block_input() {
  _impl_.block_input_ = false;
}
inline bool Configure::_internal_block_input() const {
  return _impl_.block_input_;
}
inline bool Configure::block_input() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.block_input)
  return _internal_block_input();
}
inline void Configure::_internal_set_block_input(bool value) {
  
  _impl_.block_input_ = value;
}
inline void Configure::set_block_input(bool value) {
  _internal_set_block_input(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.block_input)
}

// bool lock_at_disconnect = 5;
inline void Configure::clear_lock_at_disconnect() {
  _impl_.lock_at_disconnect_ = false;
}
inline bool Configure::_internal_lock_at_disconnect() const {
  return _impl_.lock_at_disconnect_;
}
inline bool Configure::lock_at_disconnect() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.lock_at_disconnect)
  return _internal_lock_at_disconnect();
}
inline void Configure::_internal_set_lock_at_disconnect(bool value) {
  
  _impl_.lock_at_disconnect_ = value;
}
inline void Configure::set_lock_at_disconnect(bool value) {
  _internal_set_lock_at_disconnect(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.lock_at_disconnect)
}

// bool clear_clipboard = 6;
inline void Configure::clear_clear_clipboard() {
  _impl_.clear_clipboard_ = false;
}
inline bool Configure::_internal_clear_clipboard() const {
  return _impl_.clear_clipboard_;
}
inline bool Configure::clear_clipboard() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.clear_clipboard)
  return _internal_clear_clipboard();
}
inline void Configure::_internal_set_clear_clipboard(bool value) {
  
  _impl_.clear_clipboard_ = value;
}
inline void Configure::set_clear_clipboard(bool value) {
  _internal_set_clear_clipboard(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.clear_clipboard)
}

// bool cursor_position = 7;
inline void Configure::clear_cursor_position() {
  _impl_.cursor_position_ = false;
}
inline bool Configure::_internal_cursor_position() const {
  return _impl_.cursor_position_;
}
inline bool Configure::cursor_position() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.cursor_position)
  return _internal_cursor_position();
}
inline void Configure::_internal_set_cursor_position(bool value) {
  
  _impl_.cursor_position_ = value;
}
inline void Configure::set_cursor_position(bool value) {
  _internal_set_cursor_position(value);
  // @@protoc_insertion_point(field_set:proto.internal.Configure.cursor_position)
}

// -------------------------------------------------------------------

// DesktopControl

// .proto.internal.DesktopControl.Action action = 1;
inline void DesktopControl::clear_action() {
  _impl_.action_ = 0;
}
inline ::proto::internal::DesktopControl_Action DesktopControl::_internal_action() const {
  return static_cast< ::proto::internal::DesktopControl_Action >(_impl_.action_);
}
inline ::proto::internal::DesktopControl_Action DesktopControl::action() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopControl.action)
  return _internal_action();
}
inline void DesktopControl::_internal_set_action(::proto::internal::DesktopControl_Action value) {
  
  _impl_.action_ = value;
}
inline void DesktopControl::set_action(::proto::internal::DesktopControl_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:proto.internal.DesktopControl.action)
}

// -------------------------------------------------------------------

// ServiceToDesktop

// .proto.internal.DesktopControl control = 1;
inline bool ServiceToDesktop::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool ServiceToDesktop::has_control() const {
  return _internal_has_control();
}
inline void ServiceToDesktop::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::proto::internal::DesktopControl& ServiceToDesktop::_internal_control() const {
  const ::proto::internal::DesktopControl* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::DesktopControl&>(
      ::proto::internal::_DesktopControl_default_instance_);
}
inline const ::proto::internal::DesktopControl& ServiceToDesktop::control() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.control)
  return _internal_control();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_control(
    ::proto::internal::DesktopControl* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.control)
}
inline ::proto::internal::DesktopControl* ServiceToDesktop::release_control() {
  
  ::proto::internal::DesktopControl* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::DesktopControl* ServiceToDesktop::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.control)
  
  ::proto::internal::DesktopControl* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::proto::internal::DesktopControl* ServiceToDesktop::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::DesktopControl>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::proto::internal::DesktopControl* ServiceToDesktop::mutable_control() {
  ::proto::internal::DesktopControl* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.control)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_control(::proto::internal::DesktopControl* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.control)
}

// .proto.internal.Configure configure = 2;
inline bool ServiceToDesktop::_internal_has_configure() const {
  return this != internal_default_instance() && _impl_.configure_ != nullptr;
}
inline bool ServiceToDesktop::has_configure() const {
  return _internal_has_configure();
}
inline void ServiceToDesktop::clear_configure() {
  if (GetArenaForAllocation() == nullptr && _impl_.configure_ != nullptr) {
    delete _impl_.configure_;
  }
  _impl_.configure_ = nullptr;
}
inline const ::proto::internal::Configure& ServiceToDesktop::_internal_configure() const {
  const ::proto::internal::Configure* p = _impl_.configure_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::Configure&>(
      ::proto::internal::_Configure_default_instance_);
}
inline const ::proto::internal::Configure& ServiceToDesktop::configure() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.configure)
  return _internal_configure();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_configure(
    ::proto::internal::Configure* configure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.configure_);
  }
  _impl_.configure_ = configure;
  if (configure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.configure)
}
inline ::proto::internal::Configure* ServiceToDesktop::release_configure() {
  
  ::proto::internal::Configure* temp = _impl_.configure_;
  _impl_.configure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::Configure* ServiceToDesktop::unsafe_arena_release_configure() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.configure)
  
  ::proto::internal::Configure* temp = _impl_.configure_;
  _impl_.configure_ = nullptr;
  return temp;
}
inline ::proto::internal::Configure* ServiceToDesktop::_internal_mutable_configure() {
  
  if (_impl_.configure_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::Configure>(GetArenaForAllocation());
    _impl_.configure_ = p;
  }
  return _impl_.configure_;
}
inline ::proto::internal::Configure* ServiceToDesktop::mutable_configure() {
  ::proto::internal::Configure* _msg = _internal_mutable_configure();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.configure)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_configure(::proto::internal::Configure* configure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.configure_;
  }
  if (configure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(configure);
    if (message_arena != submessage_arena) {
      configure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configure, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.configure_ = configure;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.configure)
}

// .proto.internal.SelectSource select_source = 3;
inline bool ServiceToDesktop::_internal_has_select_source() const {
  return this != internal_default_instance() && _impl_.select_source_ != nullptr;
}
inline bool ServiceToDesktop::has_select_source() const {
  return _internal_has_select_source();
}
inline void ServiceToDesktop::clear_select_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.select_source_ != nullptr) {
    delete _impl_.select_source_;
  }
  _impl_.select_source_ = nullptr;
}
inline const ::proto::internal::SelectSource& ServiceToDesktop::_internal_select_source() const {
  const ::proto::internal::SelectSource* p = _impl_.select_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::SelectSource&>(
      ::proto::internal::_SelectSource_default_instance_);
}
inline const ::proto::internal::SelectSource& ServiceToDesktop::select_source() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.select_source)
  return _internal_select_source();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_select_source(
    ::proto::internal::SelectSource* select_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.select_source_);
  }
  _impl_.select_source_ = select_source;
  if (select_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.select_source)
}
inline ::proto::internal::SelectSource* ServiceToDesktop::release_select_source() {
  
  ::proto::internal::SelectSource* temp = _impl_.select_source_;
  _impl_.select_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::SelectSource* ServiceToDesktop::unsafe_arena_release_select_source() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.select_source)
  
  ::proto::internal::SelectSource* temp = _impl_.select_source_;
  _impl_.select_source_ = nullptr;
  return temp;
}
inline ::proto::internal::SelectSource* ServiceToDesktop::_internal_mutable_select_source() {
  
  if (_impl_.select_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::SelectSource>(GetArenaForAllocation());
    _impl_.select_source_ = p;
  }
  return _impl_.select_source_;
}
inline ::proto::internal::SelectSource* ServiceToDesktop::mutable_select_source() {
  ::proto::internal::SelectSource* _msg = _internal_mutable_select_source();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.select_source)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_select_source(::proto::internal::SelectSource* select_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.select_source_;
  }
  if (select_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(select_source);
    if (message_arena != submessage_arena) {
      select_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.select_source_ = select_source;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.select_source)
}

// .proto.internal.NextScreenCapture next_screen_capture = 4;
inline bool ServiceToDesktop::_internal_has_next_screen_capture() const {
  return this != internal_default_instance() && _impl_.next_screen_capture_ != nullptr;
}
inline bool ServiceToDesktop::has_next_screen_capture() const {
  return _internal_has_next_screen_capture();
}
inline void ServiceToDesktop::clear_next_screen_capture() {
  if (GetArenaForAllocation() == nullptr && _impl_.next_screen_capture_ != nullptr) {
    delete _impl_.next_screen_capture_;
  }
  _impl_.next_screen_capture_ = nullptr;
}
inline const ::proto::internal::NextScreenCapture& ServiceToDesktop::_internal_next_screen_capture() const {
  const ::proto::internal::NextScreenCapture* p = _impl_.next_screen_capture_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::NextScreenCapture&>(
      ::proto::internal::_NextScreenCapture_default_instance_);
}
inline const ::proto::internal::NextScreenCapture& ServiceToDesktop::next_screen_capture() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.next_screen_capture)
  return _internal_next_screen_capture();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_next_screen_capture(
    ::proto::internal::NextScreenCapture* next_screen_capture) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_screen_capture_);
  }
  _impl_.next_screen_capture_ = next_screen_capture;
  if (next_screen_capture) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.next_screen_capture)
}
inline ::proto::internal::NextScreenCapture* ServiceToDesktop::release_next_screen_capture() {
  
  ::proto::internal::NextScreenCapture* temp = _impl_.next_screen_capture_;
  _impl_.next_screen_capture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::NextScreenCapture* ServiceToDesktop::unsafe_arena_release_next_screen_capture() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.next_screen_capture)
  
  ::proto::internal::NextScreenCapture* temp = _impl_.next_screen_capture_;
  _impl_.next_screen_capture_ = nullptr;
  return temp;
}
inline ::proto::internal::NextScreenCapture* ServiceToDesktop::_internal_mutable_next_screen_capture() {
  
  if (_impl_.next_screen_capture_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::NextScreenCapture>(GetArenaForAllocation());
    _impl_.next_screen_capture_ = p;
  }
  return _impl_.next_screen_capture_;
}
inline ::proto::internal::NextScreenCapture* ServiceToDesktop::mutable_next_screen_capture() {
  ::proto::internal::NextScreenCapture* _msg = _internal_mutable_next_screen_capture();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.next_screen_capture)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_next_screen_capture(::proto::internal::NextScreenCapture* next_screen_capture) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.next_screen_capture_;
  }
  if (next_screen_capture) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(next_screen_capture);
    if (message_arena != submessage_arena) {
      next_screen_capture = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_screen_capture, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_screen_capture_ = next_screen_capture;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.next_screen_capture)
}

// .proto.KeyEvent key_event = 5;
inline bool ServiceToDesktop::_internal_has_key_event() const {
  return this != internal_default_instance() && _impl_.key_event_ != nullptr;
}
inline bool ServiceToDesktop::has_key_event() const {
  return _internal_has_key_event();
}
inline const ::proto::KeyEvent& ServiceToDesktop::_internal_key_event() const {
  const ::proto::KeyEvent* p = _impl_.key_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::KeyEvent&>(
      ::proto::_KeyEvent_default_instance_);
}
inline const ::proto::KeyEvent& ServiceToDesktop::key_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.key_event)
  return _internal_key_event();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_key_event(
    ::proto::KeyEvent* key_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_event_);
  }
  _impl_.key_event_ = key_event;
  if (key_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.key_event)
}
inline ::proto::KeyEvent* ServiceToDesktop::release_key_event() {
  
  ::proto::KeyEvent* temp = _impl_.key_event_;
  _impl_.key_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::KeyEvent* ServiceToDesktop::unsafe_arena_release_key_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.key_event)
  
  ::proto::KeyEvent* temp = _impl_.key_event_;
  _impl_.key_event_ = nullptr;
  return temp;
}
inline ::proto::KeyEvent* ServiceToDesktop::_internal_mutable_key_event() {
  
  if (_impl_.key_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::KeyEvent>(GetArenaForAllocation());
    _impl_.key_event_ = p;
  }
  return _impl_.key_event_;
}
inline ::proto::KeyEvent* ServiceToDesktop::mutable_key_event() {
  ::proto::KeyEvent* _msg = _internal_mutable_key_event();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.key_event)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_key_event(::proto::KeyEvent* key_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_event_);
  }
  if (key_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_event));
    if (message_arena != submessage_arena) {
      key_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_event_ = key_event;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.key_event)
}

// .proto.TextEvent text_event = 6;
inline bool ServiceToDesktop::_internal_has_text_event() const {
  return this != internal_default_instance() && _impl_.text_event_ != nullptr;
}
inline bool ServiceToDesktop::has_text_event() const {
  return _internal_has_text_event();
}
inline const ::proto::TextEvent& ServiceToDesktop::_internal_text_event() const {
  const ::proto::TextEvent* p = _impl_.text_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TextEvent&>(
      ::proto::_TextEvent_default_instance_);
}
inline const ::proto::TextEvent& ServiceToDesktop::text_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.text_event)
  return _internal_text_event();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_text_event(
    ::proto::TextEvent* text_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_event_);
  }
  _impl_.text_event_ = text_event;
  if (text_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.text_event)
}
inline ::proto::TextEvent* ServiceToDesktop::release_text_event() {
  
  ::proto::TextEvent* temp = _impl_.text_event_;
  _impl_.text_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TextEvent* ServiceToDesktop::unsafe_arena_release_text_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.text_event)
  
  ::proto::TextEvent* temp = _impl_.text_event_;
  _impl_.text_event_ = nullptr;
  return temp;
}
inline ::proto::TextEvent* ServiceToDesktop::_internal_mutable_text_event() {
  
  if (_impl_.text_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TextEvent>(GetArenaForAllocation());
    _impl_.text_event_ = p;
  }
  return _impl_.text_event_;
}
inline ::proto::TextEvent* ServiceToDesktop::mutable_text_event() {
  ::proto::TextEvent* _msg = _internal_mutable_text_event();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.text_event)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_text_event(::proto::TextEvent* text_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_event_);
  }
  if (text_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_event));
    if (message_arena != submessage_arena) {
      text_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_event_ = text_event;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.text_event)
}

// .proto.MouseEvent mouse_event = 7;
inline bool ServiceToDesktop::_internal_has_mouse_event() const {
  return this != internal_default_instance() && _impl_.mouse_event_ != nullptr;
}
inline bool ServiceToDesktop::has_mouse_event() const {
  return _internal_has_mouse_event();
}
inline const ::proto::MouseEvent& ServiceToDesktop::_internal_mouse_event() const {
  const ::proto::MouseEvent* p = _impl_.mouse_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MouseEvent&>(
      ::proto::_MouseEvent_default_instance_);
}
inline const ::proto::MouseEvent& ServiceToDesktop::mouse_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.mouse_event)
  return _internal_mouse_event();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_mouse_event(
    ::proto::MouseEvent* mouse_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mouse_event_);
  }
  _impl_.mouse_event_ = mouse_event;
  if (mouse_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.mouse_event)
}
inline ::proto::MouseEvent* ServiceToDesktop::release_mouse_event() {
  
  ::proto::MouseEvent* temp = _impl_.mouse_event_;
  _impl_.mouse_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MouseEvent* ServiceToDesktop::unsafe_arena_release_mouse_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.mouse_event)
  
  ::proto::MouseEvent* temp = _impl_.mouse_event_;
  _impl_.mouse_event_ = nullptr;
  return temp;
}
inline ::proto::MouseEvent* ServiceToDesktop::_internal_mutable_mouse_event() {
  
  if (_impl_.mouse_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MouseEvent>(GetArenaForAllocation());
    _impl_.mouse_event_ = p;
  }
  return _impl_.mouse_event_;
}
inline ::proto::MouseEvent* ServiceToDesktop::mutable_mouse_event() {
  ::proto::MouseEvent* _msg = _internal_mutable_mouse_event();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.mouse_event)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_mouse_event(::proto::MouseEvent* mouse_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mouse_event_);
  }
  if (mouse_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mouse_event));
    if (message_arena != submessage_arena) {
      mouse_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mouse_event_ = mouse_event;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.mouse_event)
}

// .proto.ClipboardEvent clipboard_event = 8;
inline bool ServiceToDesktop::_internal_has_clipboard_event() const {
  return this != internal_default_instance() && _impl_.clipboard_event_ != nullptr;
}
inline bool ServiceToDesktop::has_clipboard_event() const {
  return _internal_has_clipboard_event();
}
inline const ::proto::ClipboardEvent& ServiceToDesktop::_internal_clipboard_event() const {
  const ::proto::ClipboardEvent* p = _impl_.clipboard_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ClipboardEvent&>(
      ::proto::_ClipboardEvent_default_instance_);
}
inline const ::proto::ClipboardEvent& ServiceToDesktop::clipboard_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.clipboard_event)
  return _internal_clipboard_event();
}
inline void ServiceToDesktop::unsafe_arena_set_allocated_clipboard_event(
    ::proto::ClipboardEvent* clipboard_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clipboard_event_);
  }
  _impl_.clipboard_event_ = clipboard_event;
  if (clipboard_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.ServiceToDesktop.clipboard_event)
}
inline ::proto::ClipboardEvent* ServiceToDesktop::release_clipboard_event() {
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ClipboardEvent* ServiceToDesktop::unsafe_arena_release_clipboard_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.clipboard_event)
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
  return temp;
}
inline ::proto::ClipboardEvent* ServiceToDesktop::_internal_mutable_clipboard_event() {
  
  if (_impl_.clipboard_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ClipboardEvent>(GetArenaForAllocation());
    _impl_.clipboard_event_ = p;
  }
  return _impl_.clipboard_event_;
}
inline ::proto::ClipboardEvent* ServiceToDesktop::mutable_clipboard_event() {
  ::proto::ClipboardEvent* _msg = _internal_mutable_clipboard_event();
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.clipboard_event)
  return _msg;
}
inline void ServiceToDesktop::set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clipboard_event_);
  }
  if (clipboard_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clipboard_event));
    if (message_arena != submessage_arena) {
      clipboard_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clipboard_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clipboard_event_ = clipboard_event;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.clipboard_event)
}

// -------------------------------------------------------------------

// DesktopToService

// .proto.ScreenList screen_list = 1;
inline bool DesktopToService::_internal_has_screen_list() const {
  return this != internal_default_instance() && _impl_.screen_list_ != nullptr;
}
inline bool DesktopToService::has_screen_list() const {
  return _internal_has_screen_list();
}
inline const ::proto::ScreenList& DesktopToService::_internal_screen_list() const {
  const ::proto::ScreenList* p = _impl_.screen_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ScreenList&>(
      ::proto::_ScreenList_default_instance_);
}
inline const ::proto::ScreenList& DesktopToService::screen_list() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.screen_list)
  return _internal_screen_list();
}
inline void DesktopToService::unsafe_arena_set_allocated_screen_list(
    ::proto::ScreenList* screen_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_list_);
  }
  _impl_.screen_list_ = screen_list;
  if (screen_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.DesktopToService.screen_list)
}
inline ::proto::ScreenList* DesktopToService::release_screen_list() {
  
  ::proto::ScreenList* temp = _impl_.screen_list_;
  _impl_.screen_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ScreenList* DesktopToService::unsafe_arena_release_screen_list() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.screen_list)
  
  ::proto::ScreenList* temp = _impl_.screen_list_;
  _impl_.screen_list_ = nullptr;
  return temp;
}
inline ::proto::ScreenList* DesktopToService::_internal_mutable_screen_list() {
  
  if (_impl_.screen_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ScreenList>(GetArenaForAllocation());
    _impl_.screen_list_ = p;
  }
  return _impl_.screen_list_;
}
inline ::proto::ScreenList* DesktopToService::mutable_screen_list() {
  ::proto::ScreenList* _msg = _internal_mutable_screen_list();
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.screen_list)
  return _msg;
}
inline void DesktopToService::set_allocated_screen_list(::proto::ScreenList* screen_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_list_);
  }
  if (screen_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen_list));
    if (message_arena != submessage_arena) {
      screen_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.screen_list_ = screen_list;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.screen_list)
}

// .proto.internal.SharedBuffer shared_buffer = 2;
inline bool DesktopToService::_internal_has_shared_buffer() const {
  return this != internal_default_instance() && _impl_.shared_buffer_ != nullptr;
}
inline bool DesktopToService::has_shared_buffer() const {
  return _internal_has_shared_buffer();
}
inline void DesktopToService::clear_shared_buffer() {
  if (GetArenaForAllocation() == nullptr && _impl_.shared_buffer_ != nullptr) {
    delete _impl_.shared_buffer_;
  }
  _impl_.shared_buffer_ = nullptr;
}
inline const ::proto::internal::SharedBuffer& DesktopToService::_internal_shared_buffer() const {
  const ::proto::internal::SharedBuffer* p = _impl_.shared_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::SharedBuffer&>(
      ::proto::internal::_SharedBuffer_default_instance_);
}
inline const ::proto::internal::SharedBuffer& DesktopToService::shared_buffer() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.shared_buffer)
  return _internal_shared_buffer();
}
inline void DesktopToService::unsafe_arena_set_allocated_shared_buffer(
    ::proto::internal::SharedBuffer* shared_buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shared_buffer_);
  }
  _impl_.shared_buffer_ = shared_buffer;
  if (shared_buffer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.DesktopToService.shared_buffer)
}
inline ::proto::internal::SharedBuffer* DesktopToService::release_shared_buffer() {
  
  ::proto::internal::SharedBuffer* temp = _impl_.shared_buffer_;
  _impl_.shared_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::SharedBuffer* DesktopToService::unsafe_arena_release_shared_buffer() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.shared_buffer)
  
  ::proto::internal::SharedBuffer* temp = _impl_.shared_buffer_;
  _impl_.shared_buffer_ = nullptr;
  return temp;
}
inline ::proto::internal::SharedBuffer* DesktopToService::_internal_mutable_shared_buffer() {
  
  if (_impl_.shared_buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::SharedBuffer>(GetArenaForAllocation());
    _impl_.shared_buffer_ = p;
  }
  return _impl_.shared_buffer_;
}
inline ::proto::internal::SharedBuffer* DesktopToService::mutable_shared_buffer() {
  ::proto::internal::SharedBuffer* _msg = _internal_mutable_shared_buffer();
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.shared_buffer)
  return _msg;
}
inline void DesktopToService::set_allocated_shared_buffer(::proto::internal::SharedBuffer* shared_buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shared_buffer_;
  }
  if (shared_buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shared_buffer);
    if (message_arena != submessage_arena) {
      shared_buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shared_buffer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shared_buffer_ = shared_buffer;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.shared_buffer)
}

// .proto.internal.ScreenCaptured screen_captured = 3;
inline bool DesktopToService::_internal_has_screen_captured() const {
  return this != internal_default_instance() && _impl_.screen_captured_ != nullptr;
}
inline bool DesktopToService::has_screen_captured() const {
  return _internal_has_screen_captured();
}
inline void DesktopToService::clear_screen_captured() {
  if (GetArenaForAllocation() == nullptr && _impl_.screen_captured_ != nullptr) {
    delete _impl_.screen_captured_;
  }
  _impl_.screen_captured_ = nullptr;
}
inline const ::proto::internal::ScreenCaptured& DesktopToService::_internal_screen_captured() const {
  const ::proto::internal::ScreenCaptured* p = _impl_.screen_captured_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::internal::ScreenCaptured&>(
      ::proto::internal::_ScreenCaptured_default_instance_);
}
inline const ::proto::internal::ScreenCaptured& DesktopToService::screen_captured() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.screen_captured)
  return _internal_screen_captured();
}
inline void DesktopToService::unsafe_arena_set_allocated_screen_captured(
    ::proto::internal::ScreenCaptured* screen_captured) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_captured_);
  }
  _impl_.screen_captured_ = screen_captured;
  if (screen_captured) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.DesktopToService.screen_captured)
}
inline ::proto::internal::ScreenCaptured* DesktopToService::release_screen_captured() {
  
  ::proto::internal::ScreenCaptured* temp = _impl_.screen_captured_;
  _impl_.screen_captured_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::internal::ScreenCaptured* DesktopToService::unsafe_arena_release_screen_captured() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.screen_captured)
  
  ::proto::internal::ScreenCaptured* temp = _impl_.screen_captured_;
  _impl_.screen_captured_ = nullptr;
  return temp;
}
inline ::proto::internal::ScreenCaptured* DesktopToService::_internal_mutable_screen_captured() {
  
  if (_impl_.screen_captured_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::internal::ScreenCaptured>(GetArenaForAllocation());
    _impl_.screen_captured_ = p;
  }
  return _impl_.screen_captured_;
}
inline ::proto::internal::ScreenCaptured* DesktopToService::mutable_screen_captured() {
  ::proto::internal::ScreenCaptured* _msg = _internal_mutable_screen_captured();
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.screen_captured)
  return _msg;
}
inline void DesktopToService::set_allocated_screen_captured(::proto::internal::ScreenCaptured* screen_captured) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.screen_captured_;
  }
  if (screen_captured) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screen_captured);
    if (message_arena != submessage_arena) {
      screen_captured = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen_captured, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.screen_captured_ = screen_captured;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.screen_captured)
}

// .proto.AudioPacket audio_packet = 4;
inline bool DesktopToService::_internal_has_audio_packet() const {
  return this != internal_default_instance() && _impl_.audio_packet_ != nullptr;
}
inline bool DesktopToService::has_audio_packet() const {
  return _internal_has_audio_packet();
}
inline const ::proto::AudioPacket& DesktopToService::_internal_audio_packet() const {
  const ::proto::AudioPacket* p = _impl_.audio_packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AudioPacket&>(
      ::proto::_AudioPacket_default_instance_);
}
inline const ::proto::AudioPacket& DesktopToService::audio_packet() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.audio_packet)
  return _internal_audio_packet();
}
inline void DesktopToService::unsafe_arena_set_allocated_audio_packet(
    ::proto::AudioPacket* audio_packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_packet_);
  }
  _impl_.audio_packet_ = audio_packet;
  if (audio_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.DesktopToService.audio_packet)
}
inline ::proto::AudioPacket* DesktopToService::release_audio_packet() {
  
  ::proto::AudioPacket* temp = _impl_.audio_packet_;
  _impl_.audio_packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AudioPacket* DesktopToService::unsafe_arena_release_audio_packet() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.audio_packet)
  
  ::proto::AudioPacket* temp = _impl_.audio_packet_;
  _impl_.audio_packet_ = nullptr;
  return temp;
}
inline ::proto::AudioPacket* DesktopToService::_internal_mutable_audio_packet() {
  
  if (_impl_.audio_packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AudioPacket>(GetArenaForAllocation());
    _impl_.audio_packet_ = p;
  }
  return _impl_.audio_packet_;
}
inline ::proto::AudioPacket* DesktopToService::mutable_audio_packet() {
  ::proto::AudioPacket* _msg = _internal_mutable_audio_packet();
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.audio_packet)
  return _msg;
}
inline void DesktopToService::set_allocated_audio_packet(::proto::AudioPacket* audio_packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_packet_);
  }
  if (audio_packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_packet));
    if (message_arena != submessage_arena) {
      audio_packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_packet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_packet_ = audio_packet;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.audio_packet)
}

// .proto.ClipboardEvent clipboard_event = 5;
inline bool DesktopToService::_internal_has_clipboard_event() const {
  return this != internal_default_instance() && _impl_.clipboard_event_ != nullptr;
}
inline bool DesktopToService::has_clipboard_event() const {
  return _internal_has_clipboard_event();
}
inline const ::proto::ClipboardEvent& DesktopToService::_internal_clipboard_event() const {
  const ::proto::ClipboardEvent* p = _impl_.clipboard_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ClipboardEvent&>(
      ::proto::_ClipboardEvent_default_instance_);
}
inline const ::proto::ClipboardEvent& DesktopToService::clipboard_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.clipboard_event)
  return _internal_clipboard_event();
}
inline void DesktopToService::unsafe_arena_set_allocated_clipboard_event(
    ::proto::ClipboardEvent* clipboard_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clipboard_event_);
  }
  _impl_.clipboard_event_ = clipboard_event;
  if (clipboard_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.DesktopToService.clipboard_event)
}
inline ::proto::ClipboardEvent* DesktopToService::release_clipboard_event() {
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ClipboardEvent* DesktopToService::unsafe_arena_release_clipboard_event() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.clipboard_event)
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
  return temp;
}
inline ::proto::ClipboardEvent* DesktopToService::_internal_mutable_clipboard_event() {
  
  if (_impl_.clipboard_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ClipboardEvent>(GetArenaForAllocation());
    _impl_.clipboard_event_ = p;
  }
  return _impl_.clipboard_event_;
}
inline ::proto::ClipboardEvent* DesktopToService::mutable_clipboard_event() {
  ::proto::ClipboardEvent* _msg = _internal_mutable_clipboard_event();
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.clipboard_event)
  return _msg;
}
inline void DesktopToService::set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clipboard_event_);
  }
  if (clipboard_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clipboard_event));
    if (message_arena != submessage_arena) {
      clipboard_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clipboard_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clipboard_event_ = clipboard_event;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.clipboard_event)
}

// .proto.CursorPosition cursor_position = 6;
inline bool DesktopToService::_internal_has_cursor_position() const {
  return this != internal_default_instance() && _impl_.cursor_position_ != nullptr;
}
inline bool DesktopToService::has_cursor_position() const {
  return _internal_has_cursor_position();
}
inline const ::proto::CursorPosition& DesktopToService::_internal_cursor_position() const {
  const ::proto::CursorPosition* p = _impl_.cursor_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CursorPosition&>(
      ::proto::_CursorPosition_default_instance_);
}
inline const ::proto::CursorPosition& DesktopToService::cursor_position() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.cursor_position)
  return _internal_cursor_position();
}
inline void DesktopToService::unsafe_arena_set_allocated_cursor_position(
    ::proto::CursorPosition* cursor_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cursor_position_);
  }
  _impl_.cursor_position_ = cursor_position;
  if (cursor_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.internal.DesktopToService.cursor_position)
}
inline ::proto::CursorPosition* DesktopToService::release_cursor_position() {
  
  ::proto::CursorPosition* temp = _impl_.cursor_position_;
  _impl_.cursor_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CursorPosition* DesktopToService::unsafe_arena_release_cursor_position() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.cursor_position)
  
  ::proto::CursorPosition* temp = _impl_.cursor_position_;
  _impl_.cursor_position_ = nullptr;
  return temp;
}
inline ::proto::CursorPosition* DesktopToService::_internal_mutable_cursor_position() {
  
  if (_impl_.cursor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CursorPosition>(GetArenaForAllocation());
    _impl_.cursor_position_ = p;
  }
  return _impl_.cursor_position_;
}
inline ::proto::CursorPosition* DesktopToService::mutable_cursor_position() {
  ::proto::CursorPosition* _msg = _internal_mutable_cursor_position();
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.cursor_position)
  return _msg;
}
inline void DesktopToService::set_allocated_cursor_position(::proto::CursorPosition* cursor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cursor_position_);
  }
  if (cursor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cursor_position));
    if (message_arena != submessage_arena) {
      cursor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cursor_position_ = cursor_position;
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.cursor_position)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace internal
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::internal::SharedBuffer_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::internal::DesktopControl_Action> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_desktop_5finternal_2eproto
