// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: file_transfer.proto

#include "file_transfer.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
PROTOBUF_CONSTEXPR DriveList_Item::DriveList_Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.total_space_)*/int64_t{0}
  , /*decltype(_impl_.free_space_)*/int64_t{0}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DriveList_ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DriveList_ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DriveList_ItemDefaultTypeInternal() {}
  union {
    DriveList_Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DriveList_ItemDefaultTypeInternal _DriveList_Item_default_instance_;
PROTOBUF_CONSTEXPR DriveList::DriveList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.item_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DriveListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DriveListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DriveListDefaultTypeInternal() {}
  union {
    DriveList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DriveListDefaultTypeInternal _DriveList_default_instance_;
PROTOBUF_CONSTEXPR DriveListRequest::DriveListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dummy_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DriveListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DriveListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DriveListRequestDefaultTypeInternal() {}
  union {
    DriveListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DriveListRequestDefaultTypeInternal _DriveListRequest_default_instance_;
PROTOBUF_CONSTEXPR FileList_Item::FileList_Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.modification_time_)*/int64_t{0}
  , /*decltype(_impl_.is_directory_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileList_ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileList_ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileList_ItemDefaultTypeInternal() {}
  union {
    FileList_Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileList_ItemDefaultTypeInternal _FileList_Item_default_instance_;
PROTOBUF_CONSTEXPR FileList::FileList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.item_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileListDefaultTypeInternal() {}
  union {
    FileList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileListDefaultTypeInternal _FileList_default_instance_;
PROTOBUF_CONSTEXPR FileListRequest::FileListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileListRequestDefaultTypeInternal() {}
  union {
    FileListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileListRequestDefaultTypeInternal _FileListRequest_default_instance_;
PROTOBUF_CONSTEXPR UploadRequest::UploadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.overwrite_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UploadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadRequestDefaultTypeInternal() {}
  union {
    UploadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadRequestDefaultTypeInternal _UploadRequest_default_instance_;
PROTOBUF_CONSTEXPR DownloadRequest::DownloadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DownloadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadRequestDefaultTypeInternal() {}
  union {
    DownloadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
PROTOBUF_CONSTEXPR FilePacketRequest::FilePacketRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FilePacketRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilePacketRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilePacketRequestDefaultTypeInternal() {}
  union {
    FilePacketRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilePacketRequestDefaultTypeInternal _FilePacketRequest_default_instance_;
PROTOBUF_CONSTEXPR FilePacket::FilePacket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_size_)*/uint64_t{0u}
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FilePacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilePacketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilePacketDefaultTypeInternal() {}
  union {
    FilePacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilePacketDefaultTypeInternal _FilePacket_default_instance_;
PROTOBUF_CONSTEXPR CreateDirectoryRequest::CreateDirectoryRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateDirectoryRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateDirectoryRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateDirectoryRequestDefaultTypeInternal() {}
  union {
    CreateDirectoryRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateDirectoryRequestDefaultTypeInternal _CreateDirectoryRequest_default_instance_;
PROTOBUF_CONSTEXPR RenameRequest::RenameRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.old_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RenameRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RenameRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RenameRequestDefaultTypeInternal() {}
  union {
    RenameRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RenameRequestDefaultTypeInternal _RenameRequest_default_instance_;
PROTOBUF_CONSTEXPR RemoveRequest::RemoveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RemoveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveRequestDefaultTypeInternal() {}
  union {
    RemoveRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveRequestDefaultTypeInternal _RemoveRequest_default_instance_;
PROTOBUF_CONSTEXPR FileReply::FileReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.drive_list_)*/nullptr
  , /*decltype(_impl_.file_list_)*/nullptr
  , /*decltype(_impl_.packet_)*/nullptr
  , /*decltype(_impl_.error_code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileReplyDefaultTypeInternal() {}
  union {
    FileReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileReplyDefaultTypeInternal _FileReply_default_instance_;
PROTOBUF_CONSTEXPR FileRequest::FileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.drive_list_request_)*/nullptr
  , /*decltype(_impl_.file_list_request_)*/nullptr
  , /*decltype(_impl_.create_directory_request_)*/nullptr
  , /*decltype(_impl_.rename_request_)*/nullptr
  , /*decltype(_impl_.remove_request_)*/nullptr
  , /*decltype(_impl_.download_request_)*/nullptr
  , /*decltype(_impl_.upload_request_)*/nullptr
  , /*decltype(_impl_.packet_request_)*/nullptr
  , /*decltype(_impl_.packet_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileRequestDefaultTypeInternal() {}
  union {
    FileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileRequestDefaultTypeInternal _FileRequest_default_instance_;
}  // namespace proto
namespace proto {
bool DriveList_Item_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DriveList_Item_Type_strings[9] = {};

static const char DriveList_Item_Type_names[] =
  "TYPE_CDROM"
  "TYPE_DESKTOP_FOLDER"
  "TYPE_FIXED"
  "TYPE_HOME_FOLDER"
  "TYPE_RAM"
  "TYPE_REMOTE"
  "TYPE_REMOVABLE"
  "TYPE_ROOT_DIRECTORY"
  "TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DriveList_Item_Type_entries[] = {
  { {DriveList_Item_Type_names + 0, 10}, 1 },
  { {DriveList_Item_Type_names + 10, 19}, 7 },
  { {DriveList_Item_Type_names + 29, 10}, 3 },
  { {DriveList_Item_Type_names + 39, 16}, 6 },
  { {DriveList_Item_Type_names + 55, 8}, 5 },
  { {DriveList_Item_Type_names + 63, 11}, 4 },
  { {DriveList_Item_Type_names + 74, 14}, 2 },
  { {DriveList_Item_Type_names + 88, 19}, 8 },
  { {DriveList_Item_Type_names + 107, 12}, 0 },
};

static const int DriveList_Item_Type_entries_by_number[] = {
  8, // 0 -> TYPE_UNKNOWN
  0, // 1 -> TYPE_CDROM
  6, // 2 -> TYPE_REMOVABLE
  2, // 3 -> TYPE_FIXED
  5, // 4 -> TYPE_REMOTE
  4, // 5 -> TYPE_RAM
  3, // 6 -> TYPE_HOME_FOLDER
  1, // 7 -> TYPE_DESKTOP_FOLDER
  7, // 8 -> TYPE_ROOT_DIRECTORY
};

const std::string& DriveList_Item_Type_Name(
    DriveList_Item_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DriveList_Item_Type_entries,
          DriveList_Item_Type_entries_by_number,
          9, DriveList_Item_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DriveList_Item_Type_entries,
      DriveList_Item_Type_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DriveList_Item_Type_strings[idx].get();
}
bool DriveList_Item_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriveList_Item_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DriveList_Item_Type_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<DriveList_Item_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DriveList_Item_Type DriveList_Item::TYPE_UNKNOWN;
constexpr DriveList_Item_Type DriveList_Item::TYPE_CDROM;
constexpr DriveList_Item_Type DriveList_Item::TYPE_REMOVABLE;
constexpr DriveList_Item_Type DriveList_Item::TYPE_FIXED;
constexpr DriveList_Item_Type DriveList_Item::TYPE_REMOTE;
constexpr DriveList_Item_Type DriveList_Item::TYPE_RAM;
constexpr DriveList_Item_Type DriveList_Item::TYPE_HOME_FOLDER;
constexpr DriveList_Item_Type DriveList_Item::TYPE_DESKTOP_FOLDER;
constexpr DriveList_Item_Type DriveList_Item::TYPE_ROOT_DIRECTORY;
constexpr DriveList_Item_Type DriveList_Item::Type_MIN;
constexpr DriveList_Item_Type DriveList_Item::Type_MAX;
constexpr int DriveList_Item::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FilePacketRequest_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FilePacketRequest_Flags_strings[2] = {};

static const char FilePacketRequest_Flags_names[] =
  "CANCEL"
  "NO_FLAGS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FilePacketRequest_Flags_entries[] = {
  { {FilePacketRequest_Flags_names + 0, 6}, 1 },
  { {FilePacketRequest_Flags_names + 6, 8}, 0 },
};

static const int FilePacketRequest_Flags_entries_by_number[] = {
  1, // 0 -> NO_FLAGS
  0, // 1 -> CANCEL
};

const std::string& FilePacketRequest_Flags_Name(
    FilePacketRequest_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FilePacketRequest_Flags_entries,
          FilePacketRequest_Flags_entries_by_number,
          2, FilePacketRequest_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FilePacketRequest_Flags_entries,
      FilePacketRequest_Flags_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FilePacketRequest_Flags_strings[idx].get();
}
bool FilePacketRequest_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilePacketRequest_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FilePacketRequest_Flags_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<FilePacketRequest_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FilePacketRequest_Flags FilePacketRequest::NO_FLAGS;
constexpr FilePacketRequest_Flags FilePacketRequest::CANCEL;
constexpr FilePacketRequest_Flags FilePacketRequest::Flags_MIN;
constexpr FilePacketRequest_Flags FilePacketRequest::Flags_MAX;
constexpr int FilePacketRequest::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FilePacket_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FilePacket_Flags_strings[3] = {};

static const char FilePacket_Flags_names[] =
  "FIRST_PACKET"
  "LAST_PACKET"
  "NO_FLAGS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FilePacket_Flags_entries[] = {
  { {FilePacket_Flags_names + 0, 12}, 1 },
  { {FilePacket_Flags_names + 12, 11}, 2 },
  { {FilePacket_Flags_names + 23, 8}, 0 },
};

static const int FilePacket_Flags_entries_by_number[] = {
  2, // 0 -> NO_FLAGS
  0, // 1 -> FIRST_PACKET
  1, // 2 -> LAST_PACKET
};

const std::string& FilePacket_Flags_Name(
    FilePacket_Flags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FilePacket_Flags_entries,
          FilePacket_Flags_entries_by_number,
          3, FilePacket_Flags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FilePacket_Flags_entries,
      FilePacket_Flags_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FilePacket_Flags_strings[idx].get();
}
bool FilePacket_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilePacket_Flags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FilePacket_Flags_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FilePacket_Flags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FilePacket_Flags FilePacket::NO_FLAGS;
constexpr FilePacket_Flags FilePacket::FIRST_PACKET;
constexpr FilePacket_Flags FilePacket::LAST_PACKET;
constexpr FilePacket_Flags FilePacket::Flags_MIN;
constexpr FilePacket_Flags FilePacket::Flags_MAX;
constexpr int FilePacket::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FileError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileError_strings[15] = {};

static const char FileError_names[] =
  "FILE_ERROR_ACCESS_DENIED"
  "FILE_ERROR_DISK_FULL"
  "FILE_ERROR_DISK_NOT_READY"
  "FILE_ERROR_FILE_CREATE_ERROR"
  "FILE_ERROR_FILE_OPEN_ERROR"
  "FILE_ERROR_FILE_READ_ERROR"
  "FILE_ERROR_FILE_WRITE_ERROR"
  "FILE_ERROR_INVALID_PATH_NAME"
  "FILE_ERROR_INVALID_REQUEST"
  "FILE_ERROR_NO_DRIVES_FOUND"
  "FILE_ERROR_NO_LOGGED_ON_USER"
  "FILE_ERROR_PATH_ALREADY_EXISTS"
  "FILE_ERROR_PATH_NOT_FOUND"
  "FILE_ERROR_SUCCESS"
  "FILE_ERROR_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileError_entries[] = {
  { {FileError_names + 0, 24}, 9 },
  { {FileError_names + 24, 20}, 8 },
  { {FileError_names + 44, 25}, 14 },
  { {FileError_names + 69, 28}, 11 },
  { {FileError_names + 97, 26}, 10 },
  { {FileError_names + 123, 26}, 13 },
  { {FileError_names + 149, 27}, 12 },
  { {FileError_names + 176, 28}, 4 },
  { {FileError_names + 204, 26}, 3 },
  { {FileError_names + 230, 26}, 7 },
  { {FileError_names + 256, 28}, 2 },
  { {FileError_names + 284, 30}, 6 },
  { {FileError_names + 314, 25}, 5 },
  { {FileError_names + 339, 18}, 1 },
  { {FileError_names + 357, 18}, 0 },
};

static const int FileError_entries_by_number[] = {
  14, // 0 -> FILE_ERROR_UNKNOWN
  13, // 1 -> FILE_ERROR_SUCCESS
  10, // 2 -> FILE_ERROR_NO_LOGGED_ON_USER
  8, // 3 -> FILE_ERROR_INVALID_REQUEST
  7, // 4 -> FILE_ERROR_INVALID_PATH_NAME
  12, // 5 -> FILE_ERROR_PATH_NOT_FOUND
  11, // 6 -> FILE_ERROR_PATH_ALREADY_EXISTS
  9, // 7 -> FILE_ERROR_NO_DRIVES_FOUND
  1, // 8 -> FILE_ERROR_DISK_FULL
  0, // 9 -> FILE_ERROR_ACCESS_DENIED
  4, // 10 -> FILE_ERROR_FILE_OPEN_ERROR
  3, // 11 -> FILE_ERROR_FILE_CREATE_ERROR
  6, // 12 -> FILE_ERROR_FILE_WRITE_ERROR
  5, // 13 -> FILE_ERROR_FILE_READ_ERROR
  2, // 14 -> FILE_ERROR_DISK_NOT_READY
};

const std::string& FileError_Name(
    FileError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileError_entries,
          FileError_entries_by_number,
          15, FileError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileError_entries,
      FileError_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileError_strings[idx].get();
}
bool FileError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileError_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<FileError>(int_value);
  }
  return success;
}

// ===================================================================

class DriveList_Item::_Internal {
 public:
};

DriveList_Item::DriveList_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DriveList.Item)
}
DriveList_Item::DriveList_Item(const DriveList_Item& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DriveList_Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.total_space_){}
    , decltype(_impl_.free_space_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.total_space_, &from._impl_.total_space_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.total_space_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:proto.DriveList.Item)
}

inline void DriveList_Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.total_space_){int64_t{0}}
    , decltype(_impl_.free_space_){int64_t{0}}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DriveList_Item::~DriveList_Item() {
  // @@protoc_insertion_point(destructor:proto.DriveList.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DriveList_Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.name_.Destroy();
}

void DriveList_Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DriveList_Item::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DriveList.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.total_space_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.total_space_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<std::string>();
}

const char* DriveList_Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.DriveList.Item.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::proto::DriveList_Item_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // string path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int64 total_space = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.total_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 free_space = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.free_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DriveList_Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DriveList.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.DriveList.Item.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string path = 2;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.DriveList.Item.path");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_path(), target);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.DriveList.Item.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // int64 total_space = 4;
  if (this->_internal_total_space() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_total_space(), target);
  }

  // int64 free_space = 5;
  if (this->_internal_free_space() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_free_space(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DriveList.Item)
  return target;
}

size_t DriveList_Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DriveList.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 2;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int64 total_space = 4;
  if (this->_internal_total_space() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_space());
  }

  // int64 free_space = 5;
  if (this->_internal_free_space() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_free_space());
  }

  // .proto.DriveList.Item.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriveList_Item::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DriveList_Item*>(
      &from));
}

void DriveList_Item::MergeFrom(const DriveList_Item& from) {
  DriveList_Item* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DriveList.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_total_space() != 0) {
    _this->_internal_set_total_space(from._internal_total_space());
  }
  if (from._internal_free_space() != 0) {
    _this->_internal_set_free_space(from._internal_free_space());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DriveList_Item::CopyFrom(const DriveList_Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DriveList.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriveList_Item::IsInitialized() const {
  return true;
}

void DriveList_Item::InternalSwap(DriveList_Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DriveList_Item, _impl_.type_)
      + sizeof(DriveList_Item::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(DriveList_Item, _impl_.total_space_)>(
          reinterpret_cast<char*>(&_impl_.total_space_),
          reinterpret_cast<char*>(&other->_impl_.total_space_));
}

std::string DriveList_Item::GetTypeName() const {
  return "proto.DriveList.Item";
}


// ===================================================================

class DriveList::_Internal {
 public:
};

DriveList::DriveList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DriveList)
}
DriveList::DriveList(const DriveList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DriveList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){from._impl_.item_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.DriveList)
}

inline void DriveList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DriveList::~DriveList() {
  // @@protoc_insertion_point(destructor:proto.DriveList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DriveList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_.~RepeatedPtrField();
}

void DriveList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DriveList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DriveList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DriveList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.DriveList.Item item = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_item(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DriveList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DriveList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.DriveList.Item item = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_item_size()); i < n; i++) {
    const auto& repfield = this->_internal_item(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DriveList)
  return target;
}

size_t DriveList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DriveList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.DriveList.Item item = 1;
  total_size += 1UL * this->_internal_item_size();
  for (const auto& msg : this->_impl_.item_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriveList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DriveList*>(
      &from));
}

void DriveList::MergeFrom(const DriveList& from) {
  DriveList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DriveList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_.MergeFrom(from._impl_.item_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DriveList::CopyFrom(const DriveList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DriveList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriveList::IsInitialized() const {
  return true;
}

void DriveList::InternalSwap(DriveList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.item_.InternalSwap(&other->_impl_.item_);
}

std::string DriveList::GetTypeName() const {
  return "proto.DriveList";
}


// ===================================================================

class DriveListRequest::_Internal {
 public:
};

DriveListRequest::DriveListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DriveListRequest)
}
DriveListRequest::DriveListRequest(const DriveListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DriveListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dummy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.dummy_ = from._impl_.dummy_;
  // @@protoc_insertion_point(copy_constructor:proto.DriveListRequest)
}

inline void DriveListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dummy_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DriveListRequest::~DriveListRequest() {
  // @@protoc_insertion_point(destructor:proto.DriveListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DriveListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DriveListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DriveListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DriveListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dummy_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* DriveListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 dummy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.dummy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DriveListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DriveListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 dummy = 1;
  if (this->_internal_dummy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dummy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DriveListRequest)
  return target;
}

size_t DriveListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DriveListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 dummy = 1;
  if (this->_internal_dummy() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dummy());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriveListRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DriveListRequest*>(
      &from));
}

void DriveListRequest::MergeFrom(const DriveListRequest& from) {
  DriveListRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DriveListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dummy() != 0) {
    _this->_internal_set_dummy(from._internal_dummy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DriveListRequest::CopyFrom(const DriveListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DriveListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriveListRequest::IsInitialized() const {
  return true;
}

void DriveListRequest::InternalSwap(DriveListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.dummy_, other->_impl_.dummy_);
}

std::string DriveListRequest::GetTypeName() const {
  return "proto.DriveListRequest";
}


// ===================================================================

class FileList_Item::_Internal {
 public:
};

FileList_Item::FileList_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FileList.Item)
}
FileList_Item::FileList_Item(const FileList_Item& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileList_Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.modification_time_){}
    , decltype(_impl_.is_directory_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_directory_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.is_directory_));
  // @@protoc_insertion_point(copy_constructor:proto.FileList.Item)
}

inline void FileList_Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.modification_time_){int64_t{0}}
    , decltype(_impl_.is_directory_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileList_Item::~FileList_Item() {
  // @@protoc_insertion_point(destructor:proto.FileList.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileList_Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void FileList_Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileList_Item::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FileList.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_directory_) -
      reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.is_directory_));
  _internal_metadata_.Clear<std::string>();
}

const char* FileList_Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 modification_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.modification_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_directory = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.is_directory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileList_Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FileList.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.FileList.Item.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // uint64 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_size(), target);
  }

  // int64 modification_time = 3;
  if (this->_internal_modification_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_modification_time(), target);
  }

  // bool is_directory = 4;
  if (this->_internal_is_directory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_directory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FileList.Item)
  return target;
}

size_t FileList_Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FileList.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint64 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  // int64 modification_time = 3;
  if (this->_internal_modification_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_modification_time());
  }

  // bool is_directory = 4;
  if (this->_internal_is_directory() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileList_Item::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileList_Item*>(
      &from));
}

void FileList_Item::MergeFrom(const FileList_Item& from) {
  FileList_Item* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FileList.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  if (from._internal_modification_time() != 0) {
    _this->_internal_set_modification_time(from._internal_modification_time());
  }
  if (from._internal_is_directory() != 0) {
    _this->_internal_set_is_directory(from._internal_is_directory());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileList_Item::CopyFrom(const FileList_Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FileList.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileList_Item::IsInitialized() const {
  return true;
}

void FileList_Item::InternalSwap(FileList_Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileList_Item, _impl_.is_directory_)
      + sizeof(FileList_Item::_impl_.is_directory_)
      - PROTOBUF_FIELD_OFFSET(FileList_Item, _impl_.size_)>(
          reinterpret_cast<char*>(&_impl_.size_),
          reinterpret_cast<char*>(&other->_impl_.size_));
}

std::string FileList_Item::GetTypeName() const {
  return "proto.FileList.Item";
}


// ===================================================================

class FileList::_Internal {
 public:
};

FileList::FileList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FileList)
}
FileList::FileList(const FileList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){from._impl_.item_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.FileList)
}

inline void FileList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FileList::~FileList() {
  // @@protoc_insertion_point(destructor:proto.FileList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_.~RepeatedPtrField();
}

void FileList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FileList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FileList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.FileList.Item item = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_item(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FileList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.FileList.Item item = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_item_size()); i < n; i++) {
    const auto& repfield = this->_internal_item(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FileList)
  return target;
}

size_t FileList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FileList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.FileList.Item item = 1;
  total_size += 1UL * this->_internal_item_size();
  for (const auto& msg : this->_impl_.item_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileList*>(
      &from));
}

void FileList::MergeFrom(const FileList& from) {
  FileList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FileList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_.MergeFrom(from._impl_.item_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileList::CopyFrom(const FileList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FileList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileList::IsInitialized() const {
  return true;
}

void FileList::InternalSwap(FileList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.item_.InternalSwap(&other->_impl_.item_);
}

std::string FileList::GetTypeName() const {
  return "proto.FileList";
}


// ===================================================================

class FileListRequest::_Internal {
 public:
};

FileListRequest::FileListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FileListRequest)
}
FileListRequest::FileListRequest(const FileListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.FileListRequest)
}

inline void FileListRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileListRequest::~FileListRequest() {
  // @@protoc_insertion_point(destructor:proto.FileListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void FileListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FileListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* FileListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FileListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.FileListRequest.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FileListRequest)
  return target;
}

size_t FileListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FileListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileListRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileListRequest*>(
      &from));
}

void FileListRequest::MergeFrom(const FileListRequest& from) {
  FileListRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FileListRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileListRequest::CopyFrom(const FileListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FileListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileListRequest::IsInitialized() const {
  return true;
}

void FileListRequest::InternalSwap(FileListRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

std::string FileListRequest::GetTypeName() const {
  return "proto.FileListRequest";
}


// ===================================================================

class UploadRequest::_Internal {
 public:
};

UploadRequest::UploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.UploadRequest)
}
UploadRequest::UploadRequest(const UploadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UploadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.overwrite_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.overwrite_ = from._impl_.overwrite_;
  // @@protoc_insertion_point(copy_constructor:proto.UploadRequest)
}

inline void UploadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.overwrite_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UploadRequest::~UploadRequest() {
  // @@protoc_insertion_point(destructor:proto.UploadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void UploadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UploadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.UploadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _impl_.overwrite_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* UploadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool overwrite = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.overwrite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.UploadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.UploadRequest.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // bool overwrite = 2;
  if (this->_internal_overwrite() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_overwrite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.UploadRequest)
  return target;
}

size_t UploadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.UploadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // bool overwrite = 2;
  if (this->_internal_overwrite() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadRequest*>(
      &from));
}

void UploadRequest::MergeFrom(const UploadRequest& from) {
  UploadRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.UploadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (from._internal_overwrite() != 0) {
    _this->_internal_set_overwrite(from._internal_overwrite());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadRequest::CopyFrom(const UploadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.UploadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadRequest::IsInitialized() const {
  return true;
}

void UploadRequest::InternalSwap(UploadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  swap(_impl_.overwrite_, other->_impl_.overwrite_);
}

std::string UploadRequest::GetTypeName() const {
  return "proto.UploadRequest";
}


// ===================================================================

class DownloadRequest::_Internal {
 public:
};

DownloadRequest::DownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.DownloadRequest)
}
DownloadRequest::DownloadRequest(const DownloadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DownloadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.DownloadRequest)
}

inline void DownloadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DownloadRequest::~DownloadRequest() {
  // @@protoc_insertion_point(destructor:proto.DownloadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void DownloadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownloadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.DownloadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.DownloadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.DownloadRequest.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.DownloadRequest)
  return target;
}

size_t DownloadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.DownloadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadRequest*>(
      &from));
}

void DownloadRequest::MergeFrom(const DownloadRequest& from) {
  DownloadRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.DownloadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadRequest::CopyFrom(const DownloadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.DownloadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadRequest::IsInitialized() const {
  return true;
}

void DownloadRequest::InternalSwap(DownloadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

std::string DownloadRequest::GetTypeName() const {
  return "proto.DownloadRequest";
}


// ===================================================================

class FilePacketRequest::_Internal {
 public:
};

FilePacketRequest::FilePacketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FilePacketRequest)
}
FilePacketRequest::FilePacketRequest(const FilePacketRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FilePacketRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.flags_ = from._impl_.flags_;
  // @@protoc_insertion_point(copy_constructor:proto.FilePacketRequest)
}

inline void FilePacketRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flags_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FilePacketRequest::~FilePacketRequest() {
  // @@protoc_insertion_point(destructor:proto.FilePacketRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FilePacketRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FilePacketRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FilePacketRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FilePacketRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flags_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* FilePacketRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FilePacketRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FilePacketRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FilePacketRequest)
  return target;
}

size_t FilePacketRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FilePacketRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FilePacketRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FilePacketRequest*>(
      &from));
}

void FilePacketRequest::MergeFrom(const FilePacketRequest& from) {
  FilePacketRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FilePacketRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FilePacketRequest::CopyFrom(const FilePacketRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FilePacketRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilePacketRequest::IsInitialized() const {
  return true;
}

void FilePacketRequest::InternalSwap(FilePacketRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flags_, other->_impl_.flags_);
}

std::string FilePacketRequest::GetTypeName() const {
  return "proto.FilePacketRequest";
}


// ===================================================================

class FilePacket::_Internal {
 public:
};

FilePacket::FilePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FilePacket)
}
FilePacket::FilePacket(const FilePacket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FilePacket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.file_size_){}
    , decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.file_size_, &from._impl_.file_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.file_size_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:proto.FilePacket)
}

inline void FilePacket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.file_size_){uint64_t{0u}}
    , decltype(_impl_.flags_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FilePacket::~FilePacket() {
  // @@protoc_insertion_point(destructor:proto.FilePacket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FilePacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void FilePacket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FilePacket::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FilePacket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.file_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.flags_) -
      reinterpret_cast<char*>(&_impl_.file_size_)) + sizeof(_impl_.flags_));
  _internal_metadata_.Clear<std::string>();
}

const char* FilePacket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 file_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FilePacket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FilePacket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  // uint64 file_size = 2;
  if (this->_internal_file_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_file_size(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FilePacket)
  return target;
}

size_t FilePacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FilePacket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint64 file_size = 2;
  if (this->_internal_file_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_file_size());
  }

  // uint32 flags = 1;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FilePacket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FilePacket*>(
      &from));
}

void FilePacket::MergeFrom(const FilePacket& from) {
  FilePacket* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FilePacket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_file_size() != 0) {
    _this->_internal_set_file_size(from._internal_file_size());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FilePacket::CopyFrom(const FilePacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FilePacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilePacket::IsInitialized() const {
  return true;
}

void FilePacket::InternalSwap(FilePacket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FilePacket, _impl_.flags_)
      + sizeof(FilePacket::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(FilePacket, _impl_.file_size_)>(
          reinterpret_cast<char*>(&_impl_.file_size_),
          reinterpret_cast<char*>(&other->_impl_.file_size_));
}

std::string FilePacket::GetTypeName() const {
  return "proto.FilePacket";
}


// ===================================================================

class CreateDirectoryRequest::_Internal {
 public:
};

CreateDirectoryRequest::CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.CreateDirectoryRequest)
}
CreateDirectoryRequest::CreateDirectoryRequest(const CreateDirectoryRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CreateDirectoryRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.CreateDirectoryRequest)
}

inline void CreateDirectoryRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateDirectoryRequest::~CreateDirectoryRequest() {
  // @@protoc_insertion_point(destructor:proto.CreateDirectoryRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateDirectoryRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void CreateDirectoryRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateDirectoryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.CreateDirectoryRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* CreateDirectoryRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateDirectoryRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.CreateDirectoryRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.CreateDirectoryRequest.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.CreateDirectoryRequest)
  return target;
}

size_t CreateDirectoryRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.CreateDirectoryRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateDirectoryRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CreateDirectoryRequest*>(
      &from));
}

void CreateDirectoryRequest::MergeFrom(const CreateDirectoryRequest& from) {
  CreateDirectoryRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.CreateDirectoryRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreateDirectoryRequest::CopyFrom(const CreateDirectoryRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.CreateDirectoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateDirectoryRequest::IsInitialized() const {
  return true;
}

void CreateDirectoryRequest::InternalSwap(CreateDirectoryRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

std::string CreateDirectoryRequest::GetTypeName() const {
  return "proto.CreateDirectoryRequest";
}


// ===================================================================

class RenameRequest::_Internal {
 public:
};

RenameRequest::RenameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.RenameRequest)
}
RenameRequest::RenameRequest(const RenameRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RenameRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.old_name_){}
    , decltype(_impl_.new_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.old_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_old_name().empty()) {
    _this->_impl_.old_name_.Set(from._internal_old_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_new_name().empty()) {
    _this->_impl_.new_name_.Set(from._internal_new_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.RenameRequest)
}

inline void RenameRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.old_name_){}
    , decltype(_impl_.new_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.old_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RenameRequest::~RenameRequest() {
  // @@protoc_insertion_point(destructor:proto.RenameRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RenameRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.old_name_.Destroy();
  _impl_.new_name_.Destroy();
}

void RenameRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RenameRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.RenameRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.old_name_.ClearToEmpty();
  _impl_.new_name_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* RenameRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string old_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_old_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string new_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RenameRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.RenameRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string old_name = 1;
  if (!this->_internal_old_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_old_name().data(), static_cast<int>(this->_internal_old_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.RenameRequest.old_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_old_name(), target);
  }

  // string new_name = 2;
  if (!this->_internal_new_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_new_name().data(), static_cast<int>(this->_internal_new_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.RenameRequest.new_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.RenameRequest)
  return target;
}

size_t RenameRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.RenameRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string old_name = 1;
  if (!this->_internal_old_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_name());
  }

  // string new_name = 2;
  if (!this->_internal_new_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_new_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RenameRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RenameRequest*>(
      &from));
}

void RenameRequest::MergeFrom(const RenameRequest& from) {
  RenameRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.RenameRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_old_name().empty()) {
    _this->_internal_set_old_name(from._internal_old_name());
  }
  if (!from._internal_new_name().empty()) {
    _this->_internal_set_new_name(from._internal_new_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RenameRequest::CopyFrom(const RenameRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.RenameRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RenameRequest::IsInitialized() const {
  return true;
}

void RenameRequest::InternalSwap(RenameRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_name_, lhs_arena,
      &other->_impl_.old_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_name_, lhs_arena,
      &other->_impl_.new_name_, rhs_arena
  );
}

std::string RenameRequest::GetTypeName() const {
  return "proto.RenameRequest";
}


// ===================================================================

class RemoveRequest::_Internal {
 public:
};

RemoveRequest::RemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.RemoveRequest)
}
RemoveRequest::RemoveRequest(const RemoveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RemoveRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.RemoveRequest)
}

inline void RemoveRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoveRequest::~RemoveRequest() {
  // @@protoc_insertion_point(destructor:proto.RemoveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void RemoveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.RemoveRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* RemoveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.RemoveRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.RemoveRequest.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.RemoveRequest)
  return target;
}

size_t RemoveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.RemoveRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoveRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RemoveRequest*>(
      &from));
}

void RemoveRequest::MergeFrom(const RemoveRequest& from) {
  RemoveRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.RemoveRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemoveRequest::CopyFrom(const RemoveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.RemoveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveRequest::IsInitialized() const {
  return true;
}

void RemoveRequest::InternalSwap(RemoveRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

std::string RemoveRequest::GetTypeName() const {
  return "proto.RemoveRequest";
}


// ===================================================================

class FileReply::_Internal {
 public:
  static const ::proto::DriveList& drive_list(const FileReply* msg);
  static const ::proto::FileList& file_list(const FileReply* msg);
  static const ::proto::FilePacket& packet(const FileReply* msg);
};

const ::proto::DriveList&
FileReply::_Internal::drive_list(const FileReply* msg) {
  return *msg->_impl_.drive_list_;
}
const ::proto::FileList&
FileReply::_Internal::file_list(const FileReply* msg) {
  return *msg->_impl_.file_list_;
}
const ::proto::FilePacket&
FileReply::_Internal::packet(const FileReply* msg) {
  return *msg->_impl_.packet_;
}
FileReply::FileReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FileReply)
}
FileReply::FileReply(const FileReply& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.drive_list_){nullptr}
    , decltype(_impl_.file_list_){nullptr}
    , decltype(_impl_.packet_){nullptr}
    , decltype(_impl_.error_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_drive_list()) {
    _this->_impl_.drive_list_ = new ::proto::DriveList(*from._impl_.drive_list_);
  }
  if (from._internal_has_file_list()) {
    _this->_impl_.file_list_ = new ::proto::FileList(*from._impl_.file_list_);
  }
  if (from._internal_has_packet()) {
    _this->_impl_.packet_ = new ::proto::FilePacket(*from._impl_.packet_);
  }
  _this->_impl_.error_code_ = from._impl_.error_code_;
  // @@protoc_insertion_point(copy_constructor:proto.FileReply)
}

inline void FileReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.drive_list_){nullptr}
    , decltype(_impl_.file_list_){nullptr}
    , decltype(_impl_.packet_){nullptr}
    , decltype(_impl_.error_code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FileReply::~FileReply() {
  // @@protoc_insertion_point(destructor:proto.FileReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drive_list_;
  if (this != internal_default_instance()) delete _impl_.file_list_;
  if (this != internal_default_instance()) delete _impl_.packet_;
}

void FileReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileReply::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FileReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.drive_list_ != nullptr) {
    delete _impl_.drive_list_;
  }
  _impl_.drive_list_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.file_list_ != nullptr) {
    delete _impl_.file_list_;
  }
  _impl_.file_list_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.packet_ != nullptr) {
    delete _impl_.packet_;
  }
  _impl_.packet_ = nullptr;
  _impl_.error_code_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* FileReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.FileError error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_code(static_cast<::proto::FileError>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.DriveList drive_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_drive_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FileList file_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_file_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FilePacket packet = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FileReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.FileError error_code = 1;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error_code(), target);
  }

  // .proto.DriveList drive_list = 2;
  if (this->_internal_has_drive_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::drive_list(this),
        _Internal::drive_list(this).GetCachedSize(), target, stream);
  }

  // .proto.FileList file_list = 3;
  if (this->_internal_has_file_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::file_list(this),
        _Internal::file_list(this).GetCachedSize(), target, stream);
  }

  // .proto.FilePacket packet = 4;
  if (this->_internal_has_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::packet(this),
        _Internal::packet(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FileReply)
  return target;
}

size_t FileReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FileReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.DriveList drive_list = 2;
  if (this->_internal_has_drive_list()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.drive_list_);
  }

  // .proto.FileList file_list = 3;
  if (this->_internal_has_file_list()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.file_list_);
  }

  // .proto.FilePacket packet = 4;
  if (this->_internal_has_packet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.packet_);
  }

  // .proto.FileError error_code = 1;
  if (this->_internal_error_code() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileReply::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileReply*>(
      &from));
}

void FileReply::MergeFrom(const FileReply& from) {
  FileReply* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FileReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_drive_list()) {
    _this->_internal_mutable_drive_list()->::proto::DriveList::MergeFrom(
        from._internal_drive_list());
  }
  if (from._internal_has_file_list()) {
    _this->_internal_mutable_file_list()->::proto::FileList::MergeFrom(
        from._internal_file_list());
  }
  if (from._internal_has_packet()) {
    _this->_internal_mutable_packet()->::proto::FilePacket::MergeFrom(
        from._internal_packet());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileReply::CopyFrom(const FileReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FileReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileReply::IsInitialized() const {
  return true;
}

void FileReply::InternalSwap(FileReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileReply, _impl_.error_code_)
      + sizeof(FileReply::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(FileReply, _impl_.drive_list_)>(
          reinterpret_cast<char*>(&_impl_.drive_list_),
          reinterpret_cast<char*>(&other->_impl_.drive_list_));
}

std::string FileReply::GetTypeName() const {
  return "proto.FileReply";
}


// ===================================================================

class FileRequest::_Internal {
 public:
  static const ::proto::DriveListRequest& drive_list_request(const FileRequest* msg);
  static const ::proto::FileListRequest& file_list_request(const FileRequest* msg);
  static const ::proto::CreateDirectoryRequest& create_directory_request(const FileRequest* msg);
  static const ::proto::RenameRequest& rename_request(const FileRequest* msg);
  static const ::proto::RemoveRequest& remove_request(const FileRequest* msg);
  static const ::proto::DownloadRequest& download_request(const FileRequest* msg);
  static const ::proto::UploadRequest& upload_request(const FileRequest* msg);
  static const ::proto::FilePacketRequest& packet_request(const FileRequest* msg);
  static const ::proto::FilePacket& packet(const FileRequest* msg);
};

const ::proto::DriveListRequest&
FileRequest::_Internal::drive_list_request(const FileRequest* msg) {
  return *msg->_impl_.drive_list_request_;
}
const ::proto::FileListRequest&
FileRequest::_Internal::file_list_request(const FileRequest* msg) {
  return *msg->_impl_.file_list_request_;
}
const ::proto::CreateDirectoryRequest&
FileRequest::_Internal::create_directory_request(const FileRequest* msg) {
  return *msg->_impl_.create_directory_request_;
}
const ::proto::RenameRequest&
FileRequest::_Internal::rename_request(const FileRequest* msg) {
  return *msg->_impl_.rename_request_;
}
const ::proto::RemoveRequest&
FileRequest::_Internal::remove_request(const FileRequest* msg) {
  return *msg->_impl_.remove_request_;
}
const ::proto::DownloadRequest&
FileRequest::_Internal::download_request(const FileRequest* msg) {
  return *msg->_impl_.download_request_;
}
const ::proto::UploadRequest&
FileRequest::_Internal::upload_request(const FileRequest* msg) {
  return *msg->_impl_.upload_request_;
}
const ::proto::FilePacketRequest&
FileRequest::_Internal::packet_request(const FileRequest* msg) {
  return *msg->_impl_.packet_request_;
}
const ::proto::FilePacket&
FileRequest::_Internal::packet(const FileRequest* msg) {
  return *msg->_impl_.packet_;
}
FileRequest::FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FileRequest)
}
FileRequest::FileRequest(const FileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.drive_list_request_){nullptr}
    , decltype(_impl_.file_list_request_){nullptr}
    , decltype(_impl_.create_directory_request_){nullptr}
    , decltype(_impl_.rename_request_){nullptr}
    , decltype(_impl_.remove_request_){nullptr}
    , decltype(_impl_.download_request_){nullptr}
    , decltype(_impl_.upload_request_){nullptr}
    , decltype(_impl_.packet_request_){nullptr}
    , decltype(_impl_.packet_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_drive_list_request()) {
    _this->_impl_.drive_list_request_ = new ::proto::DriveListRequest(*from._impl_.drive_list_request_);
  }
  if (from._internal_has_file_list_request()) {
    _this->_impl_.file_list_request_ = new ::proto::FileListRequest(*from._impl_.file_list_request_);
  }
  if (from._internal_has_create_directory_request()) {
    _this->_impl_.create_directory_request_ = new ::proto::CreateDirectoryRequest(*from._impl_.create_directory_request_);
  }
  if (from._internal_has_rename_request()) {
    _this->_impl_.rename_request_ = new ::proto::RenameRequest(*from._impl_.rename_request_);
  }
  if (from._internal_has_remove_request()) {
    _this->_impl_.remove_request_ = new ::proto::RemoveRequest(*from._impl_.remove_request_);
  }
  if (from._internal_has_download_request()) {
    _this->_impl_.download_request_ = new ::proto::DownloadRequest(*from._impl_.download_request_);
  }
  if (from._internal_has_upload_request()) {
    _this->_impl_.upload_request_ = new ::proto::UploadRequest(*from._impl_.upload_request_);
  }
  if (from._internal_has_packet_request()) {
    _this->_impl_.packet_request_ = new ::proto::FilePacketRequest(*from._impl_.packet_request_);
  }
  if (from._internal_has_packet()) {
    _this->_impl_.packet_ = new ::proto::FilePacket(*from._impl_.packet_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.FileRequest)
}

inline void FileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.drive_list_request_){nullptr}
    , decltype(_impl_.file_list_request_){nullptr}
    , decltype(_impl_.create_directory_request_){nullptr}
    , decltype(_impl_.rename_request_){nullptr}
    , decltype(_impl_.remove_request_){nullptr}
    , decltype(_impl_.download_request_){nullptr}
    , decltype(_impl_.upload_request_){nullptr}
    , decltype(_impl_.packet_request_){nullptr}
    , decltype(_impl_.packet_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FileRequest::~FileRequest() {
  // @@protoc_insertion_point(destructor:proto.FileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drive_list_request_;
  if (this != internal_default_instance()) delete _impl_.file_list_request_;
  if (this != internal_default_instance()) delete _impl_.create_directory_request_;
  if (this != internal_default_instance()) delete _impl_.rename_request_;
  if (this != internal_default_instance()) delete _impl_.remove_request_;
  if (this != internal_default_instance()) delete _impl_.download_request_;
  if (this != internal_default_instance()) delete _impl_.upload_request_;
  if (this != internal_default_instance()) delete _impl_.packet_request_;
  if (this != internal_default_instance()) delete _impl_.packet_;
}

void FileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.drive_list_request_ != nullptr) {
    delete _impl_.drive_list_request_;
  }
  _impl_.drive_list_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.file_list_request_ != nullptr) {
    delete _impl_.file_list_request_;
  }
  _impl_.file_list_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.create_directory_request_ != nullptr) {
    delete _impl_.create_directory_request_;
  }
  _impl_.create_directory_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rename_request_ != nullptr) {
    delete _impl_.rename_request_;
  }
  _impl_.rename_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.remove_request_ != nullptr) {
    delete _impl_.remove_request_;
  }
  _impl_.remove_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.download_request_ != nullptr) {
    delete _impl_.download_request_;
  }
  _impl_.download_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.upload_request_ != nullptr) {
    delete _impl_.upload_request_;
  }
  _impl_.upload_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.packet_request_ != nullptr) {
    delete _impl_.packet_request_;
  }
  _impl_.packet_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.packet_ != nullptr) {
    delete _impl_.packet_;
  }
  _impl_.packet_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* FileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.DriveListRequest drive_list_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_drive_list_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FileListRequest file_list_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_file_list_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.CreateDirectoryRequest create_directory_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_directory_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.RenameRequest rename_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rename_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.RemoveRequest remove_request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_remove_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.DownloadRequest download_request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_download_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.UploadRequest upload_request = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_upload_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FilePacketRequest packet_request = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_packet_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FilePacket packet = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.DriveListRequest drive_list_request = 1;
  if (this->_internal_has_drive_list_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::drive_list_request(this),
        _Internal::drive_list_request(this).GetCachedSize(), target, stream);
  }

  // .proto.FileListRequest file_list_request = 2;
  if (this->_internal_has_file_list_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::file_list_request(this),
        _Internal::file_list_request(this).GetCachedSize(), target, stream);
  }

  // .proto.CreateDirectoryRequest create_directory_request = 3;
  if (this->_internal_has_create_directory_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::create_directory_request(this),
        _Internal::create_directory_request(this).GetCachedSize(), target, stream);
  }

  // .proto.RenameRequest rename_request = 4;
  if (this->_internal_has_rename_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rename_request(this),
        _Internal::rename_request(this).GetCachedSize(), target, stream);
  }

  // .proto.RemoveRequest remove_request = 5;
  if (this->_internal_has_remove_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::remove_request(this),
        _Internal::remove_request(this).GetCachedSize(), target, stream);
  }

  // .proto.DownloadRequest download_request = 6;
  if (this->_internal_has_download_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::download_request(this),
        _Internal::download_request(this).GetCachedSize(), target, stream);
  }

  // .proto.UploadRequest upload_request = 7;
  if (this->_internal_has_upload_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::upload_request(this),
        _Internal::upload_request(this).GetCachedSize(), target, stream);
  }

  // .proto.FilePacketRequest packet_request = 8;
  if (this->_internal_has_packet_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::packet_request(this),
        _Internal::packet_request(this).GetCachedSize(), target, stream);
  }

  // .proto.FilePacket packet = 9;
  if (this->_internal_has_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::packet(this),
        _Internal::packet(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FileRequest)
  return target;
}

size_t FileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.DriveListRequest drive_list_request = 1;
  if (this->_internal_has_drive_list_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.drive_list_request_);
  }

  // .proto.FileListRequest file_list_request = 2;
  if (this->_internal_has_file_list_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.file_list_request_);
  }

  // .proto.CreateDirectoryRequest create_directory_request = 3;
  if (this->_internal_has_create_directory_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.create_directory_request_);
  }

  // .proto.RenameRequest rename_request = 4;
  if (this->_internal_has_rename_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rename_request_);
  }

  // .proto.RemoveRequest remove_request = 5;
  if (this->_internal_has_remove_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.remove_request_);
  }

  // .proto.DownloadRequest download_request = 6;
  if (this->_internal_has_download_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.download_request_);
  }

  // .proto.UploadRequest upload_request = 7;
  if (this->_internal_has_upload_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.upload_request_);
  }

  // .proto.FilePacketRequest packet_request = 8;
  if (this->_internal_has_packet_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.packet_request_);
  }

  // .proto.FilePacket packet = 9;
  if (this->_internal_has_packet()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.packet_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileRequest*>(
      &from));
}

void FileRequest::MergeFrom(const FileRequest& from) {
  FileRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_drive_list_request()) {
    _this->_internal_mutable_drive_list_request()->::proto::DriveListRequest::MergeFrom(
        from._internal_drive_list_request());
  }
  if (from._internal_has_file_list_request()) {
    _this->_internal_mutable_file_list_request()->::proto::FileListRequest::MergeFrom(
        from._internal_file_list_request());
  }
  if (from._internal_has_create_directory_request()) {
    _this->_internal_mutable_create_directory_request()->::proto::CreateDirectoryRequest::MergeFrom(
        from._internal_create_directory_request());
  }
  if (from._internal_has_rename_request()) {
    _this->_internal_mutable_rename_request()->::proto::RenameRequest::MergeFrom(
        from._internal_rename_request());
  }
  if (from._internal_has_remove_request()) {
    _this->_internal_mutable_remove_request()->::proto::RemoveRequest::MergeFrom(
        from._internal_remove_request());
  }
  if (from._internal_has_download_request()) {
    _this->_internal_mutable_download_request()->::proto::DownloadRequest::MergeFrom(
        from._internal_download_request());
  }
  if (from._internal_has_upload_request()) {
    _this->_internal_mutable_upload_request()->::proto::UploadRequest::MergeFrom(
        from._internal_upload_request());
  }
  if (from._internal_has_packet_request()) {
    _this->_internal_mutable_packet_request()->::proto::FilePacketRequest::MergeFrom(
        from._internal_packet_request());
  }
  if (from._internal_has_packet()) {
    _this->_internal_mutable_packet()->::proto::FilePacket::MergeFrom(
        from._internal_packet());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileRequest::CopyFrom(const FileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileRequest::IsInitialized() const {
  return true;
}

void FileRequest::InternalSwap(FileRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileRequest, _impl_.packet_)
      + sizeof(FileRequest::_impl_.packet_)
      - PROTOBUF_FIELD_OFFSET(FileRequest, _impl_.drive_list_request_)>(
          reinterpret_cast<char*>(&_impl_.drive_list_request_),
          reinterpret_cast<char*>(&other->_impl_.drive_list_request_));
}

std::string FileRequest::GetTypeName() const {
  return "proto.FileRequest";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::DriveList_Item*
Arena::CreateMaybeMessage< ::proto::DriveList_Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DriveList_Item >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DriveList*
Arena::CreateMaybeMessage< ::proto::DriveList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DriveList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DriveListRequest*
Arena::CreateMaybeMessage< ::proto::DriveListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DriveListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FileList_Item*
Arena::CreateMaybeMessage< ::proto::FileList_Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FileList_Item >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FileList*
Arena::CreateMaybeMessage< ::proto::FileList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FileList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FileListRequest*
Arena::CreateMaybeMessage< ::proto::FileListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FileListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::UploadRequest*
Arena::CreateMaybeMessage< ::proto::UploadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::UploadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::DownloadRequest*
Arena::CreateMaybeMessage< ::proto::DownloadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::DownloadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FilePacketRequest*
Arena::CreateMaybeMessage< ::proto::FilePacketRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FilePacketRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FilePacket*
Arena::CreateMaybeMessage< ::proto::FilePacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FilePacket >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::CreateDirectoryRequest*
Arena::CreateMaybeMessage< ::proto::CreateDirectoryRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::CreateDirectoryRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::RenameRequest*
Arena::CreateMaybeMessage< ::proto::RenameRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::RenameRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::RemoveRequest*
Arena::CreateMaybeMessage< ::proto::RemoveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::RemoveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FileReply*
Arena::CreateMaybeMessage< ::proto::FileReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FileReply >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FileRequest*
Arena::CreateMaybeMessage< ::proto::FileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FileRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
