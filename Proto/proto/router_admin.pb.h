// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_admin.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_5fadmin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_5fadmin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
#include "router_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_5fadmin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_5fadmin_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class AdminToRouter;
struct AdminToRouterDefaultTypeInternal;
extern AdminToRouterDefaultTypeInternal _AdminToRouter_default_instance_;
class HostSessionData;
struct HostSessionDataDefaultTypeInternal;
extern HostSessionDataDefaultTypeInternal _HostSessionData_default_instance_;
class RelaySessionData;
struct RelaySessionDataDefaultTypeInternal;
extern RelaySessionDataDefaultTypeInternal _RelaySessionData_default_instance_;
class RelaySessionData_RelayStat;
struct RelaySessionData_RelayStatDefaultTypeInternal;
extern RelaySessionData_RelayStatDefaultTypeInternal _RelaySessionData_RelayStat_default_instance_;
class RouterToAdmin;
struct RouterToAdminDefaultTypeInternal;
extern RouterToAdminDefaultTypeInternal _RouterToAdmin_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SessionList;
struct SessionListDefaultTypeInternal;
extern SessionListDefaultTypeInternal _SessionList_default_instance_;
class SessionListRequest;
struct SessionListRequestDefaultTypeInternal;
extern SessionListRequestDefaultTypeInternal _SessionListRequest_default_instance_;
class SessionRequest;
struct SessionRequestDefaultTypeInternal;
extern SessionRequestDefaultTypeInternal _SessionRequest_default_instance_;
class SessionResult;
struct SessionResultDefaultTypeInternal;
extern SessionResultDefaultTypeInternal _SessionResult_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserList;
struct UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserListRequest;
struct UserListRequestDefaultTypeInternal;
extern UserListRequestDefaultTypeInternal _UserListRequest_default_instance_;
class UserRequest;
struct UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserResult;
struct UserResultDefaultTypeInternal;
extern UserResultDefaultTypeInternal _UserResult_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::AdminToRouter* Arena::CreateMaybeMessage<::proto::AdminToRouter>(Arena*);
template<> ::proto::HostSessionData* Arena::CreateMaybeMessage<::proto::HostSessionData>(Arena*);
template<> ::proto::RelaySessionData* Arena::CreateMaybeMessage<::proto::RelaySessionData>(Arena*);
template<> ::proto::RelaySessionData_RelayStat* Arena::CreateMaybeMessage<::proto::RelaySessionData_RelayStat>(Arena*);
template<> ::proto::RouterToAdmin* Arena::CreateMaybeMessage<::proto::RouterToAdmin>(Arena*);
template<> ::proto::Session* Arena::CreateMaybeMessage<::proto::Session>(Arena*);
template<> ::proto::SessionList* Arena::CreateMaybeMessage<::proto::SessionList>(Arena*);
template<> ::proto::SessionListRequest* Arena::CreateMaybeMessage<::proto::SessionListRequest>(Arena*);
template<> ::proto::SessionRequest* Arena::CreateMaybeMessage<::proto::SessionRequest>(Arena*);
template<> ::proto::SessionResult* Arena::CreateMaybeMessage<::proto::SessionResult>(Arena*);
template<> ::proto::User* Arena::CreateMaybeMessage<::proto::User>(Arena*);
template<> ::proto::UserList* Arena::CreateMaybeMessage<::proto::UserList>(Arena*);
template<> ::proto::UserListRequest* Arena::CreateMaybeMessage<::proto::UserListRequest>(Arena*);
template<> ::proto::UserRequest* Arena::CreateMaybeMessage<::proto::UserRequest>(Arena*);
template<> ::proto::UserResult* Arena::CreateMaybeMessage<::proto::UserResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum SessionResult_ErrorCode : int {
  SessionResult_ErrorCode_SUCCESS = 0,
  SessionResult_ErrorCode_INVALID_REQUEST = 1,
  SessionResult_ErrorCode_INTERNAL_ERROR = 2,
  SessionResult_ErrorCode_INVALID_SESSION_ID = 3,
  SessionResult_ErrorCode_SessionResult_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionResult_ErrorCode_SessionResult_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionResult_ErrorCode_IsValid(int value);
constexpr SessionResult_ErrorCode SessionResult_ErrorCode_ErrorCode_MIN = SessionResult_ErrorCode_SUCCESS;
constexpr SessionResult_ErrorCode SessionResult_ErrorCode_ErrorCode_MAX = SessionResult_ErrorCode_INVALID_SESSION_ID;
constexpr int SessionResult_ErrorCode_ErrorCode_ARRAYSIZE = SessionResult_ErrorCode_ErrorCode_MAX + 1;

const std::string& SessionResult_ErrorCode_Name(SessionResult_ErrorCode value);
template<typename T>
inline const std::string& SessionResult_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionResult_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionResult_ErrorCode_Name.");
  return SessionResult_ErrorCode_Name(static_cast<SessionResult_ErrorCode>(enum_t_value));
}
bool SessionResult_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionResult_ErrorCode* value);
enum SessionList_ErrorCode : int {
  SessionList_ErrorCode_SUCCESS = 0,
  SessionList_ErrorCode_UNKNOWN_ERROR = 1,
  SessionList_ErrorCode_SessionList_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionList_ErrorCode_SessionList_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionList_ErrorCode_IsValid(int value);
constexpr SessionList_ErrorCode SessionList_ErrorCode_ErrorCode_MIN = SessionList_ErrorCode_SUCCESS;
constexpr SessionList_ErrorCode SessionList_ErrorCode_ErrorCode_MAX = SessionList_ErrorCode_UNKNOWN_ERROR;
constexpr int SessionList_ErrorCode_ErrorCode_ARRAYSIZE = SessionList_ErrorCode_ErrorCode_MAX + 1;

const std::string& SessionList_ErrorCode_Name(SessionList_ErrorCode value);
template<typename T>
inline const std::string& SessionList_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionList_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionList_ErrorCode_Name.");
  return SessionList_ErrorCode_Name(static_cast<SessionList_ErrorCode>(enum_t_value));
}
bool SessionList_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionList_ErrorCode* value);
enum UserList_ErrorCode : int {
  UserList_ErrorCode_SUCCESS = 0,
  UserList_ErrorCode_UNKNOWN_ERROR = 1,
  UserList_ErrorCode_UserList_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserList_ErrorCode_UserList_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserList_ErrorCode_IsValid(int value);
constexpr UserList_ErrorCode UserList_ErrorCode_ErrorCode_MIN = UserList_ErrorCode_SUCCESS;
constexpr UserList_ErrorCode UserList_ErrorCode_ErrorCode_MAX = UserList_ErrorCode_UNKNOWN_ERROR;
constexpr int UserList_ErrorCode_ErrorCode_ARRAYSIZE = UserList_ErrorCode_ErrorCode_MAX + 1;

const std::string& UserList_ErrorCode_Name(UserList_ErrorCode value);
template<typename T>
inline const std::string& UserList_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserList_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserList_ErrorCode_Name.");
  return UserList_ErrorCode_Name(static_cast<UserList_ErrorCode>(enum_t_value));
}
bool UserList_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserList_ErrorCode* value);
enum UserResult_ErrorCode : int {
  UserResult_ErrorCode_SUCCESS = 0,
  UserResult_ErrorCode_INTERNAL_ERROR = 1,
  UserResult_ErrorCode_INVALID_DATA = 2,
  UserResult_ErrorCode_ALREADY_EXISTS = 3,
  UserResult_ErrorCode_UserResult_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserResult_ErrorCode_UserResult_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserResult_ErrorCode_IsValid(int value);
constexpr UserResult_ErrorCode UserResult_ErrorCode_ErrorCode_MIN = UserResult_ErrorCode_SUCCESS;
constexpr UserResult_ErrorCode UserResult_ErrorCode_ErrorCode_MAX = UserResult_ErrorCode_ALREADY_EXISTS;
constexpr int UserResult_ErrorCode_ErrorCode_ARRAYSIZE = UserResult_ErrorCode_ErrorCode_MAX + 1;

const std::string& UserResult_ErrorCode_Name(UserResult_ErrorCode value);
template<typename T>
inline const std::string& UserResult_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserResult_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserResult_ErrorCode_Name.");
  return UserResult_ErrorCode_Name(static_cast<UserResult_ErrorCode>(enum_t_value));
}
bool UserResult_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserResult_ErrorCode* value);
enum SessionRequestType : int {
  SESSION_REQUEST_UNKNOWN = 0,
  SESSION_REQUEST_DISCONNECT = 1,
  SessionRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionRequestType_IsValid(int value);
constexpr SessionRequestType SessionRequestType_MIN = SESSION_REQUEST_UNKNOWN;
constexpr SessionRequestType SessionRequestType_MAX = SESSION_REQUEST_DISCONNECT;
constexpr int SessionRequestType_ARRAYSIZE = SessionRequestType_MAX + 1;

const std::string& SessionRequestType_Name(SessionRequestType value);
template<typename T>
inline const std::string& SessionRequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionRequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionRequestType_Name.");
  return SessionRequestType_Name(static_cast<SessionRequestType>(enum_t_value));
}
bool SessionRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionRequestType* value);
enum UserRequestType : int {
  USER_REQUEST_UNKNOWN = 0,
  USER_REQUEST_ADD = 1,
  USER_REQUEST_MODIFY = 2,
  USER_REQUEST_DELETE = 3,
  UserRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserRequestType_IsValid(int value);
constexpr UserRequestType UserRequestType_MIN = USER_REQUEST_UNKNOWN;
constexpr UserRequestType UserRequestType_MAX = USER_REQUEST_DELETE;
constexpr int UserRequestType_ARRAYSIZE = UserRequestType_MAX + 1;

const std::string& UserRequestType_Name(UserRequestType value);
template<typename T>
inline const std::string& UserRequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserRequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserRequestType_Name.");
  return UserRequestType_Name(static_cast<UserRequestType>(enum_t_value));
}
bool UserRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserRequestType* value);
// ===================================================================

class Session final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Session) */ {
 public:
  inline Session() : Session(nullptr) {}
  ~Session() override;
  explicit PROTOBUF_CONSTEXPR Session(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Session(const Session& from);
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Session& default_instance() {
    return *internal_default_instance();
  }
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }
  inline void Swap(Session* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Session* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Session";
  }
  protected:
  explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionDataFieldNumber = 3,
    kIpAddressFieldNumber = 5,
    kOsNameFieldNumber = 7,
    kComputerNameFieldNumber = 8,
    kVersionFieldNumber = 6,
    kSessionIdFieldNumber = 1,
    kTimepointFieldNumber = 4,
    kSessionTypeFieldNumber = 2,
  };
  // bytes session_data = 3;
  void clear_session_data();
  const std::string& session_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_data();
  PROTOBUF_NODISCARD std::string* release_session_data();
  void set_allocated_session_data(std::string* session_data);
  private:
  const std::string& _internal_session_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_data(const std::string& value);
  std::string* _internal_mutable_session_data();
  public:

  // string ip_address = 5;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string os_name = 7;
  void clear_os_name();
  const std::string& os_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_name();
  PROTOBUF_NODISCARD std::string* release_os_name();
  void set_allocated_os_name(std::string* os_name);
  private:
  const std::string& _internal_os_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_name(const std::string& value);
  std::string* _internal_mutable_os_name();
  public:

  // string computer_name = 8;
  void clear_computer_name();
  const std::string& computer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_computer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_computer_name();
  PROTOBUF_NODISCARD std::string* release_computer_name();
  void set_allocated_computer_name(std::string* computer_name);
  private:
  const std::string& _internal_computer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_computer_name(const std::string& value);
  std::string* _internal_mutable_computer_name();
  public:

  // .proto.Version version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::proto::Version& version() const;
  PROTOBUF_NODISCARD ::proto::Version* release_version();
  ::proto::Version* mutable_version();
  void set_allocated_version(::proto::Version* version);
  private:
  const ::proto::Version& _internal_version() const;
  ::proto::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::proto::Version* version);
  ::proto::Version* unsafe_arena_release_version();

  // int64 session_id = 1;
  void clear_session_id();
  int64_t session_id() const;
  void set_session_id(int64_t value);
  private:
  int64_t _internal_session_id() const;
  void _internal_set_session_id(int64_t value);
  public:

  // fixed64 timepoint = 4;
  void clear_timepoint();
  uint64_t timepoint() const;
  void set_timepoint(uint64_t value);
  private:
  uint64_t _internal_timepoint() const;
  void _internal_set_timepoint(uint64_t value);
  public:

  // .proto.RouterSession session_type = 2;
  void clear_session_type();
  ::proto::RouterSession session_type() const;
  void set_session_type(::proto::RouterSession value);
  private:
  ::proto::RouterSession _internal_session_type() const;
  void _internal_set_session_type(::proto::RouterSession value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Session)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr computer_name_;
    ::proto::Version* version_;
    int64_t session_id_;
    uint64_t timepoint_;
    int session_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class SessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionRequest) */ {
 public:
  inline SessionRequest() : SessionRequest(nullptr) {}
  ~SessionRequest() override;
  explicit PROTOBUF_CONSTEXPR SessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionRequest(const SessionRequest& from);
  SessionRequest(SessionRequest&& from) noexcept
    : SessionRequest() {
    *this = ::std::move(from);
  }

  inline SessionRequest& operator=(const SessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRequest& operator=(SessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionRequest* internal_default_instance() {
    return reinterpret_cast<const SessionRequest*>(
               &_SessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SessionRequest& a, SessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionRequest& from);
  void MergeFrom(const SessionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SessionRequest";
  }
  protected:
  explicit SessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // int64 session_id = 2;
  void clear_session_id();
  int64_t session_id() const;
  void set_session_id(int64_t value);
  private:
  int64_t _internal_session_id() const;
  void _internal_set_session_id(int64_t value);
  public:

  // .proto.SessionRequestType type = 1;
  void clear_type();
  ::proto::SessionRequestType type() const;
  void set_type(::proto::SessionRequestType value);
  private:
  ::proto::SessionRequestType _internal_type() const;
  void _internal_set_type(::proto::SessionRequestType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t session_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class SessionResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionResult) */ {
 public:
  inline SessionResult() : SessionResult(nullptr) {}
  ~SessionResult() override;
  explicit PROTOBUF_CONSTEXPR SessionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResult(const SessionResult& from);
  SessionResult(SessionResult&& from) noexcept
    : SessionResult() {
    *this = ::std::move(from);
  }

  inline SessionResult& operator=(const SessionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResult& operator=(SessionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResult* internal_default_instance() {
    return reinterpret_cast<const SessionResult*>(
               &_SessionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SessionResult& a, SessionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionResult& from);
  void MergeFrom(const SessionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SessionResult";
  }
  protected:
  explicit SessionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SessionResult_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    SessionResult_ErrorCode_SUCCESS;
  static constexpr ErrorCode INVALID_REQUEST =
    SessionResult_ErrorCode_INVALID_REQUEST;
  static constexpr ErrorCode INTERNAL_ERROR =
    SessionResult_ErrorCode_INTERNAL_ERROR;
  static constexpr ErrorCode INVALID_SESSION_ID =
    SessionResult_ErrorCode_INVALID_SESSION_ID;
  static inline bool ErrorCode_IsValid(int value) {
    return SessionResult_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    SessionResult_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    SessionResult_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    SessionResult_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return SessionResult_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return SessionResult_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .proto.SessionRequestType type = 1;
  void clear_type();
  ::proto::SessionRequestType type() const;
  void set_type(::proto::SessionRequestType value);
  private:
  ::proto::SessionRequestType _internal_type() const;
  void _internal_set_type(::proto::SessionRequestType value);
  public:

  // .proto.SessionResult.ErrorCode error_code = 2;
  void clear_error_code();
  ::proto::SessionResult_ErrorCode error_code() const;
  void set_error_code(::proto::SessionResult_ErrorCode value);
  private:
  ::proto::SessionResult_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::SessionResult_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SessionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class SessionListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionListRequest) */ {
 public:
  inline SessionListRequest() : SessionListRequest(nullptr) {}
  ~SessionListRequest() override;
  explicit PROTOBUF_CONSTEXPR SessionListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionListRequest(const SessionListRequest& from);
  SessionListRequest(SessionListRequest&& from) noexcept
    : SessionListRequest() {
    *this = ::std::move(from);
  }

  inline SessionListRequest& operator=(const SessionListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionListRequest& operator=(SessionListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionListRequest* internal_default_instance() {
    return reinterpret_cast<const SessionListRequest*>(
               &_SessionListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionListRequest& a, SessionListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionListRequest& from);
  void MergeFrom(const SessionListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SessionListRequest";
  }
  protected:
  explicit SessionListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // int64 dummy = 1;
  void clear_dummy();
  int64_t dummy() const;
  void set_dummy(int64_t value);
  private:
  int64_t _internal_dummy() const;
  void _internal_set_dummy(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SessionListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class SessionList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionList) */ {
 public:
  inline SessionList() : SessionList(nullptr) {}
  ~SessionList() override;
  explicit PROTOBUF_CONSTEXPR SessionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionList(const SessionList& from);
  SessionList(SessionList&& from) noexcept
    : SessionList() {
    *this = ::std::move(from);
  }

  inline SessionList& operator=(const SessionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionList& operator=(SessionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionList* internal_default_instance() {
    return reinterpret_cast<const SessionList*>(
               &_SessionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SessionList& a, SessionList& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionList& from);
  void MergeFrom(const SessionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SessionList";
  }
  protected:
  explicit SessionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SessionList_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    SessionList_ErrorCode_SUCCESS;
  static constexpr ErrorCode UNKNOWN_ERROR =
    SessionList_ErrorCode_UNKNOWN_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return SessionList_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    SessionList_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    SessionList_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    SessionList_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return SessionList_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return SessionList_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // repeated .proto.Session session = 2;
  int session_size() const;
  private:
  int _internal_session_size() const;
  public:
  void clear_session();
  ::proto::Session* mutable_session(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Session >*
      mutable_session();
  private:
  const ::proto::Session& _internal_session(int index) const;
  ::proto::Session* _internal_add_session();
  public:
  const ::proto::Session& session(int index) const;
  ::proto::Session* add_session();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Session >&
      session() const;

  // .proto.SessionList.ErrorCode error_code = 1;
  void clear_error_code();
  ::proto::SessionList_ErrorCode error_code() const;
  void set_error_code(::proto::SessionList_ErrorCode value);
  private:
  ::proto::SessionList_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::SessionList_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SessionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Session > session_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class HostSessionData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostSessionData) */ {
 public:
  inline HostSessionData() : HostSessionData(nullptr) {}
  ~HostSessionData() override;
  explicit PROTOBUF_CONSTEXPR HostSessionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostSessionData(const HostSessionData& from);
  HostSessionData(HostSessionData&& from) noexcept
    : HostSessionData() {
    *this = ::std::move(from);
  }

  inline HostSessionData& operator=(const HostSessionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostSessionData& operator=(HostSessionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostSessionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostSessionData* internal_default_instance() {
    return reinterpret_cast<const HostSessionData*>(
               &_HostSessionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HostSessionData& a, HostSessionData& b) {
    a.Swap(&b);
  }
  inline void Swap(HostSessionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostSessionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostSessionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostSessionData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostSessionData& from);
  void MergeFrom(const HostSessionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostSessionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HostSessionData";
  }
  protected:
  explicit HostSessionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdFieldNumber = 1,
  };
  // repeated fixed64 host_id = 1;
  int host_id_size() const;
  private:
  int _internal_host_id_size() const;
  public:
  void clear_host_id();
  private:
  uint64_t _internal_host_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_host_id() const;
  void _internal_add_host_id(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_host_id();
  public:
  uint64_t host_id(int index) const;
  void set_host_id(int index, uint64_t value);
  void add_host_id(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      host_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_host_id();

  // @@protoc_insertion_point(class_scope:proto.HostSessionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > host_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class RelaySessionData_RelayStat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelaySessionData.RelayStat) */ {
 public:
  inline RelaySessionData_RelayStat() : RelaySessionData_RelayStat(nullptr) {}
  ~RelaySessionData_RelayStat() override;
  explicit PROTOBUF_CONSTEXPR RelaySessionData_RelayStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelaySessionData_RelayStat(const RelaySessionData_RelayStat& from);
  RelaySessionData_RelayStat(RelaySessionData_RelayStat&& from) noexcept
    : RelaySessionData_RelayStat() {
    *this = ::std::move(from);
  }

  inline RelaySessionData_RelayStat& operator=(const RelaySessionData_RelayStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelaySessionData_RelayStat& operator=(RelaySessionData_RelayStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelaySessionData_RelayStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelaySessionData_RelayStat* internal_default_instance() {
    return reinterpret_cast<const RelaySessionData_RelayStat*>(
               &_RelaySessionData_RelayStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RelaySessionData_RelayStat& a, RelaySessionData_RelayStat& b) {
    a.Swap(&b);
  }
  inline void Swap(RelaySessionData_RelayStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelaySessionData_RelayStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelaySessionData_RelayStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelaySessionData_RelayStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelaySessionData_RelayStat& from);
  void MergeFrom(const RelaySessionData_RelayStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelaySessionData_RelayStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelaySessionData.RelayStat";
  }
  protected:
  explicit RelaySessionData_RelayStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerConnectionFieldNumber = 1,
    kUptimeFieldNumber = 2,
  };
  // repeated .proto.PeerConnection peer_connection = 1;
  int peer_connection_size() const;
  private:
  int _internal_peer_connection_size() const;
  public:
  void clear_peer_connection();
  ::proto::PeerConnection* mutable_peer_connection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >*
      mutable_peer_connection();
  private:
  const ::proto::PeerConnection& _internal_peer_connection(int index) const;
  ::proto::PeerConnection* _internal_add_peer_connection();
  public:
  const ::proto::PeerConnection& peer_connection(int index) const;
  ::proto::PeerConnection* add_peer_connection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >&
      peer_connection() const;

  // int64 uptime = 2;
  void clear_uptime();
  int64_t uptime() const;
  void set_uptime(int64_t value);
  private:
  int64_t _internal_uptime() const;
  void _internal_set_uptime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelaySessionData.RelayStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection > peer_connection_;
    int64_t uptime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class RelaySessionData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelaySessionData) */ {
 public:
  inline RelaySessionData() : RelaySessionData(nullptr) {}
  ~RelaySessionData() override;
  explicit PROTOBUF_CONSTEXPR RelaySessionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelaySessionData(const RelaySessionData& from);
  RelaySessionData(RelaySessionData&& from) noexcept
    : RelaySessionData() {
    *this = ::std::move(from);
  }

  inline RelaySessionData& operator=(const RelaySessionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelaySessionData& operator=(RelaySessionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelaySessionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelaySessionData* internal_default_instance() {
    return reinterpret_cast<const RelaySessionData*>(
               &_RelaySessionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RelaySessionData& a, RelaySessionData& b) {
    a.Swap(&b);
  }
  inline void Swap(RelaySessionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelaySessionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelaySessionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelaySessionData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelaySessionData& from);
  void MergeFrom(const RelaySessionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelaySessionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelaySessionData";
  }
  protected:
  explicit RelaySessionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RelaySessionData_RelayStat RelayStat;

  // accessors -------------------------------------------------------

  enum : int {
    kRelayStatFieldNumber = 2,
    kPoolSizeFieldNumber = 1,
  };
  // .proto.RelaySessionData.RelayStat relay_stat = 2;
  bool has_relay_stat() const;
  private:
  bool _internal_has_relay_stat() const;
  public:
  void clear_relay_stat();
  const ::proto::RelaySessionData_RelayStat& relay_stat() const;
  PROTOBUF_NODISCARD ::proto::RelaySessionData_RelayStat* release_relay_stat();
  ::proto::RelaySessionData_RelayStat* mutable_relay_stat();
  void set_allocated_relay_stat(::proto::RelaySessionData_RelayStat* relay_stat);
  private:
  const ::proto::RelaySessionData_RelayStat& _internal_relay_stat() const;
  ::proto::RelaySessionData_RelayStat* _internal_mutable_relay_stat();
  public:
  void unsafe_arena_set_allocated_relay_stat(
      ::proto::RelaySessionData_RelayStat* relay_stat);
  ::proto::RelaySessionData_RelayStat* unsafe_arena_release_relay_stat();

  // uint64 pool_size = 1;
  void clear_pool_size();
  uint64_t pool_size() const;
  void set_pool_size(uint64_t value);
  private:
  uint64_t _internal_pool_size() const;
  void _internal_set_pool_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelaySessionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::RelaySessionData_RelayStat* relay_stat_;
    uint64_t pool_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGroupFieldNumber = 3,
    kSaltFieldNumber = 4,
    kVerifierFieldNumber = 5,
    kEntryIdFieldNumber = 1,
    kSessionsFieldNumber = 6,
    kFlagsFieldNumber = 7,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string group = 3;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // bytes salt = 4;
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // bytes verifier = 5;
  void clear_verifier();
  const std::string& verifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verifier();
  PROTOBUF_NODISCARD std::string* release_verifier();
  void set_allocated_verifier(std::string* verifier);
  private:
  const std::string& _internal_verifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifier(const std::string& value);
  std::string* _internal_mutable_verifier();
  public:

  // int64 entry_id = 1;
  void clear_entry_id();
  int64_t entry_id() const;
  void set_entry_id(int64_t value);
  private:
  int64_t _internal_entry_id() const;
  void _internal_set_entry_id(int64_t value);
  public:

  // uint32 sessions = 6;
  void clear_sessions();
  uint32_t sessions() const;
  void set_sessions(uint32_t value);
  private:
  uint32_t _internal_sessions() const;
  void _internal_set_sessions(uint32_t value);
  public:

  // uint32 flags = 7;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verifier_;
    int64_t entry_id_;
    uint32_t sessions_;
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UserListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserListRequest) */ {
 public:
  inline UserListRequest() : UserListRequest(nullptr) {}
  ~UserListRequest() override;
  explicit PROTOBUF_CONSTEXPR UserListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListRequest(const UserListRequest& from);
  UserListRequest(UserListRequest&& from) noexcept
    : UserListRequest() {
    *this = ::std::move(from);
  }

  inline UserListRequest& operator=(const UserListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListRequest& operator=(UserListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListRequest* internal_default_instance() {
    return reinterpret_cast<const UserListRequest*>(
               &_UserListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserListRequest& a, UserListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserListRequest& from);
  void MergeFrom(const UserListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserListRequest";
  }
  protected:
  explicit UserListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // uint32 dummy = 1;
  void clear_dummy();
  uint32_t dummy() const;
  void set_dummy(uint32_t value);
  private:
  uint32_t _internal_dummy() const;
  void _internal_set_dummy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UserList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserList) */ {
 public:
  inline UserList() : UserList(nullptr) {}
  ~UserList() override;
  explicit PROTOBUF_CONSTEXPR UserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserList(const UserList& from);
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList& operator=(UserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }
  inline void Swap(UserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserList";
  }
  protected:
  explicit UserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UserList_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    UserList_ErrorCode_SUCCESS;
  static constexpr ErrorCode UNKNOWN_ERROR =
    UserList_ErrorCode_UNKNOWN_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return UserList_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    UserList_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    UserList_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    UserList_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return UserList_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return UserList_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // repeated .proto.User user = 2;
  int user_size() const;
  private:
  int _internal_user_size() const;
  public:
  void clear_user();
  ::proto::User* mutable_user(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >*
      mutable_user();
  private:
  const ::proto::User& _internal_user(int index) const;
  ::proto::User* _internal_add_user();
  public:
  const ::proto::User& user(int index) const;
  ::proto::User* add_user();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >&
      user() const;

  // .proto.UserList.ErrorCode error_code = 1;
  void clear_error_code();
  ::proto::UserList_ErrorCode error_code() const;
  void set_error_code(::proto::UserList_ErrorCode value);
  private:
  ::proto::UserList_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::UserList_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User > user_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserRequest) */ {
 public:
  inline UserRequest() : UserRequest(nullptr) {}
  ~UserRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRequest(const UserRequest& from);
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserRequest";
  }
  protected:
  explicit UserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .proto.User user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::proto::User& user() const;
  PROTOBUF_NODISCARD ::proto::User* release_user();
  ::proto::User* mutable_user();
  void set_allocated_user(::proto::User* user);
  private:
  const ::proto::User& _internal_user() const;
  ::proto::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::proto::User* user);
  ::proto::User* unsafe_arena_release_user();

  // .proto.UserRequestType type = 1;
  void clear_type();
  ::proto::UserRequestType type() const;
  void set_type(::proto::UserRequestType value);
  private:
  ::proto::UserRequestType _internal_type() const;
  void _internal_set_type(::proto::UserRequestType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::User* user_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UserResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserResult) */ {
 public:
  inline UserResult() : UserResult(nullptr) {}
  ~UserResult() override;
  explicit PROTOBUF_CONSTEXPR UserResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserResult(const UserResult& from);
  UserResult(UserResult&& from) noexcept
    : UserResult() {
    *this = ::std::move(from);
  }

  inline UserResult& operator=(const UserResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResult& operator=(UserResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UserResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResult* internal_default_instance() {
    return reinterpret_cast<const UserResult*>(
               &_UserResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserResult& a, UserResult& b) {
    a.Swap(&b);
  }
  inline void Swap(UserResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserResult& from);
  void MergeFrom(const UserResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UserResult";
  }
  protected:
  explicit UserResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UserResult_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    UserResult_ErrorCode_SUCCESS;
  static constexpr ErrorCode INTERNAL_ERROR =
    UserResult_ErrorCode_INTERNAL_ERROR;
  static constexpr ErrorCode INVALID_DATA =
    UserResult_ErrorCode_INVALID_DATA;
  static constexpr ErrorCode ALREADY_EXISTS =
    UserResult_ErrorCode_ALREADY_EXISTS;
  static inline bool ErrorCode_IsValid(int value) {
    return UserResult_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    UserResult_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    UserResult_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    UserResult_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return UserResult_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return UserResult_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .proto.UserRequestType type = 1;
  void clear_type();
  ::proto::UserRequestType type() const;
  void set_type(::proto::UserRequestType value);
  private:
  ::proto::UserRequestType _internal_type() const;
  void _internal_set_type(::proto::UserRequestType value);
  public:

  // .proto.UserResult.ErrorCode error_code = 2;
  void clear_error_code();
  ::proto::UserResult_ErrorCode error_code() const;
  void set_error_code(::proto::UserResult_ErrorCode value);
  private:
  ::proto::UserResult_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::UserResult_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.UserResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class RouterToAdmin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RouterToAdmin) */ {
 public:
  inline RouterToAdmin() : RouterToAdmin(nullptr) {}
  ~RouterToAdmin() override;
  explicit PROTOBUF_CONSTEXPR RouterToAdmin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterToAdmin(const RouterToAdmin& from);
  RouterToAdmin(RouterToAdmin&& from) noexcept
    : RouterToAdmin() {
    *this = ::std::move(from);
  }

  inline RouterToAdmin& operator=(const RouterToAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterToAdmin& operator=(RouterToAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RouterToAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterToAdmin* internal_default_instance() {
    return reinterpret_cast<const RouterToAdmin*>(
               &_RouterToAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RouterToAdmin& a, RouterToAdmin& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterToAdmin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterToAdmin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterToAdmin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterToAdmin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RouterToAdmin& from);
  void MergeFrom(const RouterToAdmin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouterToAdmin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RouterToAdmin";
  }
  protected:
  explicit RouterToAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionListFieldNumber = 1,
    kSessionResultFieldNumber = 2,
    kUserListFieldNumber = 3,
    kUserResultFieldNumber = 4,
  };
  // .proto.SessionList session_list = 1;
  bool has_session_list() const;
  private:
  bool _internal_has_session_list() const;
  public:
  void clear_session_list();
  const ::proto::SessionList& session_list() const;
  PROTOBUF_NODISCARD ::proto::SessionList* release_session_list();
  ::proto::SessionList* mutable_session_list();
  void set_allocated_session_list(::proto::SessionList* session_list);
  private:
  const ::proto::SessionList& _internal_session_list() const;
  ::proto::SessionList* _internal_mutable_session_list();
  public:
  void unsafe_arena_set_allocated_session_list(
      ::proto::SessionList* session_list);
  ::proto::SessionList* unsafe_arena_release_session_list();

  // .proto.SessionResult session_result = 2;
  bool has_session_result() const;
  private:
  bool _internal_has_session_result() const;
  public:
  void clear_session_result();
  const ::proto::SessionResult& session_result() const;
  PROTOBUF_NODISCARD ::proto::SessionResult* release_session_result();
  ::proto::SessionResult* mutable_session_result();
  void set_allocated_session_result(::proto::SessionResult* session_result);
  private:
  const ::proto::SessionResult& _internal_session_result() const;
  ::proto::SessionResult* _internal_mutable_session_result();
  public:
  void unsafe_arena_set_allocated_session_result(
      ::proto::SessionResult* session_result);
  ::proto::SessionResult* unsafe_arena_release_session_result();

  // .proto.UserList user_list = 3;
  bool has_user_list() const;
  private:
  bool _internal_has_user_list() const;
  public:
  void clear_user_list();
  const ::proto::UserList& user_list() const;
  PROTOBUF_NODISCARD ::proto::UserList* release_user_list();
  ::proto::UserList* mutable_user_list();
  void set_allocated_user_list(::proto::UserList* user_list);
  private:
  const ::proto::UserList& _internal_user_list() const;
  ::proto::UserList* _internal_mutable_user_list();
  public:
  void unsafe_arena_set_allocated_user_list(
      ::proto::UserList* user_list);
  ::proto::UserList* unsafe_arena_release_user_list();

  // .proto.UserResult user_result = 4;
  bool has_user_result() const;
  private:
  bool _internal_has_user_result() const;
  public:
  void clear_user_result();
  const ::proto::UserResult& user_result() const;
  PROTOBUF_NODISCARD ::proto::UserResult* release_user_result();
  ::proto::UserResult* mutable_user_result();
  void set_allocated_user_result(::proto::UserResult* user_result);
  private:
  const ::proto::UserResult& _internal_user_result() const;
  ::proto::UserResult* _internal_mutable_user_result();
  public:
  void unsafe_arena_set_allocated_user_result(
      ::proto::UserResult* user_result);
  ::proto::UserResult* unsafe_arena_release_user_result();

  // @@protoc_insertion_point(class_scope:proto.RouterToAdmin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::SessionList* session_list_;
    ::proto::SessionResult* session_result_;
    ::proto::UserList* user_list_;
    ::proto::UserResult* user_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class AdminToRouter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.AdminToRouter) */ {
 public:
  inline AdminToRouter() : AdminToRouter(nullptr) {}
  ~AdminToRouter() override;
  explicit PROTOBUF_CONSTEXPR AdminToRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminToRouter(const AdminToRouter& from);
  AdminToRouter(AdminToRouter&& from) noexcept
    : AdminToRouter() {
    *this = ::std::move(from);
  }

  inline AdminToRouter& operator=(const AdminToRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminToRouter& operator=(AdminToRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AdminToRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminToRouter* internal_default_instance() {
    return reinterpret_cast<const AdminToRouter*>(
               &_AdminToRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AdminToRouter& a, AdminToRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminToRouter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminToRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminToRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminToRouter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AdminToRouter& from);
  void MergeFrom(const AdminToRouter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminToRouter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AdminToRouter";
  }
  protected:
  explicit AdminToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionListRequestFieldNumber = 1,
    kSessionRequestFieldNumber = 2,
    kUserListRequestFieldNumber = 3,
    kUserRequestFieldNumber = 4,
    kPeerConnectionRequestFieldNumber = 5,
  };
  // .proto.SessionListRequest session_list_request = 1;
  bool has_session_list_request() const;
  private:
  bool _internal_has_session_list_request() const;
  public:
  void clear_session_list_request();
  const ::proto::SessionListRequest& session_list_request() const;
  PROTOBUF_NODISCARD ::proto::SessionListRequest* release_session_list_request();
  ::proto::SessionListRequest* mutable_session_list_request();
  void set_allocated_session_list_request(::proto::SessionListRequest* session_list_request);
  private:
  const ::proto::SessionListRequest& _internal_session_list_request() const;
  ::proto::SessionListRequest* _internal_mutable_session_list_request();
  public:
  void unsafe_arena_set_allocated_session_list_request(
      ::proto::SessionListRequest* session_list_request);
  ::proto::SessionListRequest* unsafe_arena_release_session_list_request();

  // .proto.SessionRequest session_request = 2;
  bool has_session_request() const;
  private:
  bool _internal_has_session_request() const;
  public:
  void clear_session_request();
  const ::proto::SessionRequest& session_request() const;
  PROTOBUF_NODISCARD ::proto::SessionRequest* release_session_request();
  ::proto::SessionRequest* mutable_session_request();
  void set_allocated_session_request(::proto::SessionRequest* session_request);
  private:
  const ::proto::SessionRequest& _internal_session_request() const;
  ::proto::SessionRequest* _internal_mutable_session_request();
  public:
  void unsafe_arena_set_allocated_session_request(
      ::proto::SessionRequest* session_request);
  ::proto::SessionRequest* unsafe_arena_release_session_request();

  // .proto.UserListRequest user_list_request = 3;
  bool has_user_list_request() const;
  private:
  bool _internal_has_user_list_request() const;
  public:
  void clear_user_list_request();
  const ::proto::UserListRequest& user_list_request() const;
  PROTOBUF_NODISCARD ::proto::UserListRequest* release_user_list_request();
  ::proto::UserListRequest* mutable_user_list_request();
  void set_allocated_user_list_request(::proto::UserListRequest* user_list_request);
  private:
  const ::proto::UserListRequest& _internal_user_list_request() const;
  ::proto::UserListRequest* _internal_mutable_user_list_request();
  public:
  void unsafe_arena_set_allocated_user_list_request(
      ::proto::UserListRequest* user_list_request);
  ::proto::UserListRequest* unsafe_arena_release_user_list_request();

  // .proto.UserRequest user_request = 4;
  bool has_user_request() const;
  private:
  bool _internal_has_user_request() const;
  public:
  void clear_user_request();
  const ::proto::UserRequest& user_request() const;
  PROTOBUF_NODISCARD ::proto::UserRequest* release_user_request();
  ::proto::UserRequest* mutable_user_request();
  void set_allocated_user_request(::proto::UserRequest* user_request);
  private:
  const ::proto::UserRequest& _internal_user_request() const;
  ::proto::UserRequest* _internal_mutable_user_request();
  public:
  void unsafe_arena_set_allocated_user_request(
      ::proto::UserRequest* user_request);
  ::proto::UserRequest* unsafe_arena_release_user_request();

  // .proto.PeerConnectionRequest peer_connection_request = 5;
  bool has_peer_connection_request() const;
  private:
  bool _internal_has_peer_connection_request() const;
  public:
  void clear_peer_connection_request();
  const ::proto::PeerConnectionRequest& peer_connection_request() const;
  PROTOBUF_NODISCARD ::proto::PeerConnectionRequest* release_peer_connection_request();
  ::proto::PeerConnectionRequest* mutable_peer_connection_request();
  void set_allocated_peer_connection_request(::proto::PeerConnectionRequest* peer_connection_request);
  private:
  const ::proto::PeerConnectionRequest& _internal_peer_connection_request() const;
  ::proto::PeerConnectionRequest* _internal_mutable_peer_connection_request();
  public:
  void unsafe_arena_set_allocated_peer_connection_request(
      ::proto::PeerConnectionRequest* peer_connection_request);
  ::proto::PeerConnectionRequest* unsafe_arena_release_peer_connection_request();

  // @@protoc_insertion_point(class_scope:proto.AdminToRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::SessionListRequest* session_list_request_;
    ::proto::SessionRequest* session_request_;
    ::proto::UserListRequest* user_list_request_;
    ::proto::UserRequest* user_request_;
    ::proto::PeerConnectionRequest* peer_connection_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fadmin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Session

// int64 session_id = 1;
inline void Session::clear_session_id() {
  _impl_.session_id_ = int64_t{0};
}
inline int64_t Session::_internal_session_id() const {
  return _impl_.session_id_;
}
inline int64_t Session::session_id() const {
  // @@protoc_insertion_point(field_get:proto.Session.session_id)
  return _internal_session_id();
}
inline void Session::_internal_set_session_id(int64_t value) {
  
  _impl_.session_id_ = value;
}
inline void Session::set_session_id(int64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:proto.Session.session_id)
}

// .proto.RouterSession session_type = 2;
inline void Session::clear_session_type() {
  _impl_.session_type_ = 0;
}
inline ::proto::RouterSession Session::_internal_session_type() const {
  return static_cast< ::proto::RouterSession >(_impl_.session_type_);
}
inline ::proto::RouterSession Session::session_type() const {
  // @@protoc_insertion_point(field_get:proto.Session.session_type)
  return _internal_session_type();
}
inline void Session::_internal_set_session_type(::proto::RouterSession value) {
  
  _impl_.session_type_ = value;
}
inline void Session::set_session_type(::proto::RouterSession value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:proto.Session.session_type)
}

// bytes session_data = 3;
inline void Session::clear_session_data() {
  _impl_.session_data_.ClearToEmpty();
}
inline const std::string& Session::session_data() const {
  // @@protoc_insertion_point(field_get:proto.Session.session_data)
  return _internal_session_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_session_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Session.session_data)
}
inline std::string* Session::mutable_session_data() {
  std::string* _s = _internal_mutable_session_data();
  // @@protoc_insertion_point(field_mutable:proto.Session.session_data)
  return _s;
}
inline const std::string& Session::_internal_session_data() const {
  return _impl_.session_data_.Get();
}
inline void Session::_internal_set_session_data(const std::string& value) {
  
  _impl_.session_data_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_session_data() {
  
  return _impl_.session_data_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_session_data() {
  // @@protoc_insertion_point(field_release:proto.Session.session_data)
  return _impl_.session_data_.Release();
}
inline void Session::set_allocated_session_data(std::string* session_data) {
  if (session_data != nullptr) {
    
  } else {
    
  }
  _impl_.session_data_.SetAllocated(session_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_data_.IsDefault()) {
    _impl_.session_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Session.session_data)
}

// fixed64 timepoint = 4;
inline void Session::clear_timepoint() {
  _impl_.timepoint_ = uint64_t{0u};
}
inline uint64_t Session::_internal_timepoint() const {
  return _impl_.timepoint_;
}
inline uint64_t Session::timepoint() const {
  // @@protoc_insertion_point(field_get:proto.Session.timepoint)
  return _internal_timepoint();
}
inline void Session::_internal_set_timepoint(uint64_t value) {
  
  _impl_.timepoint_ = value;
}
inline void Session::set_timepoint(uint64_t value) {
  _internal_set_timepoint(value);
  // @@protoc_insertion_point(field_set:proto.Session.timepoint)
}

// string ip_address = 5;
inline void Session::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& Session::ip_address() const {
  // @@protoc_insertion_point(field_get:proto.Session.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Session.ip_address)
}
inline std::string* Session::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:proto.Session.ip_address)
  return _s;
}
inline const std::string& Session::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void Session::_internal_set_ip_address(const std::string& value) {
  
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_ip_address() {
  
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_ip_address() {
  // @@protoc_insertion_point(field_release:proto.Session.ip_address)
  return _impl_.ip_address_.Release();
}
inline void Session::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Session.ip_address)
}

// .proto.Version version = 6;
inline bool Session::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool Session::has_version() const {
  return _internal_has_version();
}
inline const ::proto::Version& Session::_internal_version() const {
  const ::proto::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Version&>(
      ::proto::_Version_default_instance_);
}
inline const ::proto::Version& Session::version() const {
  // @@protoc_insertion_point(field_get:proto.Session.version)
  return _internal_version();
}
inline void Session::unsafe_arena_set_allocated_version(
    ::proto::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Session.version)
}
inline ::proto::Version* Session::release_version() {
  
  ::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Version* Session::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:proto.Session.version)
  
  ::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::proto::Version* Session::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Version>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::proto::Version* Session::mutable_version() {
  ::proto::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:proto.Session.version)
  return _msg;
}
inline void Session::set_allocated_version(::proto::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:proto.Session.version)
}

// string os_name = 7;
inline void Session::clear_os_name() {
  _impl_.os_name_.ClearToEmpty();
}
inline const std::string& Session::os_name() const {
  // @@protoc_insertion_point(field_get:proto.Session.os_name)
  return _internal_os_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_os_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Session.os_name)
}
inline std::string* Session::mutable_os_name() {
  std::string* _s = _internal_mutable_os_name();
  // @@protoc_insertion_point(field_mutable:proto.Session.os_name)
  return _s;
}
inline const std::string& Session::_internal_os_name() const {
  return _impl_.os_name_.Get();
}
inline void Session::_internal_set_os_name(const std::string& value) {
  
  _impl_.os_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_os_name() {
  
  return _impl_.os_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_os_name() {
  // @@protoc_insertion_point(field_release:proto.Session.os_name)
  return _impl_.os_name_.Release();
}
inline void Session::set_allocated_os_name(std::string* os_name) {
  if (os_name != nullptr) {
    
  } else {
    
  }
  _impl_.os_name_.SetAllocated(os_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_name_.IsDefault()) {
    _impl_.os_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Session.os_name)
}

// string computer_name = 8;
inline void Session::clear_computer_name() {
  _impl_.computer_name_.ClearToEmpty();
}
inline const std::string& Session::computer_name() const {
  // @@protoc_insertion_point(field_get:proto.Session.computer_name)
  return _internal_computer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_computer_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.computer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Session.computer_name)
}
inline std::string* Session::mutable_computer_name() {
  std::string* _s = _internal_mutable_computer_name();
  // @@protoc_insertion_point(field_mutable:proto.Session.computer_name)
  return _s;
}
inline const std::string& Session::_internal_computer_name() const {
  return _impl_.computer_name_.Get();
}
inline void Session::_internal_set_computer_name(const std::string& value) {
  
  _impl_.computer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_computer_name() {
  
  return _impl_.computer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_computer_name() {
  // @@protoc_insertion_point(field_release:proto.Session.computer_name)
  return _impl_.computer_name_.Release();
}
inline void Session::set_allocated_computer_name(std::string* computer_name) {
  if (computer_name != nullptr) {
    
  } else {
    
  }
  _impl_.computer_name_.SetAllocated(computer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Session.computer_name)
}

// -------------------------------------------------------------------

// SessionRequest

// .proto.SessionRequestType type = 1;
inline void SessionRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::SessionRequestType SessionRequest::_internal_type() const {
  return static_cast< ::proto::SessionRequestType >(_impl_.type_);
}
inline ::proto::SessionRequestType SessionRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.SessionRequest.type)
  return _internal_type();
}
inline void SessionRequest::_internal_set_type(::proto::SessionRequestType value) {
  
  _impl_.type_ = value;
}
inline void SessionRequest::set_type(::proto::SessionRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.SessionRequest.type)
}

// int64 session_id = 2;
inline void SessionRequest::clear_session_id() {
  _impl_.session_id_ = int64_t{0};
}
inline int64_t SessionRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline int64_t SessionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:proto.SessionRequest.session_id)
  return _internal_session_id();
}
inline void SessionRequest::_internal_set_session_id(int64_t value) {
  
  _impl_.session_id_ = value;
}
inline void SessionRequest::set_session_id(int64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:proto.SessionRequest.session_id)
}

// -------------------------------------------------------------------

// SessionResult

// .proto.SessionRequestType type = 1;
inline void SessionResult::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::SessionRequestType SessionResult::_internal_type() const {
  return static_cast< ::proto::SessionRequestType >(_impl_.type_);
}
inline ::proto::SessionRequestType SessionResult::type() const {
  // @@protoc_insertion_point(field_get:proto.SessionResult.type)
  return _internal_type();
}
inline void SessionResult::_internal_set_type(::proto::SessionRequestType value) {
  
  _impl_.type_ = value;
}
inline void SessionResult::set_type(::proto::SessionRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.SessionResult.type)
}

// .proto.SessionResult.ErrorCode error_code = 2;
inline void SessionResult::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::SessionResult_ErrorCode SessionResult::_internal_error_code() const {
  return static_cast< ::proto::SessionResult_ErrorCode >(_impl_.error_code_);
}
inline ::proto::SessionResult_ErrorCode SessionResult::error_code() const {
  // @@protoc_insertion_point(field_get:proto.SessionResult.error_code)
  return _internal_error_code();
}
inline void SessionResult::_internal_set_error_code(::proto::SessionResult_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void SessionResult::set_error_code(::proto::SessionResult_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.SessionResult.error_code)
}

// -------------------------------------------------------------------

// SessionListRequest

// int64 dummy = 1;
inline void SessionListRequest::clear_dummy() {
  _impl_.dummy_ = int64_t{0};
}
inline int64_t SessionListRequest::_internal_dummy() const {
  return _impl_.dummy_;
}
inline int64_t SessionListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.SessionListRequest.dummy)
  return _internal_dummy();
}
inline void SessionListRequest::_internal_set_dummy(int64_t value) {
  
  _impl_.dummy_ = value;
}
inline void SessionListRequest::set_dummy(int64_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:proto.SessionListRequest.dummy)
}

// -------------------------------------------------------------------

// SessionList

// .proto.SessionList.ErrorCode error_code = 1;
inline void SessionList::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::SessionList_ErrorCode SessionList::_internal_error_code() const {
  return static_cast< ::proto::SessionList_ErrorCode >(_impl_.error_code_);
}
inline ::proto::SessionList_ErrorCode SessionList::error_code() const {
  // @@protoc_insertion_point(field_get:proto.SessionList.error_code)
  return _internal_error_code();
}
inline void SessionList::_internal_set_error_code(::proto::SessionList_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void SessionList::set_error_code(::proto::SessionList_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.SessionList.error_code)
}

// repeated .proto.Session session = 2;
inline int SessionList::_internal_session_size() const {
  return _impl_.session_.size();
}
inline int SessionList::session_size() const {
  return _internal_session_size();
}
inline void SessionList::clear_session() {
  _impl_.session_.Clear();
}
inline ::proto::Session* SessionList::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:proto.SessionList.session)
  return _impl_.session_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Session >*
SessionList::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:proto.SessionList.session)
  return &_impl_.session_;
}
inline const ::proto::Session& SessionList::_internal_session(int index) const {
  return _impl_.session_.Get(index);
}
inline const ::proto::Session& SessionList::session(int index) const {
  // @@protoc_insertion_point(field_get:proto.SessionList.session)
  return _internal_session(index);
}
inline ::proto::Session* SessionList::_internal_add_session() {
  return _impl_.session_.Add();
}
inline ::proto::Session* SessionList::add_session() {
  ::proto::Session* _add = _internal_add_session();
  // @@protoc_insertion_point(field_add:proto.SessionList.session)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Session >&
SessionList::session() const {
  // @@protoc_insertion_point(field_list:proto.SessionList.session)
  return _impl_.session_;
}

// -------------------------------------------------------------------

// HostSessionData

// repeated fixed64 host_id = 1;
inline int HostSessionData::_internal_host_id_size() const {
  return _impl_.host_id_.size();
}
inline int HostSessionData::host_id_size() const {
  return _internal_host_id_size();
}
inline void HostSessionData::clear_host_id() {
  _impl_.host_id_.Clear();
}
inline uint64_t HostSessionData::_internal_host_id(int index) const {
  return _impl_.host_id_.Get(index);
}
inline uint64_t HostSessionData::host_id(int index) const {
  // @@protoc_insertion_point(field_get:proto.HostSessionData.host_id)
  return _internal_host_id(index);
}
inline void HostSessionData::set_host_id(int index, uint64_t value) {
  _impl_.host_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.HostSessionData.host_id)
}
inline void HostSessionData::_internal_add_host_id(uint64_t value) {
  _impl_.host_id_.Add(value);
}
inline void HostSessionData::add_host_id(uint64_t value) {
  _internal_add_host_id(value);
  // @@protoc_insertion_point(field_add:proto.HostSessionData.host_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HostSessionData::_internal_host_id() const {
  return _impl_.host_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HostSessionData::host_id() const {
  // @@protoc_insertion_point(field_list:proto.HostSessionData.host_id)
  return _internal_host_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HostSessionData::_internal_mutable_host_id() {
  return &_impl_.host_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HostSessionData::mutable_host_id() {
  // @@protoc_insertion_point(field_mutable_list:proto.HostSessionData.host_id)
  return _internal_mutable_host_id();
}

// -------------------------------------------------------------------

// RelaySessionData_RelayStat

// repeated .proto.PeerConnection peer_connection = 1;
inline int RelaySessionData_RelayStat::_internal_peer_connection_size() const {
  return _impl_.peer_connection_.size();
}
inline int RelaySessionData_RelayStat::peer_connection_size() const {
  return _internal_peer_connection_size();
}
inline ::proto::PeerConnection* RelaySessionData_RelayStat::mutable_peer_connection(int index) {
  // @@protoc_insertion_point(field_mutable:proto.RelaySessionData.RelayStat.peer_connection)
  return _impl_.peer_connection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >*
RelaySessionData_RelayStat::mutable_peer_connection() {
  // @@protoc_insertion_point(field_mutable_list:proto.RelaySessionData.RelayStat.peer_connection)
  return &_impl_.peer_connection_;
}
inline const ::proto::PeerConnection& RelaySessionData_RelayStat::_internal_peer_connection(int index) const {
  return _impl_.peer_connection_.Get(index);
}
inline const ::proto::PeerConnection& RelaySessionData_RelayStat::peer_connection(int index) const {
  // @@protoc_insertion_point(field_get:proto.RelaySessionData.RelayStat.peer_connection)
  return _internal_peer_connection(index);
}
inline ::proto::PeerConnection* RelaySessionData_RelayStat::_internal_add_peer_connection() {
  return _impl_.peer_connection_.Add();
}
inline ::proto::PeerConnection* RelaySessionData_RelayStat::add_peer_connection() {
  ::proto::PeerConnection* _add = _internal_add_peer_connection();
  // @@protoc_insertion_point(field_add:proto.RelaySessionData.RelayStat.peer_connection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >&
RelaySessionData_RelayStat::peer_connection() const {
  // @@protoc_insertion_point(field_list:proto.RelaySessionData.RelayStat.peer_connection)
  return _impl_.peer_connection_;
}

// int64 uptime = 2;
inline void RelaySessionData_RelayStat::clear_uptime() {
  _impl_.uptime_ = int64_t{0};
}
inline int64_t RelaySessionData_RelayStat::_internal_uptime() const {
  return _impl_.uptime_;
}
inline int64_t RelaySessionData_RelayStat::uptime() const {
  // @@protoc_insertion_point(field_get:proto.RelaySessionData.RelayStat.uptime)
  return _internal_uptime();
}
inline void RelaySessionData_RelayStat::_internal_set_uptime(int64_t value) {
  
  _impl_.uptime_ = value;
}
inline void RelaySessionData_RelayStat::set_uptime(int64_t value) {
  _internal_set_uptime(value);
  // @@protoc_insertion_point(field_set:proto.RelaySessionData.RelayStat.uptime)
}

// -------------------------------------------------------------------

// RelaySessionData

// uint64 pool_size = 1;
inline void RelaySessionData::clear_pool_size() {
  _impl_.pool_size_ = uint64_t{0u};
}
inline uint64_t RelaySessionData::_internal_pool_size() const {
  return _impl_.pool_size_;
}
inline uint64_t RelaySessionData::pool_size() const {
  // @@protoc_insertion_point(field_get:proto.RelaySessionData.pool_size)
  return _internal_pool_size();
}
inline void RelaySessionData::_internal_set_pool_size(uint64_t value) {
  
  _impl_.pool_size_ = value;
}
inline void RelaySessionData::set_pool_size(uint64_t value) {
  _internal_set_pool_size(value);
  // @@protoc_insertion_point(field_set:proto.RelaySessionData.pool_size)
}

// .proto.RelaySessionData.RelayStat relay_stat = 2;
inline bool RelaySessionData::_internal_has_relay_stat() const {
  return this != internal_default_instance() && _impl_.relay_stat_ != nullptr;
}
inline bool RelaySessionData::has_relay_stat() const {
  return _internal_has_relay_stat();
}
inline void RelaySessionData::clear_relay_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.relay_stat_ != nullptr) {
    delete _impl_.relay_stat_;
  }
  _impl_.relay_stat_ = nullptr;
}
inline const ::proto::RelaySessionData_RelayStat& RelaySessionData::_internal_relay_stat() const {
  const ::proto::RelaySessionData_RelayStat* p = _impl_.relay_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RelaySessionData_RelayStat&>(
      ::proto::_RelaySessionData_RelayStat_default_instance_);
}
inline const ::proto::RelaySessionData_RelayStat& RelaySessionData::relay_stat() const {
  // @@protoc_insertion_point(field_get:proto.RelaySessionData.relay_stat)
  return _internal_relay_stat();
}
inline void RelaySessionData::unsafe_arena_set_allocated_relay_stat(
    ::proto::RelaySessionData_RelayStat* relay_stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relay_stat_);
  }
  _impl_.relay_stat_ = relay_stat;
  if (relay_stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RelaySessionData.relay_stat)
}
inline ::proto::RelaySessionData_RelayStat* RelaySessionData::release_relay_stat() {
  
  ::proto::RelaySessionData_RelayStat* temp = _impl_.relay_stat_;
  _impl_.relay_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RelaySessionData_RelayStat* RelaySessionData::unsafe_arena_release_relay_stat() {
  // @@protoc_insertion_point(field_release:proto.RelaySessionData.relay_stat)
  
  ::proto::RelaySessionData_RelayStat* temp = _impl_.relay_stat_;
  _impl_.relay_stat_ = nullptr;
  return temp;
}
inline ::proto::RelaySessionData_RelayStat* RelaySessionData::_internal_mutable_relay_stat() {
  
  if (_impl_.relay_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RelaySessionData_RelayStat>(GetArenaForAllocation());
    _impl_.relay_stat_ = p;
  }
  return _impl_.relay_stat_;
}
inline ::proto::RelaySessionData_RelayStat* RelaySessionData::mutable_relay_stat() {
  ::proto::RelaySessionData_RelayStat* _msg = _internal_mutable_relay_stat();
  // @@protoc_insertion_point(field_mutable:proto.RelaySessionData.relay_stat)
  return _msg;
}
inline void RelaySessionData::set_allocated_relay_stat(::proto::RelaySessionData_RelayStat* relay_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relay_stat_;
  }
  if (relay_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relay_stat);
    if (message_arena != submessage_arena) {
      relay_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relay_stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relay_stat_ = relay_stat;
  // @@protoc_insertion_point(field_set_allocated:proto.RelaySessionData.relay_stat)
}

// -------------------------------------------------------------------

// User

// int64 entry_id = 1;
inline void User::clear_entry_id() {
  _impl_.entry_id_ = int64_t{0};
}
inline int64_t User::_internal_entry_id() const {
  return _impl_.entry_id_;
}
inline int64_t User::entry_id() const {
  // @@protoc_insertion_point(field_get:proto.User.entry_id)
  return _internal_entry_id();
}
inline void User::_internal_set_entry_id(int64_t value) {
  
  _impl_.entry_id_ = value;
}
inline void User::set_entry_id(int64_t value) {
  _internal_set_entry_id(value);
  // @@protoc_insertion_point(field_set:proto.User.entry_id)
}

// string name = 2;
inline void User::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& User::name() const {
  // @@protoc_insertion_point(field_get:proto.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.name)
}
inline std::string* User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:proto.User.name)
  return _impl_.name_.Release();
}
inline void User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.name)
}

// string group = 3;
inline void User::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& User::group() const {
  // @@protoc_insertion_point(field_get:proto.User.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.group)
}
inline std::string* User::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:proto.User.group)
  return _s;
}
inline const std::string& User::_internal_group() const {
  return _impl_.group_.Get();
}
inline void User::_internal_set_group(const std::string& value) {
  
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_group() {
  
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_group() {
  // @@protoc_insertion_point(field_release:proto.User.group)
  return _impl_.group_.Release();
}
inline void User::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.group)
}

// bytes salt = 4;
inline void User::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& User::salt() const {
  // @@protoc_insertion_point(field_get:proto.User.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.salt)
}
inline std::string* User::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:proto.User.salt)
  return _s;
}
inline const std::string& User::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void User::_internal_set_salt(const std::string& value) {
  
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_salt() {
  
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_salt() {
  // @@protoc_insertion_point(field_release:proto.User.salt)
  return _impl_.salt_.Release();
}
inline void User::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.salt)
}

// bytes verifier = 5;
inline void User::clear_verifier() {
  _impl_.verifier_.ClearToEmpty();
}
inline const std::string& User::verifier() const {
  // @@protoc_insertion_point(field_get:proto.User.verifier)
  return _internal_verifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_verifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verifier_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.User.verifier)
}
inline std::string* User::mutable_verifier() {
  std::string* _s = _internal_mutable_verifier();
  // @@protoc_insertion_point(field_mutable:proto.User.verifier)
  return _s;
}
inline const std::string& User::_internal_verifier() const {
  return _impl_.verifier_.Get();
}
inline void User::_internal_set_verifier(const std::string& value) {
  
  _impl_.verifier_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_verifier() {
  
  return _impl_.verifier_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_verifier() {
  // @@protoc_insertion_point(field_release:proto.User.verifier)
  return _impl_.verifier_.Release();
}
inline void User::set_allocated_verifier(std::string* verifier) {
  if (verifier != nullptr) {
    
  } else {
    
  }
  _impl_.verifier_.SetAllocated(verifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifier_.IsDefault()) {
    _impl_.verifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.User.verifier)
}

// uint32 sessions = 6;
inline void User::clear_sessions() {
  _impl_.sessions_ = 0u;
}
inline uint32_t User::_internal_sessions() const {
  return _impl_.sessions_;
}
inline uint32_t User::sessions() const {
  // @@protoc_insertion_point(field_get:proto.User.sessions)
  return _internal_sessions();
}
inline void User::_internal_set_sessions(uint32_t value) {
  
  _impl_.sessions_ = value;
}
inline void User::set_sessions(uint32_t value) {
  _internal_set_sessions(value);
  // @@protoc_insertion_point(field_set:proto.User.sessions)
}

// uint32 flags = 7;
inline void User::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t User::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t User::flags() const {
  // @@protoc_insertion_point(field_get:proto.User.flags)
  return _internal_flags();
}
inline void User::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void User::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.User.flags)
}

// -------------------------------------------------------------------

// UserListRequest

// uint32 dummy = 1;
inline void UserListRequest::clear_dummy() {
  _impl_.dummy_ = 0u;
}
inline uint32_t UserListRequest::_internal_dummy() const {
  return _impl_.dummy_;
}
inline uint32_t UserListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.UserListRequest.dummy)
  return _internal_dummy();
}
inline void UserListRequest::_internal_set_dummy(uint32_t value) {
  
  _impl_.dummy_ = value;
}
inline void UserListRequest::set_dummy(uint32_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:proto.UserListRequest.dummy)
}

// -------------------------------------------------------------------

// UserList

// .proto.UserList.ErrorCode error_code = 1;
inline void UserList::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::UserList_ErrorCode UserList::_internal_error_code() const {
  return static_cast< ::proto::UserList_ErrorCode >(_impl_.error_code_);
}
inline ::proto::UserList_ErrorCode UserList::error_code() const {
  // @@protoc_insertion_point(field_get:proto.UserList.error_code)
  return _internal_error_code();
}
inline void UserList::_internal_set_error_code(::proto::UserList_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void UserList::set_error_code(::proto::UserList_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.UserList.error_code)
}

// repeated .proto.User user = 2;
inline int UserList::_internal_user_size() const {
  return _impl_.user_.size();
}
inline int UserList::user_size() const {
  return _internal_user_size();
}
inline void UserList::clear_user() {
  _impl_.user_.Clear();
}
inline ::proto::User* UserList::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:proto.UserList.user)
  return _impl_.user_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >*
UserList::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:proto.UserList.user)
  return &_impl_.user_;
}
inline const ::proto::User& UserList::_internal_user(int index) const {
  return _impl_.user_.Get(index);
}
inline const ::proto::User& UserList::user(int index) const {
  // @@protoc_insertion_point(field_get:proto.UserList.user)
  return _internal_user(index);
}
inline ::proto::User* UserList::_internal_add_user() {
  return _impl_.user_.Add();
}
inline ::proto::User* UserList::add_user() {
  ::proto::User* _add = _internal_add_user();
  // @@protoc_insertion_point(field_add:proto.UserList.user)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::User >&
UserList::user() const {
  // @@protoc_insertion_point(field_list:proto.UserList.user)
  return _impl_.user_;
}

// -------------------------------------------------------------------

// UserRequest

// .proto.UserRequestType type = 1;
inline void UserRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::UserRequestType UserRequest::_internal_type() const {
  return static_cast< ::proto::UserRequestType >(_impl_.type_);
}
inline ::proto::UserRequestType UserRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.UserRequest.type)
  return _internal_type();
}
inline void UserRequest::_internal_set_type(::proto::UserRequestType value) {
  
  _impl_.type_ = value;
}
inline void UserRequest::set_type(::proto::UserRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.UserRequest.type)
}

// .proto.User user = 2;
inline bool UserRequest::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserRequest::has_user() const {
  return _internal_has_user();
}
inline void UserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::proto::User& UserRequest::_internal_user() const {
  const ::proto::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::User&>(
      ::proto::_User_default_instance_);
}
inline const ::proto::User& UserRequest::user() const {
  // @@protoc_insertion_point(field_get:proto.UserRequest.user)
  return _internal_user();
}
inline void UserRequest::unsafe_arena_set_allocated_user(
    ::proto::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.UserRequest.user)
}
inline ::proto::User* UserRequest::release_user() {
  
  ::proto::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::User* UserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:proto.UserRequest.user)
  
  ::proto::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::proto::User* UserRequest::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::proto::User* UserRequest::mutable_user() {
  ::proto::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:proto.UserRequest.user)
  return _msg;
}
inline void UserRequest::set_allocated_user(::proto::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:proto.UserRequest.user)
}

// -------------------------------------------------------------------

// UserResult

// .proto.UserRequestType type = 1;
inline void UserResult::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::UserRequestType UserResult::_internal_type() const {
  return static_cast< ::proto::UserRequestType >(_impl_.type_);
}
inline ::proto::UserRequestType UserResult::type() const {
  // @@protoc_insertion_point(field_get:proto.UserResult.type)
  return _internal_type();
}
inline void UserResult::_internal_set_type(::proto::UserRequestType value) {
  
  _impl_.type_ = value;
}
inline void UserResult::set_type(::proto::UserRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.UserResult.type)
}

// .proto.UserResult.ErrorCode error_code = 2;
inline void UserResult::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::UserResult_ErrorCode UserResult::_internal_error_code() const {
  return static_cast< ::proto::UserResult_ErrorCode >(_impl_.error_code_);
}
inline ::proto::UserResult_ErrorCode UserResult::error_code() const {
  // @@protoc_insertion_point(field_get:proto.UserResult.error_code)
  return _internal_error_code();
}
inline void UserResult::_internal_set_error_code(::proto::UserResult_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void UserResult::set_error_code(::proto::UserResult_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.UserResult.error_code)
}

// -------------------------------------------------------------------

// RouterToAdmin

// .proto.SessionList session_list = 1;
inline bool RouterToAdmin::_internal_has_session_list() const {
  return this != internal_default_instance() && _impl_.session_list_ != nullptr;
}
inline bool RouterToAdmin::has_session_list() const {
  return _internal_has_session_list();
}
inline void RouterToAdmin::clear_session_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_list_ != nullptr) {
    delete _impl_.session_list_;
  }
  _impl_.session_list_ = nullptr;
}
inline const ::proto::SessionList& RouterToAdmin::_internal_session_list() const {
  const ::proto::SessionList* p = _impl_.session_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SessionList&>(
      ::proto::_SessionList_default_instance_);
}
inline const ::proto::SessionList& RouterToAdmin::session_list() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.session_list)
  return _internal_session_list();
}
inline void RouterToAdmin::unsafe_arena_set_allocated_session_list(
    ::proto::SessionList* session_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_list_);
  }
  _impl_.session_list_ = session_list;
  if (session_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToAdmin.session_list)
}
inline ::proto::SessionList* RouterToAdmin::release_session_list() {
  
  ::proto::SessionList* temp = _impl_.session_list_;
  _impl_.session_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SessionList* RouterToAdmin::unsafe_arena_release_session_list() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.session_list)
  
  ::proto::SessionList* temp = _impl_.session_list_;
  _impl_.session_list_ = nullptr;
  return temp;
}
inline ::proto::SessionList* RouterToAdmin::_internal_mutable_session_list() {
  
  if (_impl_.session_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SessionList>(GetArenaForAllocation());
    _impl_.session_list_ = p;
  }
  return _impl_.session_list_;
}
inline ::proto::SessionList* RouterToAdmin::mutable_session_list() {
  ::proto::SessionList* _msg = _internal_mutable_session_list();
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.session_list)
  return _msg;
}
inline void RouterToAdmin::set_allocated_session_list(::proto::SessionList* session_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_list_;
  }
  if (session_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_list);
    if (message_arena != submessage_arena) {
      session_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_list_ = session_list;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.session_list)
}

// .proto.SessionResult session_result = 2;
inline bool RouterToAdmin::_internal_has_session_result() const {
  return this != internal_default_instance() && _impl_.session_result_ != nullptr;
}
inline bool RouterToAdmin::has_session_result() const {
  return _internal_has_session_result();
}
inline void RouterToAdmin::clear_session_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_result_ != nullptr) {
    delete _impl_.session_result_;
  }
  _impl_.session_result_ = nullptr;
}
inline const ::proto::SessionResult& RouterToAdmin::_internal_session_result() const {
  const ::proto::SessionResult* p = _impl_.session_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SessionResult&>(
      ::proto::_SessionResult_default_instance_);
}
inline const ::proto::SessionResult& RouterToAdmin::session_result() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.session_result)
  return _internal_session_result();
}
inline void RouterToAdmin::unsafe_arena_set_allocated_session_result(
    ::proto::SessionResult* session_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_result_);
  }
  _impl_.session_result_ = session_result;
  if (session_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToAdmin.session_result)
}
inline ::proto::SessionResult* RouterToAdmin::release_session_result() {
  
  ::proto::SessionResult* temp = _impl_.session_result_;
  _impl_.session_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SessionResult* RouterToAdmin::unsafe_arena_release_session_result() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.session_result)
  
  ::proto::SessionResult* temp = _impl_.session_result_;
  _impl_.session_result_ = nullptr;
  return temp;
}
inline ::proto::SessionResult* RouterToAdmin::_internal_mutable_session_result() {
  
  if (_impl_.session_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SessionResult>(GetArenaForAllocation());
    _impl_.session_result_ = p;
  }
  return _impl_.session_result_;
}
inline ::proto::SessionResult* RouterToAdmin::mutable_session_result() {
  ::proto::SessionResult* _msg = _internal_mutable_session_result();
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.session_result)
  return _msg;
}
inline void RouterToAdmin::set_allocated_session_result(::proto::SessionResult* session_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_result_;
  }
  if (session_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_result);
    if (message_arena != submessage_arena) {
      session_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_result_ = session_result;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.session_result)
}

// .proto.UserList user_list = 3;
inline bool RouterToAdmin::_internal_has_user_list() const {
  return this != internal_default_instance() && _impl_.user_list_ != nullptr;
}
inline bool RouterToAdmin::has_user_list() const {
  return _internal_has_user_list();
}
inline void RouterToAdmin::clear_user_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_list_ != nullptr) {
    delete _impl_.user_list_;
  }
  _impl_.user_list_ = nullptr;
}
inline const ::proto::UserList& RouterToAdmin::_internal_user_list() const {
  const ::proto::UserList* p = _impl_.user_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::UserList&>(
      ::proto::_UserList_default_instance_);
}
inline const ::proto::UserList& RouterToAdmin::user_list() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.user_list)
  return _internal_user_list();
}
inline void RouterToAdmin::unsafe_arena_set_allocated_user_list(
    ::proto::UserList* user_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_list_);
  }
  _impl_.user_list_ = user_list;
  if (user_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToAdmin.user_list)
}
inline ::proto::UserList* RouterToAdmin::release_user_list() {
  
  ::proto::UserList* temp = _impl_.user_list_;
  _impl_.user_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::UserList* RouterToAdmin::unsafe_arena_release_user_list() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.user_list)
  
  ::proto::UserList* temp = _impl_.user_list_;
  _impl_.user_list_ = nullptr;
  return temp;
}
inline ::proto::UserList* RouterToAdmin::_internal_mutable_user_list() {
  
  if (_impl_.user_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::UserList>(GetArenaForAllocation());
    _impl_.user_list_ = p;
  }
  return _impl_.user_list_;
}
inline ::proto::UserList* RouterToAdmin::mutable_user_list() {
  ::proto::UserList* _msg = _internal_mutable_user_list();
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.user_list)
  return _msg;
}
inline void RouterToAdmin::set_allocated_user_list(::proto::UserList* user_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_list_;
  }
  if (user_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_list);
    if (message_arena != submessage_arena) {
      user_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_list_ = user_list;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.user_list)
}

// .proto.UserResult user_result = 4;
inline bool RouterToAdmin::_internal_has_user_result() const {
  return this != internal_default_instance() && _impl_.user_result_ != nullptr;
}
inline bool RouterToAdmin::has_user_result() const {
  return _internal_has_user_result();
}
inline void RouterToAdmin::clear_user_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_result_ != nullptr) {
    delete _impl_.user_result_;
  }
  _impl_.user_result_ = nullptr;
}
inline const ::proto::UserResult& RouterToAdmin::_internal_user_result() const {
  const ::proto::UserResult* p = _impl_.user_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::UserResult&>(
      ::proto::_UserResult_default_instance_);
}
inline const ::proto::UserResult& RouterToAdmin::user_result() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.user_result)
  return _internal_user_result();
}
inline void RouterToAdmin::unsafe_arena_set_allocated_user_result(
    ::proto::UserResult* user_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_result_);
  }
  _impl_.user_result_ = user_result;
  if (user_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToAdmin.user_result)
}
inline ::proto::UserResult* RouterToAdmin::release_user_result() {
  
  ::proto::UserResult* temp = _impl_.user_result_;
  _impl_.user_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::UserResult* RouterToAdmin::unsafe_arena_release_user_result() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.user_result)
  
  ::proto::UserResult* temp = _impl_.user_result_;
  _impl_.user_result_ = nullptr;
  return temp;
}
inline ::proto::UserResult* RouterToAdmin::_internal_mutable_user_result() {
  
  if (_impl_.user_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::UserResult>(GetArenaForAllocation());
    _impl_.user_result_ = p;
  }
  return _impl_.user_result_;
}
inline ::proto::UserResult* RouterToAdmin::mutable_user_result() {
  ::proto::UserResult* _msg = _internal_mutable_user_result();
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.user_result)
  return _msg;
}
inline void RouterToAdmin::set_allocated_user_result(::proto::UserResult* user_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_result_;
  }
  if (user_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_result);
    if (message_arena != submessage_arena) {
      user_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_result_ = user_result;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.user_result)
}

// -------------------------------------------------------------------

// AdminToRouter

// .proto.SessionListRequest session_list_request = 1;
inline bool AdminToRouter::_internal_has_session_list_request() const {
  return this != internal_default_instance() && _impl_.session_list_request_ != nullptr;
}
inline bool AdminToRouter::has_session_list_request() const {
  return _internal_has_session_list_request();
}
inline void AdminToRouter::clear_session_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_list_request_ != nullptr) {
    delete _impl_.session_list_request_;
  }
  _impl_.session_list_request_ = nullptr;
}
inline const ::proto::SessionListRequest& AdminToRouter::_internal_session_list_request() const {
  const ::proto::SessionListRequest* p = _impl_.session_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SessionListRequest&>(
      ::proto::_SessionListRequest_default_instance_);
}
inline const ::proto::SessionListRequest& AdminToRouter::session_list_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.session_list_request)
  return _internal_session_list_request();
}
inline void AdminToRouter::unsafe_arena_set_allocated_session_list_request(
    ::proto::SessionListRequest* session_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_list_request_);
  }
  _impl_.session_list_request_ = session_list_request;
  if (session_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AdminToRouter.session_list_request)
}
inline ::proto::SessionListRequest* AdminToRouter::release_session_list_request() {
  
  ::proto::SessionListRequest* temp = _impl_.session_list_request_;
  _impl_.session_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SessionListRequest* AdminToRouter::unsafe_arena_release_session_list_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.session_list_request)
  
  ::proto::SessionListRequest* temp = _impl_.session_list_request_;
  _impl_.session_list_request_ = nullptr;
  return temp;
}
inline ::proto::SessionListRequest* AdminToRouter::_internal_mutable_session_list_request() {
  
  if (_impl_.session_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SessionListRequest>(GetArenaForAllocation());
    _impl_.session_list_request_ = p;
  }
  return _impl_.session_list_request_;
}
inline ::proto::SessionListRequest* AdminToRouter::mutable_session_list_request() {
  ::proto::SessionListRequest* _msg = _internal_mutable_session_list_request();
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.session_list_request)
  return _msg;
}
inline void AdminToRouter::set_allocated_session_list_request(::proto::SessionListRequest* session_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_list_request_;
  }
  if (session_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_list_request);
    if (message_arena != submessage_arena) {
      session_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_list_request_ = session_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.session_list_request)
}

// .proto.SessionRequest session_request = 2;
inline bool AdminToRouter::_internal_has_session_request() const {
  return this != internal_default_instance() && _impl_.session_request_ != nullptr;
}
inline bool AdminToRouter::has_session_request() const {
  return _internal_has_session_request();
}
inline void AdminToRouter::clear_session_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_request_ != nullptr) {
    delete _impl_.session_request_;
  }
  _impl_.session_request_ = nullptr;
}
inline const ::proto::SessionRequest& AdminToRouter::_internal_session_request() const {
  const ::proto::SessionRequest* p = _impl_.session_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SessionRequest&>(
      ::proto::_SessionRequest_default_instance_);
}
inline const ::proto::SessionRequest& AdminToRouter::session_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.session_request)
  return _internal_session_request();
}
inline void AdminToRouter::unsafe_arena_set_allocated_session_request(
    ::proto::SessionRequest* session_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_request_);
  }
  _impl_.session_request_ = session_request;
  if (session_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AdminToRouter.session_request)
}
inline ::proto::SessionRequest* AdminToRouter::release_session_request() {
  
  ::proto::SessionRequest* temp = _impl_.session_request_;
  _impl_.session_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SessionRequest* AdminToRouter::unsafe_arena_release_session_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.session_request)
  
  ::proto::SessionRequest* temp = _impl_.session_request_;
  _impl_.session_request_ = nullptr;
  return temp;
}
inline ::proto::SessionRequest* AdminToRouter::_internal_mutable_session_request() {
  
  if (_impl_.session_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SessionRequest>(GetArenaForAllocation());
    _impl_.session_request_ = p;
  }
  return _impl_.session_request_;
}
inline ::proto::SessionRequest* AdminToRouter::mutable_session_request() {
  ::proto::SessionRequest* _msg = _internal_mutable_session_request();
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.session_request)
  return _msg;
}
inline void AdminToRouter::set_allocated_session_request(::proto::SessionRequest* session_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_request_;
  }
  if (session_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_request);
    if (message_arena != submessage_arena) {
      session_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_request_ = session_request;
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.session_request)
}

// .proto.UserListRequest user_list_request = 3;
inline bool AdminToRouter::_internal_has_user_list_request() const {
  return this != internal_default_instance() && _impl_.user_list_request_ != nullptr;
}
inline bool AdminToRouter::has_user_list_request() const {
  return _internal_has_user_list_request();
}
inline void AdminToRouter::clear_user_list_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_list_request_ != nullptr) {
    delete _impl_.user_list_request_;
  }
  _impl_.user_list_request_ = nullptr;
}
inline const ::proto::UserListRequest& AdminToRouter::_internal_user_list_request() const {
  const ::proto::UserListRequest* p = _impl_.user_list_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::UserListRequest&>(
      ::proto::_UserListRequest_default_instance_);
}
inline const ::proto::UserListRequest& AdminToRouter::user_list_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.user_list_request)
  return _internal_user_list_request();
}
inline void AdminToRouter::unsafe_arena_set_allocated_user_list_request(
    ::proto::UserListRequest* user_list_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_list_request_);
  }
  _impl_.user_list_request_ = user_list_request;
  if (user_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AdminToRouter.user_list_request)
}
inline ::proto::UserListRequest* AdminToRouter::release_user_list_request() {
  
  ::proto::UserListRequest* temp = _impl_.user_list_request_;
  _impl_.user_list_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::UserListRequest* AdminToRouter::unsafe_arena_release_user_list_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.user_list_request)
  
  ::proto::UserListRequest* temp = _impl_.user_list_request_;
  _impl_.user_list_request_ = nullptr;
  return temp;
}
inline ::proto::UserListRequest* AdminToRouter::_internal_mutable_user_list_request() {
  
  if (_impl_.user_list_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::UserListRequest>(GetArenaForAllocation());
    _impl_.user_list_request_ = p;
  }
  return _impl_.user_list_request_;
}
inline ::proto::UserListRequest* AdminToRouter::mutable_user_list_request() {
  ::proto::UserListRequest* _msg = _internal_mutable_user_list_request();
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.user_list_request)
  return _msg;
}
inline void AdminToRouter::set_allocated_user_list_request(::proto::UserListRequest* user_list_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_list_request_;
  }
  if (user_list_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_list_request);
    if (message_arena != submessage_arena) {
      user_list_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_list_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_list_request_ = user_list_request;
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.user_list_request)
}

// .proto.UserRequest user_request = 4;
inline bool AdminToRouter::_internal_has_user_request() const {
  return this != internal_default_instance() && _impl_.user_request_ != nullptr;
}
inline bool AdminToRouter::has_user_request() const {
  return _internal_has_user_request();
}
inline void AdminToRouter::clear_user_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_request_ != nullptr) {
    delete _impl_.user_request_;
  }
  _impl_.user_request_ = nullptr;
}
inline const ::proto::UserRequest& AdminToRouter::_internal_user_request() const {
  const ::proto::UserRequest* p = _impl_.user_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::UserRequest&>(
      ::proto::_UserRequest_default_instance_);
}
inline const ::proto::UserRequest& AdminToRouter::user_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.user_request)
  return _internal_user_request();
}
inline void AdminToRouter::unsafe_arena_set_allocated_user_request(
    ::proto::UserRequest* user_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_request_);
  }
  _impl_.user_request_ = user_request;
  if (user_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AdminToRouter.user_request)
}
inline ::proto::UserRequest* AdminToRouter::release_user_request() {
  
  ::proto::UserRequest* temp = _impl_.user_request_;
  _impl_.user_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::UserRequest* AdminToRouter::unsafe_arena_release_user_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.user_request)
  
  ::proto::UserRequest* temp = _impl_.user_request_;
  _impl_.user_request_ = nullptr;
  return temp;
}
inline ::proto::UserRequest* AdminToRouter::_internal_mutable_user_request() {
  
  if (_impl_.user_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::UserRequest>(GetArenaForAllocation());
    _impl_.user_request_ = p;
  }
  return _impl_.user_request_;
}
inline ::proto::UserRequest* AdminToRouter::mutable_user_request() {
  ::proto::UserRequest* _msg = _internal_mutable_user_request();
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.user_request)
  return _msg;
}
inline void AdminToRouter::set_allocated_user_request(::proto::UserRequest* user_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_request_;
  }
  if (user_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_request);
    if (message_arena != submessage_arena) {
      user_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_request_ = user_request;
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.user_request)
}

// .proto.PeerConnectionRequest peer_connection_request = 5;
inline bool AdminToRouter::_internal_has_peer_connection_request() const {
  return this != internal_default_instance() && _impl_.peer_connection_request_ != nullptr;
}
inline bool AdminToRouter::has_peer_connection_request() const {
  return _internal_has_peer_connection_request();
}
inline const ::proto::PeerConnectionRequest& AdminToRouter::_internal_peer_connection_request() const {
  const ::proto::PeerConnectionRequest* p = _impl_.peer_connection_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PeerConnectionRequest&>(
      ::proto::_PeerConnectionRequest_default_instance_);
}
inline const ::proto::PeerConnectionRequest& AdminToRouter::peer_connection_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.peer_connection_request)
  return _internal_peer_connection_request();
}
inline void AdminToRouter::unsafe_arena_set_allocated_peer_connection_request(
    ::proto::PeerConnectionRequest* peer_connection_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_connection_request_);
  }
  _impl_.peer_connection_request_ = peer_connection_request;
  if (peer_connection_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AdminToRouter.peer_connection_request)
}
inline ::proto::PeerConnectionRequest* AdminToRouter::release_peer_connection_request() {
  
  ::proto::PeerConnectionRequest* temp = _impl_.peer_connection_request_;
  _impl_.peer_connection_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PeerConnectionRequest* AdminToRouter::unsafe_arena_release_peer_connection_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.peer_connection_request)
  
  ::proto::PeerConnectionRequest* temp = _impl_.peer_connection_request_;
  _impl_.peer_connection_request_ = nullptr;
  return temp;
}
inline ::proto::PeerConnectionRequest* AdminToRouter::_internal_mutable_peer_connection_request() {
  
  if (_impl_.peer_connection_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PeerConnectionRequest>(GetArenaForAllocation());
    _impl_.peer_connection_request_ = p;
  }
  return _impl_.peer_connection_request_;
}
inline ::proto::PeerConnectionRequest* AdminToRouter::mutable_peer_connection_request() {
  ::proto::PeerConnectionRequest* _msg = _internal_mutable_peer_connection_request();
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.peer_connection_request)
  return _msg;
}
inline void AdminToRouter::set_allocated_peer_connection_request(::proto::PeerConnectionRequest* peer_connection_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_connection_request_);
  }
  if (peer_connection_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_connection_request));
    if (message_arena != submessage_arena) {
      peer_connection_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_connection_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_connection_request_ = peer_connection_request;
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.peer_connection_request)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::SessionResult_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::SessionList_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::UserList_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::UserResult_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::SessionRequestType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::UserRequestType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_5fadmin_2eproto
