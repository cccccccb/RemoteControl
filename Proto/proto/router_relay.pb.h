// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_relay.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_5frelay_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_5frelay_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "router_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_5frelay_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_5frelay_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class RelayKeyPool;
struct RelayKeyPoolDefaultTypeInternal;
extern RelayKeyPoolDefaultTypeInternal _RelayKeyPool_default_instance_;
class RelayKeyUsed;
struct RelayKeyUsedDefaultTypeInternal;
extern RelayKeyUsedDefaultTypeInternal _RelayKeyUsed_default_instance_;
class RelayStat;
struct RelayStatDefaultTypeInternal;
extern RelayStatDefaultTypeInternal _RelayStat_default_instance_;
class RelayToRouter;
struct RelayToRouterDefaultTypeInternal;
extern RelayToRouterDefaultTypeInternal _RelayToRouter_default_instance_;
class RouterToRelay;
struct RouterToRelayDefaultTypeInternal;
extern RouterToRelayDefaultTypeInternal _RouterToRelay_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::RelayKeyPool* Arena::CreateMaybeMessage<::proto::RelayKeyPool>(Arena*);
template<> ::proto::RelayKeyUsed* Arena::CreateMaybeMessage<::proto::RelayKeyUsed>(Arena*);
template<> ::proto::RelayStat* Arena::CreateMaybeMessage<::proto::RelayStat>(Arena*);
template<> ::proto::RelayToRouter* Arena::CreateMaybeMessage<::proto::RelayToRouter>(Arena*);
template<> ::proto::RouterToRelay* Arena::CreateMaybeMessage<::proto::RouterToRelay>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class RelayKeyPool final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayKeyPool) */ {
 public:
  inline RelayKeyPool() : RelayKeyPool(nullptr) {}
  ~RelayKeyPool() override;
  explicit PROTOBUF_CONSTEXPR RelayKeyPool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayKeyPool(const RelayKeyPool& from);
  RelayKeyPool(RelayKeyPool&& from) noexcept
    : RelayKeyPool() {
    *this = ::std::move(from);
  }

  inline RelayKeyPool& operator=(const RelayKeyPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayKeyPool& operator=(RelayKeyPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelayKeyPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayKeyPool* internal_default_instance() {
    return reinterpret_cast<const RelayKeyPool*>(
               &_RelayKeyPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RelayKeyPool& a, RelayKeyPool& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayKeyPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayKeyPool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayKeyPool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayKeyPool>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelayKeyPool& from);
  void MergeFrom(const RelayKeyPool& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayKeyPool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelayKeyPool";
  }
  protected:
  explicit RelayKeyPool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 3,
    kPeerHostFieldNumber = 1,
    kPeerPortFieldNumber = 2,
  };
  // repeated .proto.RelayKey key = 3;
  int key_size() const;
  private:
  int _internal_key_size() const;
  public:
  void clear_key();
  ::proto::RelayKey* mutable_key(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RelayKey >*
      mutable_key();
  private:
  const ::proto::RelayKey& _internal_key(int index) const;
  ::proto::RelayKey* _internal_add_key();
  public:
  const ::proto::RelayKey& key(int index) const;
  ::proto::RelayKey* add_key();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RelayKey >&
      key() const;

  // string peer_host = 1;
  void clear_peer_host();
  const std::string& peer_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_host();
  PROTOBUF_NODISCARD std::string* release_peer_host();
  void set_allocated_peer_host(std::string* peer_host);
  private:
  const std::string& _internal_peer_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_host(const std::string& value);
  std::string* _internal_mutable_peer_host();
  public:

  // uint32 peer_port = 2;
  void clear_peer_port();
  uint32_t peer_port() const;
  void set_peer_port(uint32_t value);
  private:
  uint32_t _internal_peer_port() const;
  void _internal_set_peer_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelayKeyPool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RelayKey > key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_host_;
    uint32_t peer_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5frelay_2eproto;
};
// -------------------------------------------------------------------

class RelayKeyUsed final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayKeyUsed) */ {
 public:
  inline RelayKeyUsed() : RelayKeyUsed(nullptr) {}
  ~RelayKeyUsed() override;
  explicit PROTOBUF_CONSTEXPR RelayKeyUsed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayKeyUsed(const RelayKeyUsed& from);
  RelayKeyUsed(RelayKeyUsed&& from) noexcept
    : RelayKeyUsed() {
    *this = ::std::move(from);
  }

  inline RelayKeyUsed& operator=(const RelayKeyUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayKeyUsed& operator=(RelayKeyUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelayKeyUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayKeyUsed* internal_default_instance() {
    return reinterpret_cast<const RelayKeyUsed*>(
               &_RelayKeyUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RelayKeyUsed& a, RelayKeyUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayKeyUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayKeyUsed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayKeyUsed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayKeyUsed>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelayKeyUsed& from);
  void MergeFrom(const RelayKeyUsed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayKeyUsed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelayKeyUsed";
  }
  protected:
  explicit RelayKeyUsed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
  };
  // uint32 key_id = 1;
  void clear_key_id();
  uint32_t key_id() const;
  void set_key_id(uint32_t value);
  private:
  uint32_t _internal_key_id() const;
  void _internal_set_key_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelayKeyUsed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t key_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5frelay_2eproto;
};
// -------------------------------------------------------------------

class RelayStat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayStat) */ {
 public:
  inline RelayStat() : RelayStat(nullptr) {}
  ~RelayStat() override;
  explicit PROTOBUF_CONSTEXPR RelayStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayStat(const RelayStat& from);
  RelayStat(RelayStat&& from) noexcept
    : RelayStat() {
    *this = ::std::move(from);
  }

  inline RelayStat& operator=(const RelayStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayStat& operator=(RelayStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelayStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayStat* internal_default_instance() {
    return reinterpret_cast<const RelayStat*>(
               &_RelayStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RelayStat& a, RelayStat& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelayStat& from);
  void MergeFrom(const RelayStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelayStat";
  }
  protected:
  explicit RelayStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerConnectionFieldNumber = 1,
    kUptimeFieldNumber = 2,
  };
  // repeated .proto.PeerConnection peer_connection = 1;
  int peer_connection_size() const;
  private:
  int _internal_peer_connection_size() const;
  public:
  void clear_peer_connection();
  ::proto::PeerConnection* mutable_peer_connection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >*
      mutable_peer_connection();
  private:
  const ::proto::PeerConnection& _internal_peer_connection(int index) const;
  ::proto::PeerConnection* _internal_add_peer_connection();
  public:
  const ::proto::PeerConnection& peer_connection(int index) const;
  ::proto::PeerConnection* add_peer_connection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >&
      peer_connection() const;

  // int64 uptime = 2;
  void clear_uptime();
  int64_t uptime() const;
  void set_uptime(int64_t value);
  private:
  int64_t _internal_uptime() const;
  void _internal_set_uptime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RelayStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection > peer_connection_;
    int64_t uptime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5frelay_2eproto;
};
// -------------------------------------------------------------------

class RelayToRouter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayToRouter) */ {
 public:
  inline RelayToRouter() : RelayToRouter(nullptr) {}
  ~RelayToRouter() override;
  explicit PROTOBUF_CONSTEXPR RelayToRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayToRouter(const RelayToRouter& from);
  RelayToRouter(RelayToRouter&& from) noexcept
    : RelayToRouter() {
    *this = ::std::move(from);
  }

  inline RelayToRouter& operator=(const RelayToRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayToRouter& operator=(RelayToRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelayToRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayToRouter* internal_default_instance() {
    return reinterpret_cast<const RelayToRouter*>(
               &_RelayToRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RelayToRouter& a, RelayToRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayToRouter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayToRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayToRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayToRouter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RelayToRouter& from);
  void MergeFrom(const RelayToRouter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayToRouter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RelayToRouter";
  }
  protected:
  explicit RelayToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyPoolFieldNumber = 1,
    kRelayStatFieldNumber = 2,
  };
  // .proto.RelayKeyPool key_pool = 1;
  bool has_key_pool() const;
  private:
  bool _internal_has_key_pool() const;
  public:
  void clear_key_pool();
  const ::proto::RelayKeyPool& key_pool() const;
  PROTOBUF_NODISCARD ::proto::RelayKeyPool* release_key_pool();
  ::proto::RelayKeyPool* mutable_key_pool();
  void set_allocated_key_pool(::proto::RelayKeyPool* key_pool);
  private:
  const ::proto::RelayKeyPool& _internal_key_pool() const;
  ::proto::RelayKeyPool* _internal_mutable_key_pool();
  public:
  void unsafe_arena_set_allocated_key_pool(
      ::proto::RelayKeyPool* key_pool);
  ::proto::RelayKeyPool* unsafe_arena_release_key_pool();

  // .proto.RelayStat relay_stat = 2;
  bool has_relay_stat() const;
  private:
  bool _internal_has_relay_stat() const;
  public:
  void clear_relay_stat();
  const ::proto::RelayStat& relay_stat() const;
  PROTOBUF_NODISCARD ::proto::RelayStat* release_relay_stat();
  ::proto::RelayStat* mutable_relay_stat();
  void set_allocated_relay_stat(::proto::RelayStat* relay_stat);
  private:
  const ::proto::RelayStat& _internal_relay_stat() const;
  ::proto::RelayStat* _internal_mutable_relay_stat();
  public:
  void unsafe_arena_set_allocated_relay_stat(
      ::proto::RelayStat* relay_stat);
  ::proto::RelayStat* unsafe_arena_release_relay_stat();

  // @@protoc_insertion_point(class_scope:proto.RelayToRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::RelayKeyPool* key_pool_;
    ::proto::RelayStat* relay_stat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5frelay_2eproto;
};
// -------------------------------------------------------------------

class RouterToRelay final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RouterToRelay) */ {
 public:
  inline RouterToRelay() : RouterToRelay(nullptr) {}
  ~RouterToRelay() override;
  explicit PROTOBUF_CONSTEXPR RouterToRelay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterToRelay(const RouterToRelay& from);
  RouterToRelay(RouterToRelay&& from) noexcept
    : RouterToRelay() {
    *this = ::std::move(from);
  }

  inline RouterToRelay& operator=(const RouterToRelay& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterToRelay& operator=(RouterToRelay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RouterToRelay& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterToRelay* internal_default_instance() {
    return reinterpret_cast<const RouterToRelay*>(
               &_RouterToRelay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RouterToRelay& a, RouterToRelay& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterToRelay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterToRelay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterToRelay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterToRelay>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RouterToRelay& from);
  void MergeFrom(const RouterToRelay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouterToRelay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RouterToRelay";
  }
  protected:
  explicit RouterToRelay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyUsedFieldNumber = 1,
    kPeerConnectionRequestFieldNumber = 2,
  };
  // .proto.RelayKeyUsed key_used = 1;
  bool has_key_used() const;
  private:
  bool _internal_has_key_used() const;
  public:
  void clear_key_used();
  const ::proto::RelayKeyUsed& key_used() const;
  PROTOBUF_NODISCARD ::proto::RelayKeyUsed* release_key_used();
  ::proto::RelayKeyUsed* mutable_key_used();
  void set_allocated_key_used(::proto::RelayKeyUsed* key_used);
  private:
  const ::proto::RelayKeyUsed& _internal_key_used() const;
  ::proto::RelayKeyUsed* _internal_mutable_key_used();
  public:
  void unsafe_arena_set_allocated_key_used(
      ::proto::RelayKeyUsed* key_used);
  ::proto::RelayKeyUsed* unsafe_arena_release_key_used();

  // .proto.PeerConnectionRequest peer_connection_request = 2;
  bool has_peer_connection_request() const;
  private:
  bool _internal_has_peer_connection_request() const;
  public:
  void clear_peer_connection_request();
  const ::proto::PeerConnectionRequest& peer_connection_request() const;
  PROTOBUF_NODISCARD ::proto::PeerConnectionRequest* release_peer_connection_request();
  ::proto::PeerConnectionRequest* mutable_peer_connection_request();
  void set_allocated_peer_connection_request(::proto::PeerConnectionRequest* peer_connection_request);
  private:
  const ::proto::PeerConnectionRequest& _internal_peer_connection_request() const;
  ::proto::PeerConnectionRequest* _internal_mutable_peer_connection_request();
  public:
  void unsafe_arena_set_allocated_peer_connection_request(
      ::proto::PeerConnectionRequest* peer_connection_request);
  ::proto::PeerConnectionRequest* unsafe_arena_release_peer_connection_request();

  // @@protoc_insertion_point(class_scope:proto.RouterToRelay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::RelayKeyUsed* key_used_;
    ::proto::PeerConnectionRequest* peer_connection_request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5frelay_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RelayKeyPool

// string peer_host = 1;
inline void RelayKeyPool::clear_peer_host() {
  _impl_.peer_host_.ClearToEmpty();
}
inline const std::string& RelayKeyPool::peer_host() const {
  // @@protoc_insertion_point(field_get:proto.RelayKeyPool.peer_host)
  return _internal_peer_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelayKeyPool::set_peer_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.peer_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RelayKeyPool.peer_host)
}
inline std::string* RelayKeyPool::mutable_peer_host() {
  std::string* _s = _internal_mutable_peer_host();
  // @@protoc_insertion_point(field_mutable:proto.RelayKeyPool.peer_host)
  return _s;
}
inline const std::string& RelayKeyPool::_internal_peer_host() const {
  return _impl_.peer_host_.Get();
}
inline void RelayKeyPool::_internal_set_peer_host(const std::string& value) {
  
  _impl_.peer_host_.Set(value, GetArenaForAllocation());
}
inline std::string* RelayKeyPool::_internal_mutable_peer_host() {
  
  return _impl_.peer_host_.Mutable(GetArenaForAllocation());
}
inline std::string* RelayKeyPool::release_peer_host() {
  // @@protoc_insertion_point(field_release:proto.RelayKeyPool.peer_host)
  return _impl_.peer_host_.Release();
}
inline void RelayKeyPool::set_allocated_peer_host(std::string* peer_host) {
  if (peer_host != nullptr) {
    
  } else {
    
  }
  _impl_.peer_host_.SetAllocated(peer_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.peer_host_.IsDefault()) {
    _impl_.peer_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RelayKeyPool.peer_host)
}

// uint32 peer_port = 2;
inline void RelayKeyPool::clear_peer_port() {
  _impl_.peer_port_ = 0u;
}
inline uint32_t RelayKeyPool::_internal_peer_port() const {
  return _impl_.peer_port_;
}
inline uint32_t RelayKeyPool::peer_port() const {
  // @@protoc_insertion_point(field_get:proto.RelayKeyPool.peer_port)
  return _internal_peer_port();
}
inline void RelayKeyPool::_internal_set_peer_port(uint32_t value) {
  
  _impl_.peer_port_ = value;
}
inline void RelayKeyPool::set_peer_port(uint32_t value) {
  _internal_set_peer_port(value);
  // @@protoc_insertion_point(field_set:proto.RelayKeyPool.peer_port)
}

// repeated .proto.RelayKey key = 3;
inline int RelayKeyPool::_internal_key_size() const {
  return _impl_.key_.size();
}
inline int RelayKeyPool::key_size() const {
  return _internal_key_size();
}
inline ::proto::RelayKey* RelayKeyPool::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:proto.RelayKeyPool.key)
  return _impl_.key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RelayKey >*
RelayKeyPool::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:proto.RelayKeyPool.key)
  return &_impl_.key_;
}
inline const ::proto::RelayKey& RelayKeyPool::_internal_key(int index) const {
  return _impl_.key_.Get(index);
}
inline const ::proto::RelayKey& RelayKeyPool::key(int index) const {
  // @@protoc_insertion_point(field_get:proto.RelayKeyPool.key)
  return _internal_key(index);
}
inline ::proto::RelayKey* RelayKeyPool::_internal_add_key() {
  return _impl_.key_.Add();
}
inline ::proto::RelayKey* RelayKeyPool::add_key() {
  ::proto::RelayKey* _add = _internal_add_key();
  // @@protoc_insertion_point(field_add:proto.RelayKeyPool.key)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RelayKey >&
RelayKeyPool::key() const {
  // @@protoc_insertion_point(field_list:proto.RelayKeyPool.key)
  return _impl_.key_;
}

// -------------------------------------------------------------------

// RelayKeyUsed

// uint32 key_id = 1;
inline void RelayKeyUsed::clear_key_id() {
  _impl_.key_id_ = 0u;
}
inline uint32_t RelayKeyUsed::_internal_key_id() const {
  return _impl_.key_id_;
}
inline uint32_t RelayKeyUsed::key_id() const {
  // @@protoc_insertion_point(field_get:proto.RelayKeyUsed.key_id)
  return _internal_key_id();
}
inline void RelayKeyUsed::_internal_set_key_id(uint32_t value) {
  
  _impl_.key_id_ = value;
}
inline void RelayKeyUsed::set_key_id(uint32_t value) {
  _internal_set_key_id(value);
  // @@protoc_insertion_point(field_set:proto.RelayKeyUsed.key_id)
}

// -------------------------------------------------------------------

// RelayStat

// repeated .proto.PeerConnection peer_connection = 1;
inline int RelayStat::_internal_peer_connection_size() const {
  return _impl_.peer_connection_.size();
}
inline int RelayStat::peer_connection_size() const {
  return _internal_peer_connection_size();
}
inline ::proto::PeerConnection* RelayStat::mutable_peer_connection(int index) {
  // @@protoc_insertion_point(field_mutable:proto.RelayStat.peer_connection)
  return _impl_.peer_connection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >*
RelayStat::mutable_peer_connection() {
  // @@protoc_insertion_point(field_mutable_list:proto.RelayStat.peer_connection)
  return &_impl_.peer_connection_;
}
inline const ::proto::PeerConnection& RelayStat::_internal_peer_connection(int index) const {
  return _impl_.peer_connection_.Get(index);
}
inline const ::proto::PeerConnection& RelayStat::peer_connection(int index) const {
  // @@protoc_insertion_point(field_get:proto.RelayStat.peer_connection)
  return _internal_peer_connection(index);
}
inline ::proto::PeerConnection* RelayStat::_internal_add_peer_connection() {
  return _impl_.peer_connection_.Add();
}
inline ::proto::PeerConnection* RelayStat::add_peer_connection() {
  ::proto::PeerConnection* _add = _internal_add_peer_connection();
  // @@protoc_insertion_point(field_add:proto.RelayStat.peer_connection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PeerConnection >&
RelayStat::peer_connection() const {
  // @@protoc_insertion_point(field_list:proto.RelayStat.peer_connection)
  return _impl_.peer_connection_;
}

// int64 uptime = 2;
inline void RelayStat::clear_uptime() {
  _impl_.uptime_ = int64_t{0};
}
inline int64_t RelayStat::_internal_uptime() const {
  return _impl_.uptime_;
}
inline int64_t RelayStat::uptime() const {
  // @@protoc_insertion_point(field_get:proto.RelayStat.uptime)
  return _internal_uptime();
}
inline void RelayStat::_internal_set_uptime(int64_t value) {
  
  _impl_.uptime_ = value;
}
inline void RelayStat::set_uptime(int64_t value) {
  _internal_set_uptime(value);
  // @@protoc_insertion_point(field_set:proto.RelayStat.uptime)
}

// -------------------------------------------------------------------

// RelayToRouter

// .proto.RelayKeyPool key_pool = 1;
inline bool RelayToRouter::_internal_has_key_pool() const {
  return this != internal_default_instance() && _impl_.key_pool_ != nullptr;
}
inline bool RelayToRouter::has_key_pool() const {
  return _internal_has_key_pool();
}
inline void RelayToRouter::clear_key_pool() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_pool_ != nullptr) {
    delete _impl_.key_pool_;
  }
  _impl_.key_pool_ = nullptr;
}
inline const ::proto::RelayKeyPool& RelayToRouter::_internal_key_pool() const {
  const ::proto::RelayKeyPool* p = _impl_.key_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RelayKeyPool&>(
      ::proto::_RelayKeyPool_default_instance_);
}
inline const ::proto::RelayKeyPool& RelayToRouter::key_pool() const {
  // @@protoc_insertion_point(field_get:proto.RelayToRouter.key_pool)
  return _internal_key_pool();
}
inline void RelayToRouter::unsafe_arena_set_allocated_key_pool(
    ::proto::RelayKeyPool* key_pool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_pool_);
  }
  _impl_.key_pool_ = key_pool;
  if (key_pool) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RelayToRouter.key_pool)
}
inline ::proto::RelayKeyPool* RelayToRouter::release_key_pool() {
  
  ::proto::RelayKeyPool* temp = _impl_.key_pool_;
  _impl_.key_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RelayKeyPool* RelayToRouter::unsafe_arena_release_key_pool() {
  // @@protoc_insertion_point(field_release:proto.RelayToRouter.key_pool)
  
  ::proto::RelayKeyPool* temp = _impl_.key_pool_;
  _impl_.key_pool_ = nullptr;
  return temp;
}
inline ::proto::RelayKeyPool* RelayToRouter::_internal_mutable_key_pool() {
  
  if (_impl_.key_pool_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RelayKeyPool>(GetArenaForAllocation());
    _impl_.key_pool_ = p;
  }
  return _impl_.key_pool_;
}
inline ::proto::RelayKeyPool* RelayToRouter::mutable_key_pool() {
  ::proto::RelayKeyPool* _msg = _internal_mutable_key_pool();
  // @@protoc_insertion_point(field_mutable:proto.RelayToRouter.key_pool)
  return _msg;
}
inline void RelayToRouter::set_allocated_key_pool(::proto::RelayKeyPool* key_pool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_pool_;
  }
  if (key_pool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_pool);
    if (message_arena != submessage_arena) {
      key_pool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_pool, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_pool_ = key_pool;
  // @@protoc_insertion_point(field_set_allocated:proto.RelayToRouter.key_pool)
}

// .proto.RelayStat relay_stat = 2;
inline bool RelayToRouter::_internal_has_relay_stat() const {
  return this != internal_default_instance() && _impl_.relay_stat_ != nullptr;
}
inline bool RelayToRouter::has_relay_stat() const {
  return _internal_has_relay_stat();
}
inline void RelayToRouter::clear_relay_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.relay_stat_ != nullptr) {
    delete _impl_.relay_stat_;
  }
  _impl_.relay_stat_ = nullptr;
}
inline const ::proto::RelayStat& RelayToRouter::_internal_relay_stat() const {
  const ::proto::RelayStat* p = _impl_.relay_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RelayStat&>(
      ::proto::_RelayStat_default_instance_);
}
inline const ::proto::RelayStat& RelayToRouter::relay_stat() const {
  // @@protoc_insertion_point(field_get:proto.RelayToRouter.relay_stat)
  return _internal_relay_stat();
}
inline void RelayToRouter::unsafe_arena_set_allocated_relay_stat(
    ::proto::RelayStat* relay_stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relay_stat_);
  }
  _impl_.relay_stat_ = relay_stat;
  if (relay_stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RelayToRouter.relay_stat)
}
inline ::proto::RelayStat* RelayToRouter::release_relay_stat() {
  
  ::proto::RelayStat* temp = _impl_.relay_stat_;
  _impl_.relay_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RelayStat* RelayToRouter::unsafe_arena_release_relay_stat() {
  // @@protoc_insertion_point(field_release:proto.RelayToRouter.relay_stat)
  
  ::proto::RelayStat* temp = _impl_.relay_stat_;
  _impl_.relay_stat_ = nullptr;
  return temp;
}
inline ::proto::RelayStat* RelayToRouter::_internal_mutable_relay_stat() {
  
  if (_impl_.relay_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RelayStat>(GetArenaForAllocation());
    _impl_.relay_stat_ = p;
  }
  return _impl_.relay_stat_;
}
inline ::proto::RelayStat* RelayToRouter::mutable_relay_stat() {
  ::proto::RelayStat* _msg = _internal_mutable_relay_stat();
  // @@protoc_insertion_point(field_mutable:proto.RelayToRouter.relay_stat)
  return _msg;
}
inline void RelayToRouter::set_allocated_relay_stat(::proto::RelayStat* relay_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relay_stat_;
  }
  if (relay_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relay_stat);
    if (message_arena != submessage_arena) {
      relay_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relay_stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relay_stat_ = relay_stat;
  // @@protoc_insertion_point(field_set_allocated:proto.RelayToRouter.relay_stat)
}

// -------------------------------------------------------------------

// RouterToRelay

// .proto.RelayKeyUsed key_used = 1;
inline bool RouterToRelay::_internal_has_key_used() const {
  return this != internal_default_instance() && _impl_.key_used_ != nullptr;
}
inline bool RouterToRelay::has_key_used() const {
  return _internal_has_key_used();
}
inline void RouterToRelay::clear_key_used() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_used_ != nullptr) {
    delete _impl_.key_used_;
  }
  _impl_.key_used_ = nullptr;
}
inline const ::proto::RelayKeyUsed& RouterToRelay::_internal_key_used() const {
  const ::proto::RelayKeyUsed* p = _impl_.key_used_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RelayKeyUsed&>(
      ::proto::_RelayKeyUsed_default_instance_);
}
inline const ::proto::RelayKeyUsed& RouterToRelay::key_used() const {
  // @@protoc_insertion_point(field_get:proto.RouterToRelay.key_used)
  return _internal_key_used();
}
inline void RouterToRelay::unsafe_arena_set_allocated_key_used(
    ::proto::RelayKeyUsed* key_used) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_used_);
  }
  _impl_.key_used_ = key_used;
  if (key_used) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToRelay.key_used)
}
inline ::proto::RelayKeyUsed* RouterToRelay::release_key_used() {
  
  ::proto::RelayKeyUsed* temp = _impl_.key_used_;
  _impl_.key_used_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RelayKeyUsed* RouterToRelay::unsafe_arena_release_key_used() {
  // @@protoc_insertion_point(field_release:proto.RouterToRelay.key_used)
  
  ::proto::RelayKeyUsed* temp = _impl_.key_used_;
  _impl_.key_used_ = nullptr;
  return temp;
}
inline ::proto::RelayKeyUsed* RouterToRelay::_internal_mutable_key_used() {
  
  if (_impl_.key_used_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RelayKeyUsed>(GetArenaForAllocation());
    _impl_.key_used_ = p;
  }
  return _impl_.key_used_;
}
inline ::proto::RelayKeyUsed* RouterToRelay::mutable_key_used() {
  ::proto::RelayKeyUsed* _msg = _internal_mutable_key_used();
  // @@protoc_insertion_point(field_mutable:proto.RouterToRelay.key_used)
  return _msg;
}
inline void RouterToRelay::set_allocated_key_used(::proto::RelayKeyUsed* key_used) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_used_;
  }
  if (key_used) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_used);
    if (message_arena != submessage_arena) {
      key_used = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_used, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_used_ = key_used;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToRelay.key_used)
}

// .proto.PeerConnectionRequest peer_connection_request = 2;
inline bool RouterToRelay::_internal_has_peer_connection_request() const {
  return this != internal_default_instance() && _impl_.peer_connection_request_ != nullptr;
}
inline bool RouterToRelay::has_peer_connection_request() const {
  return _internal_has_peer_connection_request();
}
inline const ::proto::PeerConnectionRequest& RouterToRelay::_internal_peer_connection_request() const {
  const ::proto::PeerConnectionRequest* p = _impl_.peer_connection_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PeerConnectionRequest&>(
      ::proto::_PeerConnectionRequest_default_instance_);
}
inline const ::proto::PeerConnectionRequest& RouterToRelay::peer_connection_request() const {
  // @@protoc_insertion_point(field_get:proto.RouterToRelay.peer_connection_request)
  return _internal_peer_connection_request();
}
inline void RouterToRelay::unsafe_arena_set_allocated_peer_connection_request(
    ::proto::PeerConnectionRequest* peer_connection_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_connection_request_);
  }
  _impl_.peer_connection_request_ = peer_connection_request;
  if (peer_connection_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToRelay.peer_connection_request)
}
inline ::proto::PeerConnectionRequest* RouterToRelay::release_peer_connection_request() {
  
  ::proto::PeerConnectionRequest* temp = _impl_.peer_connection_request_;
  _impl_.peer_connection_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PeerConnectionRequest* RouterToRelay::unsafe_arena_release_peer_connection_request() {
  // @@protoc_insertion_point(field_release:proto.RouterToRelay.peer_connection_request)
  
  ::proto::PeerConnectionRequest* temp = _impl_.peer_connection_request_;
  _impl_.peer_connection_request_ = nullptr;
  return temp;
}
inline ::proto::PeerConnectionRequest* RouterToRelay::_internal_mutable_peer_connection_request() {
  
  if (_impl_.peer_connection_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PeerConnectionRequest>(GetArenaForAllocation());
    _impl_.peer_connection_request_ = p;
  }
  return _impl_.peer_connection_request_;
}
inline ::proto::PeerConnectionRequest* RouterToRelay::mutable_peer_connection_request() {
  ::proto::PeerConnectionRequest* _msg = _internal_mutable_peer_connection_request();
  // @@protoc_insertion_point(field_mutable:proto.RouterToRelay.peer_connection_request)
  return _msg;
}
inline void RouterToRelay::set_allocated_peer_connection_request(::proto::PeerConnectionRequest* peer_connection_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_connection_request_);
  }
  if (peer_connection_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_connection_request));
    if (message_arena != submessage_arena) {
      peer_connection_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_connection_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_connection_request_ = peer_connection_request;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToRelay.peer_connection_request)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_5frelay_2eproto
