// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_peer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_5fpeer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_5fpeer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "router_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_5fpeer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_5fpeer_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class CheckHostStatus;
struct CheckHostStatusDefaultTypeInternal;
extern CheckHostStatusDefaultTypeInternal _CheckHostStatus_default_instance_;
class ConnectionOffer;
struct ConnectionOfferDefaultTypeInternal;
extern ConnectionOfferDefaultTypeInternal _ConnectionOffer_default_instance_;
class ConnectionRequest;
struct ConnectionRequestDefaultTypeInternal;
extern ConnectionRequestDefaultTypeInternal _ConnectionRequest_default_instance_;
class HostIdRequest;
struct HostIdRequestDefaultTypeInternal;
extern HostIdRequestDefaultTypeInternal _HostIdRequest_default_instance_;
class HostIdResponse;
struct HostIdResponseDefaultTypeInternal;
extern HostIdResponseDefaultTypeInternal _HostIdResponse_default_instance_;
class HostOfferData;
struct HostOfferDataDefaultTypeInternal;
extern HostOfferDataDefaultTypeInternal _HostOfferData_default_instance_;
class HostStatus;
struct HostStatusDefaultTypeInternal;
extern HostStatusDefaultTypeInternal _HostStatus_default_instance_;
class PeerToRouter;
struct PeerToRouterDefaultTypeInternal;
extern PeerToRouterDefaultTypeInternal _PeerToRouter_default_instance_;
class ResetHostId;
struct ResetHostIdDefaultTypeInternal;
extern ResetHostIdDefaultTypeInternal _ResetHostId_default_instance_;
class RouterToPeer;
struct RouterToPeerDefaultTypeInternal;
extern RouterToPeerDefaultTypeInternal _RouterToPeer_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::CheckHostStatus* Arena::CreateMaybeMessage<::proto::CheckHostStatus>(Arena*);
template<> ::proto::ConnectionOffer* Arena::CreateMaybeMessage<::proto::ConnectionOffer>(Arena*);
template<> ::proto::ConnectionRequest* Arena::CreateMaybeMessage<::proto::ConnectionRequest>(Arena*);
template<> ::proto::HostIdRequest* Arena::CreateMaybeMessage<::proto::HostIdRequest>(Arena*);
template<> ::proto::HostIdResponse* Arena::CreateMaybeMessage<::proto::HostIdResponse>(Arena*);
template<> ::proto::HostOfferData* Arena::CreateMaybeMessage<::proto::HostOfferData>(Arena*);
template<> ::proto::HostStatus* Arena::CreateMaybeMessage<::proto::HostStatus>(Arena*);
template<> ::proto::PeerToRouter* Arena::CreateMaybeMessage<::proto::PeerToRouter>(Arena*);
template<> ::proto::ResetHostId* Arena::CreateMaybeMessage<::proto::ResetHostId>(Arena*);
template<> ::proto::RouterToPeer* Arena::CreateMaybeMessage<::proto::RouterToPeer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum HostIdRequest_Type : int {
  HostIdRequest_Type_UNKNOWN = 0,
  HostIdRequest_Type_NEW_ID = 1,
  HostIdRequest_Type_EXISTING_ID = 2,
  HostIdRequest_Type_HostIdRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HostIdRequest_Type_HostIdRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HostIdRequest_Type_IsValid(int value);
constexpr HostIdRequest_Type HostIdRequest_Type_Type_MIN = HostIdRequest_Type_UNKNOWN;
constexpr HostIdRequest_Type HostIdRequest_Type_Type_MAX = HostIdRequest_Type_EXISTING_ID;
constexpr int HostIdRequest_Type_Type_ARRAYSIZE = HostIdRequest_Type_Type_MAX + 1;

const std::string& HostIdRequest_Type_Name(HostIdRequest_Type value);
template<typename T>
inline const std::string& HostIdRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HostIdRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HostIdRequest_Type_Name.");
  return HostIdRequest_Type_Name(static_cast<HostIdRequest_Type>(enum_t_value));
}
bool HostIdRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostIdRequest_Type* value);
enum HostIdResponse_ErrorCode : int {
  HostIdResponse_ErrorCode_SUCCESS = 0,
  HostIdResponse_ErrorCode_UNKNOWN = 1,
  HostIdResponse_ErrorCode_NO_HOST_FOUND = 2,
  HostIdResponse_ErrorCode_HostIdResponse_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HostIdResponse_ErrorCode_HostIdResponse_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HostIdResponse_ErrorCode_IsValid(int value);
constexpr HostIdResponse_ErrorCode HostIdResponse_ErrorCode_ErrorCode_MIN = HostIdResponse_ErrorCode_SUCCESS;
constexpr HostIdResponse_ErrorCode HostIdResponse_ErrorCode_ErrorCode_MAX = HostIdResponse_ErrorCode_NO_HOST_FOUND;
constexpr int HostIdResponse_ErrorCode_ErrorCode_ARRAYSIZE = HostIdResponse_ErrorCode_ErrorCode_MAX + 1;

const std::string& HostIdResponse_ErrorCode_Name(HostIdResponse_ErrorCode value);
template<typename T>
inline const std::string& HostIdResponse_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HostIdResponse_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HostIdResponse_ErrorCode_Name.");
  return HostIdResponse_ErrorCode_Name(static_cast<HostIdResponse_ErrorCode>(enum_t_value));
}
bool HostIdResponse_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostIdResponse_ErrorCode* value);
enum ConnectionOffer_PeerRole : int {
  ConnectionOffer_PeerRole_HOST = 0,
  ConnectionOffer_PeerRole_CLIENT = 1,
  ConnectionOffer_PeerRole_ConnectionOffer_PeerRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnectionOffer_PeerRole_ConnectionOffer_PeerRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnectionOffer_PeerRole_IsValid(int value);
constexpr ConnectionOffer_PeerRole ConnectionOffer_PeerRole_PeerRole_MIN = ConnectionOffer_PeerRole_HOST;
constexpr ConnectionOffer_PeerRole ConnectionOffer_PeerRole_PeerRole_MAX = ConnectionOffer_PeerRole_CLIENT;
constexpr int ConnectionOffer_PeerRole_PeerRole_ARRAYSIZE = ConnectionOffer_PeerRole_PeerRole_MAX + 1;

const std::string& ConnectionOffer_PeerRole_Name(ConnectionOffer_PeerRole value);
template<typename T>
inline const std::string& ConnectionOffer_PeerRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionOffer_PeerRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionOffer_PeerRole_Name.");
  return ConnectionOffer_PeerRole_Name(static_cast<ConnectionOffer_PeerRole>(enum_t_value));
}
bool ConnectionOffer_PeerRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionOffer_PeerRole* value);
enum ConnectionOffer_ErrorCode : int {
  ConnectionOffer_ErrorCode_SUCCESS = 0,
  ConnectionOffer_ErrorCode_UNKNOWN_ERROR = 1,
  ConnectionOffer_ErrorCode_PEER_NOT_FOUND = 2,
  ConnectionOffer_ErrorCode_ACCESS_DENIED = 3,
  ConnectionOffer_ErrorCode_KEY_POOL_EMPTY = 4,
  ConnectionOffer_ErrorCode_ConnectionOffer_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnectionOffer_ErrorCode_ConnectionOffer_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnectionOffer_ErrorCode_IsValid(int value);
constexpr ConnectionOffer_ErrorCode ConnectionOffer_ErrorCode_ErrorCode_MIN = ConnectionOffer_ErrorCode_SUCCESS;
constexpr ConnectionOffer_ErrorCode ConnectionOffer_ErrorCode_ErrorCode_MAX = ConnectionOffer_ErrorCode_KEY_POOL_EMPTY;
constexpr int ConnectionOffer_ErrorCode_ErrorCode_ARRAYSIZE = ConnectionOffer_ErrorCode_ErrorCode_MAX + 1;

const std::string& ConnectionOffer_ErrorCode_Name(ConnectionOffer_ErrorCode value);
template<typename T>
inline const std::string& ConnectionOffer_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionOffer_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionOffer_ErrorCode_Name.");
  return ConnectionOffer_ErrorCode_Name(static_cast<ConnectionOffer_ErrorCode>(enum_t_value));
}
bool ConnectionOffer_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionOffer_ErrorCode* value);
enum HostStatus_Status : int {
  HostStatus_Status_STATUS_UNKNOWN = 0,
  HostStatus_Status_STATUS_OFFLINE = 1,
  HostStatus_Status_STATUS_ONLINE = 2,
  HostStatus_Status_HostStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HostStatus_Status_HostStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HostStatus_Status_IsValid(int value);
constexpr HostStatus_Status HostStatus_Status_Status_MIN = HostStatus_Status_STATUS_UNKNOWN;
constexpr HostStatus_Status HostStatus_Status_Status_MAX = HostStatus_Status_STATUS_ONLINE;
constexpr int HostStatus_Status_Status_ARRAYSIZE = HostStatus_Status_Status_MAX + 1;

const std::string& HostStatus_Status_Name(HostStatus_Status value);
template<typename T>
inline const std::string& HostStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HostStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HostStatus_Status_Name.");
  return HostStatus_Status_Name(static_cast<HostStatus_Status>(enum_t_value));
}
bool HostStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostStatus_Status* value);
// ===================================================================

class HostIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostIdRequest) */ {
 public:
  inline HostIdRequest() : HostIdRequest(nullptr) {}
  ~HostIdRequest() override;
  explicit PROTOBUF_CONSTEXPR HostIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostIdRequest(const HostIdRequest& from);
  HostIdRequest(HostIdRequest&& from) noexcept
    : HostIdRequest() {
    *this = ::std::move(from);
  }

  inline HostIdRequest& operator=(const HostIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostIdRequest& operator=(HostIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostIdRequest* internal_default_instance() {
    return reinterpret_cast<const HostIdRequest*>(
               &_HostIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HostIdRequest& a, HostIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HostIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostIdRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostIdRequest& from);
  void MergeFrom(const HostIdRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HostIdRequest";
  }
  protected:
  explicit HostIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef HostIdRequest_Type Type;
  static constexpr Type UNKNOWN =
    HostIdRequest_Type_UNKNOWN;
  static constexpr Type NEW_ID =
    HostIdRequest_Type_NEW_ID;
  static constexpr Type EXISTING_ID =
    HostIdRequest_Type_EXISTING_ID;
  static inline bool Type_IsValid(int value) {
    return HostIdRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    HostIdRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    HostIdRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    HostIdRequest_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return HostIdRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return HostIdRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .proto.HostIdRequest.Type type = 1;
  void clear_type();
  ::proto::HostIdRequest_Type type() const;
  void set_type(::proto::HostIdRequest_Type value);
  private:
  ::proto::HostIdRequest_Type _internal_type() const;
  void _internal_set_type(::proto::HostIdRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HostIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class ResetHostId final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ResetHostId) */ {
 public:
  inline ResetHostId() : ResetHostId(nullptr) {}
  ~ResetHostId() override;
  explicit PROTOBUF_CONSTEXPR ResetHostId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetHostId(const ResetHostId& from);
  ResetHostId(ResetHostId&& from) noexcept
    : ResetHostId() {
    *this = ::std::move(from);
  }

  inline ResetHostId& operator=(const ResetHostId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetHostId& operator=(ResetHostId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ResetHostId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetHostId* internal_default_instance() {
    return reinterpret_cast<const ResetHostId*>(
               &_ResetHostId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResetHostId& a, ResetHostId& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetHostId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetHostId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetHostId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetHostId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResetHostId& from);
  void MergeFrom(const ResetHostId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetHostId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ResetHostId";
  }
  protected:
  explicit ResetHostId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdFieldNumber = 1,
  };
  // fixed64 host_id = 1;
  void clear_host_id();
  uint64_t host_id() const;
  void set_host_id(uint64_t value);
  private:
  uint64_t _internal_host_id() const;
  void _internal_set_host_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ResetHostId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t host_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class HostIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostIdResponse) */ {
 public:
  inline HostIdResponse() : HostIdResponse(nullptr) {}
  ~HostIdResponse() override;
  explicit PROTOBUF_CONSTEXPR HostIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostIdResponse(const HostIdResponse& from);
  HostIdResponse(HostIdResponse&& from) noexcept
    : HostIdResponse() {
    *this = ::std::move(from);
  }

  inline HostIdResponse& operator=(const HostIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostIdResponse& operator=(HostIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostIdResponse* internal_default_instance() {
    return reinterpret_cast<const HostIdResponse*>(
               &_HostIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HostIdResponse& a, HostIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HostIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostIdResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostIdResponse& from);
  void MergeFrom(const HostIdResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostIdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HostIdResponse";
  }
  protected:
  explicit HostIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef HostIdResponse_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    HostIdResponse_ErrorCode_SUCCESS;
  static constexpr ErrorCode UNKNOWN =
    HostIdResponse_ErrorCode_UNKNOWN;
  static constexpr ErrorCode NO_HOST_FOUND =
    HostIdResponse_ErrorCode_NO_HOST_FOUND;
  static inline bool ErrorCode_IsValid(int value) {
    return HostIdResponse_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    HostIdResponse_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    HostIdResponse_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    HostIdResponse_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return HostIdResponse_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return HostIdResponse_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kHostIdFieldNumber = 1,
    kErrorCodeFieldNumber = 3,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // fixed64 host_id = 1;
  void clear_host_id();
  uint64_t host_id() const;
  void set_host_id(uint64_t value);
  private:
  uint64_t _internal_host_id() const;
  void _internal_set_host_id(uint64_t value);
  public:

  // .proto.HostIdResponse.ErrorCode error_code = 3;
  void clear_error_code();
  ::proto::HostIdResponse_ErrorCode error_code() const;
  void set_error_code(::proto::HostIdResponse_ErrorCode value);
  private:
  ::proto::HostIdResponse_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::HostIdResponse_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HostIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t host_id_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class ConnectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ConnectionRequest) */ {
 public:
  inline ConnectionRequest() : ConnectionRequest(nullptr) {}
  ~ConnectionRequest() override;
  explicit PROTOBUF_CONSTEXPR ConnectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionRequest(const ConnectionRequest& from);
  ConnectionRequest(ConnectionRequest&& from) noexcept
    : ConnectionRequest() {
    *this = ::std::move(from);
  }

  inline ConnectionRequest& operator=(const ConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionRequest& operator=(ConnectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ConnectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequest*>(
               &_ConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectionRequest& a, ConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionRequest& from);
  void MergeFrom(const ConnectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ConnectionRequest";
  }
  protected:
  explicit ConnectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdFieldNumber = 1,
  };
  // fixed64 host_id = 1;
  void clear_host_id();
  uint64_t host_id() const;
  void set_host_id(uint64_t value);
  private:
  uint64_t _internal_host_id() const;
  void _internal_set_host_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ConnectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t host_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class HostOfferData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostOfferData) */ {
 public:
  inline HostOfferData() : HostOfferData(nullptr) {}
  ~HostOfferData() override;
  explicit PROTOBUF_CONSTEXPR HostOfferData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostOfferData(const HostOfferData& from);
  HostOfferData(HostOfferData&& from) noexcept
    : HostOfferData() {
    *this = ::std::move(from);
  }

  inline HostOfferData& operator=(const HostOfferData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostOfferData& operator=(HostOfferData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostOfferData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostOfferData* internal_default_instance() {
    return reinterpret_cast<const HostOfferData*>(
               &_HostOfferData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HostOfferData& a, HostOfferData& b) {
    a.Swap(&b);
  }
  inline void Swap(HostOfferData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostOfferData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostOfferData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostOfferData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostOfferData& from);
  void MergeFrom(const HostOfferData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostOfferData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HostOfferData";
  }
  protected:
  explicit HostOfferData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdFieldNumber = 1,
  };
  // fixed64 host_id = 1;
  void clear_host_id();
  uint64_t host_id() const;
  void set_host_id(uint64_t value);
  private:
  uint64_t _internal_host_id() const;
  void _internal_set_host_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HostOfferData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t host_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class ConnectionOffer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ConnectionOffer) */ {
 public:
  inline ConnectionOffer() : ConnectionOffer(nullptr) {}
  ~ConnectionOffer() override;
  explicit PROTOBUF_CONSTEXPR ConnectionOffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionOffer(const ConnectionOffer& from);
  ConnectionOffer(ConnectionOffer&& from) noexcept
    : ConnectionOffer() {
    *this = ::std::move(from);
  }

  inline ConnectionOffer& operator=(const ConnectionOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionOffer& operator=(ConnectionOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ConnectionOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionOffer* internal_default_instance() {
    return reinterpret_cast<const ConnectionOffer*>(
               &_ConnectionOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConnectionOffer& a, ConnectionOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionOffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionOffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionOffer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionOffer& from);
  void MergeFrom(const ConnectionOffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionOffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ConnectionOffer";
  }
  protected:
  explicit ConnectionOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionOffer_PeerRole PeerRole;
  static constexpr PeerRole HOST =
    ConnectionOffer_PeerRole_HOST;
  static constexpr PeerRole CLIENT =
    ConnectionOffer_PeerRole_CLIENT;
  static inline bool PeerRole_IsValid(int value) {
    return ConnectionOffer_PeerRole_IsValid(value);
  }
  static constexpr PeerRole PeerRole_MIN =
    ConnectionOffer_PeerRole_PeerRole_MIN;
  static constexpr PeerRole PeerRole_MAX =
    ConnectionOffer_PeerRole_PeerRole_MAX;
  static constexpr int PeerRole_ARRAYSIZE =
    ConnectionOffer_PeerRole_PeerRole_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PeerRole_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PeerRole>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PeerRole_Name.");
    return ConnectionOffer_PeerRole_Name(enum_t_value);
  }
  static inline bool PeerRole_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PeerRole* value) {
    return ConnectionOffer_PeerRole_Parse(name, value);
  }

  typedef ConnectionOffer_ErrorCode ErrorCode;
  static constexpr ErrorCode SUCCESS =
    ConnectionOffer_ErrorCode_SUCCESS;
  static constexpr ErrorCode UNKNOWN_ERROR =
    ConnectionOffer_ErrorCode_UNKNOWN_ERROR;
  static constexpr ErrorCode PEER_NOT_FOUND =
    ConnectionOffer_ErrorCode_PEER_NOT_FOUND;
  static constexpr ErrorCode ACCESS_DENIED =
    ConnectionOffer_ErrorCode_ACCESS_DENIED;
  static constexpr ErrorCode KEY_POOL_EMPTY =
    ConnectionOffer_ErrorCode_KEY_POOL_EMPTY;
  static inline bool ErrorCode_IsValid(int value) {
    return ConnectionOffer_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    ConnectionOffer_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    ConnectionOffer_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    ConnectionOffer_ErrorCode_ErrorCode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return ConnectionOffer_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return ConnectionOffer_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRelayFieldNumber = 3,
    kHostDataFieldNumber = 4,
    kPeerRoleFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .proto.RelayCredentials relay = 3;
  bool has_relay() const;
  private:
  bool _internal_has_relay() const;
  public:
  void clear_relay();
  const ::proto::RelayCredentials& relay() const;
  PROTOBUF_NODISCARD ::proto::RelayCredentials* release_relay();
  ::proto::RelayCredentials* mutable_relay();
  void set_allocated_relay(::proto::RelayCredentials* relay);
  private:
  const ::proto::RelayCredentials& _internal_relay() const;
  ::proto::RelayCredentials* _internal_mutable_relay();
  public:
  void unsafe_arena_set_allocated_relay(
      ::proto::RelayCredentials* relay);
  ::proto::RelayCredentials* unsafe_arena_release_relay();

  // .proto.HostOfferData host_data = 4;
  bool has_host_data() const;
  private:
  bool _internal_has_host_data() const;
  public:
  void clear_host_data();
  const ::proto::HostOfferData& host_data() const;
  PROTOBUF_NODISCARD ::proto::HostOfferData* release_host_data();
  ::proto::HostOfferData* mutable_host_data();
  void set_allocated_host_data(::proto::HostOfferData* host_data);
  private:
  const ::proto::HostOfferData& _internal_host_data() const;
  ::proto::HostOfferData* _internal_mutable_host_data();
  public:
  void unsafe_arena_set_allocated_host_data(
      ::proto::HostOfferData* host_data);
  ::proto::HostOfferData* unsafe_arena_release_host_data();

  // .proto.ConnectionOffer.PeerRole peer_role = 1;
  void clear_peer_role();
  ::proto::ConnectionOffer_PeerRole peer_role() const;
  void set_peer_role(::proto::ConnectionOffer_PeerRole value);
  private:
  ::proto::ConnectionOffer_PeerRole _internal_peer_role() const;
  void _internal_set_peer_role(::proto::ConnectionOffer_PeerRole value);
  public:

  // .proto.ConnectionOffer.ErrorCode error_code = 2;
  void clear_error_code();
  ::proto::ConnectionOffer_ErrorCode error_code() const;
  void set_error_code(::proto::ConnectionOffer_ErrorCode value);
  private:
  ::proto::ConnectionOffer_ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::ConnectionOffer_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ConnectionOffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::RelayCredentials* relay_;
    ::proto::HostOfferData* host_data_;
    int peer_role_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class CheckHostStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.CheckHostStatus) */ {
 public:
  inline CheckHostStatus() : CheckHostStatus(nullptr) {}
  ~CheckHostStatus() override;
  explicit PROTOBUF_CONSTEXPR CheckHostStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckHostStatus(const CheckHostStatus& from);
  CheckHostStatus(CheckHostStatus&& from) noexcept
    : CheckHostStatus() {
    *this = ::std::move(from);
  }

  inline CheckHostStatus& operator=(const CheckHostStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckHostStatus& operator=(CheckHostStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CheckHostStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckHostStatus* internal_default_instance() {
    return reinterpret_cast<const CheckHostStatus*>(
               &_CheckHostStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CheckHostStatus& a, CheckHostStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckHostStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckHostStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckHostStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckHostStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckHostStatus& from);
  void MergeFrom(const CheckHostStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckHostStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CheckHostStatus";
  }
  protected:
  explicit CheckHostStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdFieldNumber = 1,
  };
  // fixed64 host_id = 1;
  void clear_host_id();
  uint64_t host_id() const;
  void set_host_id(uint64_t value);
  private:
  uint64_t _internal_host_id() const;
  void _internal_set_host_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.CheckHostStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t host_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class HostStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostStatus) */ {
 public:
  inline HostStatus() : HostStatus(nullptr) {}
  ~HostStatus() override;
  explicit PROTOBUF_CONSTEXPR HostStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostStatus(const HostStatus& from);
  HostStatus(HostStatus&& from) noexcept
    : HostStatus() {
    *this = ::std::move(from);
  }

  inline HostStatus& operator=(const HostStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostStatus& operator=(HostStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostStatus* internal_default_instance() {
    return reinterpret_cast<const HostStatus*>(
               &_HostStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HostStatus& a, HostStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(HostStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostStatus& from);
  void MergeFrom(const HostStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HostStatus";
  }
  protected:
  explicit HostStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef HostStatus_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    HostStatus_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OFFLINE =
    HostStatus_Status_STATUS_OFFLINE;
  static constexpr Status STATUS_ONLINE =
    HostStatus_Status_STATUS_ONLINE;
  static inline bool Status_IsValid(int value) {
    return HostStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    HostStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    HostStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    HostStatus_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return HostStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return HostStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .proto.HostStatus.Status status = 1;
  void clear_status();
  ::proto::HostStatus_Status status() const;
  void set_status(::proto::HostStatus_Status value);
  private:
  ::proto::HostStatus_Status _internal_status() const;
  void _internal_set_status(::proto::HostStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HostStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class RouterToPeer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.RouterToPeer) */ {
 public:
  inline RouterToPeer() : RouterToPeer(nullptr) {}
  ~RouterToPeer() override;
  explicit PROTOBUF_CONSTEXPR RouterToPeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterToPeer(const RouterToPeer& from);
  RouterToPeer(RouterToPeer&& from) noexcept
    : RouterToPeer() {
    *this = ::std::move(from);
  }

  inline RouterToPeer& operator=(const RouterToPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterToPeer& operator=(RouterToPeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RouterToPeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterToPeer* internal_default_instance() {
    return reinterpret_cast<const RouterToPeer*>(
               &_RouterToPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RouterToPeer& a, RouterToPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterToPeer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterToPeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterToPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterToPeer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RouterToPeer& from);
  void MergeFrom(const RouterToPeer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouterToPeer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RouterToPeer";
  }
  protected:
  explicit RouterToPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdResponseFieldNumber = 1,
    kConnectionOfferFieldNumber = 2,
    kHostStatusFieldNumber = 3,
  };
  // .proto.HostIdResponse host_id_response = 1;
  bool has_host_id_response() const;
  private:
  bool _internal_has_host_id_response() const;
  public:
  void clear_host_id_response();
  const ::proto::HostIdResponse& host_id_response() const;
  PROTOBUF_NODISCARD ::proto::HostIdResponse* release_host_id_response();
  ::proto::HostIdResponse* mutable_host_id_response();
  void set_allocated_host_id_response(::proto::HostIdResponse* host_id_response);
  private:
  const ::proto::HostIdResponse& _internal_host_id_response() const;
  ::proto::HostIdResponse* _internal_mutable_host_id_response();
  public:
  void unsafe_arena_set_allocated_host_id_response(
      ::proto::HostIdResponse* host_id_response);
  ::proto::HostIdResponse* unsafe_arena_release_host_id_response();

  // .proto.ConnectionOffer connection_offer = 2;
  bool has_connection_offer() const;
  private:
  bool _internal_has_connection_offer() const;
  public:
  void clear_connection_offer();
  const ::proto::ConnectionOffer& connection_offer() const;
  PROTOBUF_NODISCARD ::proto::ConnectionOffer* release_connection_offer();
  ::proto::ConnectionOffer* mutable_connection_offer();
  void set_allocated_connection_offer(::proto::ConnectionOffer* connection_offer);
  private:
  const ::proto::ConnectionOffer& _internal_connection_offer() const;
  ::proto::ConnectionOffer* _internal_mutable_connection_offer();
  public:
  void unsafe_arena_set_allocated_connection_offer(
      ::proto::ConnectionOffer* connection_offer);
  ::proto::ConnectionOffer* unsafe_arena_release_connection_offer();

  // .proto.HostStatus host_status = 3;
  bool has_host_status() const;
  private:
  bool _internal_has_host_status() const;
  public:
  void clear_host_status();
  const ::proto::HostStatus& host_status() const;
  PROTOBUF_NODISCARD ::proto::HostStatus* release_host_status();
  ::proto::HostStatus* mutable_host_status();
  void set_allocated_host_status(::proto::HostStatus* host_status);
  private:
  const ::proto::HostStatus& _internal_host_status() const;
  ::proto::HostStatus* _internal_mutable_host_status();
  public:
  void unsafe_arena_set_allocated_host_status(
      ::proto::HostStatus* host_status);
  ::proto::HostStatus* unsafe_arena_release_host_status();

  // @@protoc_insertion_point(class_scope:proto.RouterToPeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::HostIdResponse* host_id_response_;
    ::proto::ConnectionOffer* connection_offer_;
    ::proto::HostStatus* host_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// -------------------------------------------------------------------

class PeerToRouter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.PeerToRouter) */ {
 public:
  inline PeerToRouter() : PeerToRouter(nullptr) {}
  ~PeerToRouter() override;
  explicit PROTOBUF_CONSTEXPR PeerToRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerToRouter(const PeerToRouter& from);
  PeerToRouter(PeerToRouter&& from) noexcept
    : PeerToRouter() {
    *this = ::std::move(from);
  }

  inline PeerToRouter& operator=(const PeerToRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerToRouter& operator=(PeerToRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PeerToRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerToRouter* internal_default_instance() {
    return reinterpret_cast<const PeerToRouter*>(
               &_PeerToRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PeerToRouter& a, PeerToRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerToRouter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerToRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerToRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerToRouter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PeerToRouter& from);
  void MergeFrom(const PeerToRouter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerToRouter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PeerToRouter";
  }
  protected:
  explicit PeerToRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionRequestFieldNumber = 1,
    kHostIdRequestFieldNumber = 2,
    kResetHostIdFieldNumber = 3,
    kCheckHostStatusFieldNumber = 4,
  };
  // .proto.ConnectionRequest connection_request = 1;
  bool has_connection_request() const;
  private:
  bool _internal_has_connection_request() const;
  public:
  void clear_connection_request();
  const ::proto::ConnectionRequest& connection_request() const;
  PROTOBUF_NODISCARD ::proto::ConnectionRequest* release_connection_request();
  ::proto::ConnectionRequest* mutable_connection_request();
  void set_allocated_connection_request(::proto::ConnectionRequest* connection_request);
  private:
  const ::proto::ConnectionRequest& _internal_connection_request() const;
  ::proto::ConnectionRequest* _internal_mutable_connection_request();
  public:
  void unsafe_arena_set_allocated_connection_request(
      ::proto::ConnectionRequest* connection_request);
  ::proto::ConnectionRequest* unsafe_arena_release_connection_request();

  // .proto.HostIdRequest host_id_request = 2;
  bool has_host_id_request() const;
  private:
  bool _internal_has_host_id_request() const;
  public:
  void clear_host_id_request();
  const ::proto::HostIdRequest& host_id_request() const;
  PROTOBUF_NODISCARD ::proto::HostIdRequest* release_host_id_request();
  ::proto::HostIdRequest* mutable_host_id_request();
  void set_allocated_host_id_request(::proto::HostIdRequest* host_id_request);
  private:
  const ::proto::HostIdRequest& _internal_host_id_request() const;
  ::proto::HostIdRequest* _internal_mutable_host_id_request();
  public:
  void unsafe_arena_set_allocated_host_id_request(
      ::proto::HostIdRequest* host_id_request);
  ::proto::HostIdRequest* unsafe_arena_release_host_id_request();

  // .proto.ResetHostId reset_host_id = 3;
  bool has_reset_host_id() const;
  private:
  bool _internal_has_reset_host_id() const;
  public:
  void clear_reset_host_id();
  const ::proto::ResetHostId& reset_host_id() const;
  PROTOBUF_NODISCARD ::proto::ResetHostId* release_reset_host_id();
  ::proto::ResetHostId* mutable_reset_host_id();
  void set_allocated_reset_host_id(::proto::ResetHostId* reset_host_id);
  private:
  const ::proto::ResetHostId& _internal_reset_host_id() const;
  ::proto::ResetHostId* _internal_mutable_reset_host_id();
  public:
  void unsafe_arena_set_allocated_reset_host_id(
      ::proto::ResetHostId* reset_host_id);
  ::proto::ResetHostId* unsafe_arena_release_reset_host_id();

  // .proto.CheckHostStatus check_host_status = 4;
  bool has_check_host_status() const;
  private:
  bool _internal_has_check_host_status() const;
  public:
  void clear_check_host_status();
  const ::proto::CheckHostStatus& check_host_status() const;
  PROTOBUF_NODISCARD ::proto::CheckHostStatus* release_check_host_status();
  ::proto::CheckHostStatus* mutable_check_host_status();
  void set_allocated_check_host_status(::proto::CheckHostStatus* check_host_status);
  private:
  const ::proto::CheckHostStatus& _internal_check_host_status() const;
  ::proto::CheckHostStatus* _internal_mutable_check_host_status();
  public:
  void unsafe_arena_set_allocated_check_host_status(
      ::proto::CheckHostStatus* check_host_status);
  ::proto::CheckHostStatus* unsafe_arena_release_check_host_status();

  // @@protoc_insertion_point(class_scope:proto.PeerToRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::ConnectionRequest* connection_request_;
    ::proto::HostIdRequest* host_id_request_;
    ::proto::ResetHostId* reset_host_id_;
    ::proto::CheckHostStatus* check_host_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_5fpeer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HostIdRequest

// .proto.HostIdRequest.Type type = 1;
inline void HostIdRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::HostIdRequest_Type HostIdRequest::_internal_type() const {
  return static_cast< ::proto::HostIdRequest_Type >(_impl_.type_);
}
inline ::proto::HostIdRequest_Type HostIdRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.HostIdRequest.type)
  return _internal_type();
}
inline void HostIdRequest::_internal_set_type(::proto::HostIdRequest_Type value) {
  
  _impl_.type_ = value;
}
inline void HostIdRequest::set_type(::proto::HostIdRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.HostIdRequest.type)
}

// bytes key = 2;
inline void HostIdRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& HostIdRequest::key() const {
  // @@protoc_insertion_point(field_get:proto.HostIdRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostIdRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HostIdRequest.key)
}
inline std::string* HostIdRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.HostIdRequest.key)
  return _s;
}
inline const std::string& HostIdRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void HostIdRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* HostIdRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* HostIdRequest::release_key() {
  // @@protoc_insertion_point(field_release:proto.HostIdRequest.key)
  return _impl_.key_.Release();
}
inline void HostIdRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HostIdRequest.key)
}

// -------------------------------------------------------------------

// ResetHostId

// fixed64 host_id = 1;
inline void ResetHostId::clear_host_id() {
  _impl_.host_id_ = uint64_t{0u};
}
inline uint64_t ResetHostId::_internal_host_id() const {
  return _impl_.host_id_;
}
inline uint64_t ResetHostId::host_id() const {
  // @@protoc_insertion_point(field_get:proto.ResetHostId.host_id)
  return _internal_host_id();
}
inline void ResetHostId::_internal_set_host_id(uint64_t value) {
  
  _impl_.host_id_ = value;
}
inline void ResetHostId::set_host_id(uint64_t value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:proto.ResetHostId.host_id)
}

// -------------------------------------------------------------------

// HostIdResponse

// fixed64 host_id = 1;
inline void HostIdResponse::clear_host_id() {
  _impl_.host_id_ = uint64_t{0u};
}
inline uint64_t HostIdResponse::_internal_host_id() const {
  return _impl_.host_id_;
}
inline uint64_t HostIdResponse::host_id() const {
  // @@protoc_insertion_point(field_get:proto.HostIdResponse.host_id)
  return _internal_host_id();
}
inline void HostIdResponse::_internal_set_host_id(uint64_t value) {
  
  _impl_.host_id_ = value;
}
inline void HostIdResponse::set_host_id(uint64_t value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:proto.HostIdResponse.host_id)
}

// bytes key = 2;
inline void HostIdResponse::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& HostIdResponse::key() const {
  // @@protoc_insertion_point(field_get:proto.HostIdResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostIdResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HostIdResponse.key)
}
inline std::string* HostIdResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.HostIdResponse.key)
  return _s;
}
inline const std::string& HostIdResponse::_internal_key() const {
  return _impl_.key_.Get();
}
inline void HostIdResponse::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* HostIdResponse::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* HostIdResponse::release_key() {
  // @@protoc_insertion_point(field_release:proto.HostIdResponse.key)
  return _impl_.key_.Release();
}
inline void HostIdResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HostIdResponse.key)
}

// .proto.HostIdResponse.ErrorCode error_code = 3;
inline void HostIdResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::HostIdResponse_ErrorCode HostIdResponse::_internal_error_code() const {
  return static_cast< ::proto::HostIdResponse_ErrorCode >(_impl_.error_code_);
}
inline ::proto::HostIdResponse_ErrorCode HostIdResponse::error_code() const {
  // @@protoc_insertion_point(field_get:proto.HostIdResponse.error_code)
  return _internal_error_code();
}
inline void HostIdResponse::_internal_set_error_code(::proto::HostIdResponse_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void HostIdResponse::set_error_code(::proto::HostIdResponse_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.HostIdResponse.error_code)
}

// -------------------------------------------------------------------

// ConnectionRequest

// fixed64 host_id = 1;
inline void ConnectionRequest::clear_host_id() {
  _impl_.host_id_ = uint64_t{0u};
}
inline uint64_t ConnectionRequest::_internal_host_id() const {
  return _impl_.host_id_;
}
inline uint64_t ConnectionRequest::host_id() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionRequest.host_id)
  return _internal_host_id();
}
inline void ConnectionRequest::_internal_set_host_id(uint64_t value) {
  
  _impl_.host_id_ = value;
}
inline void ConnectionRequest::set_host_id(uint64_t value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:proto.ConnectionRequest.host_id)
}

// -------------------------------------------------------------------

// HostOfferData

// fixed64 host_id = 1;
inline void HostOfferData::clear_host_id() {
  _impl_.host_id_ = uint64_t{0u};
}
inline uint64_t HostOfferData::_internal_host_id() const {
  return _impl_.host_id_;
}
inline uint64_t HostOfferData::host_id() const {
  // @@protoc_insertion_point(field_get:proto.HostOfferData.host_id)
  return _internal_host_id();
}
inline void HostOfferData::_internal_set_host_id(uint64_t value) {
  
  _impl_.host_id_ = value;
}
inline void HostOfferData::set_host_id(uint64_t value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:proto.HostOfferData.host_id)
}

// -------------------------------------------------------------------

// ConnectionOffer

// .proto.ConnectionOffer.PeerRole peer_role = 1;
inline void ConnectionOffer::clear_peer_role() {
  _impl_.peer_role_ = 0;
}
inline ::proto::ConnectionOffer_PeerRole ConnectionOffer::_internal_peer_role() const {
  return static_cast< ::proto::ConnectionOffer_PeerRole >(_impl_.peer_role_);
}
inline ::proto::ConnectionOffer_PeerRole ConnectionOffer::peer_role() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.peer_role)
  return _internal_peer_role();
}
inline void ConnectionOffer::_internal_set_peer_role(::proto::ConnectionOffer_PeerRole value) {
  
  _impl_.peer_role_ = value;
}
inline void ConnectionOffer::set_peer_role(::proto::ConnectionOffer_PeerRole value) {
  _internal_set_peer_role(value);
  // @@protoc_insertion_point(field_set:proto.ConnectionOffer.peer_role)
}

// .proto.ConnectionOffer.ErrorCode error_code = 2;
inline void ConnectionOffer::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::ConnectionOffer_ErrorCode ConnectionOffer::_internal_error_code() const {
  return static_cast< ::proto::ConnectionOffer_ErrorCode >(_impl_.error_code_);
}
inline ::proto::ConnectionOffer_ErrorCode ConnectionOffer::error_code() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.error_code)
  return _internal_error_code();
}
inline void ConnectionOffer::_internal_set_error_code(::proto::ConnectionOffer_ErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void ConnectionOffer::set_error_code(::proto::ConnectionOffer_ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.ConnectionOffer.error_code)
}

// .proto.RelayCredentials relay = 3;
inline bool ConnectionOffer::_internal_has_relay() const {
  return this != internal_default_instance() && _impl_.relay_ != nullptr;
}
inline bool ConnectionOffer::has_relay() const {
  return _internal_has_relay();
}
inline const ::proto::RelayCredentials& ConnectionOffer::_internal_relay() const {
  const ::proto::RelayCredentials* p = _impl_.relay_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RelayCredentials&>(
      ::proto::_RelayCredentials_default_instance_);
}
inline const ::proto::RelayCredentials& ConnectionOffer::relay() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.relay)
  return _internal_relay();
}
inline void ConnectionOffer::unsafe_arena_set_allocated_relay(
    ::proto::RelayCredentials* relay) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relay_);
  }
  _impl_.relay_ = relay;
  if (relay) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ConnectionOffer.relay)
}
inline ::proto::RelayCredentials* ConnectionOffer::release_relay() {
  
  ::proto::RelayCredentials* temp = _impl_.relay_;
  _impl_.relay_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RelayCredentials* ConnectionOffer::unsafe_arena_release_relay() {
  // @@protoc_insertion_point(field_release:proto.ConnectionOffer.relay)
  
  ::proto::RelayCredentials* temp = _impl_.relay_;
  _impl_.relay_ = nullptr;
  return temp;
}
inline ::proto::RelayCredentials* ConnectionOffer::_internal_mutable_relay() {
  
  if (_impl_.relay_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RelayCredentials>(GetArenaForAllocation());
    _impl_.relay_ = p;
  }
  return _impl_.relay_;
}
inline ::proto::RelayCredentials* ConnectionOffer::mutable_relay() {
  ::proto::RelayCredentials* _msg = _internal_mutable_relay();
  // @@protoc_insertion_point(field_mutable:proto.ConnectionOffer.relay)
  return _msg;
}
inline void ConnectionOffer::set_allocated_relay(::proto::RelayCredentials* relay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relay_);
  }
  if (relay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relay));
    if (message_arena != submessage_arena) {
      relay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relay, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relay_ = relay;
  // @@protoc_insertion_point(field_set_allocated:proto.ConnectionOffer.relay)
}

// .proto.HostOfferData host_data = 4;
inline bool ConnectionOffer::_internal_has_host_data() const {
  return this != internal_default_instance() && _impl_.host_data_ != nullptr;
}
inline bool ConnectionOffer::has_host_data() const {
  return _internal_has_host_data();
}
inline void ConnectionOffer::clear_host_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.host_data_ != nullptr) {
    delete _impl_.host_data_;
  }
  _impl_.host_data_ = nullptr;
}
inline const ::proto::HostOfferData& ConnectionOffer::_internal_host_data() const {
  const ::proto::HostOfferData* p = _impl_.host_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HostOfferData&>(
      ::proto::_HostOfferData_default_instance_);
}
inline const ::proto::HostOfferData& ConnectionOffer::host_data() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.host_data)
  return _internal_host_data();
}
inline void ConnectionOffer::unsafe_arena_set_allocated_host_data(
    ::proto::HostOfferData* host_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.host_data_);
  }
  _impl_.host_data_ = host_data;
  if (host_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ConnectionOffer.host_data)
}
inline ::proto::HostOfferData* ConnectionOffer::release_host_data() {
  
  ::proto::HostOfferData* temp = _impl_.host_data_;
  _impl_.host_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HostOfferData* ConnectionOffer::unsafe_arena_release_host_data() {
  // @@protoc_insertion_point(field_release:proto.ConnectionOffer.host_data)
  
  ::proto::HostOfferData* temp = _impl_.host_data_;
  _impl_.host_data_ = nullptr;
  return temp;
}
inline ::proto::HostOfferData* ConnectionOffer::_internal_mutable_host_data() {
  
  if (_impl_.host_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HostOfferData>(GetArenaForAllocation());
    _impl_.host_data_ = p;
  }
  return _impl_.host_data_;
}
inline ::proto::HostOfferData* ConnectionOffer::mutable_host_data() {
  ::proto::HostOfferData* _msg = _internal_mutable_host_data();
  // @@protoc_insertion_point(field_mutable:proto.ConnectionOffer.host_data)
  return _msg;
}
inline void ConnectionOffer::set_allocated_host_data(::proto::HostOfferData* host_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.host_data_;
  }
  if (host_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_data);
    if (message_arena != submessage_arena) {
      host_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.host_data_ = host_data;
  // @@protoc_insertion_point(field_set_allocated:proto.ConnectionOffer.host_data)
}

// -------------------------------------------------------------------

// CheckHostStatus

// fixed64 host_id = 1;
inline void CheckHostStatus::clear_host_id() {
  _impl_.host_id_ = uint64_t{0u};
}
inline uint64_t CheckHostStatus::_internal_host_id() const {
  return _impl_.host_id_;
}
inline uint64_t CheckHostStatus::host_id() const {
  // @@protoc_insertion_point(field_get:proto.CheckHostStatus.host_id)
  return _internal_host_id();
}
inline void CheckHostStatus::_internal_set_host_id(uint64_t value) {
  
  _impl_.host_id_ = value;
}
inline void CheckHostStatus::set_host_id(uint64_t value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:proto.CheckHostStatus.host_id)
}

// -------------------------------------------------------------------

// HostStatus

// .proto.HostStatus.Status status = 1;
inline void HostStatus::clear_status() {
  _impl_.status_ = 0;
}
inline ::proto::HostStatus_Status HostStatus::_internal_status() const {
  return static_cast< ::proto::HostStatus_Status >(_impl_.status_);
}
inline ::proto::HostStatus_Status HostStatus::status() const {
  // @@protoc_insertion_point(field_get:proto.HostStatus.status)
  return _internal_status();
}
inline void HostStatus::_internal_set_status(::proto::HostStatus_Status value) {
  
  _impl_.status_ = value;
}
inline void HostStatus::set_status(::proto::HostStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.HostStatus.status)
}

// -------------------------------------------------------------------

// RouterToPeer

// .proto.HostIdResponse host_id_response = 1;
inline bool RouterToPeer::_internal_has_host_id_response() const {
  return this != internal_default_instance() && _impl_.host_id_response_ != nullptr;
}
inline bool RouterToPeer::has_host_id_response() const {
  return _internal_has_host_id_response();
}
inline void RouterToPeer::clear_host_id_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.host_id_response_ != nullptr) {
    delete _impl_.host_id_response_;
  }
  _impl_.host_id_response_ = nullptr;
}
inline const ::proto::HostIdResponse& RouterToPeer::_internal_host_id_response() const {
  const ::proto::HostIdResponse* p = _impl_.host_id_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HostIdResponse&>(
      ::proto::_HostIdResponse_default_instance_);
}
inline const ::proto::HostIdResponse& RouterToPeer::host_id_response() const {
  // @@protoc_insertion_point(field_get:proto.RouterToPeer.host_id_response)
  return _internal_host_id_response();
}
inline void RouterToPeer::unsafe_arena_set_allocated_host_id_response(
    ::proto::HostIdResponse* host_id_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.host_id_response_);
  }
  _impl_.host_id_response_ = host_id_response;
  if (host_id_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToPeer.host_id_response)
}
inline ::proto::HostIdResponse* RouterToPeer::release_host_id_response() {
  
  ::proto::HostIdResponse* temp = _impl_.host_id_response_;
  _impl_.host_id_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HostIdResponse* RouterToPeer::unsafe_arena_release_host_id_response() {
  // @@protoc_insertion_point(field_release:proto.RouterToPeer.host_id_response)
  
  ::proto::HostIdResponse* temp = _impl_.host_id_response_;
  _impl_.host_id_response_ = nullptr;
  return temp;
}
inline ::proto::HostIdResponse* RouterToPeer::_internal_mutable_host_id_response() {
  
  if (_impl_.host_id_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HostIdResponse>(GetArenaForAllocation());
    _impl_.host_id_response_ = p;
  }
  return _impl_.host_id_response_;
}
inline ::proto::HostIdResponse* RouterToPeer::mutable_host_id_response() {
  ::proto::HostIdResponse* _msg = _internal_mutable_host_id_response();
  // @@protoc_insertion_point(field_mutable:proto.RouterToPeer.host_id_response)
  return _msg;
}
inline void RouterToPeer::set_allocated_host_id_response(::proto::HostIdResponse* host_id_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.host_id_response_;
  }
  if (host_id_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_id_response);
    if (message_arena != submessage_arena) {
      host_id_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_id_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.host_id_response_ = host_id_response;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToPeer.host_id_response)
}

// .proto.ConnectionOffer connection_offer = 2;
inline bool RouterToPeer::_internal_has_connection_offer() const {
  return this != internal_default_instance() && _impl_.connection_offer_ != nullptr;
}
inline bool RouterToPeer::has_connection_offer() const {
  return _internal_has_connection_offer();
}
inline void RouterToPeer::clear_connection_offer() {
  if (GetArenaForAllocation() == nullptr && _impl_.connection_offer_ != nullptr) {
    delete _impl_.connection_offer_;
  }
  _impl_.connection_offer_ = nullptr;
}
inline const ::proto::ConnectionOffer& RouterToPeer::_internal_connection_offer() const {
  const ::proto::ConnectionOffer* p = _impl_.connection_offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ConnectionOffer&>(
      ::proto::_ConnectionOffer_default_instance_);
}
inline const ::proto::ConnectionOffer& RouterToPeer::connection_offer() const {
  // @@protoc_insertion_point(field_get:proto.RouterToPeer.connection_offer)
  return _internal_connection_offer();
}
inline void RouterToPeer::unsafe_arena_set_allocated_connection_offer(
    ::proto::ConnectionOffer* connection_offer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_offer_);
  }
  _impl_.connection_offer_ = connection_offer;
  if (connection_offer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToPeer.connection_offer)
}
inline ::proto::ConnectionOffer* RouterToPeer::release_connection_offer() {
  
  ::proto::ConnectionOffer* temp = _impl_.connection_offer_;
  _impl_.connection_offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ConnectionOffer* RouterToPeer::unsafe_arena_release_connection_offer() {
  // @@protoc_insertion_point(field_release:proto.RouterToPeer.connection_offer)
  
  ::proto::ConnectionOffer* temp = _impl_.connection_offer_;
  _impl_.connection_offer_ = nullptr;
  return temp;
}
inline ::proto::ConnectionOffer* RouterToPeer::_internal_mutable_connection_offer() {
  
  if (_impl_.connection_offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ConnectionOffer>(GetArenaForAllocation());
    _impl_.connection_offer_ = p;
  }
  return _impl_.connection_offer_;
}
inline ::proto::ConnectionOffer* RouterToPeer::mutable_connection_offer() {
  ::proto::ConnectionOffer* _msg = _internal_mutable_connection_offer();
  // @@protoc_insertion_point(field_mutable:proto.RouterToPeer.connection_offer)
  return _msg;
}
inline void RouterToPeer::set_allocated_connection_offer(::proto::ConnectionOffer* connection_offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_offer_;
  }
  if (connection_offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_offer);
    if (message_arena != submessage_arena) {
      connection_offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_offer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.connection_offer_ = connection_offer;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToPeer.connection_offer)
}

// .proto.HostStatus host_status = 3;
inline bool RouterToPeer::_internal_has_host_status() const {
  return this != internal_default_instance() && _impl_.host_status_ != nullptr;
}
inline bool RouterToPeer::has_host_status() const {
  return _internal_has_host_status();
}
inline void RouterToPeer::clear_host_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.host_status_ != nullptr) {
    delete _impl_.host_status_;
  }
  _impl_.host_status_ = nullptr;
}
inline const ::proto::HostStatus& RouterToPeer::_internal_host_status() const {
  const ::proto::HostStatus* p = _impl_.host_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HostStatus&>(
      ::proto::_HostStatus_default_instance_);
}
inline const ::proto::HostStatus& RouterToPeer::host_status() const {
  // @@protoc_insertion_point(field_get:proto.RouterToPeer.host_status)
  return _internal_host_status();
}
inline void RouterToPeer::unsafe_arena_set_allocated_host_status(
    ::proto::HostStatus* host_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.host_status_);
  }
  _impl_.host_status_ = host_status;
  if (host_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RouterToPeer.host_status)
}
inline ::proto::HostStatus* RouterToPeer::release_host_status() {
  
  ::proto::HostStatus* temp = _impl_.host_status_;
  _impl_.host_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HostStatus* RouterToPeer::unsafe_arena_release_host_status() {
  // @@protoc_insertion_point(field_release:proto.RouterToPeer.host_status)
  
  ::proto::HostStatus* temp = _impl_.host_status_;
  _impl_.host_status_ = nullptr;
  return temp;
}
inline ::proto::HostStatus* RouterToPeer::_internal_mutable_host_status() {
  
  if (_impl_.host_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HostStatus>(GetArenaForAllocation());
    _impl_.host_status_ = p;
  }
  return _impl_.host_status_;
}
inline ::proto::HostStatus* RouterToPeer::mutable_host_status() {
  ::proto::HostStatus* _msg = _internal_mutable_host_status();
  // @@protoc_insertion_point(field_mutable:proto.RouterToPeer.host_status)
  return _msg;
}
inline void RouterToPeer::set_allocated_host_status(::proto::HostStatus* host_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.host_status_;
  }
  if (host_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_status);
    if (message_arena != submessage_arena) {
      host_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.host_status_ = host_status;
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToPeer.host_status)
}

// -------------------------------------------------------------------

// PeerToRouter

// .proto.ConnectionRequest connection_request = 1;
inline bool PeerToRouter::_internal_has_connection_request() const {
  return this != internal_default_instance() && _impl_.connection_request_ != nullptr;
}
inline bool PeerToRouter::has_connection_request() const {
  return _internal_has_connection_request();
}
inline void PeerToRouter::clear_connection_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.connection_request_ != nullptr) {
    delete _impl_.connection_request_;
  }
  _impl_.connection_request_ = nullptr;
}
inline const ::proto::ConnectionRequest& PeerToRouter::_internal_connection_request() const {
  const ::proto::ConnectionRequest* p = _impl_.connection_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ConnectionRequest&>(
      ::proto::_ConnectionRequest_default_instance_);
}
inline const ::proto::ConnectionRequest& PeerToRouter::connection_request() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.connection_request)
  return _internal_connection_request();
}
inline void PeerToRouter::unsafe_arena_set_allocated_connection_request(
    ::proto::ConnectionRequest* connection_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_request_);
  }
  _impl_.connection_request_ = connection_request;
  if (connection_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PeerToRouter.connection_request)
}
inline ::proto::ConnectionRequest* PeerToRouter::release_connection_request() {
  
  ::proto::ConnectionRequest* temp = _impl_.connection_request_;
  _impl_.connection_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ConnectionRequest* PeerToRouter::unsafe_arena_release_connection_request() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.connection_request)
  
  ::proto::ConnectionRequest* temp = _impl_.connection_request_;
  _impl_.connection_request_ = nullptr;
  return temp;
}
inline ::proto::ConnectionRequest* PeerToRouter::_internal_mutable_connection_request() {
  
  if (_impl_.connection_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ConnectionRequest>(GetArenaForAllocation());
    _impl_.connection_request_ = p;
  }
  return _impl_.connection_request_;
}
inline ::proto::ConnectionRequest* PeerToRouter::mutable_connection_request() {
  ::proto::ConnectionRequest* _msg = _internal_mutable_connection_request();
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.connection_request)
  return _msg;
}
inline void PeerToRouter::set_allocated_connection_request(::proto::ConnectionRequest* connection_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_request_;
  }
  if (connection_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_request);
    if (message_arena != submessage_arena) {
      connection_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.connection_request_ = connection_request;
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.connection_request)
}

// .proto.HostIdRequest host_id_request = 2;
inline bool PeerToRouter::_internal_has_host_id_request() const {
  return this != internal_default_instance() && _impl_.host_id_request_ != nullptr;
}
inline bool PeerToRouter::has_host_id_request() const {
  return _internal_has_host_id_request();
}
inline void PeerToRouter::clear_host_id_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.host_id_request_ != nullptr) {
    delete _impl_.host_id_request_;
  }
  _impl_.host_id_request_ = nullptr;
}
inline const ::proto::HostIdRequest& PeerToRouter::_internal_host_id_request() const {
  const ::proto::HostIdRequest* p = _impl_.host_id_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HostIdRequest&>(
      ::proto::_HostIdRequest_default_instance_);
}
inline const ::proto::HostIdRequest& PeerToRouter::host_id_request() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.host_id_request)
  return _internal_host_id_request();
}
inline void PeerToRouter::unsafe_arena_set_allocated_host_id_request(
    ::proto::HostIdRequest* host_id_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.host_id_request_);
  }
  _impl_.host_id_request_ = host_id_request;
  if (host_id_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PeerToRouter.host_id_request)
}
inline ::proto::HostIdRequest* PeerToRouter::release_host_id_request() {
  
  ::proto::HostIdRequest* temp = _impl_.host_id_request_;
  _impl_.host_id_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HostIdRequest* PeerToRouter::unsafe_arena_release_host_id_request() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.host_id_request)
  
  ::proto::HostIdRequest* temp = _impl_.host_id_request_;
  _impl_.host_id_request_ = nullptr;
  return temp;
}
inline ::proto::HostIdRequest* PeerToRouter::_internal_mutable_host_id_request() {
  
  if (_impl_.host_id_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HostIdRequest>(GetArenaForAllocation());
    _impl_.host_id_request_ = p;
  }
  return _impl_.host_id_request_;
}
inline ::proto::HostIdRequest* PeerToRouter::mutable_host_id_request() {
  ::proto::HostIdRequest* _msg = _internal_mutable_host_id_request();
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.host_id_request)
  return _msg;
}
inline void PeerToRouter::set_allocated_host_id_request(::proto::HostIdRequest* host_id_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.host_id_request_;
  }
  if (host_id_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_id_request);
    if (message_arena != submessage_arena) {
      host_id_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_id_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.host_id_request_ = host_id_request;
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.host_id_request)
}

// .proto.ResetHostId reset_host_id = 3;
inline bool PeerToRouter::_internal_has_reset_host_id() const {
  return this != internal_default_instance() && _impl_.reset_host_id_ != nullptr;
}
inline bool PeerToRouter::has_reset_host_id() const {
  return _internal_has_reset_host_id();
}
inline void PeerToRouter::clear_reset_host_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.reset_host_id_ != nullptr) {
    delete _impl_.reset_host_id_;
  }
  _impl_.reset_host_id_ = nullptr;
}
inline const ::proto::ResetHostId& PeerToRouter::_internal_reset_host_id() const {
  const ::proto::ResetHostId* p = _impl_.reset_host_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ResetHostId&>(
      ::proto::_ResetHostId_default_instance_);
}
inline const ::proto::ResetHostId& PeerToRouter::reset_host_id() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.reset_host_id)
  return _internal_reset_host_id();
}
inline void PeerToRouter::unsafe_arena_set_allocated_reset_host_id(
    ::proto::ResetHostId* reset_host_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_host_id_);
  }
  _impl_.reset_host_id_ = reset_host_id;
  if (reset_host_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PeerToRouter.reset_host_id)
}
inline ::proto::ResetHostId* PeerToRouter::release_reset_host_id() {
  
  ::proto::ResetHostId* temp = _impl_.reset_host_id_;
  _impl_.reset_host_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ResetHostId* PeerToRouter::unsafe_arena_release_reset_host_id() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.reset_host_id)
  
  ::proto::ResetHostId* temp = _impl_.reset_host_id_;
  _impl_.reset_host_id_ = nullptr;
  return temp;
}
inline ::proto::ResetHostId* PeerToRouter::_internal_mutable_reset_host_id() {
  
  if (_impl_.reset_host_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ResetHostId>(GetArenaForAllocation());
    _impl_.reset_host_id_ = p;
  }
  return _impl_.reset_host_id_;
}
inline ::proto::ResetHostId* PeerToRouter::mutable_reset_host_id() {
  ::proto::ResetHostId* _msg = _internal_mutable_reset_host_id();
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.reset_host_id)
  return _msg;
}
inline void PeerToRouter::set_allocated_reset_host_id(::proto::ResetHostId* reset_host_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reset_host_id_;
  }
  if (reset_host_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reset_host_id);
    if (message_arena != submessage_arena) {
      reset_host_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset_host_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reset_host_id_ = reset_host_id;
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.reset_host_id)
}

// .proto.CheckHostStatus check_host_status = 4;
inline bool PeerToRouter::_internal_has_check_host_status() const {
  return this != internal_default_instance() && _impl_.check_host_status_ != nullptr;
}
inline bool PeerToRouter::has_check_host_status() const {
  return _internal_has_check_host_status();
}
inline void PeerToRouter::clear_check_host_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.check_host_status_ != nullptr) {
    delete _impl_.check_host_status_;
  }
  _impl_.check_host_status_ = nullptr;
}
inline const ::proto::CheckHostStatus& PeerToRouter::_internal_check_host_status() const {
  const ::proto::CheckHostStatus* p = _impl_.check_host_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CheckHostStatus&>(
      ::proto::_CheckHostStatus_default_instance_);
}
inline const ::proto::CheckHostStatus& PeerToRouter::check_host_status() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.check_host_status)
  return _internal_check_host_status();
}
inline void PeerToRouter::unsafe_arena_set_allocated_check_host_status(
    ::proto::CheckHostStatus* check_host_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_host_status_);
  }
  _impl_.check_host_status_ = check_host_status;
  if (check_host_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PeerToRouter.check_host_status)
}
inline ::proto::CheckHostStatus* PeerToRouter::release_check_host_status() {
  
  ::proto::CheckHostStatus* temp = _impl_.check_host_status_;
  _impl_.check_host_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CheckHostStatus* PeerToRouter::unsafe_arena_release_check_host_status() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.check_host_status)
  
  ::proto::CheckHostStatus* temp = _impl_.check_host_status_;
  _impl_.check_host_status_ = nullptr;
  return temp;
}
inline ::proto::CheckHostStatus* PeerToRouter::_internal_mutable_check_host_status() {
  
  if (_impl_.check_host_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CheckHostStatus>(GetArenaForAllocation());
    _impl_.check_host_status_ = p;
  }
  return _impl_.check_host_status_;
}
inline ::proto::CheckHostStatus* PeerToRouter::mutable_check_host_status() {
  ::proto::CheckHostStatus* _msg = _internal_mutable_check_host_status();
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.check_host_status)
  return _msg;
}
inline void PeerToRouter::set_allocated_check_host_status(::proto::CheckHostStatus* check_host_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_host_status_;
  }
  if (check_host_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_host_status);
    if (message_arena != submessage_arena) {
      check_host_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_host_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.check_host_status_ = check_host_status;
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.check_host_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::HostIdRequest_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::HostIdResponse_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::ConnectionOffer_PeerRole> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::ConnectionOffer_ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::HostStatus_Status> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_5fpeer_2eproto
