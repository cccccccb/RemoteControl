// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: desktop.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_desktop_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_desktop_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_desktop_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_desktop_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class AudioPacket;
struct AudioPacketDefaultTypeInternal;
extern AudioPacketDefaultTypeInternal _AudioPacket_default_instance_;
class ClientToHost;
struct ClientToHostDefaultTypeInternal;
extern ClientToHostDefaultTypeInternal _ClientToHost_default_instance_;
class ClipboardEvent;
struct ClipboardEventDefaultTypeInternal;
extern ClipboardEventDefaultTypeInternal _ClipboardEvent_default_instance_;
class CursorPosition;
struct CursorPositionDefaultTypeInternal;
extern CursorPositionDefaultTypeInternal _CursorPosition_default_instance_;
class CursorShape;
struct CursorShapeDefaultTypeInternal;
extern CursorShapeDefaultTypeInternal _CursorShape_default_instance_;
class DesktopCapabilities;
struct DesktopCapabilitiesDefaultTypeInternal;
extern DesktopCapabilitiesDefaultTypeInternal _DesktopCapabilities_default_instance_;
class DesktopCapabilities_Flag;
struct DesktopCapabilities_FlagDefaultTypeInternal;
extern DesktopCapabilities_FlagDefaultTypeInternal _DesktopCapabilities_Flag_default_instance_;
class DesktopConfig;
struct DesktopConfigDefaultTypeInternal;
extern DesktopConfigDefaultTypeInternal _DesktopConfig_default_instance_;
class DesktopExtension;
struct DesktopExtensionDefaultTypeInternal;
extern DesktopExtensionDefaultTypeInternal _DesktopExtension_default_instance_;
class HostToClient;
struct HostToClientDefaultTypeInternal;
extern HostToClientDefaultTypeInternal _HostToClient_default_instance_;
class KeyEvent;
struct KeyEventDefaultTypeInternal;
extern KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
class MouseEvent;
struct MouseEventDefaultTypeInternal;
extern MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
class PixelFormat;
struct PixelFormatDefaultTypeInternal;
extern PixelFormatDefaultTypeInternal _PixelFormat_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class Size;
struct SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class TextEvent;
struct TextEventDefaultTypeInternal;
extern TextEventDefaultTypeInternal _TextEvent_default_instance_;
class VideoPacket;
struct VideoPacketDefaultTypeInternal;
extern VideoPacketDefaultTypeInternal _VideoPacket_default_instance_;
class VideoPacketFormat;
struct VideoPacketFormatDefaultTypeInternal;
extern VideoPacketFormatDefaultTypeInternal _VideoPacketFormat_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::AudioPacket* Arena::CreateMaybeMessage<::proto::AudioPacket>(Arena*);
template<> ::proto::ClientToHost* Arena::CreateMaybeMessage<::proto::ClientToHost>(Arena*);
template<> ::proto::ClipboardEvent* Arena::CreateMaybeMessage<::proto::ClipboardEvent>(Arena*);
template<> ::proto::CursorPosition* Arena::CreateMaybeMessage<::proto::CursorPosition>(Arena*);
template<> ::proto::CursorShape* Arena::CreateMaybeMessage<::proto::CursorShape>(Arena*);
template<> ::proto::DesktopCapabilities* Arena::CreateMaybeMessage<::proto::DesktopCapabilities>(Arena*);
template<> ::proto::DesktopCapabilities_Flag* Arena::CreateMaybeMessage<::proto::DesktopCapabilities_Flag>(Arena*);
template<> ::proto::DesktopConfig* Arena::CreateMaybeMessage<::proto::DesktopConfig>(Arena*);
template<> ::proto::DesktopExtension* Arena::CreateMaybeMessage<::proto::DesktopExtension>(Arena*);
template<> ::proto::HostToClient* Arena::CreateMaybeMessage<::proto::HostToClient>(Arena*);
template<> ::proto::KeyEvent* Arena::CreateMaybeMessage<::proto::KeyEvent>(Arena*);
template<> ::proto::MouseEvent* Arena::CreateMaybeMessage<::proto::MouseEvent>(Arena*);
template<> ::proto::PixelFormat* Arena::CreateMaybeMessage<::proto::PixelFormat>(Arena*);
template<> ::proto::Rect* Arena::CreateMaybeMessage<::proto::Rect>(Arena*);
template<> ::proto::Size* Arena::CreateMaybeMessage<::proto::Size>(Arena*);
template<> ::proto::TextEvent* Arena::CreateMaybeMessage<::proto::TextEvent>(Arena*);
template<> ::proto::VideoPacket* Arena::CreateMaybeMessage<::proto::VideoPacket>(Arena*);
template<> ::proto::VideoPacketFormat* Arena::CreateMaybeMessage<::proto::VideoPacketFormat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum KeyEvent_Flags : int {
  KeyEvent_Flags_UNKNOWN = 0,
  KeyEvent_Flags_CAPSLOCK = 1,
  KeyEvent_Flags_NUMLOCK = 2,
  KeyEvent_Flags_PRESSED = 4,
  KeyEvent_Flags_KeyEvent_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KeyEvent_Flags_KeyEvent_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KeyEvent_Flags_IsValid(int value);
constexpr KeyEvent_Flags KeyEvent_Flags_Flags_MIN = KeyEvent_Flags_UNKNOWN;
constexpr KeyEvent_Flags KeyEvent_Flags_Flags_MAX = KeyEvent_Flags_PRESSED;
constexpr int KeyEvent_Flags_Flags_ARRAYSIZE = KeyEvent_Flags_Flags_MAX + 1;

const std::string& KeyEvent_Flags_Name(KeyEvent_Flags value);
template<typename T>
inline const std::string& KeyEvent_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyEvent_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyEvent_Flags_Name.");
  return KeyEvent_Flags_Name(static_cast<KeyEvent_Flags>(enum_t_value));
}
bool KeyEvent_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyEvent_Flags* value);
enum MouseEvent_ButtonMask : int {
  MouseEvent_ButtonMask_EMPTY = 0,
  MouseEvent_ButtonMask_LEFT_BUTTON = 1,
  MouseEvent_ButtonMask_MIDDLE_BUTTON = 2,
  MouseEvent_ButtonMask_RIGHT_BUTTON = 4,
  MouseEvent_ButtonMask_WHEEL_UP = 8,
  MouseEvent_ButtonMask_WHEEL_DOWN = 16,
  MouseEvent_ButtonMask_BACK_BUTTON = 32,
  MouseEvent_ButtonMask_FORWARD_BUTTON = 64,
  MouseEvent_ButtonMask_MouseEvent_ButtonMask_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MouseEvent_ButtonMask_MouseEvent_ButtonMask_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MouseEvent_ButtonMask_IsValid(int value);
constexpr MouseEvent_ButtonMask MouseEvent_ButtonMask_ButtonMask_MIN = MouseEvent_ButtonMask_EMPTY;
constexpr MouseEvent_ButtonMask MouseEvent_ButtonMask_ButtonMask_MAX = MouseEvent_ButtonMask_FORWARD_BUTTON;
constexpr int MouseEvent_ButtonMask_ButtonMask_ARRAYSIZE = MouseEvent_ButtonMask_ButtonMask_MAX + 1;

const std::string& MouseEvent_ButtonMask_Name(MouseEvent_ButtonMask value);
template<typename T>
inline const std::string& MouseEvent_ButtonMask_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MouseEvent_ButtonMask>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MouseEvent_ButtonMask_Name.");
  return MouseEvent_ButtonMask_Name(static_cast<MouseEvent_ButtonMask>(enum_t_value));
}
bool MouseEvent_ButtonMask_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MouseEvent_ButtonMask* value);
enum CursorShape_Flags : int {
  CursorShape_Flags_UNKNOWN = 0,
  CursorShape_Flags_RESET_CACHE = 64,
  CursorShape_Flags_CACHE = 128,
  CursorShape_Flags_CursorShape_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CursorShape_Flags_CursorShape_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CursorShape_Flags_IsValid(int value);
constexpr CursorShape_Flags CursorShape_Flags_Flags_MIN = CursorShape_Flags_UNKNOWN;
constexpr CursorShape_Flags CursorShape_Flags_Flags_MAX = CursorShape_Flags_CACHE;
constexpr int CursorShape_Flags_Flags_ARRAYSIZE = CursorShape_Flags_Flags_MAX + 1;

const std::string& CursorShape_Flags_Name(CursorShape_Flags value);
template<typename T>
inline const std::string& CursorShape_Flags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CursorShape_Flags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CursorShape_Flags_Name.");
  return CursorShape_Flags_Name(static_cast<CursorShape_Flags>(enum_t_value));
}
bool CursorShape_Flags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CursorShape_Flags* value);
enum AudioPacket_SamplingRate : int {
  AudioPacket_SamplingRate_SAMPLING_RATE_INVALID = 0,
  AudioPacket_SamplingRate_SAMPLING_RATE_44100 = 44100,
  AudioPacket_SamplingRate_SAMPLING_RATE_48000 = 48000,
  AudioPacket_SamplingRate_SAMPLING_RATE_96000 = 96000,
  AudioPacket_SamplingRate_SAMPLING_RATE_192000 = 192000,
  AudioPacket_SamplingRate_AudioPacket_SamplingRate_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioPacket_SamplingRate_AudioPacket_SamplingRate_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioPacket_SamplingRate_IsValid(int value);
constexpr AudioPacket_SamplingRate AudioPacket_SamplingRate_SamplingRate_MIN = AudioPacket_SamplingRate_SAMPLING_RATE_INVALID;
constexpr AudioPacket_SamplingRate AudioPacket_SamplingRate_SamplingRate_MAX = AudioPacket_SamplingRate_SAMPLING_RATE_192000;
constexpr int AudioPacket_SamplingRate_SamplingRate_ARRAYSIZE = AudioPacket_SamplingRate_SamplingRate_MAX + 1;

const std::string& AudioPacket_SamplingRate_Name(AudioPacket_SamplingRate value);
template<typename T>
inline const std::string& AudioPacket_SamplingRate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioPacket_SamplingRate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioPacket_SamplingRate_Name.");
  return AudioPacket_SamplingRate_Name(static_cast<AudioPacket_SamplingRate>(enum_t_value));
}
bool AudioPacket_SamplingRate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPacket_SamplingRate* value);
enum AudioPacket_BytesPerSample : int {
  AudioPacket_BytesPerSample_BYTES_PER_SAMPLE_INVALID = 0,
  AudioPacket_BytesPerSample_BYTES_PER_SAMPLE_2 = 2,
  AudioPacket_BytesPerSample_AudioPacket_BytesPerSample_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioPacket_BytesPerSample_AudioPacket_BytesPerSample_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioPacket_BytesPerSample_IsValid(int value);
constexpr AudioPacket_BytesPerSample AudioPacket_BytesPerSample_BytesPerSample_MIN = AudioPacket_BytesPerSample_BYTES_PER_SAMPLE_INVALID;
constexpr AudioPacket_BytesPerSample AudioPacket_BytesPerSample_BytesPerSample_MAX = AudioPacket_BytesPerSample_BYTES_PER_SAMPLE_2;
constexpr int AudioPacket_BytesPerSample_BytesPerSample_ARRAYSIZE = AudioPacket_BytesPerSample_BytesPerSample_MAX + 1;

const std::string& AudioPacket_BytesPerSample_Name(AudioPacket_BytesPerSample value);
template<typename T>
inline const std::string& AudioPacket_BytesPerSample_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioPacket_BytesPerSample>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioPacket_BytesPerSample_Name.");
  return AudioPacket_BytesPerSample_Name(static_cast<AudioPacket_BytesPerSample>(enum_t_value));
}
bool AudioPacket_BytesPerSample_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPacket_BytesPerSample* value);
enum AudioPacket_Channels : int {
  AudioPacket_Channels_CHANNELS_INVALID = 0,
  AudioPacket_Channels_CHANNELS_MONO = 1,
  AudioPacket_Channels_CHANNELS_STEREO = 2,
  AudioPacket_Channels_CHANNELS_SURROUND = 3,
  AudioPacket_Channels_CHANNELS_4_0 = 4,
  AudioPacket_Channels_CHANNELS_4_1 = 5,
  AudioPacket_Channels_CHANNELS_5_1 = 6,
  AudioPacket_Channels_CHANNELS_6_1 = 7,
  AudioPacket_Channels_CHANNELS_7_1 = 8,
  AudioPacket_Channels_AudioPacket_Channels_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioPacket_Channels_AudioPacket_Channels_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioPacket_Channels_IsValid(int value);
constexpr AudioPacket_Channels AudioPacket_Channels_Channels_MIN = AudioPacket_Channels_CHANNELS_INVALID;
constexpr AudioPacket_Channels AudioPacket_Channels_Channels_MAX = AudioPacket_Channels_CHANNELS_7_1;
constexpr int AudioPacket_Channels_Channels_ARRAYSIZE = AudioPacket_Channels_Channels_MAX + 1;

const std::string& AudioPacket_Channels_Name(AudioPacket_Channels value);
template<typename T>
inline const std::string& AudioPacket_Channels_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioPacket_Channels>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioPacket_Channels_Name.");
  return AudioPacket_Channels_Name(static_cast<AudioPacket_Channels>(enum_t_value));
}
bool AudioPacket_Channels_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPacket_Channels* value);
enum DesktopCapabilities_OsType : int {
  DesktopCapabilities_OsType_OS_TYPE_WINDOWS = 0,
  DesktopCapabilities_OsType_OS_TYPE_LINUX = 1,
  DesktopCapabilities_OsType_OS_TYPE_MACOSX = 2,
  DesktopCapabilities_OsType_DesktopCapabilities_OsType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DesktopCapabilities_OsType_DesktopCapabilities_OsType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DesktopCapabilities_OsType_IsValid(int value);
constexpr DesktopCapabilities_OsType DesktopCapabilities_OsType_OsType_MIN = DesktopCapabilities_OsType_OS_TYPE_WINDOWS;
constexpr DesktopCapabilities_OsType DesktopCapabilities_OsType_OsType_MAX = DesktopCapabilities_OsType_OS_TYPE_MACOSX;
constexpr int DesktopCapabilities_OsType_OsType_ARRAYSIZE = DesktopCapabilities_OsType_OsType_MAX + 1;

const std::string& DesktopCapabilities_OsType_Name(DesktopCapabilities_OsType value);
template<typename T>
inline const std::string& DesktopCapabilities_OsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DesktopCapabilities_OsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DesktopCapabilities_OsType_Name.");
  return DesktopCapabilities_OsType_Name(static_cast<DesktopCapabilities_OsType>(enum_t_value));
}
bool DesktopCapabilities_OsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DesktopCapabilities_OsType* value);
enum VideoEncoding : int {
  VIDEO_ENCODING_UNKNOWN = 0,
  VIDEO_ENCODING_ZSTD = 1,
  VIDEO_ENCODING_VP8 = 2,
  VIDEO_ENCODING_VP9 = 4,
  VideoEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VideoEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VideoEncoding_IsValid(int value);
constexpr VideoEncoding VideoEncoding_MIN = VIDEO_ENCODING_UNKNOWN;
constexpr VideoEncoding VideoEncoding_MAX = VIDEO_ENCODING_VP9;
constexpr int VideoEncoding_ARRAYSIZE = VideoEncoding_MAX + 1;

const std::string& VideoEncoding_Name(VideoEncoding value);
template<typename T>
inline const std::string& VideoEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoEncoding_Name.");
  return VideoEncoding_Name(static_cast<VideoEncoding>(enum_t_value));
}
bool VideoEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoEncoding* value);
enum VideoErrorCode : int {
  VIDEO_ERROR_CODE_OK = 0,
  VIDEO_ERROR_CODE_PAUSED = 1,
  VIDEO_ERROR_CODE_TEMPORARY = 2,
  VIDEO_ERROR_CODE_PERMANENT = 3,
  VideoErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VideoErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VideoErrorCode_IsValid(int value);
constexpr VideoErrorCode VideoErrorCode_MIN = VIDEO_ERROR_CODE_OK;
constexpr VideoErrorCode VideoErrorCode_MAX = VIDEO_ERROR_CODE_PERMANENT;
constexpr int VideoErrorCode_ARRAYSIZE = VideoErrorCode_MAX + 1;

const std::string& VideoErrorCode_Name(VideoErrorCode value);
template<typename T>
inline const std::string& VideoErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoErrorCode_Name.");
  return VideoErrorCode_Name(static_cast<VideoErrorCode>(enum_t_value));
}
bool VideoErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoErrorCode* value);
enum AudioEncoding : int {
  AUDIO_ENCODING_UNKNOWN = 0,
  AUDIO_ENCODING_DEFAULT = 1,
  AUDIO_ENCODING_RAW = 2,
  AUDIO_ENCODING_OPUS = 3,
  AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioEncoding_IsValid(int value);
constexpr AudioEncoding AudioEncoding_MIN = AUDIO_ENCODING_UNKNOWN;
constexpr AudioEncoding AudioEncoding_MAX = AUDIO_ENCODING_OPUS;
constexpr int AudioEncoding_ARRAYSIZE = AudioEncoding_MAX + 1;

const std::string& AudioEncoding_Name(AudioEncoding value);
template<typename T>
inline const std::string& AudioEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioEncoding_Name.");
  return AudioEncoding_Name(static_cast<AudioEncoding>(enum_t_value));
}
bool AudioEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioEncoding* value);
enum DesktopFlags : int {
  NO_FLAGS = 0,
  ENABLE_CURSOR_SHAPE = 1,
  ENABLE_CLIPBOARD = 2,
  DISABLE_DESKTOP_EFFECTS = 4,
  DISABLE_DESKTOP_WALLPAPER = 8,
  DISABLE_FONT_SMOOTHING = 16,
  BLOCK_REMOTE_INPUT = 32,
  LOCK_AT_DISCONNECT = 64,
  CURSOR_POSITION = 128,
  CLEAR_CLIPBOARD = 256,
  DesktopFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DesktopFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DesktopFlags_IsValid(int value);
constexpr DesktopFlags DesktopFlags_MIN = NO_FLAGS;
constexpr DesktopFlags DesktopFlags_MAX = CLEAR_CLIPBOARD;
constexpr int DesktopFlags_ARRAYSIZE = DesktopFlags_MAX + 1;

const std::string& DesktopFlags_Name(DesktopFlags value);
template<typename T>
inline const std::string& DesktopFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DesktopFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DesktopFlags_Name.");
  return DesktopFlags_Name(static_cast<DesktopFlags>(enum_t_value));
}
bool DesktopFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DesktopFlags* value);
// ===================================================================

class KeyEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.KeyEvent) */ {
 public:
  inline KeyEvent() : KeyEvent(nullptr) {}
  ~KeyEvent() override;
  explicit PROTOBUF_CONSTEXPR KeyEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyEvent(const KeyEvent& from);
  KeyEvent(KeyEvent&& from) noexcept
    : KeyEvent() {
    *this = ::std::move(from);
  }

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyEvent& operator=(KeyEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KeyEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyEvent* internal_default_instance() {
    return reinterpret_cast<const KeyEvent*>(
               &_KeyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KeyEvent& a, KeyEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.KeyEvent";
  }
  protected:
  explicit KeyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef KeyEvent_Flags Flags;
  static constexpr Flags UNKNOWN =
    KeyEvent_Flags_UNKNOWN;
  static constexpr Flags CAPSLOCK =
    KeyEvent_Flags_CAPSLOCK;
  static constexpr Flags NUMLOCK =
    KeyEvent_Flags_NUMLOCK;
  static constexpr Flags PRESSED =
    KeyEvent_Flags_PRESSED;
  static inline bool Flags_IsValid(int value) {
    return KeyEvent_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    KeyEvent_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    KeyEvent_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    KeyEvent_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return KeyEvent_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return KeyEvent_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsbKeycodeFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  // uint32 usb_keycode = 1;
  void clear_usb_keycode();
  uint32_t usb_keycode() const;
  void set_usb_keycode(uint32_t value);
  private:
  uint32_t _internal_usb_keycode() const;
  void _internal_set_usb_keycode(uint32_t value);
  public:

  // uint32 flags = 2;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.KeyEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t usb_keycode_;
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class TextEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.TextEvent) */ {
 public:
  inline TextEvent() : TextEvent(nullptr) {}
  ~TextEvent() override;
  explicit PROTOBUF_CONSTEXPR TextEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextEvent(const TextEvent& from);
  TextEvent(TextEvent&& from) noexcept
    : TextEvent() {
    *this = ::std::move(from);
  }

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent& operator=(TextEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TextEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextEvent* internal_default_instance() {
    return reinterpret_cast<const TextEvent*>(
               &_TextEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TextEvent& a, TextEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextEvent& from);
  void MergeFrom(const TextEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TextEvent";
  }
  protected:
  explicit TextEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:proto.TextEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class MouseEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.MouseEvent) */ {
 public:
  inline MouseEvent() : MouseEvent(nullptr) {}
  ~MouseEvent() override;
  explicit PROTOBUF_CONSTEXPR MouseEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MouseEvent(const MouseEvent& from);
  MouseEvent(MouseEvent&& from) noexcept
    : MouseEvent() {
    *this = ::std::move(from);
  }

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseEvent& operator=(MouseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MouseEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseEvent* internal_default_instance() {
    return reinterpret_cast<const MouseEvent*>(
               &_MouseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MouseEvent& a, MouseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MouseEvent& from);
  void MergeFrom(const MouseEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MouseEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MouseEvent";
  }
  protected:
  explicit MouseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef MouseEvent_ButtonMask ButtonMask;
  static constexpr ButtonMask EMPTY =
    MouseEvent_ButtonMask_EMPTY;
  static constexpr ButtonMask LEFT_BUTTON =
    MouseEvent_ButtonMask_LEFT_BUTTON;
  static constexpr ButtonMask MIDDLE_BUTTON =
    MouseEvent_ButtonMask_MIDDLE_BUTTON;
  static constexpr ButtonMask RIGHT_BUTTON =
    MouseEvent_ButtonMask_RIGHT_BUTTON;
  static constexpr ButtonMask WHEEL_UP =
    MouseEvent_ButtonMask_WHEEL_UP;
  static constexpr ButtonMask WHEEL_DOWN =
    MouseEvent_ButtonMask_WHEEL_DOWN;
  static constexpr ButtonMask BACK_BUTTON =
    MouseEvent_ButtonMask_BACK_BUTTON;
  static constexpr ButtonMask FORWARD_BUTTON =
    MouseEvent_ButtonMask_FORWARD_BUTTON;
  static inline bool ButtonMask_IsValid(int value) {
    return MouseEvent_ButtonMask_IsValid(value);
  }
  static constexpr ButtonMask ButtonMask_MIN =
    MouseEvent_ButtonMask_ButtonMask_MIN;
  static constexpr ButtonMask ButtonMask_MAX =
    MouseEvent_ButtonMask_ButtonMask_MAX;
  static constexpr int ButtonMask_ARRAYSIZE =
    MouseEvent_ButtonMask_ButtonMask_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ButtonMask_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ButtonMask>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ButtonMask_Name.");
    return MouseEvent_ButtonMask_Name(enum_t_value);
  }
  static inline bool ButtonMask_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ButtonMask* value) {
    return MouseEvent_ButtonMask_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMaskFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // uint32 mask = 1;
  void clear_mask();
  uint32_t mask() const;
  void set_mask(uint32_t value);
  private:
  uint32_t _internal_mask() const;
  void _internal_set_mask(uint32_t value);
  public:

  // int32 x = 2;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 3;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MouseEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t mask_;
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class ClipboardEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ClipboardEvent) */ {
 public:
  inline ClipboardEvent() : ClipboardEvent(nullptr) {}
  ~ClipboardEvent() override;
  explicit PROTOBUF_CONSTEXPR ClipboardEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClipboardEvent(const ClipboardEvent& from);
  ClipboardEvent(ClipboardEvent&& from) noexcept
    : ClipboardEvent() {
    *this = ::std::move(from);
  }

  inline ClipboardEvent& operator=(const ClipboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClipboardEvent& operator=(ClipboardEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ClipboardEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClipboardEvent* internal_default_instance() {
    return reinterpret_cast<const ClipboardEvent*>(
               &_ClipboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClipboardEvent& a, ClipboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ClipboardEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClipboardEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClipboardEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClipboardEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClipboardEvent& from);
  void MergeFrom(const ClipboardEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClipboardEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ClipboardEvent";
  }
  protected:
  explicit ClipboardEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string mime_type = 1;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:proto.ClipboardEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class CursorShape final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.CursorShape) */ {
 public:
  inline CursorShape() : CursorShape(nullptr) {}
  ~CursorShape() override;
  explicit PROTOBUF_CONSTEXPR CursorShape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CursorShape(const CursorShape& from);
  CursorShape(CursorShape&& from) noexcept
    : CursorShape() {
    *this = ::std::move(from);
  }

  inline CursorShape& operator=(const CursorShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline CursorShape& operator=(CursorShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CursorShape& default_instance() {
    return *internal_default_instance();
  }
  static inline const CursorShape* internal_default_instance() {
    return reinterpret_cast<const CursorShape*>(
               &_CursorShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CursorShape& a, CursorShape& b) {
    a.Swap(&b);
  }
  inline void Swap(CursorShape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CursorShape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CursorShape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CursorShape>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CursorShape& from);
  void MergeFrom(const CursorShape& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CursorShape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CursorShape";
  }
  protected:
  explicit CursorShape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CursorShape_Flags Flags;
  static constexpr Flags UNKNOWN =
    CursorShape_Flags_UNKNOWN;
  static constexpr Flags RESET_CACHE =
    CursorShape_Flags_RESET_CACHE;
  static constexpr Flags CACHE =
    CursorShape_Flags_CACHE;
  static inline bool Flags_IsValid(int value) {
    return CursorShape_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN =
    CursorShape_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX =
    CursorShape_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE =
    CursorShape_Flags_Flags_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Flags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Flags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Flags_Name.");
    return CursorShape_Flags_Name(enum_t_value);
  }
  static inline bool Flags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Flags* value) {
    return CursorShape_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 6,
    kFlagsFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kHotspotXFieldNumber = 4,
    kHotspotYFieldNumber = 5,
    kDpiXFieldNumber = 7,
    kDpiYFieldNumber = 8,
  };
  // bytes data = 6;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 flags = 1;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // int32 width = 2;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 3;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 hotspot_x = 4;
  void clear_hotspot_x();
  int32_t hotspot_x() const;
  void set_hotspot_x(int32_t value);
  private:
  int32_t _internal_hotspot_x() const;
  void _internal_set_hotspot_x(int32_t value);
  public:

  // int32 hotspot_y = 5;
  void clear_hotspot_y();
  int32_t hotspot_y() const;
  void set_hotspot_y(int32_t value);
  private:
  int32_t _internal_hotspot_y() const;
  void _internal_set_hotspot_y(int32_t value);
  public:

  // int32 dpi_x = 7;
  void clear_dpi_x();
  int32_t dpi_x() const;
  void set_dpi_x(int32_t value);
  private:
  int32_t _internal_dpi_x() const;
  void _internal_set_dpi_x(int32_t value);
  public:

  // int32 dpi_y = 8;
  void clear_dpi_y();
  int32_t dpi_y() const;
  void set_dpi_y(int32_t value);
  private:
  int32_t _internal_dpi_y() const;
  void _internal_set_dpi_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.CursorShape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint32_t flags_;
    int32_t width_;
    int32_t height_;
    int32_t hotspot_x_;
    int32_t hotspot_y_;
    int32_t dpi_x_;
    int32_t dpi_y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class CursorPosition final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.CursorPosition) */ {
 public:
  inline CursorPosition() : CursorPosition(nullptr) {}
  ~CursorPosition() override;
  explicit PROTOBUF_CONSTEXPR CursorPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CursorPosition(const CursorPosition& from);
  CursorPosition(CursorPosition&& from) noexcept
    : CursorPosition() {
    *this = ::std::move(from);
  }

  inline CursorPosition& operator=(const CursorPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CursorPosition& operator=(CursorPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CursorPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CursorPosition* internal_default_instance() {
    return reinterpret_cast<const CursorPosition*>(
               &_CursorPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CursorPosition& a, CursorPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(CursorPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CursorPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CursorPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CursorPosition>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CursorPosition& from);
  void MergeFrom(const CursorPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CursorPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CursorPosition";
  }
  protected:
  explicit CursorPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.CursorPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Size) */ {
 public:
  inline Size() : Size(nullptr) {}
  ~Size() override;
  explicit PROTOBUF_CONSTEXPR Size(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Size& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  inline void Swap(Size* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Size& from);
  void MergeFrom(const Size& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Size* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Size";
  }
  protected:
  explicit Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Size)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Rect) */ {
 public:
  inline Rect() : Rect(nullptr) {}
  ~Rect() override;
  explicit PROTOBUF_CONSTEXPR Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Rect";
  }
  protected:
  explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 width = 3;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class PixelFormat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.PixelFormat) */ {
 public:
  inline PixelFormat() : PixelFormat(nullptr) {}
  ~PixelFormat() override;
  explicit PROTOBUF_CONSTEXPR PixelFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PixelFormat(const PixelFormat& from);
  PixelFormat(PixelFormat&& from) noexcept
    : PixelFormat() {
    *this = ::std::move(from);
  }

  inline PixelFormat& operator=(const PixelFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline PixelFormat& operator=(PixelFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PixelFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const PixelFormat* internal_default_instance() {
    return reinterpret_cast<const PixelFormat*>(
               &_PixelFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PixelFormat& a, PixelFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(PixelFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PixelFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PixelFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PixelFormat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PixelFormat& from);
  void MergeFrom(const PixelFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PixelFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PixelFormat";
  }
  protected:
  explicit PixelFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitsPerPixelFieldNumber = 1,
    kRedMaxFieldNumber = 2,
    kGreenMaxFieldNumber = 3,
    kBlueMaxFieldNumber = 4,
    kRedShiftFieldNumber = 5,
    kGreenShiftFieldNumber = 6,
    kBlueShiftFieldNumber = 7,
  };
  // uint32 bits_per_pixel = 1;
  void clear_bits_per_pixel();
  uint32_t bits_per_pixel() const;
  void set_bits_per_pixel(uint32_t value);
  private:
  uint32_t _internal_bits_per_pixel() const;
  void _internal_set_bits_per_pixel(uint32_t value);
  public:

  // uint32 red_max = 2;
  void clear_red_max();
  uint32_t red_max() const;
  void set_red_max(uint32_t value);
  private:
  uint32_t _internal_red_max() const;
  void _internal_set_red_max(uint32_t value);
  public:

  // uint32 green_max = 3;
  void clear_green_max();
  uint32_t green_max() const;
  void set_green_max(uint32_t value);
  private:
  uint32_t _internal_green_max() const;
  void _internal_set_green_max(uint32_t value);
  public:

  // uint32 blue_max = 4;
  void clear_blue_max();
  uint32_t blue_max() const;
  void set_blue_max(uint32_t value);
  private:
  uint32_t _internal_blue_max() const;
  void _internal_set_blue_max(uint32_t value);
  public:

  // uint32 red_shift = 5;
  void clear_red_shift();
  uint32_t red_shift() const;
  void set_red_shift(uint32_t value);
  private:
  uint32_t _internal_red_shift() const;
  void _internal_set_red_shift(uint32_t value);
  public:

  // uint32 green_shift = 6;
  void clear_green_shift();
  uint32_t green_shift() const;
  void set_green_shift(uint32_t value);
  private:
  uint32_t _internal_green_shift() const;
  void _internal_set_green_shift(uint32_t value);
  public:

  // uint32 blue_shift = 7;
  void clear_blue_shift();
  uint32_t blue_shift() const;
  void set_blue_shift(uint32_t value);
  private:
  uint32_t _internal_blue_shift() const;
  void _internal_set_blue_shift(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.PixelFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t bits_per_pixel_;
    uint32_t red_max_;
    uint32_t green_max_;
    uint32_t blue_max_;
    uint32_t red_shift_;
    uint32_t green_shift_;
    uint32_t blue_shift_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class VideoPacketFormat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.VideoPacketFormat) */ {
 public:
  inline VideoPacketFormat() : VideoPacketFormat(nullptr) {}
  ~VideoPacketFormat() override;
  explicit PROTOBUF_CONSTEXPR VideoPacketFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoPacketFormat(const VideoPacketFormat& from);
  VideoPacketFormat(VideoPacketFormat&& from) noexcept
    : VideoPacketFormat() {
    *this = ::std::move(from);
  }

  inline VideoPacketFormat& operator=(const VideoPacketFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoPacketFormat& operator=(VideoPacketFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoPacketFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoPacketFormat* internal_default_instance() {
    return reinterpret_cast<const VideoPacketFormat*>(
               &_VideoPacketFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VideoPacketFormat& a, VideoPacketFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoPacketFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoPacketFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoPacketFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoPacketFormat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoPacketFormat& from);
  void MergeFrom(const VideoPacketFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoPacketFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.VideoPacketFormat";
  }
  protected:
  explicit VideoPacketFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoRectFieldNumber = 1,
    kPixelFormatFieldNumber = 2,
    kScreenSizeFieldNumber = 3,
    kCapturerTypeFieldNumber = 4,
  };
  // .proto.Rect video_rect = 1;
  bool has_video_rect() const;
  private:
  bool _internal_has_video_rect() const;
  public:
  void clear_video_rect();
  const ::proto::Rect& video_rect() const;
  PROTOBUF_NODISCARD ::proto::Rect* release_video_rect();
  ::proto::Rect* mutable_video_rect();
  void set_allocated_video_rect(::proto::Rect* video_rect);
  private:
  const ::proto::Rect& _internal_video_rect() const;
  ::proto::Rect* _internal_mutable_video_rect();
  public:
  void unsafe_arena_set_allocated_video_rect(
      ::proto::Rect* video_rect);
  ::proto::Rect* unsafe_arena_release_video_rect();

  // .proto.PixelFormat pixel_format = 2;
  bool has_pixel_format() const;
  private:
  bool _internal_has_pixel_format() const;
  public:
  void clear_pixel_format();
  const ::proto::PixelFormat& pixel_format() const;
  PROTOBUF_NODISCARD ::proto::PixelFormat* release_pixel_format();
  ::proto::PixelFormat* mutable_pixel_format();
  void set_allocated_pixel_format(::proto::PixelFormat* pixel_format);
  private:
  const ::proto::PixelFormat& _internal_pixel_format() const;
  ::proto::PixelFormat* _internal_mutable_pixel_format();
  public:
  void unsafe_arena_set_allocated_pixel_format(
      ::proto::PixelFormat* pixel_format);
  ::proto::PixelFormat* unsafe_arena_release_pixel_format();

  // .proto.Size screen_size = 3;
  bool has_screen_size() const;
  private:
  bool _internal_has_screen_size() const;
  public:
  void clear_screen_size();
  const ::proto::Size& screen_size() const;
  PROTOBUF_NODISCARD ::proto::Size* release_screen_size();
  ::proto::Size* mutable_screen_size();
  void set_allocated_screen_size(::proto::Size* screen_size);
  private:
  const ::proto::Size& _internal_screen_size() const;
  ::proto::Size* _internal_mutable_screen_size();
  public:
  void unsafe_arena_set_allocated_screen_size(
      ::proto::Size* screen_size);
  ::proto::Size* unsafe_arena_release_screen_size();

  // uint32 capturer_type = 4;
  void clear_capturer_type();
  uint32_t capturer_type() const;
  void set_capturer_type(uint32_t value);
  private:
  uint32_t _internal_capturer_type() const;
  void _internal_set_capturer_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.VideoPacketFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::Rect* video_rect_;
    ::proto::PixelFormat* pixel_format_;
    ::proto::Size* screen_size_;
    uint32_t capturer_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class VideoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.VideoPacket) */ {
 public:
  inline VideoPacket() : VideoPacket(nullptr) {}
  ~VideoPacket() override;
  explicit PROTOBUF_CONSTEXPR VideoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoPacket(const VideoPacket& from);
  VideoPacket(VideoPacket&& from) noexcept
    : VideoPacket() {
    *this = ::std::move(from);
  }

  inline VideoPacket& operator=(const VideoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoPacket& operator=(VideoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoPacket* internal_default_instance() {
    return reinterpret_cast<const VideoPacket*>(
               &_VideoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VideoPacket& a, VideoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoPacket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoPacket& from);
  void MergeFrom(const VideoPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.VideoPacket";
  }
  protected:
  explicit VideoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirtyRectFieldNumber = 3,
    kDataFieldNumber = 4,
    kFormatFieldNumber = 2,
    kEncodingFieldNumber = 1,
    kErrorCodeFieldNumber = 5,
  };
  // repeated .proto.Rect dirty_rect = 3;
  int dirty_rect_size() const;
  private:
  int _internal_dirty_rect_size() const;
  public:
  void clear_dirty_rect();
  ::proto::Rect* mutable_dirty_rect(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >*
      mutable_dirty_rect();
  private:
  const ::proto::Rect& _internal_dirty_rect(int index) const;
  ::proto::Rect* _internal_add_dirty_rect();
  public:
  const ::proto::Rect& dirty_rect(int index) const;
  ::proto::Rect* add_dirty_rect();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >&
      dirty_rect() const;

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .proto.VideoPacketFormat format = 2;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const ::proto::VideoPacketFormat& format() const;
  PROTOBUF_NODISCARD ::proto::VideoPacketFormat* release_format();
  ::proto::VideoPacketFormat* mutable_format();
  void set_allocated_format(::proto::VideoPacketFormat* format);
  private:
  const ::proto::VideoPacketFormat& _internal_format() const;
  ::proto::VideoPacketFormat* _internal_mutable_format();
  public:
  void unsafe_arena_set_allocated_format(
      ::proto::VideoPacketFormat* format);
  ::proto::VideoPacketFormat* unsafe_arena_release_format();

  // .proto.VideoEncoding encoding = 1;
  void clear_encoding();
  ::proto::VideoEncoding encoding() const;
  void set_encoding(::proto::VideoEncoding value);
  private:
  ::proto::VideoEncoding _internal_encoding() const;
  void _internal_set_encoding(::proto::VideoEncoding value);
  public:

  // .proto.VideoErrorCode error_code = 5;
  void clear_error_code();
  ::proto::VideoErrorCode error_code() const;
  void set_error_code(::proto::VideoErrorCode value);
  private:
  ::proto::VideoErrorCode _internal_error_code() const;
  void _internal_set_error_code(::proto::VideoErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:proto.VideoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect > dirty_rect_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::proto::VideoPacketFormat* format_;
    int encoding_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class AudioPacket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.AudioPacket) */ {
 public:
  inline AudioPacket() : AudioPacket(nullptr) {}
  ~AudioPacket() override;
  explicit PROTOBUF_CONSTEXPR AudioPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioPacket(const AudioPacket& from);
  AudioPacket(AudioPacket&& from) noexcept
    : AudioPacket() {
    *this = ::std::move(from);
  }

  inline AudioPacket& operator=(const AudioPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioPacket& operator=(AudioPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AudioPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioPacket* internal_default_instance() {
    return reinterpret_cast<const AudioPacket*>(
               &_AudioPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AudioPacket& a, AudioPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioPacket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AudioPacket& from);
  void MergeFrom(const AudioPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AudioPacket";
  }
  protected:
  explicit AudioPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AudioPacket_SamplingRate SamplingRate;
  static constexpr SamplingRate SAMPLING_RATE_INVALID =
    AudioPacket_SamplingRate_SAMPLING_RATE_INVALID;
  static constexpr SamplingRate SAMPLING_RATE_44100 =
    AudioPacket_SamplingRate_SAMPLING_RATE_44100;
  static constexpr SamplingRate SAMPLING_RATE_48000 =
    AudioPacket_SamplingRate_SAMPLING_RATE_48000;
  static constexpr SamplingRate SAMPLING_RATE_96000 =
    AudioPacket_SamplingRate_SAMPLING_RATE_96000;
  static constexpr SamplingRate SAMPLING_RATE_192000 =
    AudioPacket_SamplingRate_SAMPLING_RATE_192000;
  static inline bool SamplingRate_IsValid(int value) {
    return AudioPacket_SamplingRate_IsValid(value);
  }
  static constexpr SamplingRate SamplingRate_MIN =
    AudioPacket_SamplingRate_SamplingRate_MIN;
  static constexpr SamplingRate SamplingRate_MAX =
    AudioPacket_SamplingRate_SamplingRate_MAX;
  static constexpr int SamplingRate_ARRAYSIZE =
    AudioPacket_SamplingRate_SamplingRate_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SamplingRate_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SamplingRate>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SamplingRate_Name.");
    return AudioPacket_SamplingRate_Name(enum_t_value);
  }
  static inline bool SamplingRate_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SamplingRate* value) {
    return AudioPacket_SamplingRate_Parse(name, value);
  }

  typedef AudioPacket_BytesPerSample BytesPerSample;
  static constexpr BytesPerSample BYTES_PER_SAMPLE_INVALID =
    AudioPacket_BytesPerSample_BYTES_PER_SAMPLE_INVALID;
  static constexpr BytesPerSample BYTES_PER_SAMPLE_2 =
    AudioPacket_BytesPerSample_BYTES_PER_SAMPLE_2;
  static inline bool BytesPerSample_IsValid(int value) {
    return AudioPacket_BytesPerSample_IsValid(value);
  }
  static constexpr BytesPerSample BytesPerSample_MIN =
    AudioPacket_BytesPerSample_BytesPerSample_MIN;
  static constexpr BytesPerSample BytesPerSample_MAX =
    AudioPacket_BytesPerSample_BytesPerSample_MAX;
  static constexpr int BytesPerSample_ARRAYSIZE =
    AudioPacket_BytesPerSample_BytesPerSample_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BytesPerSample_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BytesPerSample>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BytesPerSample_Name.");
    return AudioPacket_BytesPerSample_Name(enum_t_value);
  }
  static inline bool BytesPerSample_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BytesPerSample* value) {
    return AudioPacket_BytesPerSample_Parse(name, value);
  }

  typedef AudioPacket_Channels Channels;
  static constexpr Channels CHANNELS_INVALID =
    AudioPacket_Channels_CHANNELS_INVALID;
  static constexpr Channels CHANNELS_MONO =
    AudioPacket_Channels_CHANNELS_MONO;
  static constexpr Channels CHANNELS_STEREO =
    AudioPacket_Channels_CHANNELS_STEREO;
  static constexpr Channels CHANNELS_SURROUND =
    AudioPacket_Channels_CHANNELS_SURROUND;
  static constexpr Channels CHANNELS_4_0 =
    AudioPacket_Channels_CHANNELS_4_0;
  static constexpr Channels CHANNELS_4_1 =
    AudioPacket_Channels_CHANNELS_4_1;
  static constexpr Channels CHANNELS_5_1 =
    AudioPacket_Channels_CHANNELS_5_1;
  static constexpr Channels CHANNELS_6_1 =
    AudioPacket_Channels_CHANNELS_6_1;
  static constexpr Channels CHANNELS_7_1 =
    AudioPacket_Channels_CHANNELS_7_1;
  static inline bool Channels_IsValid(int value) {
    return AudioPacket_Channels_IsValid(value);
  }
  static constexpr Channels Channels_MIN =
    AudioPacket_Channels_Channels_MIN;
  static constexpr Channels Channels_MAX =
    AudioPacket_Channels_Channels_MAX;
  static constexpr int Channels_ARRAYSIZE =
    AudioPacket_Channels_Channels_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Channels_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Channels>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Channels_Name.");
    return AudioPacket_Channels_Name(enum_t_value);
  }
  static inline bool Channels_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Channels* value) {
    return AudioPacket_Channels_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kEncodingFieldNumber = 3,
    kSamplingRateFieldNumber = 4,
    kBytesPerSampleFieldNumber = 5,
    kChannelsFieldNumber = 6,
  };
  // repeated bytes data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // int32 timestamp = 1;
  void clear_timestamp();
  int32_t timestamp() const;
  void set_timestamp(int32_t value);
  private:
  int32_t _internal_timestamp() const;
  void _internal_set_timestamp(int32_t value);
  public:

  // .proto.AudioEncoding encoding = 3;
  void clear_encoding();
  ::proto::AudioEncoding encoding() const;
  void set_encoding(::proto::AudioEncoding value);
  private:
  ::proto::AudioEncoding _internal_encoding() const;
  void _internal_set_encoding(::proto::AudioEncoding value);
  public:

  // .proto.AudioPacket.SamplingRate sampling_rate = 4;
  void clear_sampling_rate();
  ::proto::AudioPacket_SamplingRate sampling_rate() const;
  void set_sampling_rate(::proto::AudioPacket_SamplingRate value);
  private:
  ::proto::AudioPacket_SamplingRate _internal_sampling_rate() const;
  void _internal_set_sampling_rate(::proto::AudioPacket_SamplingRate value);
  public:

  // .proto.AudioPacket.BytesPerSample bytes_per_sample = 5;
  void clear_bytes_per_sample();
  ::proto::AudioPacket_BytesPerSample bytes_per_sample() const;
  void set_bytes_per_sample(::proto::AudioPacket_BytesPerSample value);
  private:
  ::proto::AudioPacket_BytesPerSample _internal_bytes_per_sample() const;
  void _internal_set_bytes_per_sample(::proto::AudioPacket_BytesPerSample value);
  public:

  // .proto.AudioPacket.Channels channels = 6;
  void clear_channels();
  ::proto::AudioPacket_Channels channels() const;
  void set_channels(::proto::AudioPacket_Channels value);
  private:
  ::proto::AudioPacket_Channels _internal_channels() const;
  void _internal_set_channels(::proto::AudioPacket_Channels value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AudioPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
    int32_t timestamp_;
    int encoding_;
    int sampling_rate_;
    int bytes_per_sample_;
    int channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class DesktopExtension final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DesktopExtension) */ {
 public:
  inline DesktopExtension() : DesktopExtension(nullptr) {}
  ~DesktopExtension() override;
  explicit PROTOBUF_CONSTEXPR DesktopExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopExtension(const DesktopExtension& from);
  DesktopExtension(DesktopExtension&& from) noexcept
    : DesktopExtension() {
    *this = ::std::move(from);
  }

  inline DesktopExtension& operator=(const DesktopExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopExtension& operator=(DesktopExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopExtension* internal_default_instance() {
    return reinterpret_cast<const DesktopExtension*>(
               &_DesktopExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DesktopExtension& a, DesktopExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopExtension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopExtension& from);
  void MergeFrom(const DesktopExtension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DesktopExtension";
  }
  protected:
  explicit DesktopExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:proto.DesktopExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class DesktopCapabilities_Flag final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DesktopCapabilities.Flag) */ {
 public:
  inline DesktopCapabilities_Flag() : DesktopCapabilities_Flag(nullptr) {}
  ~DesktopCapabilities_Flag() override;
  explicit PROTOBUF_CONSTEXPR DesktopCapabilities_Flag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopCapabilities_Flag(const DesktopCapabilities_Flag& from);
  DesktopCapabilities_Flag(DesktopCapabilities_Flag&& from) noexcept
    : DesktopCapabilities_Flag() {
    *this = ::std::move(from);
  }

  inline DesktopCapabilities_Flag& operator=(const DesktopCapabilities_Flag& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopCapabilities_Flag& operator=(DesktopCapabilities_Flag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopCapabilities_Flag& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopCapabilities_Flag* internal_default_instance() {
    return reinterpret_cast<const DesktopCapabilities_Flag*>(
               &_DesktopCapabilities_Flag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DesktopCapabilities_Flag& a, DesktopCapabilities_Flag& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopCapabilities_Flag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopCapabilities_Flag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopCapabilities_Flag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopCapabilities_Flag>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopCapabilities_Flag& from);
  void MergeFrom(const DesktopCapabilities_Flag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopCapabilities_Flag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DesktopCapabilities.Flag";
  }
  protected:
  explicit DesktopCapabilities_Flag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool value = 2;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DesktopCapabilities.Flag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class DesktopCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DesktopCapabilities) */ {
 public:
  inline DesktopCapabilities() : DesktopCapabilities(nullptr) {}
  ~DesktopCapabilities() override;
  explicit PROTOBUF_CONSTEXPR DesktopCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopCapabilities(const DesktopCapabilities& from);
  DesktopCapabilities(DesktopCapabilities&& from) noexcept
    : DesktopCapabilities() {
    *this = ::std::move(from);
  }

  inline DesktopCapabilities& operator=(const DesktopCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopCapabilities& operator=(DesktopCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopCapabilities* internal_default_instance() {
    return reinterpret_cast<const DesktopCapabilities*>(
               &_DesktopCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DesktopCapabilities& a, DesktopCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopCapabilities>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopCapabilities& from);
  void MergeFrom(const DesktopCapabilities& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DesktopCapabilities";
  }
  protected:
  explicit DesktopCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DesktopCapabilities_Flag Flag;

  typedef DesktopCapabilities_OsType OsType;
  static constexpr OsType OS_TYPE_WINDOWS =
    DesktopCapabilities_OsType_OS_TYPE_WINDOWS;
  static constexpr OsType OS_TYPE_LINUX =
    DesktopCapabilities_OsType_OS_TYPE_LINUX;
  static constexpr OsType OS_TYPE_MACOSX =
    DesktopCapabilities_OsType_OS_TYPE_MACOSX;
  static inline bool OsType_IsValid(int value) {
    return DesktopCapabilities_OsType_IsValid(value);
  }
  static constexpr OsType OsType_MIN =
    DesktopCapabilities_OsType_OsType_MIN;
  static constexpr OsType OsType_MAX =
    DesktopCapabilities_OsType_OsType_MAX;
  static constexpr int OsType_ARRAYSIZE =
    DesktopCapabilities_OsType_OsType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& OsType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OsType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OsType_Name.");
    return DesktopCapabilities_OsType_Name(enum_t_value);
  }
  static inline bool OsType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OsType* value) {
    return DesktopCapabilities_OsType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 5,
    kExtensionsFieldNumber = 1,
    kVideoEncodingsFieldNumber = 2,
    kAudioEncodingsFieldNumber = 3,
    kOsTypeFieldNumber = 4,
  };
  // repeated .proto.DesktopCapabilities.Flag flag = 5;
  int flag_size() const;
  private:
  int _internal_flag_size() const;
  public:
  void clear_flag();
  ::proto::DesktopCapabilities_Flag* mutable_flag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DesktopCapabilities_Flag >*
      mutable_flag();
  private:
  const ::proto::DesktopCapabilities_Flag& _internal_flag(int index) const;
  ::proto::DesktopCapabilities_Flag* _internal_add_flag();
  public:
  const ::proto::DesktopCapabilities_Flag& flag(int index) const;
  ::proto::DesktopCapabilities_Flag* add_flag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DesktopCapabilities_Flag >&
      flag() const;

  // string extensions = 1;
  void clear_extensions();
  const std::string& extensions() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extensions(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extensions();
  PROTOBUF_NODISCARD std::string* release_extensions();
  void set_allocated_extensions(std::string* extensions);
  private:
  const std::string& _internal_extensions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extensions(const std::string& value);
  std::string* _internal_mutable_extensions();
  public:

  // uint32 video_encodings = 2;
  void clear_video_encodings();
  uint32_t video_encodings() const;
  void set_video_encodings(uint32_t value);
  private:
  uint32_t _internal_video_encodings() const;
  void _internal_set_video_encodings(uint32_t value);
  public:

  // uint32 audio_encodings = 3;
  void clear_audio_encodings();
  uint32_t audio_encodings() const;
  void set_audio_encodings(uint32_t value);
  private:
  uint32_t _internal_audio_encodings() const;
  void _internal_set_audio_encodings(uint32_t value);
  public:

  // .proto.DesktopCapabilities.OsType os_type = 4;
  void clear_os_type();
  ::proto::DesktopCapabilities_OsType os_type() const;
  void set_os_type(::proto::DesktopCapabilities_OsType value);
  private:
  ::proto::DesktopCapabilities_OsType _internal_os_type() const;
  void _internal_set_os_type(::proto::DesktopCapabilities_OsType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DesktopCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DesktopCapabilities_Flag > flag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extensions_;
    uint32_t video_encodings_;
    uint32_t audio_encodings_;
    int os_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class DesktopConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.DesktopConfig) */ {
 public:
  inline DesktopConfig() : DesktopConfig(nullptr) {}
  ~DesktopConfig() override;
  explicit PROTOBUF_CONSTEXPR DesktopConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesktopConfig(const DesktopConfig& from);
  DesktopConfig(DesktopConfig&& from) noexcept
    : DesktopConfig() {
    *this = ::std::move(from);
  }

  inline DesktopConfig& operator=(const DesktopConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesktopConfig& operator=(DesktopConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DesktopConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesktopConfig* internal_default_instance() {
    return reinterpret_cast<const DesktopConfig*>(
               &_DesktopConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DesktopConfig& a, DesktopConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DesktopConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesktopConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesktopConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesktopConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DesktopConfig& from);
  void MergeFrom(const DesktopConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DesktopConfig";
  }
  protected:
  explicit DesktopConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelFormatFieldNumber = 3,
    kFlagsFieldNumber = 1,
    kVideoEncodingFieldNumber = 2,
    kUpdateIntervalFieldNumber = 4,
    kCompressRatioFieldNumber = 5,
    kScaleFactorFieldNumber = 6,
    kAudioEncodingFieldNumber = 7,
  };
  // .proto.PixelFormat pixel_format = 3;
  bool has_pixel_format() const;
  private:
  bool _internal_has_pixel_format() const;
  public:
  void clear_pixel_format();
  const ::proto::PixelFormat& pixel_format() const;
  PROTOBUF_NODISCARD ::proto::PixelFormat* release_pixel_format();
  ::proto::PixelFormat* mutable_pixel_format();
  void set_allocated_pixel_format(::proto::PixelFormat* pixel_format);
  private:
  const ::proto::PixelFormat& _internal_pixel_format() const;
  ::proto::PixelFormat* _internal_mutable_pixel_format();
  public:
  void unsafe_arena_set_allocated_pixel_format(
      ::proto::PixelFormat* pixel_format);
  ::proto::PixelFormat* unsafe_arena_release_pixel_format();

  // uint32 flags = 1;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // .proto.VideoEncoding video_encoding = 2;
  void clear_video_encoding();
  ::proto::VideoEncoding video_encoding() const;
  void set_video_encoding(::proto::VideoEncoding value);
  private:
  ::proto::VideoEncoding _internal_video_encoding() const;
  void _internal_set_video_encoding(::proto::VideoEncoding value);
  public:

  // uint32 update_interval = 4;
  void clear_update_interval();
  uint32_t update_interval() const;
  void set_update_interval(uint32_t value);
  private:
  uint32_t _internal_update_interval() const;
  void _internal_set_update_interval(uint32_t value);
  public:

  // uint32 compress_ratio = 5;
  void clear_compress_ratio();
  uint32_t compress_ratio() const;
  void set_compress_ratio(uint32_t value);
  private:
  uint32_t _internal_compress_ratio() const;
  void _internal_set_compress_ratio(uint32_t value);
  public:

  // uint32 scale_factor = 6;
  void clear_scale_factor();
  uint32_t scale_factor() const;
  void set_scale_factor(uint32_t value);
  private:
  uint32_t _internal_scale_factor() const;
  void _internal_set_scale_factor(uint32_t value);
  public:

  // .proto.AudioEncoding audio_encoding = 7;
  void clear_audio_encoding();
  ::proto::AudioEncoding audio_encoding() const;
  void set_audio_encoding(::proto::AudioEncoding value);
  private:
  ::proto::AudioEncoding _internal_audio_encoding() const;
  void _internal_set_audio_encoding(::proto::AudioEncoding value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DesktopConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::PixelFormat* pixel_format_;
    uint32_t flags_;
    int video_encoding_;
    uint32_t update_interval_;
    uint32_t compress_ratio_;
    uint32_t scale_factor_;
    int audio_encoding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class HostToClient final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostToClient) */ {
 public:
  inline HostToClient() : HostToClient(nullptr) {}
  ~HostToClient() override;
  explicit PROTOBUF_CONSTEXPR HostToClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostToClient(const HostToClient& from);
  HostToClient(HostToClient&& from) noexcept
    : HostToClient() {
    *this = ::std::move(from);
  }

  inline HostToClient& operator=(const HostToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostToClient& operator=(HostToClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HostToClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostToClient* internal_default_instance() {
    return reinterpret_cast<const HostToClient*>(
               &_HostToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HostToClient& a, HostToClient& b) {
    a.Swap(&b);
  }
  inline void Swap(HostToClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostToClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostToClient>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostToClient& from);
  void MergeFrom(const HostToClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostToClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HostToClient";
  }
  protected:
  explicit HostToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoPacketFieldNumber = 1,
    kAudioPacketFieldNumber = 2,
    kCursorShapeFieldNumber = 3,
    kClipboardEventFieldNumber = 4,
    kExtensionFieldNumber = 5,
    kCapabilitiesFieldNumber = 6,
    kCursorPositionFieldNumber = 7,
  };
  // .proto.VideoPacket video_packet = 1;
  bool has_video_packet() const;
  private:
  bool _internal_has_video_packet() const;
  public:
  void clear_video_packet();
  const ::proto::VideoPacket& video_packet() const;
  PROTOBUF_NODISCARD ::proto::VideoPacket* release_video_packet();
  ::proto::VideoPacket* mutable_video_packet();
  void set_allocated_video_packet(::proto::VideoPacket* video_packet);
  private:
  const ::proto::VideoPacket& _internal_video_packet() const;
  ::proto::VideoPacket* _internal_mutable_video_packet();
  public:
  void unsafe_arena_set_allocated_video_packet(
      ::proto::VideoPacket* video_packet);
  ::proto::VideoPacket* unsafe_arena_release_video_packet();

  // .proto.AudioPacket audio_packet = 2;
  bool has_audio_packet() const;
  private:
  bool _internal_has_audio_packet() const;
  public:
  void clear_audio_packet();
  const ::proto::AudioPacket& audio_packet() const;
  PROTOBUF_NODISCARD ::proto::AudioPacket* release_audio_packet();
  ::proto::AudioPacket* mutable_audio_packet();
  void set_allocated_audio_packet(::proto::AudioPacket* audio_packet);
  private:
  const ::proto::AudioPacket& _internal_audio_packet() const;
  ::proto::AudioPacket* _internal_mutable_audio_packet();
  public:
  void unsafe_arena_set_allocated_audio_packet(
      ::proto::AudioPacket* audio_packet);
  ::proto::AudioPacket* unsafe_arena_release_audio_packet();

  // .proto.CursorShape cursor_shape = 3;
  bool has_cursor_shape() const;
  private:
  bool _internal_has_cursor_shape() const;
  public:
  void clear_cursor_shape();
  const ::proto::CursorShape& cursor_shape() const;
  PROTOBUF_NODISCARD ::proto::CursorShape* release_cursor_shape();
  ::proto::CursorShape* mutable_cursor_shape();
  void set_allocated_cursor_shape(::proto::CursorShape* cursor_shape);
  private:
  const ::proto::CursorShape& _internal_cursor_shape() const;
  ::proto::CursorShape* _internal_mutable_cursor_shape();
  public:
  void unsafe_arena_set_allocated_cursor_shape(
      ::proto::CursorShape* cursor_shape);
  ::proto::CursorShape* unsafe_arena_release_cursor_shape();

  // .proto.ClipboardEvent clipboard_event = 4;
  bool has_clipboard_event() const;
  private:
  bool _internal_has_clipboard_event() const;
  public:
  void clear_clipboard_event();
  const ::proto::ClipboardEvent& clipboard_event() const;
  PROTOBUF_NODISCARD ::proto::ClipboardEvent* release_clipboard_event();
  ::proto::ClipboardEvent* mutable_clipboard_event();
  void set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event);
  private:
  const ::proto::ClipboardEvent& _internal_clipboard_event() const;
  ::proto::ClipboardEvent* _internal_mutable_clipboard_event();
  public:
  void unsafe_arena_set_allocated_clipboard_event(
      ::proto::ClipboardEvent* clipboard_event);
  ::proto::ClipboardEvent* unsafe_arena_release_clipboard_event();

  // .proto.DesktopExtension extension = 5;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const ::proto::DesktopExtension& extension() const;
  PROTOBUF_NODISCARD ::proto::DesktopExtension* release_extension();
  ::proto::DesktopExtension* mutable_extension();
  void set_allocated_extension(::proto::DesktopExtension* extension);
  private:
  const ::proto::DesktopExtension& _internal_extension() const;
  ::proto::DesktopExtension* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::proto::DesktopExtension* extension);
  ::proto::DesktopExtension* unsafe_arena_release_extension();

  // .proto.DesktopCapabilities capabilities = 6;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::proto::DesktopCapabilities& capabilities() const;
  PROTOBUF_NODISCARD ::proto::DesktopCapabilities* release_capabilities();
  ::proto::DesktopCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::proto::DesktopCapabilities* capabilities);
  private:
  const ::proto::DesktopCapabilities& _internal_capabilities() const;
  ::proto::DesktopCapabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::proto::DesktopCapabilities* capabilities);
  ::proto::DesktopCapabilities* unsafe_arena_release_capabilities();

  // .proto.CursorPosition cursor_position = 7;
  bool has_cursor_position() const;
  private:
  bool _internal_has_cursor_position() const;
  public:
  void clear_cursor_position();
  const ::proto::CursorPosition& cursor_position() const;
  PROTOBUF_NODISCARD ::proto::CursorPosition* release_cursor_position();
  ::proto::CursorPosition* mutable_cursor_position();
  void set_allocated_cursor_position(::proto::CursorPosition* cursor_position);
  private:
  const ::proto::CursorPosition& _internal_cursor_position() const;
  ::proto::CursorPosition* _internal_mutable_cursor_position();
  public:
  void unsafe_arena_set_allocated_cursor_position(
      ::proto::CursorPosition* cursor_position);
  ::proto::CursorPosition* unsafe_arena_release_cursor_position();

  // @@protoc_insertion_point(class_scope:proto.HostToClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::VideoPacket* video_packet_;
    ::proto::AudioPacket* audio_packet_;
    ::proto::CursorShape* cursor_shape_;
    ::proto::ClipboardEvent* clipboard_event_;
    ::proto::DesktopExtension* extension_;
    ::proto::DesktopCapabilities* capabilities_;
    ::proto::CursorPosition* cursor_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// -------------------------------------------------------------------

class ClientToHost final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ClientToHost) */ {
 public:
  inline ClientToHost() : ClientToHost(nullptr) {}
  ~ClientToHost() override;
  explicit PROTOBUF_CONSTEXPR ClientToHost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToHost(const ClientToHost& from);
  ClientToHost(ClientToHost&& from) noexcept
    : ClientToHost() {
    *this = ::std::move(from);
  }

  inline ClientToHost& operator=(const ClientToHost& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToHost& operator=(ClientToHost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ClientToHost& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToHost* internal_default_instance() {
    return reinterpret_cast<const ClientToHost*>(
               &_ClientToHost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ClientToHost& a, ClientToHost& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToHost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToHost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToHost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToHost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientToHost& from);
  void MergeFrom(const ClientToHost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToHost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ClientToHost";
  }
  protected:
  explicit ClientToHost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMouseEventFieldNumber = 1,
    kKeyEventFieldNumber = 2,
    kTextEventFieldNumber = 4,
    kClipboardEventFieldNumber = 5,
    kExtensionFieldNumber = 6,
    kConfigFieldNumber = 7,
    kAudioPacketFieldNumber = 8,
  };
  // .proto.MouseEvent mouse_event = 1;
  bool has_mouse_event() const;
  private:
  bool _internal_has_mouse_event() const;
  public:
  void clear_mouse_event();
  const ::proto::MouseEvent& mouse_event() const;
  PROTOBUF_NODISCARD ::proto::MouseEvent* release_mouse_event();
  ::proto::MouseEvent* mutable_mouse_event();
  void set_allocated_mouse_event(::proto::MouseEvent* mouse_event);
  private:
  const ::proto::MouseEvent& _internal_mouse_event() const;
  ::proto::MouseEvent* _internal_mutable_mouse_event();
  public:
  void unsafe_arena_set_allocated_mouse_event(
      ::proto::MouseEvent* mouse_event);
  ::proto::MouseEvent* unsafe_arena_release_mouse_event();

  // .proto.KeyEvent key_event = 2;
  bool has_key_event() const;
  private:
  bool _internal_has_key_event() const;
  public:
  void clear_key_event();
  const ::proto::KeyEvent& key_event() const;
  PROTOBUF_NODISCARD ::proto::KeyEvent* release_key_event();
  ::proto::KeyEvent* mutable_key_event();
  void set_allocated_key_event(::proto::KeyEvent* key_event);
  private:
  const ::proto::KeyEvent& _internal_key_event() const;
  ::proto::KeyEvent* _internal_mutable_key_event();
  public:
  void unsafe_arena_set_allocated_key_event(
      ::proto::KeyEvent* key_event);
  ::proto::KeyEvent* unsafe_arena_release_key_event();

  // .proto.TextEvent text_event = 4;
  bool has_text_event() const;
  private:
  bool _internal_has_text_event() const;
  public:
  void clear_text_event();
  const ::proto::TextEvent& text_event() const;
  PROTOBUF_NODISCARD ::proto::TextEvent* release_text_event();
  ::proto::TextEvent* mutable_text_event();
  void set_allocated_text_event(::proto::TextEvent* text_event);
  private:
  const ::proto::TextEvent& _internal_text_event() const;
  ::proto::TextEvent* _internal_mutable_text_event();
  public:
  void unsafe_arena_set_allocated_text_event(
      ::proto::TextEvent* text_event);
  ::proto::TextEvent* unsafe_arena_release_text_event();

  // .proto.ClipboardEvent clipboard_event = 5;
  bool has_clipboard_event() const;
  private:
  bool _internal_has_clipboard_event() const;
  public:
  void clear_clipboard_event();
  const ::proto::ClipboardEvent& clipboard_event() const;
  PROTOBUF_NODISCARD ::proto::ClipboardEvent* release_clipboard_event();
  ::proto::ClipboardEvent* mutable_clipboard_event();
  void set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event);
  private:
  const ::proto::ClipboardEvent& _internal_clipboard_event() const;
  ::proto::ClipboardEvent* _internal_mutable_clipboard_event();
  public:
  void unsafe_arena_set_allocated_clipboard_event(
      ::proto::ClipboardEvent* clipboard_event);
  ::proto::ClipboardEvent* unsafe_arena_release_clipboard_event();

  // .proto.DesktopExtension extension = 6;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const ::proto::DesktopExtension& extension() const;
  PROTOBUF_NODISCARD ::proto::DesktopExtension* release_extension();
  ::proto::DesktopExtension* mutable_extension();
  void set_allocated_extension(::proto::DesktopExtension* extension);
  private:
  const ::proto::DesktopExtension& _internal_extension() const;
  ::proto::DesktopExtension* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::proto::DesktopExtension* extension);
  ::proto::DesktopExtension* unsafe_arena_release_extension();

  // .proto.DesktopConfig config = 7;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::proto::DesktopConfig& config() const;
  PROTOBUF_NODISCARD ::proto::DesktopConfig* release_config();
  ::proto::DesktopConfig* mutable_config();
  void set_allocated_config(::proto::DesktopConfig* config);
  private:
  const ::proto::DesktopConfig& _internal_config() const;
  ::proto::DesktopConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::proto::DesktopConfig* config);
  ::proto::DesktopConfig* unsafe_arena_release_config();

  // .proto.AudioPacket audio_packet = 8;
  bool has_audio_packet() const;
  private:
  bool _internal_has_audio_packet() const;
  public:
  void clear_audio_packet();
  const ::proto::AudioPacket& audio_packet() const;
  PROTOBUF_NODISCARD ::proto::AudioPacket* release_audio_packet();
  ::proto::AudioPacket* mutable_audio_packet();
  void set_allocated_audio_packet(::proto::AudioPacket* audio_packet);
  private:
  const ::proto::AudioPacket& _internal_audio_packet() const;
  ::proto::AudioPacket* _internal_mutable_audio_packet();
  public:
  void unsafe_arena_set_allocated_audio_packet(
      ::proto::AudioPacket* audio_packet);
  ::proto::AudioPacket* unsafe_arena_release_audio_packet();

  // @@protoc_insertion_point(class_scope:proto.ClientToHost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::MouseEvent* mouse_event_;
    ::proto::KeyEvent* key_event_;
    ::proto::TextEvent* text_event_;
    ::proto::ClipboardEvent* clipboard_event_;
    ::proto::DesktopExtension* extension_;
    ::proto::DesktopConfig* config_;
    ::proto::AudioPacket* audio_packet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_desktop_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KeyEvent

// uint32 usb_keycode = 1;
inline void KeyEvent::clear_usb_keycode() {
  _impl_.usb_keycode_ = 0u;
}
inline uint32_t KeyEvent::_internal_usb_keycode() const {
  return _impl_.usb_keycode_;
}
inline uint32_t KeyEvent::usb_keycode() const {
  // @@protoc_insertion_point(field_get:proto.KeyEvent.usb_keycode)
  return _internal_usb_keycode();
}
inline void KeyEvent::_internal_set_usb_keycode(uint32_t value) {
  
  _impl_.usb_keycode_ = value;
}
inline void KeyEvent::set_usb_keycode(uint32_t value) {
  _internal_set_usb_keycode(value);
  // @@protoc_insertion_point(field_set:proto.KeyEvent.usb_keycode)
}

// uint32 flags = 2;
inline void KeyEvent::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t KeyEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t KeyEvent::flags() const {
  // @@protoc_insertion_point(field_get:proto.KeyEvent.flags)
  return _internal_flags();
}
inline void KeyEvent::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void KeyEvent::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.KeyEvent.flags)
}

// -------------------------------------------------------------------

// TextEvent

// string text = 1;
inline void TextEvent::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextEvent::text() const {
  // @@protoc_insertion_point(field_get:proto.TextEvent.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextEvent::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.TextEvent.text)
}
inline std::string* TextEvent::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:proto.TextEvent.text)
  return _s;
}
inline const std::string& TextEvent::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextEvent::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextEvent::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextEvent::release_text() {
  // @@protoc_insertion_point(field_release:proto.TextEvent.text)
  return _impl_.text_.Release();
}
inline void TextEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.TextEvent.text)
}

// -------------------------------------------------------------------

// MouseEvent

// uint32 mask = 1;
inline void MouseEvent::clear_mask() {
  _impl_.mask_ = 0u;
}
inline uint32_t MouseEvent::_internal_mask() const {
  return _impl_.mask_;
}
inline uint32_t MouseEvent::mask() const {
  // @@protoc_insertion_point(field_get:proto.MouseEvent.mask)
  return _internal_mask();
}
inline void MouseEvent::_internal_set_mask(uint32_t value) {
  
  _impl_.mask_ = value;
}
inline void MouseEvent::set_mask(uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:proto.MouseEvent.mask)
}

// int32 x = 2;
inline void MouseEvent::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t MouseEvent::_internal_x() const {
  return _impl_.x_;
}
inline int32_t MouseEvent::x() const {
  // @@protoc_insertion_point(field_get:proto.MouseEvent.x)
  return _internal_x();
}
inline void MouseEvent::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void MouseEvent::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.MouseEvent.x)
}

// int32 y = 3;
inline void MouseEvent::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t MouseEvent::_internal_y() const {
  return _impl_.y_;
}
inline int32_t MouseEvent::y() const {
  // @@protoc_insertion_point(field_get:proto.MouseEvent.y)
  return _internal_y();
}
inline void MouseEvent::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void MouseEvent::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.MouseEvent.y)
}

// -------------------------------------------------------------------

// ClipboardEvent

// string mime_type = 1;
inline void ClipboardEvent::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& ClipboardEvent::mime_type() const {
  // @@protoc_insertion_point(field_get:proto.ClipboardEvent.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClipboardEvent::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ClipboardEvent.mime_type)
}
inline std::string* ClipboardEvent::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:proto.ClipboardEvent.mime_type)
  return _s;
}
inline const std::string& ClipboardEvent::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void ClipboardEvent::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ClipboardEvent::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ClipboardEvent::release_mime_type() {
  // @@protoc_insertion_point(field_release:proto.ClipboardEvent.mime_type)
  return _impl_.mime_type_.Release();
}
inline void ClipboardEvent::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ClipboardEvent.mime_type)
}

// bytes data = 2;
inline void ClipboardEvent::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ClipboardEvent::data() const {
  // @@protoc_insertion_point(field_get:proto.ClipboardEvent.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClipboardEvent::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ClipboardEvent.data)
}
inline std::string* ClipboardEvent::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.ClipboardEvent.data)
  return _s;
}
inline const std::string& ClipboardEvent::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ClipboardEvent::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ClipboardEvent::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ClipboardEvent::release_data() {
  // @@protoc_insertion_point(field_release:proto.ClipboardEvent.data)
  return _impl_.data_.Release();
}
inline void ClipboardEvent::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ClipboardEvent.data)
}

// -------------------------------------------------------------------

// CursorShape

// uint32 flags = 1;
inline void CursorShape::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t CursorShape::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t CursorShape::flags() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.flags)
  return _internal_flags();
}
inline void CursorShape::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void CursorShape::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.flags)
}

// int32 width = 2;
inline void CursorShape::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t CursorShape::_internal_width() const {
  return _impl_.width_;
}
inline int32_t CursorShape::width() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.width)
  return _internal_width();
}
inline void CursorShape::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void CursorShape::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.width)
}

// int32 height = 3;
inline void CursorShape::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t CursorShape::_internal_height() const {
  return _impl_.height_;
}
inline int32_t CursorShape::height() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.height)
  return _internal_height();
}
inline void CursorShape::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void CursorShape::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.height)
}

// int32 hotspot_x = 4;
inline void CursorShape::clear_hotspot_x() {
  _impl_.hotspot_x_ = 0;
}
inline int32_t CursorShape::_internal_hotspot_x() const {
  return _impl_.hotspot_x_;
}
inline int32_t CursorShape::hotspot_x() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.hotspot_x)
  return _internal_hotspot_x();
}
inline void CursorShape::_internal_set_hotspot_x(int32_t value) {
  
  _impl_.hotspot_x_ = value;
}
inline void CursorShape::set_hotspot_x(int32_t value) {
  _internal_set_hotspot_x(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.hotspot_x)
}

// int32 hotspot_y = 5;
inline void CursorShape::clear_hotspot_y() {
  _impl_.hotspot_y_ = 0;
}
inline int32_t CursorShape::_internal_hotspot_y() const {
  return _impl_.hotspot_y_;
}
inline int32_t CursorShape::hotspot_y() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.hotspot_y)
  return _internal_hotspot_y();
}
inline void CursorShape::_internal_set_hotspot_y(int32_t value) {
  
  _impl_.hotspot_y_ = value;
}
inline void CursorShape::set_hotspot_y(int32_t value) {
  _internal_set_hotspot_y(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.hotspot_y)
}

// bytes data = 6;
inline void CursorShape::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& CursorShape::data() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CursorShape::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CursorShape.data)
}
inline std::string* CursorShape::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.CursorShape.data)
  return _s;
}
inline const std::string& CursorShape::_internal_data() const {
  return _impl_.data_.Get();
}
inline void CursorShape::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* CursorShape::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* CursorShape::release_data() {
  // @@protoc_insertion_point(field_release:proto.CursorShape.data)
  return _impl_.data_.Release();
}
inline void CursorShape::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CursorShape.data)
}

// int32 dpi_x = 7;
inline void CursorShape::clear_dpi_x() {
  _impl_.dpi_x_ = 0;
}
inline int32_t CursorShape::_internal_dpi_x() const {
  return _impl_.dpi_x_;
}
inline int32_t CursorShape::dpi_x() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.dpi_x)
  return _internal_dpi_x();
}
inline void CursorShape::_internal_set_dpi_x(int32_t value) {
  
  _impl_.dpi_x_ = value;
}
inline void CursorShape::set_dpi_x(int32_t value) {
  _internal_set_dpi_x(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.dpi_x)
}

// int32 dpi_y = 8;
inline void CursorShape::clear_dpi_y() {
  _impl_.dpi_y_ = 0;
}
inline int32_t CursorShape::_internal_dpi_y() const {
  return _impl_.dpi_y_;
}
inline int32_t CursorShape::dpi_y() const {
  // @@protoc_insertion_point(field_get:proto.CursorShape.dpi_y)
  return _internal_dpi_y();
}
inline void CursorShape::_internal_set_dpi_y(int32_t value) {
  
  _impl_.dpi_y_ = value;
}
inline void CursorShape::set_dpi_y(int32_t value) {
  _internal_set_dpi_y(value);
  // @@protoc_insertion_point(field_set:proto.CursorShape.dpi_y)
}

// -------------------------------------------------------------------

// CursorPosition

// int32 x = 1;
inline void CursorPosition::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t CursorPosition::_internal_x() const {
  return _impl_.x_;
}
inline int32_t CursorPosition::x() const {
  // @@protoc_insertion_point(field_get:proto.CursorPosition.x)
  return _internal_x();
}
inline void CursorPosition::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void CursorPosition::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.CursorPosition.x)
}

// int32 y = 2;
inline void CursorPosition::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t CursorPosition::_internal_y() const {
  return _impl_.y_;
}
inline int32_t CursorPosition::y() const {
  // @@protoc_insertion_point(field_get:proto.CursorPosition.y)
  return _internal_y();
}
inline void CursorPosition::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void CursorPosition::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.CursorPosition.y)
}

// -------------------------------------------------------------------

// Size

// int32 width = 1;
inline void Size::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t Size::_internal_width() const {
  return _impl_.width_;
}
inline int32_t Size::width() const {
  // @@protoc_insertion_point(field_get:proto.Size.width)
  return _internal_width();
}
inline void Size::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void Size::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.Size.width)
}

// int32 height = 2;
inline void Size::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t Size::_internal_height() const {
  return _impl_.height_;
}
inline int32_t Size::height() const {
  // @@protoc_insertion_point(field_get:proto.Size.height)
  return _internal_height();
}
inline void Size::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void Size::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.Size.height)
}

// -------------------------------------------------------------------

// Rect

// int32 x = 1;
inline void Rect::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t Rect::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Rect::x() const {
  // @@protoc_insertion_point(field_get:proto.Rect.x)
  return _internal_x();
}
inline void Rect::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void Rect::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.Rect.x)
}

// int32 y = 2;
inline void Rect::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t Rect::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Rect::y() const {
  // @@protoc_insertion_point(field_get:proto.Rect.y)
  return _internal_y();
}
inline void Rect::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void Rect::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.Rect.y)
}

// int32 width = 3;
inline void Rect::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t Rect::_internal_width() const {
  return _impl_.width_;
}
inline int32_t Rect::width() const {
  // @@protoc_insertion_point(field_get:proto.Rect.width)
  return _internal_width();
}
inline void Rect::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void Rect::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.Rect.width)
}

// int32 height = 4;
inline void Rect::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t Rect::_internal_height() const {
  return _impl_.height_;
}
inline int32_t Rect::height() const {
  // @@protoc_insertion_point(field_get:proto.Rect.height)
  return _internal_height();
}
inline void Rect::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void Rect::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.Rect.height)
}

// -------------------------------------------------------------------

// PixelFormat

// uint32 bits_per_pixel = 1;
inline void PixelFormat::clear_bits_per_pixel() {
  _impl_.bits_per_pixel_ = 0u;
}
inline uint32_t PixelFormat::_internal_bits_per_pixel() const {
  return _impl_.bits_per_pixel_;
}
inline uint32_t PixelFormat::bits_per_pixel() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.bits_per_pixel)
  return _internal_bits_per_pixel();
}
inline void PixelFormat::_internal_set_bits_per_pixel(uint32_t value) {
  
  _impl_.bits_per_pixel_ = value;
}
inline void PixelFormat::set_bits_per_pixel(uint32_t value) {
  _internal_set_bits_per_pixel(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.bits_per_pixel)
}

// uint32 red_max = 2;
inline void PixelFormat::clear_red_max() {
  _impl_.red_max_ = 0u;
}
inline uint32_t PixelFormat::_internal_red_max() const {
  return _impl_.red_max_;
}
inline uint32_t PixelFormat::red_max() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.red_max)
  return _internal_red_max();
}
inline void PixelFormat::_internal_set_red_max(uint32_t value) {
  
  _impl_.red_max_ = value;
}
inline void PixelFormat::set_red_max(uint32_t value) {
  _internal_set_red_max(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.red_max)
}

// uint32 green_max = 3;
inline void PixelFormat::clear_green_max() {
  _impl_.green_max_ = 0u;
}
inline uint32_t PixelFormat::_internal_green_max() const {
  return _impl_.green_max_;
}
inline uint32_t PixelFormat::green_max() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.green_max)
  return _internal_green_max();
}
inline void PixelFormat::_internal_set_green_max(uint32_t value) {
  
  _impl_.green_max_ = value;
}
inline void PixelFormat::set_green_max(uint32_t value) {
  _internal_set_green_max(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.green_max)
}

// uint32 blue_max = 4;
inline void PixelFormat::clear_blue_max() {
  _impl_.blue_max_ = 0u;
}
inline uint32_t PixelFormat::_internal_blue_max() const {
  return _impl_.blue_max_;
}
inline uint32_t PixelFormat::blue_max() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.blue_max)
  return _internal_blue_max();
}
inline void PixelFormat::_internal_set_blue_max(uint32_t value) {
  
  _impl_.blue_max_ = value;
}
inline void PixelFormat::set_blue_max(uint32_t value) {
  _internal_set_blue_max(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.blue_max)
}

// uint32 red_shift = 5;
inline void PixelFormat::clear_red_shift() {
  _impl_.red_shift_ = 0u;
}
inline uint32_t PixelFormat::_internal_red_shift() const {
  return _impl_.red_shift_;
}
inline uint32_t PixelFormat::red_shift() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.red_shift)
  return _internal_red_shift();
}
inline void PixelFormat::_internal_set_red_shift(uint32_t value) {
  
  _impl_.red_shift_ = value;
}
inline void PixelFormat::set_red_shift(uint32_t value) {
  _internal_set_red_shift(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.red_shift)
}

// uint32 green_shift = 6;
inline void PixelFormat::clear_green_shift() {
  _impl_.green_shift_ = 0u;
}
inline uint32_t PixelFormat::_internal_green_shift() const {
  return _impl_.green_shift_;
}
inline uint32_t PixelFormat::green_shift() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.green_shift)
  return _internal_green_shift();
}
inline void PixelFormat::_internal_set_green_shift(uint32_t value) {
  
  _impl_.green_shift_ = value;
}
inline void PixelFormat::set_green_shift(uint32_t value) {
  _internal_set_green_shift(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.green_shift)
}

// uint32 blue_shift = 7;
inline void PixelFormat::clear_blue_shift() {
  _impl_.blue_shift_ = 0u;
}
inline uint32_t PixelFormat::_internal_blue_shift() const {
  return _impl_.blue_shift_;
}
inline uint32_t PixelFormat::blue_shift() const {
  // @@protoc_insertion_point(field_get:proto.PixelFormat.blue_shift)
  return _internal_blue_shift();
}
inline void PixelFormat::_internal_set_blue_shift(uint32_t value) {
  
  _impl_.blue_shift_ = value;
}
inline void PixelFormat::set_blue_shift(uint32_t value) {
  _internal_set_blue_shift(value);
  // @@protoc_insertion_point(field_set:proto.PixelFormat.blue_shift)
}

// -------------------------------------------------------------------

// VideoPacketFormat

// .proto.Rect video_rect = 1;
inline bool VideoPacketFormat::_internal_has_video_rect() const {
  return this != internal_default_instance() && _impl_.video_rect_ != nullptr;
}
inline bool VideoPacketFormat::has_video_rect() const {
  return _internal_has_video_rect();
}
inline void VideoPacketFormat::clear_video_rect() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_rect_ != nullptr) {
    delete _impl_.video_rect_;
  }
  _impl_.video_rect_ = nullptr;
}
inline const ::proto::Rect& VideoPacketFormat::_internal_video_rect() const {
  const ::proto::Rect* p = _impl_.video_rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Rect&>(
      ::proto::_Rect_default_instance_);
}
inline const ::proto::Rect& VideoPacketFormat::video_rect() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacketFormat.video_rect)
  return _internal_video_rect();
}
inline void VideoPacketFormat::unsafe_arena_set_allocated_video_rect(
    ::proto::Rect* video_rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_rect_);
  }
  _impl_.video_rect_ = video_rect;
  if (video_rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.VideoPacketFormat.video_rect)
}
inline ::proto::Rect* VideoPacketFormat::release_video_rect() {
  
  ::proto::Rect* temp = _impl_.video_rect_;
  _impl_.video_rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Rect* VideoPacketFormat::unsafe_arena_release_video_rect() {
  // @@protoc_insertion_point(field_release:proto.VideoPacketFormat.video_rect)
  
  ::proto::Rect* temp = _impl_.video_rect_;
  _impl_.video_rect_ = nullptr;
  return temp;
}
inline ::proto::Rect* VideoPacketFormat::_internal_mutable_video_rect() {
  
  if (_impl_.video_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Rect>(GetArenaForAllocation());
    _impl_.video_rect_ = p;
  }
  return _impl_.video_rect_;
}
inline ::proto::Rect* VideoPacketFormat::mutable_video_rect() {
  ::proto::Rect* _msg = _internal_mutable_video_rect();
  // @@protoc_insertion_point(field_mutable:proto.VideoPacketFormat.video_rect)
  return _msg;
}
inline void VideoPacketFormat::set_allocated_video_rect(::proto::Rect* video_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_rect_;
  }
  if (video_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_rect);
    if (message_arena != submessage_arena) {
      video_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_rect, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_rect_ = video_rect;
  // @@protoc_insertion_point(field_set_allocated:proto.VideoPacketFormat.video_rect)
}

// .proto.PixelFormat pixel_format = 2;
inline bool VideoPacketFormat::_internal_has_pixel_format() const {
  return this != internal_default_instance() && _impl_.pixel_format_ != nullptr;
}
inline bool VideoPacketFormat::has_pixel_format() const {
  return _internal_has_pixel_format();
}
inline void VideoPacketFormat::clear_pixel_format() {
  if (GetArenaForAllocation() == nullptr && _impl_.pixel_format_ != nullptr) {
    delete _impl_.pixel_format_;
  }
  _impl_.pixel_format_ = nullptr;
}
inline const ::proto::PixelFormat& VideoPacketFormat::_internal_pixel_format() const {
  const ::proto::PixelFormat* p = _impl_.pixel_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PixelFormat&>(
      ::proto::_PixelFormat_default_instance_);
}
inline const ::proto::PixelFormat& VideoPacketFormat::pixel_format() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacketFormat.pixel_format)
  return _internal_pixel_format();
}
inline void VideoPacketFormat::unsafe_arena_set_allocated_pixel_format(
    ::proto::PixelFormat* pixel_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixel_format_);
  }
  _impl_.pixel_format_ = pixel_format;
  if (pixel_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.VideoPacketFormat.pixel_format)
}
inline ::proto::PixelFormat* VideoPacketFormat::release_pixel_format() {
  
  ::proto::PixelFormat* temp = _impl_.pixel_format_;
  _impl_.pixel_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PixelFormat* VideoPacketFormat::unsafe_arena_release_pixel_format() {
  // @@protoc_insertion_point(field_release:proto.VideoPacketFormat.pixel_format)
  
  ::proto::PixelFormat* temp = _impl_.pixel_format_;
  _impl_.pixel_format_ = nullptr;
  return temp;
}
inline ::proto::PixelFormat* VideoPacketFormat::_internal_mutable_pixel_format() {
  
  if (_impl_.pixel_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PixelFormat>(GetArenaForAllocation());
    _impl_.pixel_format_ = p;
  }
  return _impl_.pixel_format_;
}
inline ::proto::PixelFormat* VideoPacketFormat::mutable_pixel_format() {
  ::proto::PixelFormat* _msg = _internal_mutable_pixel_format();
  // @@protoc_insertion_point(field_mutable:proto.VideoPacketFormat.pixel_format)
  return _msg;
}
inline void VideoPacketFormat::set_allocated_pixel_format(::proto::PixelFormat* pixel_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pixel_format_;
  }
  if (pixel_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pixel_format);
    if (message_arena != submessage_arena) {
      pixel_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_format, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pixel_format_ = pixel_format;
  // @@protoc_insertion_point(field_set_allocated:proto.VideoPacketFormat.pixel_format)
}

// .proto.Size screen_size = 3;
inline bool VideoPacketFormat::_internal_has_screen_size() const {
  return this != internal_default_instance() && _impl_.screen_size_ != nullptr;
}
inline bool VideoPacketFormat::has_screen_size() const {
  return _internal_has_screen_size();
}
inline void VideoPacketFormat::clear_screen_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.screen_size_ != nullptr) {
    delete _impl_.screen_size_;
  }
  _impl_.screen_size_ = nullptr;
}
inline const ::proto::Size& VideoPacketFormat::_internal_screen_size() const {
  const ::proto::Size* p = _impl_.screen_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Size&>(
      ::proto::_Size_default_instance_);
}
inline const ::proto::Size& VideoPacketFormat::screen_size() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacketFormat.screen_size)
  return _internal_screen_size();
}
inline void VideoPacketFormat::unsafe_arena_set_allocated_screen_size(
    ::proto::Size* screen_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_size_);
  }
  _impl_.screen_size_ = screen_size;
  if (screen_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.VideoPacketFormat.screen_size)
}
inline ::proto::Size* VideoPacketFormat::release_screen_size() {
  
  ::proto::Size* temp = _impl_.screen_size_;
  _impl_.screen_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Size* VideoPacketFormat::unsafe_arena_release_screen_size() {
  // @@protoc_insertion_point(field_release:proto.VideoPacketFormat.screen_size)
  
  ::proto::Size* temp = _impl_.screen_size_;
  _impl_.screen_size_ = nullptr;
  return temp;
}
inline ::proto::Size* VideoPacketFormat::_internal_mutable_screen_size() {
  
  if (_impl_.screen_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Size>(GetArenaForAllocation());
    _impl_.screen_size_ = p;
  }
  return _impl_.screen_size_;
}
inline ::proto::Size* VideoPacketFormat::mutable_screen_size() {
  ::proto::Size* _msg = _internal_mutable_screen_size();
  // @@protoc_insertion_point(field_mutable:proto.VideoPacketFormat.screen_size)
  return _msg;
}
inline void VideoPacketFormat::set_allocated_screen_size(::proto::Size* screen_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.screen_size_;
  }
  if (screen_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screen_size);
    if (message_arena != submessage_arena) {
      screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen_size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.screen_size_ = screen_size;
  // @@protoc_insertion_point(field_set_allocated:proto.VideoPacketFormat.screen_size)
}

// uint32 capturer_type = 4;
inline void VideoPacketFormat::clear_capturer_type() {
  _impl_.capturer_type_ = 0u;
}
inline uint32_t VideoPacketFormat::_internal_capturer_type() const {
  return _impl_.capturer_type_;
}
inline uint32_t VideoPacketFormat::capturer_type() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacketFormat.capturer_type)
  return _internal_capturer_type();
}
inline void VideoPacketFormat::_internal_set_capturer_type(uint32_t value) {
  
  _impl_.capturer_type_ = value;
}
inline void VideoPacketFormat::set_capturer_type(uint32_t value) {
  _internal_set_capturer_type(value);
  // @@protoc_insertion_point(field_set:proto.VideoPacketFormat.capturer_type)
}

// -------------------------------------------------------------------

// VideoPacket

// .proto.VideoEncoding encoding = 1;
inline void VideoPacket::clear_encoding() {
  _impl_.encoding_ = 0;
}
inline ::proto::VideoEncoding VideoPacket::_internal_encoding() const {
  return static_cast< ::proto::VideoEncoding >(_impl_.encoding_);
}
inline ::proto::VideoEncoding VideoPacket::encoding() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacket.encoding)
  return _internal_encoding();
}
inline void VideoPacket::_internal_set_encoding(::proto::VideoEncoding value) {
  
  _impl_.encoding_ = value;
}
inline void VideoPacket::set_encoding(::proto::VideoEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:proto.VideoPacket.encoding)
}

// .proto.VideoPacketFormat format = 2;
inline bool VideoPacket::_internal_has_format() const {
  return this != internal_default_instance() && _impl_.format_ != nullptr;
}
inline bool VideoPacket::has_format() const {
  return _internal_has_format();
}
inline void VideoPacket::clear_format() {
  if (GetArenaForAllocation() == nullptr && _impl_.format_ != nullptr) {
    delete _impl_.format_;
  }
  _impl_.format_ = nullptr;
}
inline const ::proto::VideoPacketFormat& VideoPacket::_internal_format() const {
  const ::proto::VideoPacketFormat* p = _impl_.format_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::VideoPacketFormat&>(
      ::proto::_VideoPacketFormat_default_instance_);
}
inline const ::proto::VideoPacketFormat& VideoPacket::format() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacket.format)
  return _internal_format();
}
inline void VideoPacket::unsafe_arena_set_allocated_format(
    ::proto::VideoPacketFormat* format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.format_);
  }
  _impl_.format_ = format;
  if (format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.VideoPacket.format)
}
inline ::proto::VideoPacketFormat* VideoPacket::release_format() {
  
  ::proto::VideoPacketFormat* temp = _impl_.format_;
  _impl_.format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::VideoPacketFormat* VideoPacket::unsafe_arena_release_format() {
  // @@protoc_insertion_point(field_release:proto.VideoPacket.format)
  
  ::proto::VideoPacketFormat* temp = _impl_.format_;
  _impl_.format_ = nullptr;
  return temp;
}
inline ::proto::VideoPacketFormat* VideoPacket::_internal_mutable_format() {
  
  if (_impl_.format_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::VideoPacketFormat>(GetArenaForAllocation());
    _impl_.format_ = p;
  }
  return _impl_.format_;
}
inline ::proto::VideoPacketFormat* VideoPacket::mutable_format() {
  ::proto::VideoPacketFormat* _msg = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:proto.VideoPacket.format)
  return _msg;
}
inline void VideoPacket::set_allocated_format(::proto::VideoPacketFormat* format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.format_;
  }
  if (format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(format);
    if (message_arena != submessage_arena) {
      format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, format, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.format_ = format;
  // @@protoc_insertion_point(field_set_allocated:proto.VideoPacket.format)
}

// repeated .proto.Rect dirty_rect = 3;
inline int VideoPacket::_internal_dirty_rect_size() const {
  return _impl_.dirty_rect_.size();
}
inline int VideoPacket::dirty_rect_size() const {
  return _internal_dirty_rect_size();
}
inline void VideoPacket::clear_dirty_rect() {
  _impl_.dirty_rect_.Clear();
}
inline ::proto::Rect* VideoPacket::mutable_dirty_rect(int index) {
  // @@protoc_insertion_point(field_mutable:proto.VideoPacket.dirty_rect)
  return _impl_.dirty_rect_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >*
VideoPacket::mutable_dirty_rect() {
  // @@protoc_insertion_point(field_mutable_list:proto.VideoPacket.dirty_rect)
  return &_impl_.dirty_rect_;
}
inline const ::proto::Rect& VideoPacket::_internal_dirty_rect(int index) const {
  return _impl_.dirty_rect_.Get(index);
}
inline const ::proto::Rect& VideoPacket::dirty_rect(int index) const {
  // @@protoc_insertion_point(field_get:proto.VideoPacket.dirty_rect)
  return _internal_dirty_rect(index);
}
inline ::proto::Rect* VideoPacket::_internal_add_dirty_rect() {
  return _impl_.dirty_rect_.Add();
}
inline ::proto::Rect* VideoPacket::add_dirty_rect() {
  ::proto::Rect* _add = _internal_add_dirty_rect();
  // @@protoc_insertion_point(field_add:proto.VideoPacket.dirty_rect)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Rect >&
VideoPacket::dirty_rect() const {
  // @@protoc_insertion_point(field_list:proto.VideoPacket.dirty_rect)
  return _impl_.dirty_rect_;
}

// bytes data = 4;
inline void VideoPacket::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& VideoPacket::data() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacket.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoPacket::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoPacket.data)
}
inline std::string* VideoPacket::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.VideoPacket.data)
  return _s;
}
inline const std::string& VideoPacket::_internal_data() const {
  return _impl_.data_.Get();
}
inline void VideoPacket::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoPacket::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoPacket::release_data() {
  // @@protoc_insertion_point(field_release:proto.VideoPacket.data)
  return _impl_.data_.Release();
}
inline void VideoPacket::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoPacket.data)
}

// .proto.VideoErrorCode error_code = 5;
inline void VideoPacket::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::proto::VideoErrorCode VideoPacket::_internal_error_code() const {
  return static_cast< ::proto::VideoErrorCode >(_impl_.error_code_);
}
inline ::proto::VideoErrorCode VideoPacket::error_code() const {
  // @@protoc_insertion_point(field_get:proto.VideoPacket.error_code)
  return _internal_error_code();
}
inline void VideoPacket::_internal_set_error_code(::proto::VideoErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void VideoPacket::set_error_code(::proto::VideoErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:proto.VideoPacket.error_code)
}

// -------------------------------------------------------------------

// AudioPacket

// int32 timestamp = 1;
inline void AudioPacket::clear_timestamp() {
  _impl_.timestamp_ = 0;
}
inline int32_t AudioPacket::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int32_t AudioPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.AudioPacket.timestamp)
  return _internal_timestamp();
}
inline void AudioPacket::_internal_set_timestamp(int32_t value) {
  
  _impl_.timestamp_ = value;
}
inline void AudioPacket::set_timestamp(int32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.AudioPacket.timestamp)
}

// repeated bytes data = 2;
inline int AudioPacket::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int AudioPacket::data_size() const {
  return _internal_data_size();
}
inline void AudioPacket::clear_data() {
  _impl_.data_.Clear();
}
inline std::string* AudioPacket::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:proto.AudioPacket.data)
  return _s;
}
inline const std::string& AudioPacket::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const std::string& AudioPacket::data(int index) const {
  // @@protoc_insertion_point(field_get:proto.AudioPacket.data)
  return _internal_data(index);
}
inline std::string* AudioPacket::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AudioPacket.data)
  return _impl_.data_.Mutable(index);
}
inline void AudioPacket::set_data(int index, const std::string& value) {
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.AudioPacket.data)
}
inline void AudioPacket::set_data(int index, std::string&& value) {
  _impl_.data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.AudioPacket.data)
}
inline void AudioPacket::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.AudioPacket.data)
}
inline void AudioPacket::set_data(int index, const void* value, size_t size) {
  _impl_.data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.AudioPacket.data)
}
inline std::string* AudioPacket::_internal_add_data() {
  return _impl_.data_.Add();
}
inline void AudioPacket::add_data(const std::string& value) {
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.AudioPacket.data)
}
inline void AudioPacket::add_data(std::string&& value) {
  _impl_.data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.AudioPacket.data)
}
inline void AudioPacket::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.AudioPacket.data)
}
inline void AudioPacket::add_data(const void* value, size_t size) {
  _impl_.data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.AudioPacket.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AudioPacket::data() const {
  // @@protoc_insertion_point(field_list:proto.AudioPacket.data)
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AudioPacket::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:proto.AudioPacket.data)
  return &_impl_.data_;
}

// .proto.AudioEncoding encoding = 3;
inline void AudioPacket::clear_encoding() {
  _impl_.encoding_ = 0;
}
inline ::proto::AudioEncoding AudioPacket::_internal_encoding() const {
  return static_cast< ::proto::AudioEncoding >(_impl_.encoding_);
}
inline ::proto::AudioEncoding AudioPacket::encoding() const {
  // @@protoc_insertion_point(field_get:proto.AudioPacket.encoding)
  return _internal_encoding();
}
inline void AudioPacket::_internal_set_encoding(::proto::AudioEncoding value) {
  
  _impl_.encoding_ = value;
}
inline void AudioPacket::set_encoding(::proto::AudioEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:proto.AudioPacket.encoding)
}

// .proto.AudioPacket.SamplingRate sampling_rate = 4;
inline void AudioPacket::clear_sampling_rate() {
  _impl_.sampling_rate_ = 0;
}
inline ::proto::AudioPacket_SamplingRate AudioPacket::_internal_sampling_rate() const {
  return static_cast< ::proto::AudioPacket_SamplingRate >(_impl_.sampling_rate_);
}
inline ::proto::AudioPacket_SamplingRate AudioPacket::sampling_rate() const {
  // @@protoc_insertion_point(field_get:proto.AudioPacket.sampling_rate)
  return _internal_sampling_rate();
}
inline void AudioPacket::_internal_set_sampling_rate(::proto::AudioPacket_SamplingRate value) {
  
  _impl_.sampling_rate_ = value;
}
inline void AudioPacket::set_sampling_rate(::proto::AudioPacket_SamplingRate value) {
  _internal_set_sampling_rate(value);
  // @@protoc_insertion_point(field_set:proto.AudioPacket.sampling_rate)
}

// .proto.AudioPacket.BytesPerSample bytes_per_sample = 5;
inline void AudioPacket::clear_bytes_per_sample() {
  _impl_.bytes_per_sample_ = 0;
}
inline ::proto::AudioPacket_BytesPerSample AudioPacket::_internal_bytes_per_sample() const {
  return static_cast< ::proto::AudioPacket_BytesPerSample >(_impl_.bytes_per_sample_);
}
inline ::proto::AudioPacket_BytesPerSample AudioPacket::bytes_per_sample() const {
  // @@protoc_insertion_point(field_get:proto.AudioPacket.bytes_per_sample)
  return _internal_bytes_per_sample();
}
inline void AudioPacket::_internal_set_bytes_per_sample(::proto::AudioPacket_BytesPerSample value) {
  
  _impl_.bytes_per_sample_ = value;
}
inline void AudioPacket::set_bytes_per_sample(::proto::AudioPacket_BytesPerSample value) {
  _internal_set_bytes_per_sample(value);
  // @@protoc_insertion_point(field_set:proto.AudioPacket.bytes_per_sample)
}

// .proto.AudioPacket.Channels channels = 6;
inline void AudioPacket::clear_channels() {
  _impl_.channels_ = 0;
}
inline ::proto::AudioPacket_Channels AudioPacket::_internal_channels() const {
  return static_cast< ::proto::AudioPacket_Channels >(_impl_.channels_);
}
inline ::proto::AudioPacket_Channels AudioPacket::channels() const {
  // @@protoc_insertion_point(field_get:proto.AudioPacket.channels)
  return _internal_channels();
}
inline void AudioPacket::_internal_set_channels(::proto::AudioPacket_Channels value) {
  
  _impl_.channels_ = value;
}
inline void AudioPacket::set_channels(::proto::AudioPacket_Channels value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:proto.AudioPacket.channels)
}

// -------------------------------------------------------------------

// DesktopExtension

// string name = 1;
inline void DesktopExtension::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DesktopExtension::name() const {
  // @@protoc_insertion_point(field_get:proto.DesktopExtension.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DesktopExtension::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DesktopExtension.name)
}
inline std::string* DesktopExtension::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.DesktopExtension.name)
  return _s;
}
inline const std::string& DesktopExtension::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DesktopExtension::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DesktopExtension::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DesktopExtension::release_name() {
  // @@protoc_insertion_point(field_release:proto.DesktopExtension.name)
  return _impl_.name_.Release();
}
inline void DesktopExtension::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DesktopExtension.name)
}

// bytes data = 2;
inline void DesktopExtension::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& DesktopExtension::data() const {
  // @@protoc_insertion_point(field_get:proto.DesktopExtension.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DesktopExtension::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DesktopExtension.data)
}
inline std::string* DesktopExtension::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.DesktopExtension.data)
  return _s;
}
inline const std::string& DesktopExtension::_internal_data() const {
  return _impl_.data_.Get();
}
inline void DesktopExtension::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* DesktopExtension::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* DesktopExtension::release_data() {
  // @@protoc_insertion_point(field_release:proto.DesktopExtension.data)
  return _impl_.data_.Release();
}
inline void DesktopExtension::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DesktopExtension.data)
}

// -------------------------------------------------------------------

// DesktopCapabilities_Flag

// string name = 1;
inline void DesktopCapabilities_Flag::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DesktopCapabilities_Flag::name() const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.Flag.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DesktopCapabilities_Flag::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DesktopCapabilities.Flag.name)
}
inline std::string* DesktopCapabilities_Flag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.DesktopCapabilities.Flag.name)
  return _s;
}
inline const std::string& DesktopCapabilities_Flag::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DesktopCapabilities_Flag::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DesktopCapabilities_Flag::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DesktopCapabilities_Flag::release_name() {
  // @@protoc_insertion_point(field_release:proto.DesktopCapabilities.Flag.name)
  return _impl_.name_.Release();
}
inline void DesktopCapabilities_Flag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DesktopCapabilities.Flag.name)
}

// bool value = 2;
inline void DesktopCapabilities_Flag::clear_value() {
  _impl_.value_ = false;
}
inline bool DesktopCapabilities_Flag::_internal_value() const {
  return _impl_.value_;
}
inline bool DesktopCapabilities_Flag::value() const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.Flag.value)
  return _internal_value();
}
inline void DesktopCapabilities_Flag::_internal_set_value(bool value) {
  
  _impl_.value_ = value;
}
inline void DesktopCapabilities_Flag::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:proto.DesktopCapabilities.Flag.value)
}

// -------------------------------------------------------------------

// DesktopCapabilities

// string extensions = 1;
inline void DesktopCapabilities::clear_extensions() {
  _impl_.extensions_.ClearToEmpty();
}
inline const std::string& DesktopCapabilities::extensions() const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.extensions)
  return _internal_extensions();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DesktopCapabilities::set_extensions(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extensions_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DesktopCapabilities.extensions)
}
inline std::string* DesktopCapabilities::mutable_extensions() {
  std::string* _s = _internal_mutable_extensions();
  // @@protoc_insertion_point(field_mutable:proto.DesktopCapabilities.extensions)
  return _s;
}
inline const std::string& DesktopCapabilities::_internal_extensions() const {
  return _impl_.extensions_.Get();
}
inline void DesktopCapabilities::_internal_set_extensions(const std::string& value) {
  
  _impl_.extensions_.Set(value, GetArenaForAllocation());
}
inline std::string* DesktopCapabilities::_internal_mutable_extensions() {
  
  return _impl_.extensions_.Mutable(GetArenaForAllocation());
}
inline std::string* DesktopCapabilities::release_extensions() {
  // @@protoc_insertion_point(field_release:proto.DesktopCapabilities.extensions)
  return _impl_.extensions_.Release();
}
inline void DesktopCapabilities::set_allocated_extensions(std::string* extensions) {
  if (extensions != nullptr) {
    
  } else {
    
  }
  _impl_.extensions_.SetAllocated(extensions, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extensions_.IsDefault()) {
    _impl_.extensions_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DesktopCapabilities.extensions)
}

// uint32 video_encodings = 2;
inline void DesktopCapabilities::clear_video_encodings() {
  _impl_.video_encodings_ = 0u;
}
inline uint32_t DesktopCapabilities::_internal_video_encodings() const {
  return _impl_.video_encodings_;
}
inline uint32_t DesktopCapabilities::video_encodings() const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.video_encodings)
  return _internal_video_encodings();
}
inline void DesktopCapabilities::_internal_set_video_encodings(uint32_t value) {
  
  _impl_.video_encodings_ = value;
}
inline void DesktopCapabilities::set_video_encodings(uint32_t value) {
  _internal_set_video_encodings(value);
  // @@protoc_insertion_point(field_set:proto.DesktopCapabilities.video_encodings)
}

// uint32 audio_encodings = 3;
inline void DesktopCapabilities::clear_audio_encodings() {
  _impl_.audio_encodings_ = 0u;
}
inline uint32_t DesktopCapabilities::_internal_audio_encodings() const {
  return _impl_.audio_encodings_;
}
inline uint32_t DesktopCapabilities::audio_encodings() const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.audio_encodings)
  return _internal_audio_encodings();
}
inline void DesktopCapabilities::_internal_set_audio_encodings(uint32_t value) {
  
  _impl_.audio_encodings_ = value;
}
inline void DesktopCapabilities::set_audio_encodings(uint32_t value) {
  _internal_set_audio_encodings(value);
  // @@protoc_insertion_point(field_set:proto.DesktopCapabilities.audio_encodings)
}

// .proto.DesktopCapabilities.OsType os_type = 4;
inline void DesktopCapabilities::clear_os_type() {
  _impl_.os_type_ = 0;
}
inline ::proto::DesktopCapabilities_OsType DesktopCapabilities::_internal_os_type() const {
  return static_cast< ::proto::DesktopCapabilities_OsType >(_impl_.os_type_);
}
inline ::proto::DesktopCapabilities_OsType DesktopCapabilities::os_type() const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.os_type)
  return _internal_os_type();
}
inline void DesktopCapabilities::_internal_set_os_type(::proto::DesktopCapabilities_OsType value) {
  
  _impl_.os_type_ = value;
}
inline void DesktopCapabilities::set_os_type(::proto::DesktopCapabilities_OsType value) {
  _internal_set_os_type(value);
  // @@protoc_insertion_point(field_set:proto.DesktopCapabilities.os_type)
}

// repeated .proto.DesktopCapabilities.Flag flag = 5;
inline int DesktopCapabilities::_internal_flag_size() const {
  return _impl_.flag_.size();
}
inline int DesktopCapabilities::flag_size() const {
  return _internal_flag_size();
}
inline void DesktopCapabilities::clear_flag() {
  _impl_.flag_.Clear();
}
inline ::proto::DesktopCapabilities_Flag* DesktopCapabilities::mutable_flag(int index) {
  // @@protoc_insertion_point(field_mutable:proto.DesktopCapabilities.flag)
  return _impl_.flag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DesktopCapabilities_Flag >*
DesktopCapabilities::mutable_flag() {
  // @@protoc_insertion_point(field_mutable_list:proto.DesktopCapabilities.flag)
  return &_impl_.flag_;
}
inline const ::proto::DesktopCapabilities_Flag& DesktopCapabilities::_internal_flag(int index) const {
  return _impl_.flag_.Get(index);
}
inline const ::proto::DesktopCapabilities_Flag& DesktopCapabilities::flag(int index) const {
  // @@protoc_insertion_point(field_get:proto.DesktopCapabilities.flag)
  return _internal_flag(index);
}
inline ::proto::DesktopCapabilities_Flag* DesktopCapabilities::_internal_add_flag() {
  return _impl_.flag_.Add();
}
inline ::proto::DesktopCapabilities_Flag* DesktopCapabilities::add_flag() {
  ::proto::DesktopCapabilities_Flag* _add = _internal_add_flag();
  // @@protoc_insertion_point(field_add:proto.DesktopCapabilities.flag)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::DesktopCapabilities_Flag >&
DesktopCapabilities::flag() const {
  // @@protoc_insertion_point(field_list:proto.DesktopCapabilities.flag)
  return _impl_.flag_;
}

// -------------------------------------------------------------------

// DesktopConfig

// uint32 flags = 1;
inline void DesktopConfig::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t DesktopConfig::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t DesktopConfig::flags() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.flags)
  return _internal_flags();
}
inline void DesktopConfig::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void DesktopConfig::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:proto.DesktopConfig.flags)
}

// .proto.VideoEncoding video_encoding = 2;
inline void DesktopConfig::clear_video_encoding() {
  _impl_.video_encoding_ = 0;
}
inline ::proto::VideoEncoding DesktopConfig::_internal_video_encoding() const {
  return static_cast< ::proto::VideoEncoding >(_impl_.video_encoding_);
}
inline ::proto::VideoEncoding DesktopConfig::video_encoding() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.video_encoding)
  return _internal_video_encoding();
}
inline void DesktopConfig::_internal_set_video_encoding(::proto::VideoEncoding value) {
  
  _impl_.video_encoding_ = value;
}
inline void DesktopConfig::set_video_encoding(::proto::VideoEncoding value) {
  _internal_set_video_encoding(value);
  // @@protoc_insertion_point(field_set:proto.DesktopConfig.video_encoding)
}

// .proto.PixelFormat pixel_format = 3;
inline bool DesktopConfig::_internal_has_pixel_format() const {
  return this != internal_default_instance() && _impl_.pixel_format_ != nullptr;
}
inline bool DesktopConfig::has_pixel_format() const {
  return _internal_has_pixel_format();
}
inline void DesktopConfig::clear_pixel_format() {
  if (GetArenaForAllocation() == nullptr && _impl_.pixel_format_ != nullptr) {
    delete _impl_.pixel_format_;
  }
  _impl_.pixel_format_ = nullptr;
}
inline const ::proto::PixelFormat& DesktopConfig::_internal_pixel_format() const {
  const ::proto::PixelFormat* p = _impl_.pixel_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PixelFormat&>(
      ::proto::_PixelFormat_default_instance_);
}
inline const ::proto::PixelFormat& DesktopConfig::pixel_format() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.pixel_format)
  return _internal_pixel_format();
}
inline void DesktopConfig::unsafe_arena_set_allocated_pixel_format(
    ::proto::PixelFormat* pixel_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixel_format_);
  }
  _impl_.pixel_format_ = pixel_format;
  if (pixel_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.DesktopConfig.pixel_format)
}
inline ::proto::PixelFormat* DesktopConfig::release_pixel_format() {
  
  ::proto::PixelFormat* temp = _impl_.pixel_format_;
  _impl_.pixel_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PixelFormat* DesktopConfig::unsafe_arena_release_pixel_format() {
  // @@protoc_insertion_point(field_release:proto.DesktopConfig.pixel_format)
  
  ::proto::PixelFormat* temp = _impl_.pixel_format_;
  _impl_.pixel_format_ = nullptr;
  return temp;
}
inline ::proto::PixelFormat* DesktopConfig::_internal_mutable_pixel_format() {
  
  if (_impl_.pixel_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PixelFormat>(GetArenaForAllocation());
    _impl_.pixel_format_ = p;
  }
  return _impl_.pixel_format_;
}
inline ::proto::PixelFormat* DesktopConfig::mutable_pixel_format() {
  ::proto::PixelFormat* _msg = _internal_mutable_pixel_format();
  // @@protoc_insertion_point(field_mutable:proto.DesktopConfig.pixel_format)
  return _msg;
}
inline void DesktopConfig::set_allocated_pixel_format(::proto::PixelFormat* pixel_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pixel_format_;
  }
  if (pixel_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pixel_format);
    if (message_arena != submessage_arena) {
      pixel_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_format, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pixel_format_ = pixel_format;
  // @@protoc_insertion_point(field_set_allocated:proto.DesktopConfig.pixel_format)
}

// uint32 update_interval = 4;
inline void DesktopConfig::clear_update_interval() {
  _impl_.update_interval_ = 0u;
}
inline uint32_t DesktopConfig::_internal_update_interval() const {
  return _impl_.update_interval_;
}
inline uint32_t DesktopConfig::update_interval() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.update_interval)
  return _internal_update_interval();
}
inline void DesktopConfig::_internal_set_update_interval(uint32_t value) {
  
  _impl_.update_interval_ = value;
}
inline void DesktopConfig::set_update_interval(uint32_t value) {
  _internal_set_update_interval(value);
  // @@protoc_insertion_point(field_set:proto.DesktopConfig.update_interval)
}

// uint32 compress_ratio = 5;
inline void DesktopConfig::clear_compress_ratio() {
  _impl_.compress_ratio_ = 0u;
}
inline uint32_t DesktopConfig::_internal_compress_ratio() const {
  return _impl_.compress_ratio_;
}
inline uint32_t DesktopConfig::compress_ratio() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.compress_ratio)
  return _internal_compress_ratio();
}
inline void DesktopConfig::_internal_set_compress_ratio(uint32_t value) {
  
  _impl_.compress_ratio_ = value;
}
inline void DesktopConfig::set_compress_ratio(uint32_t value) {
  _internal_set_compress_ratio(value);
  // @@protoc_insertion_point(field_set:proto.DesktopConfig.compress_ratio)
}

// uint32 scale_factor = 6;
inline void DesktopConfig::clear_scale_factor() {
  _impl_.scale_factor_ = 0u;
}
inline uint32_t DesktopConfig::_internal_scale_factor() const {
  return _impl_.scale_factor_;
}
inline uint32_t DesktopConfig::scale_factor() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.scale_factor)
  return _internal_scale_factor();
}
inline void DesktopConfig::_internal_set_scale_factor(uint32_t value) {
  
  _impl_.scale_factor_ = value;
}
inline void DesktopConfig::set_scale_factor(uint32_t value) {
  _internal_set_scale_factor(value);
  // @@protoc_insertion_point(field_set:proto.DesktopConfig.scale_factor)
}

// .proto.AudioEncoding audio_encoding = 7;
inline void DesktopConfig::clear_audio_encoding() {
  _impl_.audio_encoding_ = 0;
}
inline ::proto::AudioEncoding DesktopConfig::_internal_audio_encoding() const {
  return static_cast< ::proto::AudioEncoding >(_impl_.audio_encoding_);
}
inline ::proto::AudioEncoding DesktopConfig::audio_encoding() const {
  // @@protoc_insertion_point(field_get:proto.DesktopConfig.audio_encoding)
  return _internal_audio_encoding();
}
inline void DesktopConfig::_internal_set_audio_encoding(::proto::AudioEncoding value) {
  
  _impl_.audio_encoding_ = value;
}
inline void DesktopConfig::set_audio_encoding(::proto::AudioEncoding value) {
  _internal_set_audio_encoding(value);
  // @@protoc_insertion_point(field_set:proto.DesktopConfig.audio_encoding)
}

// -------------------------------------------------------------------

// HostToClient

// .proto.VideoPacket video_packet = 1;
inline bool HostToClient::_internal_has_video_packet() const {
  return this != internal_default_instance() && _impl_.video_packet_ != nullptr;
}
inline bool HostToClient::has_video_packet() const {
  return _internal_has_video_packet();
}
inline void HostToClient::clear_video_packet() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_packet_ != nullptr) {
    delete _impl_.video_packet_;
  }
  _impl_.video_packet_ = nullptr;
}
inline const ::proto::VideoPacket& HostToClient::_internal_video_packet() const {
  const ::proto::VideoPacket* p = _impl_.video_packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::VideoPacket&>(
      ::proto::_VideoPacket_default_instance_);
}
inline const ::proto::VideoPacket& HostToClient::video_packet() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.video_packet)
  return _internal_video_packet();
}
inline void HostToClient::unsafe_arena_set_allocated_video_packet(
    ::proto::VideoPacket* video_packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_packet_);
  }
  _impl_.video_packet_ = video_packet;
  if (video_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.video_packet)
}
inline ::proto::VideoPacket* HostToClient::release_video_packet() {
  
  ::proto::VideoPacket* temp = _impl_.video_packet_;
  _impl_.video_packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::VideoPacket* HostToClient::unsafe_arena_release_video_packet() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.video_packet)
  
  ::proto::VideoPacket* temp = _impl_.video_packet_;
  _impl_.video_packet_ = nullptr;
  return temp;
}
inline ::proto::VideoPacket* HostToClient::_internal_mutable_video_packet() {
  
  if (_impl_.video_packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::VideoPacket>(GetArenaForAllocation());
    _impl_.video_packet_ = p;
  }
  return _impl_.video_packet_;
}
inline ::proto::VideoPacket* HostToClient::mutable_video_packet() {
  ::proto::VideoPacket* _msg = _internal_mutable_video_packet();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.video_packet)
  return _msg;
}
inline void HostToClient::set_allocated_video_packet(::proto::VideoPacket* video_packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_packet_;
  }
  if (video_packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_packet);
    if (message_arena != submessage_arena) {
      video_packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_packet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_packet_ = video_packet;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.video_packet)
}

// .proto.AudioPacket audio_packet = 2;
inline bool HostToClient::_internal_has_audio_packet() const {
  return this != internal_default_instance() && _impl_.audio_packet_ != nullptr;
}
inline bool HostToClient::has_audio_packet() const {
  return _internal_has_audio_packet();
}
inline void HostToClient::clear_audio_packet() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_packet_ != nullptr) {
    delete _impl_.audio_packet_;
  }
  _impl_.audio_packet_ = nullptr;
}
inline const ::proto::AudioPacket& HostToClient::_internal_audio_packet() const {
  const ::proto::AudioPacket* p = _impl_.audio_packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AudioPacket&>(
      ::proto::_AudioPacket_default_instance_);
}
inline const ::proto::AudioPacket& HostToClient::audio_packet() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.audio_packet)
  return _internal_audio_packet();
}
inline void HostToClient::unsafe_arena_set_allocated_audio_packet(
    ::proto::AudioPacket* audio_packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_packet_);
  }
  _impl_.audio_packet_ = audio_packet;
  if (audio_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.audio_packet)
}
inline ::proto::AudioPacket* HostToClient::release_audio_packet() {
  
  ::proto::AudioPacket* temp = _impl_.audio_packet_;
  _impl_.audio_packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AudioPacket* HostToClient::unsafe_arena_release_audio_packet() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.audio_packet)
  
  ::proto::AudioPacket* temp = _impl_.audio_packet_;
  _impl_.audio_packet_ = nullptr;
  return temp;
}
inline ::proto::AudioPacket* HostToClient::_internal_mutable_audio_packet() {
  
  if (_impl_.audio_packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AudioPacket>(GetArenaForAllocation());
    _impl_.audio_packet_ = p;
  }
  return _impl_.audio_packet_;
}
inline ::proto::AudioPacket* HostToClient::mutable_audio_packet() {
  ::proto::AudioPacket* _msg = _internal_mutable_audio_packet();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.audio_packet)
  return _msg;
}
inline void HostToClient::set_allocated_audio_packet(::proto::AudioPacket* audio_packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_packet_;
  }
  if (audio_packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_packet);
    if (message_arena != submessage_arena) {
      audio_packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_packet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_packet_ = audio_packet;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.audio_packet)
}

// .proto.CursorShape cursor_shape = 3;
inline bool HostToClient::_internal_has_cursor_shape() const {
  return this != internal_default_instance() && _impl_.cursor_shape_ != nullptr;
}
inline bool HostToClient::has_cursor_shape() const {
  return _internal_has_cursor_shape();
}
inline void HostToClient::clear_cursor_shape() {
  if (GetArenaForAllocation() == nullptr && _impl_.cursor_shape_ != nullptr) {
    delete _impl_.cursor_shape_;
  }
  _impl_.cursor_shape_ = nullptr;
}
inline const ::proto::CursorShape& HostToClient::_internal_cursor_shape() const {
  const ::proto::CursorShape* p = _impl_.cursor_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CursorShape&>(
      ::proto::_CursorShape_default_instance_);
}
inline const ::proto::CursorShape& HostToClient::cursor_shape() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.cursor_shape)
  return _internal_cursor_shape();
}
inline void HostToClient::unsafe_arena_set_allocated_cursor_shape(
    ::proto::CursorShape* cursor_shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cursor_shape_);
  }
  _impl_.cursor_shape_ = cursor_shape;
  if (cursor_shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.cursor_shape)
}
inline ::proto::CursorShape* HostToClient::release_cursor_shape() {
  
  ::proto::CursorShape* temp = _impl_.cursor_shape_;
  _impl_.cursor_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CursorShape* HostToClient::unsafe_arena_release_cursor_shape() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.cursor_shape)
  
  ::proto::CursorShape* temp = _impl_.cursor_shape_;
  _impl_.cursor_shape_ = nullptr;
  return temp;
}
inline ::proto::CursorShape* HostToClient::_internal_mutable_cursor_shape() {
  
  if (_impl_.cursor_shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CursorShape>(GetArenaForAllocation());
    _impl_.cursor_shape_ = p;
  }
  return _impl_.cursor_shape_;
}
inline ::proto::CursorShape* HostToClient::mutable_cursor_shape() {
  ::proto::CursorShape* _msg = _internal_mutable_cursor_shape();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.cursor_shape)
  return _msg;
}
inline void HostToClient::set_allocated_cursor_shape(::proto::CursorShape* cursor_shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cursor_shape_;
  }
  if (cursor_shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cursor_shape);
    if (message_arena != submessage_arena) {
      cursor_shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor_shape, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cursor_shape_ = cursor_shape;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.cursor_shape)
}

// .proto.ClipboardEvent clipboard_event = 4;
inline bool HostToClient::_internal_has_clipboard_event() const {
  return this != internal_default_instance() && _impl_.clipboard_event_ != nullptr;
}
inline bool HostToClient::has_clipboard_event() const {
  return _internal_has_clipboard_event();
}
inline void HostToClient::clear_clipboard_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.clipboard_event_ != nullptr) {
    delete _impl_.clipboard_event_;
  }
  _impl_.clipboard_event_ = nullptr;
}
inline const ::proto::ClipboardEvent& HostToClient::_internal_clipboard_event() const {
  const ::proto::ClipboardEvent* p = _impl_.clipboard_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ClipboardEvent&>(
      ::proto::_ClipboardEvent_default_instance_);
}
inline const ::proto::ClipboardEvent& HostToClient::clipboard_event() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.clipboard_event)
  return _internal_clipboard_event();
}
inline void HostToClient::unsafe_arena_set_allocated_clipboard_event(
    ::proto::ClipboardEvent* clipboard_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clipboard_event_);
  }
  _impl_.clipboard_event_ = clipboard_event;
  if (clipboard_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.clipboard_event)
}
inline ::proto::ClipboardEvent* HostToClient::release_clipboard_event() {
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ClipboardEvent* HostToClient::unsafe_arena_release_clipboard_event() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.clipboard_event)
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
  return temp;
}
inline ::proto::ClipboardEvent* HostToClient::_internal_mutable_clipboard_event() {
  
  if (_impl_.clipboard_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ClipboardEvent>(GetArenaForAllocation());
    _impl_.clipboard_event_ = p;
  }
  return _impl_.clipboard_event_;
}
inline ::proto::ClipboardEvent* HostToClient::mutable_clipboard_event() {
  ::proto::ClipboardEvent* _msg = _internal_mutable_clipboard_event();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.clipboard_event)
  return _msg;
}
inline void HostToClient::set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clipboard_event_;
  }
  if (clipboard_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clipboard_event);
    if (message_arena != submessage_arena) {
      clipboard_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clipboard_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clipboard_event_ = clipboard_event;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.clipboard_event)
}

// .proto.DesktopExtension extension = 5;
inline bool HostToClient::_internal_has_extension() const {
  return this != internal_default_instance() && _impl_.extension_ != nullptr;
}
inline bool HostToClient::has_extension() const {
  return _internal_has_extension();
}
inline void HostToClient::clear_extension() {
  if (GetArenaForAllocation() == nullptr && _impl_.extension_ != nullptr) {
    delete _impl_.extension_;
  }
  _impl_.extension_ = nullptr;
}
inline const ::proto::DesktopExtension& HostToClient::_internal_extension() const {
  const ::proto::DesktopExtension* p = _impl_.extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DesktopExtension&>(
      ::proto::_DesktopExtension_default_instance_);
}
inline const ::proto::DesktopExtension& HostToClient::extension() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.extension)
  return _internal_extension();
}
inline void HostToClient::unsafe_arena_set_allocated_extension(
    ::proto::DesktopExtension* extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_);
  }
  _impl_.extension_ = extension;
  if (extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.extension)
}
inline ::proto::DesktopExtension* HostToClient::release_extension() {
  
  ::proto::DesktopExtension* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DesktopExtension* HostToClient::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.extension)
  
  ::proto::DesktopExtension* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
  return temp;
}
inline ::proto::DesktopExtension* HostToClient::_internal_mutable_extension() {
  
  if (_impl_.extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DesktopExtension>(GetArenaForAllocation());
    _impl_.extension_ = p;
  }
  return _impl_.extension_;
}
inline ::proto::DesktopExtension* HostToClient::mutable_extension() {
  ::proto::DesktopExtension* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.extension)
  return _msg;
}
inline void HostToClient::set_allocated_extension(::proto::DesktopExtension* extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extension_;
  }
  if (extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extension);
    if (message_arena != submessage_arena) {
      extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.extension)
}

// .proto.DesktopCapabilities capabilities = 6;
inline bool HostToClient::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool HostToClient::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void HostToClient::clear_capabilities() {
  if (GetArenaForAllocation() == nullptr && _impl_.capabilities_ != nullptr) {
    delete _impl_.capabilities_;
  }
  _impl_.capabilities_ = nullptr;
}
inline const ::proto::DesktopCapabilities& HostToClient::_internal_capabilities() const {
  const ::proto::DesktopCapabilities* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DesktopCapabilities&>(
      ::proto::_DesktopCapabilities_default_instance_);
}
inline const ::proto::DesktopCapabilities& HostToClient::capabilities() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.capabilities)
  return _internal_capabilities();
}
inline void HostToClient::unsafe_arena_set_allocated_capabilities(
    ::proto::DesktopCapabilities* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.capabilities)
}
inline ::proto::DesktopCapabilities* HostToClient::release_capabilities() {
  
  ::proto::DesktopCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DesktopCapabilities* HostToClient::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.capabilities)
  
  ::proto::DesktopCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::proto::DesktopCapabilities* HostToClient::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DesktopCapabilities>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::proto::DesktopCapabilities* HostToClient::mutable_capabilities() {
  ::proto::DesktopCapabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.capabilities)
  return _msg;
}
inline void HostToClient::set_allocated_capabilities(::proto::DesktopCapabilities* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capabilities_;
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capabilities);
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.capabilities)
}

// .proto.CursorPosition cursor_position = 7;
inline bool HostToClient::_internal_has_cursor_position() const {
  return this != internal_default_instance() && _impl_.cursor_position_ != nullptr;
}
inline bool HostToClient::has_cursor_position() const {
  return _internal_has_cursor_position();
}
inline void HostToClient::clear_cursor_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.cursor_position_ != nullptr) {
    delete _impl_.cursor_position_;
  }
  _impl_.cursor_position_ = nullptr;
}
inline const ::proto::CursorPosition& HostToClient::_internal_cursor_position() const {
  const ::proto::CursorPosition* p = _impl_.cursor_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CursorPosition&>(
      ::proto::_CursorPosition_default_instance_);
}
inline const ::proto::CursorPosition& HostToClient::cursor_position() const {
  // @@protoc_insertion_point(field_get:proto.HostToClient.cursor_position)
  return _internal_cursor_position();
}
inline void HostToClient::unsafe_arena_set_allocated_cursor_position(
    ::proto::CursorPosition* cursor_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cursor_position_);
  }
  _impl_.cursor_position_ = cursor_position;
  if (cursor_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HostToClient.cursor_position)
}
inline ::proto::CursorPosition* HostToClient::release_cursor_position() {
  
  ::proto::CursorPosition* temp = _impl_.cursor_position_;
  _impl_.cursor_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CursorPosition* HostToClient::unsafe_arena_release_cursor_position() {
  // @@protoc_insertion_point(field_release:proto.HostToClient.cursor_position)
  
  ::proto::CursorPosition* temp = _impl_.cursor_position_;
  _impl_.cursor_position_ = nullptr;
  return temp;
}
inline ::proto::CursorPosition* HostToClient::_internal_mutable_cursor_position() {
  
  if (_impl_.cursor_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CursorPosition>(GetArenaForAllocation());
    _impl_.cursor_position_ = p;
  }
  return _impl_.cursor_position_;
}
inline ::proto::CursorPosition* HostToClient::mutable_cursor_position() {
  ::proto::CursorPosition* _msg = _internal_mutable_cursor_position();
  // @@protoc_insertion_point(field_mutable:proto.HostToClient.cursor_position)
  return _msg;
}
inline void HostToClient::set_allocated_cursor_position(::proto::CursorPosition* cursor_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cursor_position_;
  }
  if (cursor_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cursor_position);
    if (message_arena != submessage_arena) {
      cursor_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cursor_position_ = cursor_position;
  // @@protoc_insertion_point(field_set_allocated:proto.HostToClient.cursor_position)
}

// -------------------------------------------------------------------

// ClientToHost

// .proto.MouseEvent mouse_event = 1;
inline bool ClientToHost::_internal_has_mouse_event() const {
  return this != internal_default_instance() && _impl_.mouse_event_ != nullptr;
}
inline bool ClientToHost::has_mouse_event() const {
  return _internal_has_mouse_event();
}
inline void ClientToHost::clear_mouse_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.mouse_event_ != nullptr) {
    delete _impl_.mouse_event_;
  }
  _impl_.mouse_event_ = nullptr;
}
inline const ::proto::MouseEvent& ClientToHost::_internal_mouse_event() const {
  const ::proto::MouseEvent* p = _impl_.mouse_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MouseEvent&>(
      ::proto::_MouseEvent_default_instance_);
}
inline const ::proto::MouseEvent& ClientToHost::mouse_event() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.mouse_event)
  return _internal_mouse_event();
}
inline void ClientToHost::unsafe_arena_set_allocated_mouse_event(
    ::proto::MouseEvent* mouse_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mouse_event_);
  }
  _impl_.mouse_event_ = mouse_event;
  if (mouse_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.mouse_event)
}
inline ::proto::MouseEvent* ClientToHost::release_mouse_event() {
  
  ::proto::MouseEvent* temp = _impl_.mouse_event_;
  _impl_.mouse_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MouseEvent* ClientToHost::unsafe_arena_release_mouse_event() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.mouse_event)
  
  ::proto::MouseEvent* temp = _impl_.mouse_event_;
  _impl_.mouse_event_ = nullptr;
  return temp;
}
inline ::proto::MouseEvent* ClientToHost::_internal_mutable_mouse_event() {
  
  if (_impl_.mouse_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MouseEvent>(GetArenaForAllocation());
    _impl_.mouse_event_ = p;
  }
  return _impl_.mouse_event_;
}
inline ::proto::MouseEvent* ClientToHost::mutable_mouse_event() {
  ::proto::MouseEvent* _msg = _internal_mutable_mouse_event();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.mouse_event)
  return _msg;
}
inline void ClientToHost::set_allocated_mouse_event(::proto::MouseEvent* mouse_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mouse_event_;
  }
  if (mouse_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mouse_event);
    if (message_arena != submessage_arena) {
      mouse_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mouse_event_ = mouse_event;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.mouse_event)
}

// .proto.KeyEvent key_event = 2;
inline bool ClientToHost::_internal_has_key_event() const {
  return this != internal_default_instance() && _impl_.key_event_ != nullptr;
}
inline bool ClientToHost::has_key_event() const {
  return _internal_has_key_event();
}
inline void ClientToHost::clear_key_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_event_ != nullptr) {
    delete _impl_.key_event_;
  }
  _impl_.key_event_ = nullptr;
}
inline const ::proto::KeyEvent& ClientToHost::_internal_key_event() const {
  const ::proto::KeyEvent* p = _impl_.key_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::KeyEvent&>(
      ::proto::_KeyEvent_default_instance_);
}
inline const ::proto::KeyEvent& ClientToHost::key_event() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.key_event)
  return _internal_key_event();
}
inline void ClientToHost::unsafe_arena_set_allocated_key_event(
    ::proto::KeyEvent* key_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_event_);
  }
  _impl_.key_event_ = key_event;
  if (key_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.key_event)
}
inline ::proto::KeyEvent* ClientToHost::release_key_event() {
  
  ::proto::KeyEvent* temp = _impl_.key_event_;
  _impl_.key_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::KeyEvent* ClientToHost::unsafe_arena_release_key_event() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.key_event)
  
  ::proto::KeyEvent* temp = _impl_.key_event_;
  _impl_.key_event_ = nullptr;
  return temp;
}
inline ::proto::KeyEvent* ClientToHost::_internal_mutable_key_event() {
  
  if (_impl_.key_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::KeyEvent>(GetArenaForAllocation());
    _impl_.key_event_ = p;
  }
  return _impl_.key_event_;
}
inline ::proto::KeyEvent* ClientToHost::mutable_key_event() {
  ::proto::KeyEvent* _msg = _internal_mutable_key_event();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.key_event)
  return _msg;
}
inline void ClientToHost::set_allocated_key_event(::proto::KeyEvent* key_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_event_;
  }
  if (key_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_event);
    if (message_arena != submessage_arena) {
      key_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_event_ = key_event;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.key_event)
}

// .proto.TextEvent text_event = 4;
inline bool ClientToHost::_internal_has_text_event() const {
  return this != internal_default_instance() && _impl_.text_event_ != nullptr;
}
inline bool ClientToHost::has_text_event() const {
  return _internal_has_text_event();
}
inline void ClientToHost::clear_text_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.text_event_ != nullptr) {
    delete _impl_.text_event_;
  }
  _impl_.text_event_ = nullptr;
}
inline const ::proto::TextEvent& ClientToHost::_internal_text_event() const {
  const ::proto::TextEvent* p = _impl_.text_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TextEvent&>(
      ::proto::_TextEvent_default_instance_);
}
inline const ::proto::TextEvent& ClientToHost::text_event() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.text_event)
  return _internal_text_event();
}
inline void ClientToHost::unsafe_arena_set_allocated_text_event(
    ::proto::TextEvent* text_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_event_);
  }
  _impl_.text_event_ = text_event;
  if (text_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.text_event)
}
inline ::proto::TextEvent* ClientToHost::release_text_event() {
  
  ::proto::TextEvent* temp = _impl_.text_event_;
  _impl_.text_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TextEvent* ClientToHost::unsafe_arena_release_text_event() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.text_event)
  
  ::proto::TextEvent* temp = _impl_.text_event_;
  _impl_.text_event_ = nullptr;
  return temp;
}
inline ::proto::TextEvent* ClientToHost::_internal_mutable_text_event() {
  
  if (_impl_.text_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TextEvent>(GetArenaForAllocation());
    _impl_.text_event_ = p;
  }
  return _impl_.text_event_;
}
inline ::proto::TextEvent* ClientToHost::mutable_text_event() {
  ::proto::TextEvent* _msg = _internal_mutable_text_event();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.text_event)
  return _msg;
}
inline void ClientToHost::set_allocated_text_event(::proto::TextEvent* text_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_event_;
  }
  if (text_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_event);
    if (message_arena != submessage_arena) {
      text_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_event_ = text_event;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.text_event)
}

// .proto.ClipboardEvent clipboard_event = 5;
inline bool ClientToHost::_internal_has_clipboard_event() const {
  return this != internal_default_instance() && _impl_.clipboard_event_ != nullptr;
}
inline bool ClientToHost::has_clipboard_event() const {
  return _internal_has_clipboard_event();
}
inline void ClientToHost::clear_clipboard_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.clipboard_event_ != nullptr) {
    delete _impl_.clipboard_event_;
  }
  _impl_.clipboard_event_ = nullptr;
}
inline const ::proto::ClipboardEvent& ClientToHost::_internal_clipboard_event() const {
  const ::proto::ClipboardEvent* p = _impl_.clipboard_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ClipboardEvent&>(
      ::proto::_ClipboardEvent_default_instance_);
}
inline const ::proto::ClipboardEvent& ClientToHost::clipboard_event() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.clipboard_event)
  return _internal_clipboard_event();
}
inline void ClientToHost::unsafe_arena_set_allocated_clipboard_event(
    ::proto::ClipboardEvent* clipboard_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clipboard_event_);
  }
  _impl_.clipboard_event_ = clipboard_event;
  if (clipboard_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.clipboard_event)
}
inline ::proto::ClipboardEvent* ClientToHost::release_clipboard_event() {
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ClipboardEvent* ClientToHost::unsafe_arena_release_clipboard_event() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.clipboard_event)
  
  ::proto::ClipboardEvent* temp = _impl_.clipboard_event_;
  _impl_.clipboard_event_ = nullptr;
  return temp;
}
inline ::proto::ClipboardEvent* ClientToHost::_internal_mutable_clipboard_event() {
  
  if (_impl_.clipboard_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ClipboardEvent>(GetArenaForAllocation());
    _impl_.clipboard_event_ = p;
  }
  return _impl_.clipboard_event_;
}
inline ::proto::ClipboardEvent* ClientToHost::mutable_clipboard_event() {
  ::proto::ClipboardEvent* _msg = _internal_mutable_clipboard_event();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.clipboard_event)
  return _msg;
}
inline void ClientToHost::set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clipboard_event_;
  }
  if (clipboard_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clipboard_event);
    if (message_arena != submessage_arena) {
      clipboard_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clipboard_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clipboard_event_ = clipboard_event;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.clipboard_event)
}

// .proto.DesktopExtension extension = 6;
inline bool ClientToHost::_internal_has_extension() const {
  return this != internal_default_instance() && _impl_.extension_ != nullptr;
}
inline bool ClientToHost::has_extension() const {
  return _internal_has_extension();
}
inline void ClientToHost::clear_extension() {
  if (GetArenaForAllocation() == nullptr && _impl_.extension_ != nullptr) {
    delete _impl_.extension_;
  }
  _impl_.extension_ = nullptr;
}
inline const ::proto::DesktopExtension& ClientToHost::_internal_extension() const {
  const ::proto::DesktopExtension* p = _impl_.extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DesktopExtension&>(
      ::proto::_DesktopExtension_default_instance_);
}
inline const ::proto::DesktopExtension& ClientToHost::extension() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.extension)
  return _internal_extension();
}
inline void ClientToHost::unsafe_arena_set_allocated_extension(
    ::proto::DesktopExtension* extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_);
  }
  _impl_.extension_ = extension;
  if (extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.extension)
}
inline ::proto::DesktopExtension* ClientToHost::release_extension() {
  
  ::proto::DesktopExtension* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DesktopExtension* ClientToHost::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.extension)
  
  ::proto::DesktopExtension* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
  return temp;
}
inline ::proto::DesktopExtension* ClientToHost::_internal_mutable_extension() {
  
  if (_impl_.extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DesktopExtension>(GetArenaForAllocation());
    _impl_.extension_ = p;
  }
  return _impl_.extension_;
}
inline ::proto::DesktopExtension* ClientToHost::mutable_extension() {
  ::proto::DesktopExtension* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.extension)
  return _msg;
}
inline void ClientToHost::set_allocated_extension(::proto::DesktopExtension* extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extension_;
  }
  if (extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extension);
    if (message_arena != submessage_arena) {
      extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.extension)
}

// .proto.DesktopConfig config = 7;
inline bool ClientToHost::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool ClientToHost::has_config() const {
  return _internal_has_config();
}
inline void ClientToHost::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::proto::DesktopConfig& ClientToHost::_internal_config() const {
  const ::proto::DesktopConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DesktopConfig&>(
      ::proto::_DesktopConfig_default_instance_);
}
inline const ::proto::DesktopConfig& ClientToHost::config() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.config)
  return _internal_config();
}
inline void ClientToHost::unsafe_arena_set_allocated_config(
    ::proto::DesktopConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.config)
}
inline ::proto::DesktopConfig* ClientToHost::release_config() {
  
  ::proto::DesktopConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DesktopConfig* ClientToHost::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.config)
  
  ::proto::DesktopConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::proto::DesktopConfig* ClientToHost::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DesktopConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::proto::DesktopConfig* ClientToHost::mutable_config() {
  ::proto::DesktopConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.config)
  return _msg;
}
inline void ClientToHost::set_allocated_config(::proto::DesktopConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.config)
}

// .proto.AudioPacket audio_packet = 8;
inline bool ClientToHost::_internal_has_audio_packet() const {
  return this != internal_default_instance() && _impl_.audio_packet_ != nullptr;
}
inline bool ClientToHost::has_audio_packet() const {
  return _internal_has_audio_packet();
}
inline void ClientToHost::clear_audio_packet() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_packet_ != nullptr) {
    delete _impl_.audio_packet_;
  }
  _impl_.audio_packet_ = nullptr;
}
inline const ::proto::AudioPacket& ClientToHost::_internal_audio_packet() const {
  const ::proto::AudioPacket* p = _impl_.audio_packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AudioPacket&>(
      ::proto::_AudioPacket_default_instance_);
}
inline const ::proto::AudioPacket& ClientToHost::audio_packet() const {
  // @@protoc_insertion_point(field_get:proto.ClientToHost.audio_packet)
  return _internal_audio_packet();
}
inline void ClientToHost::unsafe_arena_set_allocated_audio_packet(
    ::proto::AudioPacket* audio_packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_packet_);
  }
  _impl_.audio_packet_ = audio_packet;
  if (audio_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ClientToHost.audio_packet)
}
inline ::proto::AudioPacket* ClientToHost::release_audio_packet() {
  
  ::proto::AudioPacket* temp = _impl_.audio_packet_;
  _impl_.audio_packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AudioPacket* ClientToHost::unsafe_arena_release_audio_packet() {
  // @@protoc_insertion_point(field_release:proto.ClientToHost.audio_packet)
  
  ::proto::AudioPacket* temp = _impl_.audio_packet_;
  _impl_.audio_packet_ = nullptr;
  return temp;
}
inline ::proto::AudioPacket* ClientToHost::_internal_mutable_audio_packet() {
  
  if (_impl_.audio_packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AudioPacket>(GetArenaForAllocation());
    _impl_.audio_packet_ = p;
  }
  return _impl_.audio_packet_;
}
inline ::proto::AudioPacket* ClientToHost::mutable_audio_packet() {
  ::proto::AudioPacket* _msg = _internal_mutable_audio_packet();
  // @@protoc_insertion_point(field_mutable:proto.ClientToHost.audio_packet)
  return _msg;
}
inline void ClientToHost::set_allocated_audio_packet(::proto::AudioPacket* audio_packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_packet_;
  }
  if (audio_packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_packet);
    if (message_arena != submessage_arena) {
      audio_packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_packet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_packet_ = audio_packet;
  // @@protoc_insertion_point(field_set_allocated:proto.ClientToHost.audio_packet)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::KeyEvent_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::MouseEvent_ButtonMask> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::CursorShape_Flags> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::AudioPacket_SamplingRate> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::AudioPacket_BytesPerSample> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::AudioPacket_Channels> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::DesktopCapabilities_OsType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::VideoEncoding> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::VideoErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::AudioEncoding> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::DesktopFlags> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_desktop_2eproto
