// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: key_exchange.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_key_5fexchange_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_key_5fexchange_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_key_5fexchange_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_key_5fexchange_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class ClientHello;
struct ClientHelloDefaultTypeInternal;
extern ClientHelloDefaultTypeInternal _ClientHello_default_instance_;
class ServerHello;
struct ServerHelloDefaultTypeInternal;
extern ServerHelloDefaultTypeInternal _ServerHello_default_instance_;
class SessionChallenge;
struct SessionChallengeDefaultTypeInternal;
extern SessionChallengeDefaultTypeInternal _SessionChallenge_default_instance_;
class SessionResponse;
struct SessionResponseDefaultTypeInternal;
extern SessionResponseDefaultTypeInternal _SessionResponse_default_instance_;
class SrpClientKeyExchange;
struct SrpClientKeyExchangeDefaultTypeInternal;
extern SrpClientKeyExchangeDefaultTypeInternal _SrpClientKeyExchange_default_instance_;
class SrpIdentify;
struct SrpIdentifyDefaultTypeInternal;
extern SrpIdentifyDefaultTypeInternal _SrpIdentify_default_instance_;
class SrpServerKeyExchange;
struct SrpServerKeyExchangeDefaultTypeInternal;
extern SrpServerKeyExchangeDefaultTypeInternal _SrpServerKeyExchange_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::ClientHello* Arena::CreateMaybeMessage<::proto::ClientHello>(Arena*);
template<> ::proto::ServerHello* Arena::CreateMaybeMessage<::proto::ServerHello>(Arena*);
template<> ::proto::SessionChallenge* Arena::CreateMaybeMessage<::proto::SessionChallenge>(Arena*);
template<> ::proto::SessionResponse* Arena::CreateMaybeMessage<::proto::SessionResponse>(Arena*);
template<> ::proto::SrpClientKeyExchange* Arena::CreateMaybeMessage<::proto::SrpClientKeyExchange>(Arena*);
template<> ::proto::SrpIdentify* Arena::CreateMaybeMessage<::proto::SrpIdentify>(Arena*);
template<> ::proto::SrpServerKeyExchange* Arena::CreateMaybeMessage<::proto::SrpServerKeyExchange>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum Identify : int {
  IDENTIFY_SRP = 0,
  IDENTIFY_ANONYMOUS = 1,
  Identify_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Identify_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Identify_IsValid(int value);
constexpr Identify Identify_MIN = IDENTIFY_SRP;
constexpr Identify Identify_MAX = IDENTIFY_ANONYMOUS;
constexpr int Identify_ARRAYSIZE = Identify_MAX + 1;

const std::string& Identify_Name(Identify value);
template<typename T>
inline const std::string& Identify_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Identify>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Identify_Name.");
  return Identify_Name(static_cast<Identify>(enum_t_value));
}
bool Identify_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Identify* value);
enum Encryption : int {
  ENCRYPTION_UNKNOWN = 0,
  ENCRYPTION_CHACHA20_POLY1305 = 1,
  ENCRYPTION_AES256_GCM = 2,
  Encryption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Encryption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Encryption_IsValid(int value);
constexpr Encryption Encryption_MIN = ENCRYPTION_UNKNOWN;
constexpr Encryption Encryption_MAX = ENCRYPTION_AES256_GCM;
constexpr int Encryption_ARRAYSIZE = Encryption_MAX + 1;

const std::string& Encryption_Name(Encryption value);
template<typename T>
inline const std::string& Encryption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Encryption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Encryption_Name.");
  return Encryption_Name(static_cast<Encryption>(enum_t_value));
}
bool Encryption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Encryption* value);
// ===================================================================

class ClientHello final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ClientHello) */ {
 public:
  inline ClientHello() : ClientHello(nullptr) {}
  ~ClientHello() override;
  explicit PROTOBUF_CONSTEXPR ClientHello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientHello(const ClientHello& from);
  ClientHello(ClientHello&& from) noexcept
    : ClientHello() {
    *this = ::std::move(from);
  }

  inline ClientHello& operator=(const ClientHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientHello& operator=(ClientHello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ClientHello& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientHello* internal_default_instance() {
    return reinterpret_cast<const ClientHello*>(
               &_ClientHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientHello& a, ClientHello& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientHello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientHello* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientHello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientHello>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientHello& from);
  void MergeFrom(const ClientHello& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientHello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ClientHello";
  }
  protected:
  explicit ClientHello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 3,
    kIvFieldNumber = 4,
    kEncryptionFieldNumber = 1,
    kIdentifyFieldNumber = 2,
  };
  // bytes public_key = 3;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes iv = 4;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // uint32 encryption = 1;
  void clear_encryption();
  uint32_t encryption() const;
  void set_encryption(uint32_t value);
  private:
  uint32_t _internal_encryption() const;
  void _internal_set_encryption(uint32_t value);
  public:

  // .proto.Identify identify = 2;
  void clear_identify();
  ::proto::Identify identify() const;
  void set_identify(::proto::Identify value);
  private:
  ::proto::Identify _internal_identify() const;
  void _internal_set_identify(::proto::Identify value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ClientHello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    uint32_t encryption_;
    int identify_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// -------------------------------------------------------------------

class ServerHello final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ServerHello) */ {
 public:
  inline ServerHello() : ServerHello(nullptr) {}
  ~ServerHello() override;
  explicit PROTOBUF_CONSTEXPR ServerHello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerHello(const ServerHello& from);
  ServerHello(ServerHello&& from) noexcept
    : ServerHello() {
    *this = ::std::move(from);
  }

  inline ServerHello& operator=(const ServerHello& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerHello& operator=(ServerHello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ServerHello& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerHello* internal_default_instance() {
    return reinterpret_cast<const ServerHello*>(
               &_ServerHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerHello& a, ServerHello& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerHello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerHello* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerHello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerHello>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServerHello& from);
  void MergeFrom(const ServerHello& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerHello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ServerHello";
  }
  protected:
  explicit ServerHello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvFieldNumber = 2,
    kEncryptionFieldNumber = 1,
  };
  // bytes iv = 2;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // .proto.Encryption encryption = 1;
  void clear_encryption();
  ::proto::Encryption encryption() const;
  void set_encryption(::proto::Encryption value);
  private:
  ::proto::Encryption _internal_encryption() const;
  void _internal_set_encryption(::proto::Encryption value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ServerHello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    int encryption_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// -------------------------------------------------------------------

class SrpIdentify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SrpIdentify) */ {
 public:
  inline SrpIdentify() : SrpIdentify(nullptr) {}
  ~SrpIdentify() override;
  explicit PROTOBUF_CONSTEXPR SrpIdentify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SrpIdentify(const SrpIdentify& from);
  SrpIdentify(SrpIdentify&& from) noexcept
    : SrpIdentify() {
    *this = ::std::move(from);
  }

  inline SrpIdentify& operator=(const SrpIdentify& from) {
    CopyFrom(from);
    return *this;
  }
  inline SrpIdentify& operator=(SrpIdentify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SrpIdentify& default_instance() {
    return *internal_default_instance();
  }
  static inline const SrpIdentify* internal_default_instance() {
    return reinterpret_cast<const SrpIdentify*>(
               &_SrpIdentify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SrpIdentify& a, SrpIdentify& b) {
    a.Swap(&b);
  }
  inline void Swap(SrpIdentify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SrpIdentify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SrpIdentify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SrpIdentify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SrpIdentify& from);
  void MergeFrom(const SrpIdentify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpIdentify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SrpIdentify";
  }
  protected:
  explicit SrpIdentify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:proto.SrpIdentify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// -------------------------------------------------------------------

class SrpServerKeyExchange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SrpServerKeyExchange) */ {
 public:
  inline SrpServerKeyExchange() : SrpServerKeyExchange(nullptr) {}
  ~SrpServerKeyExchange() override;
  explicit PROTOBUF_CONSTEXPR SrpServerKeyExchange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SrpServerKeyExchange(const SrpServerKeyExchange& from);
  SrpServerKeyExchange(SrpServerKeyExchange&& from) noexcept
    : SrpServerKeyExchange() {
    *this = ::std::move(from);
  }

  inline SrpServerKeyExchange& operator=(const SrpServerKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }
  inline SrpServerKeyExchange& operator=(SrpServerKeyExchange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SrpServerKeyExchange& default_instance() {
    return *internal_default_instance();
  }
  static inline const SrpServerKeyExchange* internal_default_instance() {
    return reinterpret_cast<const SrpServerKeyExchange*>(
               &_SrpServerKeyExchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SrpServerKeyExchange& a, SrpServerKeyExchange& b) {
    a.Swap(&b);
  }
  inline void Swap(SrpServerKeyExchange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SrpServerKeyExchange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SrpServerKeyExchange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SrpServerKeyExchange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SrpServerKeyExchange& from);
  void MergeFrom(const SrpServerKeyExchange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpServerKeyExchange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SrpServerKeyExchange";
  }
  protected:
  explicit SrpServerKeyExchange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kGeneratorFieldNumber = 2,
    kSaltFieldNumber = 3,
    kBFieldNumber = 4,
    kIvFieldNumber = 5,
  };
  // bytes number = 1;
  void clear_number();
  const std::string& number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_number();
  PROTOBUF_NODISCARD std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // bytes generator = 2;
  void clear_generator();
  const std::string& generator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_generator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_generator();
  PROTOBUF_NODISCARD std::string* release_generator();
  void set_allocated_generator(std::string* generator);
  private:
  const std::string& _internal_generator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_generator(const std::string& value);
  std::string* _internal_mutable_generator();
  public:

  // bytes salt = 3;
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // bytes B = 4;
  void clear_b();
  const std::string& b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_b();
  PROTOBUF_NODISCARD std::string* release_b();
  void set_allocated_b(std::string* b);
  private:
  const std::string& _internal_b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_b(const std::string& value);
  std::string* _internal_mutable_b();
  public:

  // bytes iv = 5;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // @@protoc_insertion_point(class_scope:proto.SrpServerKeyExchange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr generator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// -------------------------------------------------------------------

class SrpClientKeyExchange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SrpClientKeyExchange) */ {
 public:
  inline SrpClientKeyExchange() : SrpClientKeyExchange(nullptr) {}
  ~SrpClientKeyExchange() override;
  explicit PROTOBUF_CONSTEXPR SrpClientKeyExchange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SrpClientKeyExchange(const SrpClientKeyExchange& from);
  SrpClientKeyExchange(SrpClientKeyExchange&& from) noexcept
    : SrpClientKeyExchange() {
    *this = ::std::move(from);
  }

  inline SrpClientKeyExchange& operator=(const SrpClientKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }
  inline SrpClientKeyExchange& operator=(SrpClientKeyExchange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SrpClientKeyExchange& default_instance() {
    return *internal_default_instance();
  }
  static inline const SrpClientKeyExchange* internal_default_instance() {
    return reinterpret_cast<const SrpClientKeyExchange*>(
               &_SrpClientKeyExchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SrpClientKeyExchange& a, SrpClientKeyExchange& b) {
    a.Swap(&b);
  }
  inline void Swap(SrpClientKeyExchange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SrpClientKeyExchange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SrpClientKeyExchange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SrpClientKeyExchange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SrpClientKeyExchange& from);
  void MergeFrom(const SrpClientKeyExchange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpClientKeyExchange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SrpClientKeyExchange";
  }
  protected:
  explicit SrpClientKeyExchange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 1,
    kIvFieldNumber = 2,
  };
  // bytes A = 1;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // bytes iv = 2;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // @@protoc_insertion_point(class_scope:proto.SrpClientKeyExchange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// -------------------------------------------------------------------

class SessionChallenge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionChallenge) */ {
 public:
  inline SessionChallenge() : SessionChallenge(nullptr) {}
  ~SessionChallenge() override;
  explicit PROTOBUF_CONSTEXPR SessionChallenge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionChallenge(const SessionChallenge& from);
  SessionChallenge(SessionChallenge&& from) noexcept
    : SessionChallenge() {
    *this = ::std::move(from);
  }

  inline SessionChallenge& operator=(const SessionChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionChallenge& operator=(SessionChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionChallenge* internal_default_instance() {
    return reinterpret_cast<const SessionChallenge*>(
               &_SessionChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SessionChallenge& a, SessionChallenge& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionChallenge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionChallenge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionChallenge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionChallenge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionChallenge& from);
  void MergeFrom(const SessionChallenge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionChallenge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SessionChallenge";
  }
  protected:
  explicit SessionChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOsNameFieldNumber = 4,
    kComputerNameFieldNumber = 5,
    kVersionFieldNumber = 1,
    kSessionTypesFieldNumber = 2,
    kCpuCoresFieldNumber = 3,
  };
  // string os_name = 4;
  void clear_os_name();
  const std::string& os_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_name();
  PROTOBUF_NODISCARD std::string* release_os_name();
  void set_allocated_os_name(std::string* os_name);
  private:
  const std::string& _internal_os_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_name(const std::string& value);
  std::string* _internal_mutable_os_name();
  public:

  // string computer_name = 5;
  void clear_computer_name();
  const std::string& computer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_computer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_computer_name();
  PROTOBUF_NODISCARD std::string* release_computer_name();
  void set_allocated_computer_name(std::string* computer_name);
  private:
  const std::string& _internal_computer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_computer_name(const std::string& value);
  std::string* _internal_mutable_computer_name();
  public:

  // .proto.Version version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::proto::Version& version() const;
  PROTOBUF_NODISCARD ::proto::Version* release_version();
  ::proto::Version* mutable_version();
  void set_allocated_version(::proto::Version* version);
  private:
  const ::proto::Version& _internal_version() const;
  ::proto::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::proto::Version* version);
  ::proto::Version* unsafe_arena_release_version();

  // uint32 session_types = 2;
  void clear_session_types();
  uint32_t session_types() const;
  void set_session_types(uint32_t value);
  private:
  uint32_t _internal_session_types() const;
  void _internal_set_session_types(uint32_t value);
  public:

  // uint32 cpu_cores = 3;
  void clear_cpu_cores();
  uint32_t cpu_cores() const;
  void set_cpu_cores(uint32_t value);
  private:
  uint32_t _internal_cpu_cores() const;
  void _internal_set_cpu_cores(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SessionChallenge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr computer_name_;
    ::proto::Version* version_;
    uint32_t session_types_;
    uint32_t cpu_cores_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// -------------------------------------------------------------------

class SessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionResponse) */ {
 public:
  inline SessionResponse() : SessionResponse(nullptr) {}
  ~SessionResponse() override;
  explicit PROTOBUF_CONSTEXPR SessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponse(const SessionResponse& from);
  SessionResponse(SessionResponse&& from) noexcept
    : SessionResponse() {
    *this = ::std::move(from);
  }

  inline SessionResponse& operator=(const SessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponse& operator=(SessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponse* internal_default_instance() {
    return reinterpret_cast<const SessionResponse*>(
               &_SessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SessionResponse& a, SessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionResponse& from);
  void MergeFrom(const SessionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SessionResponse";
  }
  protected:
  explicit SessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOsNameFieldNumber = 4,
    kComputerNameFieldNumber = 5,
    kVersionFieldNumber = 1,
    kSessionTypeFieldNumber = 2,
    kCpuCoresFieldNumber = 3,
  };
  // string os_name = 4;
  void clear_os_name();
  const std::string& os_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_name();
  PROTOBUF_NODISCARD std::string* release_os_name();
  void set_allocated_os_name(std::string* os_name);
  private:
  const std::string& _internal_os_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_name(const std::string& value);
  std::string* _internal_mutable_os_name();
  public:

  // string computer_name = 5;
  void clear_computer_name();
  const std::string& computer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_computer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_computer_name();
  PROTOBUF_NODISCARD std::string* release_computer_name();
  void set_allocated_computer_name(std::string* computer_name);
  private:
  const std::string& _internal_computer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_computer_name(const std::string& value);
  std::string* _internal_mutable_computer_name();
  public:

  // .proto.Version version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::proto::Version& version() const;
  PROTOBUF_NODISCARD ::proto::Version* release_version();
  ::proto::Version* mutable_version();
  void set_allocated_version(::proto::Version* version);
  private:
  const ::proto::Version& _internal_version() const;
  ::proto::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::proto::Version* version);
  ::proto::Version* unsafe_arena_release_version();

  // uint32 session_type = 2;
  void clear_session_type();
  uint32_t session_type() const;
  void set_session_type(uint32_t value);
  private:
  uint32_t _internal_session_type() const;
  void _internal_set_session_type(uint32_t value);
  public:

  // uint32 cpu_cores = 3;
  void clear_cpu_cores();
  uint32_t cpu_cores() const;
  void set_cpu_cores(uint32_t value);
  private:
  uint32_t _internal_cpu_cores() const;
  void _internal_set_cpu_cores(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr computer_name_;
    ::proto::Version* version_;
    uint32_t session_type_;
    uint32_t cpu_cores_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_key_5fexchange_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientHello

// uint32 encryption = 1;
inline void ClientHello::clear_encryption() {
  _impl_.encryption_ = 0u;
}
inline uint32_t ClientHello::_internal_encryption() const {
  return _impl_.encryption_;
}
inline uint32_t ClientHello::encryption() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.encryption)
  return _internal_encryption();
}
inline void ClientHello::_internal_set_encryption(uint32_t value) {
  
  _impl_.encryption_ = value;
}
inline void ClientHello::set_encryption(uint32_t value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:proto.ClientHello.encryption)
}

// .proto.Identify identify = 2;
inline void ClientHello::clear_identify() {
  _impl_.identify_ = 0;
}
inline ::proto::Identify ClientHello::_internal_identify() const {
  return static_cast< ::proto::Identify >(_impl_.identify_);
}
inline ::proto::Identify ClientHello::identify() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.identify)
  return _internal_identify();
}
inline void ClientHello::_internal_set_identify(::proto::Identify value) {
  
  _impl_.identify_ = value;
}
inline void ClientHello::set_identify(::proto::Identify value) {
  _internal_set_identify(value);
  // @@protoc_insertion_point(field_set:proto.ClientHello.identify)
}

// bytes public_key = 3;
inline void ClientHello::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& ClientHello::public_key() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientHello::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ClientHello.public_key)
}
inline std::string* ClientHello::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:proto.ClientHello.public_key)
  return _s;
}
inline const std::string& ClientHello::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void ClientHello::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientHello::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientHello::release_public_key() {
  // @@protoc_insertion_point(field_release:proto.ClientHello.public_key)
  return _impl_.public_key_.Release();
}
inline void ClientHello::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.public_key)
}

// bytes iv = 4;
inline void ClientHello::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& ClientHello::iv() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientHello::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ClientHello.iv)
}
inline std::string* ClientHello::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.ClientHello.iv)
  return _s;
}
inline const std::string& ClientHello::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void ClientHello::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientHello::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientHello::release_iv() {
  // @@protoc_insertion_point(field_release:proto.ClientHello.iv)
  return _impl_.iv_.Release();
}
inline void ClientHello::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.iv)
}

// -------------------------------------------------------------------

// ServerHello

// .proto.Encryption encryption = 1;
inline void ServerHello::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::proto::Encryption ServerHello::_internal_encryption() const {
  return static_cast< ::proto::Encryption >(_impl_.encryption_);
}
inline ::proto::Encryption ServerHello::encryption() const {
  // @@protoc_insertion_point(field_get:proto.ServerHello.encryption)
  return _internal_encryption();
}
inline void ServerHello::_internal_set_encryption(::proto::Encryption value) {
  
  _impl_.encryption_ = value;
}
inline void ServerHello::set_encryption(::proto::Encryption value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:proto.ServerHello.encryption)
}

// bytes iv = 2;
inline void ServerHello::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& ServerHello::iv() const {
  // @@protoc_insertion_point(field_get:proto.ServerHello.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerHello::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ServerHello.iv)
}
inline std::string* ServerHello::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.ServerHello.iv)
  return _s;
}
inline const std::string& ServerHello::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void ServerHello::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerHello::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerHello::release_iv() {
  // @@protoc_insertion_point(field_release:proto.ServerHello.iv)
  return _impl_.iv_.Release();
}
inline void ServerHello::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ServerHello.iv)
}

// -------------------------------------------------------------------

// SrpIdentify

// string username = 1;
inline void SrpIdentify::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& SrpIdentify::username() const {
  // @@protoc_insertion_point(field_get:proto.SrpIdentify.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpIdentify::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpIdentify.username)
}
inline std::string* SrpIdentify::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.SrpIdentify.username)
  return _s;
}
inline const std::string& SrpIdentify::_internal_username() const {
  return _impl_.username_.Get();
}
inline void SrpIdentify::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpIdentify::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpIdentify::release_username() {
  // @@protoc_insertion_point(field_release:proto.SrpIdentify.username)
  return _impl_.username_.Release();
}
inline void SrpIdentify::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpIdentify.username)
}

// -------------------------------------------------------------------

// SrpServerKeyExchange

// bytes number = 1;
inline void SrpServerKeyExchange::clear_number() {
  _impl_.number_.ClearToEmpty();
}
inline const std::string& SrpServerKeyExchange::number() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.number)
  return _internal_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpServerKeyExchange::set_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.number_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.number)
}
inline std::string* SrpServerKeyExchange::mutable_number() {
  std::string* _s = _internal_mutable_number();
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.number)
  return _s;
}
inline const std::string& SrpServerKeyExchange::_internal_number() const {
  return _impl_.number_.Get();
}
inline void SrpServerKeyExchange::_internal_set_number(const std::string& value) {
  
  _impl_.number_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::_internal_mutable_number() {
  
  return _impl_.number_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::release_number() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.number)
  return _impl_.number_.Release();
}
inline void SrpServerKeyExchange::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  _impl_.number_.SetAllocated(number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.number_.IsDefault()) {
    _impl_.number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.number)
}

// bytes generator = 2;
inline void SrpServerKeyExchange::clear_generator() {
  _impl_.generator_.ClearToEmpty();
}
inline const std::string& SrpServerKeyExchange::generator() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.generator)
  return _internal_generator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpServerKeyExchange::set_generator(ArgT0&& arg0, ArgT... args) {
 
 _impl_.generator_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.generator)
}
inline std::string* SrpServerKeyExchange::mutable_generator() {
  std::string* _s = _internal_mutable_generator();
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.generator)
  return _s;
}
inline const std::string& SrpServerKeyExchange::_internal_generator() const {
  return _impl_.generator_.Get();
}
inline void SrpServerKeyExchange::_internal_set_generator(const std::string& value) {
  
  _impl_.generator_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::_internal_mutable_generator() {
  
  return _impl_.generator_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::release_generator() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.generator)
  return _impl_.generator_.Release();
}
inline void SrpServerKeyExchange::set_allocated_generator(std::string* generator) {
  if (generator != nullptr) {
    
  } else {
    
  }
  _impl_.generator_.SetAllocated(generator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.generator_.IsDefault()) {
    _impl_.generator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.generator)
}

// bytes salt = 3;
inline void SrpServerKeyExchange::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& SrpServerKeyExchange::salt() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpServerKeyExchange::set_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.salt)
}
inline std::string* SrpServerKeyExchange::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.salt)
  return _s;
}
inline const std::string& SrpServerKeyExchange::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void SrpServerKeyExchange::_internal_set_salt(const std::string& value) {
  
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::_internal_mutable_salt() {
  
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::release_salt() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.salt)
  return _impl_.salt_.Release();
}
inline void SrpServerKeyExchange::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.salt)
}

// bytes B = 4;
inline void SrpServerKeyExchange::clear_b() {
  _impl_.b_.ClearToEmpty();
}
inline const std::string& SrpServerKeyExchange::b() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.B)
  return _internal_b();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpServerKeyExchange::set_b(ArgT0&& arg0, ArgT... args) {
 
 _impl_.b_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.B)
}
inline std::string* SrpServerKeyExchange::mutable_b() {
  std::string* _s = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.B)
  return _s;
}
inline const std::string& SrpServerKeyExchange::_internal_b() const {
  return _impl_.b_.Get();
}
inline void SrpServerKeyExchange::_internal_set_b(const std::string& value) {
  
  _impl_.b_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::_internal_mutable_b() {
  
  return _impl_.b_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::release_b() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.B)
  return _impl_.b_.Release();
}
inline void SrpServerKeyExchange::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    
  } else {
    
  }
  _impl_.b_.SetAllocated(b, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.b_.IsDefault()) {
    _impl_.b_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.B)
}

// bytes iv = 5;
inline void SrpServerKeyExchange::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& SrpServerKeyExchange::iv() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpServerKeyExchange::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.iv)
}
inline std::string* SrpServerKeyExchange::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.iv)
  return _s;
}
inline const std::string& SrpServerKeyExchange::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void SrpServerKeyExchange::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpServerKeyExchange::release_iv() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.iv)
  return _impl_.iv_.Release();
}
inline void SrpServerKeyExchange::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.iv)
}

// -------------------------------------------------------------------

// SrpClientKeyExchange

// bytes A = 1;
inline void SrpClientKeyExchange::clear_a() {
  _impl_.a_.ClearToEmpty();
}
inline const std::string& SrpClientKeyExchange::a() const {
  // @@protoc_insertion_point(field_get:proto.SrpClientKeyExchange.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpClientKeyExchange::set_a(ArgT0&& arg0, ArgT... args) {
 
 _impl_.a_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpClientKeyExchange.A)
}
inline std::string* SrpClientKeyExchange::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:proto.SrpClientKeyExchange.A)
  return _s;
}
inline const std::string& SrpClientKeyExchange::_internal_a() const {
  return _impl_.a_.Get();
}
inline void SrpClientKeyExchange::_internal_set_a(const std::string& value) {
  
  _impl_.a_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpClientKeyExchange::_internal_mutable_a() {
  
  return _impl_.a_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpClientKeyExchange::release_a() {
  // @@protoc_insertion_point(field_release:proto.SrpClientKeyExchange.A)
  return _impl_.a_.Release();
}
inline void SrpClientKeyExchange::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  _impl_.a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.a_.IsDefault()) {
    _impl_.a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpClientKeyExchange.A)
}

// bytes iv = 2;
inline void SrpClientKeyExchange::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& SrpClientKeyExchange::iv() const {
  // @@protoc_insertion_point(field_get:proto.SrpClientKeyExchange.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrpClientKeyExchange::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SrpClientKeyExchange.iv)
}
inline std::string* SrpClientKeyExchange::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.SrpClientKeyExchange.iv)
  return _s;
}
inline const std::string& SrpClientKeyExchange::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void SrpClientKeyExchange::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* SrpClientKeyExchange::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* SrpClientKeyExchange::release_iv() {
  // @@protoc_insertion_point(field_release:proto.SrpClientKeyExchange.iv)
  return _impl_.iv_.Release();
}
inline void SrpClientKeyExchange::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SrpClientKeyExchange.iv)
}

// -------------------------------------------------------------------

// SessionChallenge

// .proto.Version version = 1;
inline bool SessionChallenge::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool SessionChallenge::has_version() const {
  return _internal_has_version();
}
inline const ::proto::Version& SessionChallenge::_internal_version() const {
  const ::proto::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Version&>(
      ::proto::_Version_default_instance_);
}
inline const ::proto::Version& SessionChallenge::version() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.version)
  return _internal_version();
}
inline void SessionChallenge::unsafe_arena_set_allocated_version(
    ::proto::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SessionChallenge.version)
}
inline ::proto::Version* SessionChallenge::release_version() {
  
  ::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Version* SessionChallenge::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:proto.SessionChallenge.version)
  
  ::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::proto::Version* SessionChallenge::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Version>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::proto::Version* SessionChallenge::mutable_version() {
  ::proto::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:proto.SessionChallenge.version)
  return _msg;
}
inline void SessionChallenge::set_allocated_version(::proto::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:proto.SessionChallenge.version)
}

// uint32 session_types = 2;
inline void SessionChallenge::clear_session_types() {
  _impl_.session_types_ = 0u;
}
inline uint32_t SessionChallenge::_internal_session_types() const {
  return _impl_.session_types_;
}
inline uint32_t SessionChallenge::session_types() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.session_types)
  return _internal_session_types();
}
inline void SessionChallenge::_internal_set_session_types(uint32_t value) {
  
  _impl_.session_types_ = value;
}
inline void SessionChallenge::set_session_types(uint32_t value) {
  _internal_set_session_types(value);
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.session_types)
}

// uint32 cpu_cores = 3;
inline void SessionChallenge::clear_cpu_cores() {
  _impl_.cpu_cores_ = 0u;
}
inline uint32_t SessionChallenge::_internal_cpu_cores() const {
  return _impl_.cpu_cores_;
}
inline uint32_t SessionChallenge::cpu_cores() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.cpu_cores)
  return _internal_cpu_cores();
}
inline void SessionChallenge::_internal_set_cpu_cores(uint32_t value) {
  
  _impl_.cpu_cores_ = value;
}
inline void SessionChallenge::set_cpu_cores(uint32_t value) {
  _internal_set_cpu_cores(value);
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.cpu_cores)
}

// string os_name = 4;
inline void SessionChallenge::clear_os_name() {
  _impl_.os_name_.ClearToEmpty();
}
inline const std::string& SessionChallenge::os_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.os_name)
  return _internal_os_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionChallenge::set_os_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.os_name)
}
inline std::string* SessionChallenge::mutable_os_name() {
  std::string* _s = _internal_mutable_os_name();
  // @@protoc_insertion_point(field_mutable:proto.SessionChallenge.os_name)
  return _s;
}
inline const std::string& SessionChallenge::_internal_os_name() const {
  return _impl_.os_name_.Get();
}
inline void SessionChallenge::_internal_set_os_name(const std::string& value) {
  
  _impl_.os_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionChallenge::_internal_mutable_os_name() {
  
  return _impl_.os_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionChallenge::release_os_name() {
  // @@protoc_insertion_point(field_release:proto.SessionChallenge.os_name)
  return _impl_.os_name_.Release();
}
inline void SessionChallenge::set_allocated_os_name(std::string* os_name) {
  if (os_name != nullptr) {
    
  } else {
    
  }
  _impl_.os_name_.SetAllocated(os_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_name_.IsDefault()) {
    _impl_.os_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SessionChallenge.os_name)
}

// string computer_name = 5;
inline void SessionChallenge::clear_computer_name() {
  _impl_.computer_name_.ClearToEmpty();
}
inline const std::string& SessionChallenge::computer_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.computer_name)
  return _internal_computer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionChallenge::set_computer_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.computer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.computer_name)
}
inline std::string* SessionChallenge::mutable_computer_name() {
  std::string* _s = _internal_mutable_computer_name();
  // @@protoc_insertion_point(field_mutable:proto.SessionChallenge.computer_name)
  return _s;
}
inline const std::string& SessionChallenge::_internal_computer_name() const {
  return _impl_.computer_name_.Get();
}
inline void SessionChallenge::_internal_set_computer_name(const std::string& value) {
  
  _impl_.computer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionChallenge::_internal_mutable_computer_name() {
  
  return _impl_.computer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionChallenge::release_computer_name() {
  // @@protoc_insertion_point(field_release:proto.SessionChallenge.computer_name)
  return _impl_.computer_name_.Release();
}
inline void SessionChallenge::set_allocated_computer_name(std::string* computer_name) {
  if (computer_name != nullptr) {
    
  } else {
    
  }
  _impl_.computer_name_.SetAllocated(computer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SessionChallenge.computer_name)
}

// -------------------------------------------------------------------

// SessionResponse

// .proto.Version version = 1;
inline bool SessionResponse::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool SessionResponse::has_version() const {
  return _internal_has_version();
}
inline const ::proto::Version& SessionResponse::_internal_version() const {
  const ::proto::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Version&>(
      ::proto::_Version_default_instance_);
}
inline const ::proto::Version& SessionResponse::version() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.version)
  return _internal_version();
}
inline void SessionResponse::unsafe_arena_set_allocated_version(
    ::proto::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SessionResponse.version)
}
inline ::proto::Version* SessionResponse::release_version() {
  
  ::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Version* SessionResponse::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:proto.SessionResponse.version)
  
  ::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::proto::Version* SessionResponse::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Version>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::proto::Version* SessionResponse::mutable_version() {
  ::proto::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:proto.SessionResponse.version)
  return _msg;
}
inline void SessionResponse::set_allocated_version(::proto::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:proto.SessionResponse.version)
}

// uint32 session_type = 2;
inline void SessionResponse::clear_session_type() {
  _impl_.session_type_ = 0u;
}
inline uint32_t SessionResponse::_internal_session_type() const {
  return _impl_.session_type_;
}
inline uint32_t SessionResponse::session_type() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.session_type)
  return _internal_session_type();
}
inline void SessionResponse::_internal_set_session_type(uint32_t value) {
  
  _impl_.session_type_ = value;
}
inline void SessionResponse::set_session_type(uint32_t value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:proto.SessionResponse.session_type)
}

// uint32 cpu_cores = 3;
inline void SessionResponse::clear_cpu_cores() {
  _impl_.cpu_cores_ = 0u;
}
inline uint32_t SessionResponse::_internal_cpu_cores() const {
  return _impl_.cpu_cores_;
}
inline uint32_t SessionResponse::cpu_cores() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.cpu_cores)
  return _internal_cpu_cores();
}
inline void SessionResponse::_internal_set_cpu_cores(uint32_t value) {
  
  _impl_.cpu_cores_ = value;
}
inline void SessionResponse::set_cpu_cores(uint32_t value) {
  _internal_set_cpu_cores(value);
  // @@protoc_insertion_point(field_set:proto.SessionResponse.cpu_cores)
}

// string os_name = 4;
inline void SessionResponse::clear_os_name() {
  _impl_.os_name_.ClearToEmpty();
}
inline const std::string& SessionResponse::os_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.os_name)
  return _internal_os_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionResponse::set_os_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SessionResponse.os_name)
}
inline std::string* SessionResponse::mutable_os_name() {
  std::string* _s = _internal_mutable_os_name();
  // @@protoc_insertion_point(field_mutable:proto.SessionResponse.os_name)
  return _s;
}
inline const std::string& SessionResponse::_internal_os_name() const {
  return _impl_.os_name_.Get();
}
inline void SessionResponse::_internal_set_os_name(const std::string& value) {
  
  _impl_.os_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionResponse::_internal_mutable_os_name() {
  
  return _impl_.os_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionResponse::release_os_name() {
  // @@protoc_insertion_point(field_release:proto.SessionResponse.os_name)
  return _impl_.os_name_.Release();
}
inline void SessionResponse::set_allocated_os_name(std::string* os_name) {
  if (os_name != nullptr) {
    
  } else {
    
  }
  _impl_.os_name_.SetAllocated(os_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_name_.IsDefault()) {
    _impl_.os_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SessionResponse.os_name)
}

// string computer_name = 5;
inline void SessionResponse::clear_computer_name() {
  _impl_.computer_name_.ClearToEmpty();
}
inline const std::string& SessionResponse::computer_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.computer_name)
  return _internal_computer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionResponse::set_computer_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.computer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SessionResponse.computer_name)
}
inline std::string* SessionResponse::mutable_computer_name() {
  std::string* _s = _internal_mutable_computer_name();
  // @@protoc_insertion_point(field_mutable:proto.SessionResponse.computer_name)
  return _s;
}
inline const std::string& SessionResponse::_internal_computer_name() const {
  return _impl_.computer_name_.Get();
}
inline void SessionResponse::_internal_set_computer_name(const std::string& value) {
  
  _impl_.computer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionResponse::_internal_mutable_computer_name() {
  
  return _impl_.computer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionResponse::release_computer_name() {
  // @@protoc_insertion_point(field_release:proto.SessionResponse.computer_name)
  return _impl_.computer_name_.Release();
}
inline void SessionResponse::set_allocated_computer_name(std::string* computer_name) {
  if (computer_name != nullptr) {
    
  } else {
    
  }
  _impl_.computer_name_.SetAllocated(computer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.computer_name_.IsDefault()) {
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SessionResponse.computer_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::Identify> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::Encryption> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_key_5fexchange_2eproto
