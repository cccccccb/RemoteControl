// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_system_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_system_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_system_5finfo_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
namespace system_info {
class Applications;
struct ApplicationsDefaultTypeInternal;
extern ApplicationsDefaultTypeInternal _Applications_default_instance_;
class Applications_Application;
struct Applications_ApplicationDefaultTypeInternal;
extern Applications_ApplicationDefaultTypeInternal _Applications_Application_default_instance_;
class Bios;
struct BiosDefaultTypeInternal;
extern BiosDefaultTypeInternal _Bios_default_instance_;
class Computer;
struct ComputerDefaultTypeInternal;
extern ComputerDefaultTypeInternal _Computer_default_instance_;
class Connections;
struct ConnectionsDefaultTypeInternal;
extern ConnectionsDefaultTypeInternal _Connections_default_instance_;
class Connections_Connection;
struct Connections_ConnectionDefaultTypeInternal;
extern Connections_ConnectionDefaultTypeInternal _Connections_Connection_default_instance_;
class Drivers;
struct DriversDefaultTypeInternal;
extern DriversDefaultTypeInternal _Drivers_default_instance_;
class Drivers_Driver;
struct Drivers_DriverDefaultTypeInternal;
extern Drivers_DriverDefaultTypeInternal _Drivers_Driver_default_instance_;
class EnvironmentVariables;
struct EnvironmentVariablesDefaultTypeInternal;
extern EnvironmentVariablesDefaultTypeInternal _EnvironmentVariables_default_instance_;
class EnvironmentVariables_Variable;
struct EnvironmentVariables_VariableDefaultTypeInternal;
extern EnvironmentVariables_VariableDefaultTypeInternal _EnvironmentVariables_Variable_default_instance_;
class EventLogs;
struct EventLogsDefaultTypeInternal;
extern EventLogsDefaultTypeInternal _EventLogs_default_instance_;
class EventLogsData;
struct EventLogsDataDefaultTypeInternal;
extern EventLogsDataDefaultTypeInternal _EventLogsData_default_instance_;
class EventLogs_Event;
struct EventLogs_EventDefaultTypeInternal;
extern EventLogs_EventDefaultTypeInternal _EventLogs_Event_default_instance_;
class Licenses;
struct LicensesDefaultTypeInternal;
extern LicensesDefaultTypeInternal _Licenses_default_instance_;
class Licenses_License;
struct Licenses_LicenseDefaultTypeInternal;
extern Licenses_LicenseDefaultTypeInternal _Licenses_License_default_instance_;
class Licenses_License_Field;
struct Licenses_License_FieldDefaultTypeInternal;
extern Licenses_License_FieldDefaultTypeInternal _Licenses_License_Field_default_instance_;
class LocalUserGroups;
struct LocalUserGroupsDefaultTypeInternal;
extern LocalUserGroupsDefaultTypeInternal _LocalUserGroups_default_instance_;
class LocalUserGroups_LocalUserGroup;
struct LocalUserGroups_LocalUserGroupDefaultTypeInternal;
extern LocalUserGroups_LocalUserGroupDefaultTypeInternal _LocalUserGroups_LocalUserGroup_default_instance_;
class LocalUsers;
struct LocalUsersDefaultTypeInternal;
extern LocalUsersDefaultTypeInternal _LocalUsers_default_instance_;
class LocalUsers_LocalUser;
struct LocalUsers_LocalUserDefaultTypeInternal;
extern LocalUsers_LocalUserDefaultTypeInternal _LocalUsers_LocalUser_default_instance_;
class LocalUsers_LocalUser_LocalUserGroup;
struct LocalUsers_LocalUser_LocalUserGroupDefaultTypeInternal;
extern LocalUsers_LocalUser_LocalUserGroupDefaultTypeInternal _LocalUsers_LocalUser_LocalUserGroup_default_instance_;
class LogicalDrives;
struct LogicalDrivesDefaultTypeInternal;
extern LogicalDrivesDefaultTypeInternal _LogicalDrives_default_instance_;
class LogicalDrives_Drive;
struct LogicalDrives_DriveDefaultTypeInternal;
extern LogicalDrives_DriveDefaultTypeInternal _LogicalDrives_Drive_default_instance_;
class Memory;
struct MemoryDefaultTypeInternal;
extern MemoryDefaultTypeInternal _Memory_default_instance_;
class Memory_Module;
struct Memory_ModuleDefaultTypeInternal;
extern Memory_ModuleDefaultTypeInternal _Memory_Module_default_instance_;
class Monitors;
struct MonitorsDefaultTypeInternal;
extern MonitorsDefaultTypeInternal _Monitors_default_instance_;
class Monitors_Monitor;
struct Monitors_MonitorDefaultTypeInternal;
extern Monitors_MonitorDefaultTypeInternal _Monitors_Monitor_default_instance_;
class Monitors_Monitor_Timing;
struct Monitors_Monitor_TimingDefaultTypeInternal;
extern Monitors_Monitor_TimingDefaultTypeInternal _Monitors_Monitor_Timing_default_instance_;
class Motherboard;
struct MotherboardDefaultTypeInternal;
extern MotherboardDefaultTypeInternal _Motherboard_default_instance_;
class NetworkAdapters;
struct NetworkAdaptersDefaultTypeInternal;
extern NetworkAdaptersDefaultTypeInternal _NetworkAdapters_default_instance_;
class NetworkAdapters_Adapter;
struct NetworkAdapters_AdapterDefaultTypeInternal;
extern NetworkAdapters_AdapterDefaultTypeInternal _NetworkAdapters_Adapter_default_instance_;
class NetworkAdapters_Adapter_Address;
struct NetworkAdapters_Adapter_AddressDefaultTypeInternal;
extern NetworkAdapters_Adapter_AddressDefaultTypeInternal _NetworkAdapters_Adapter_Address_default_instance_;
class NetworkShares;
struct NetworkSharesDefaultTypeInternal;
extern NetworkSharesDefaultTypeInternal _NetworkShares_default_instance_;
class NetworkShares_Share;
struct NetworkShares_ShareDefaultTypeInternal;
extern NetworkShares_ShareDefaultTypeInternal _NetworkShares_Share_default_instance_;
class OpenFiles;
struct OpenFilesDefaultTypeInternal;
extern OpenFilesDefaultTypeInternal _OpenFiles_default_instance_;
class OpenFiles_OpenFile;
struct OpenFiles_OpenFileDefaultTypeInternal;
extern OpenFiles_OpenFileDefaultTypeInternal _OpenFiles_OpenFile_default_instance_;
class OperatingSystem;
struct OperatingSystemDefaultTypeInternal;
extern OperatingSystemDefaultTypeInternal _OperatingSystem_default_instance_;
class PowerOptions;
struct PowerOptionsDefaultTypeInternal;
extern PowerOptionsDefaultTypeInternal _PowerOptions_default_instance_;
class PowerOptions_Battery;
struct PowerOptions_BatteryDefaultTypeInternal;
extern PowerOptions_BatteryDefaultTypeInternal _PowerOptions_Battery_default_instance_;
class Printers;
struct PrintersDefaultTypeInternal;
extern PrintersDefaultTypeInternal _Printers_default_instance_;
class Printers_Printer;
struct Printers_PrinterDefaultTypeInternal;
extern Printers_PrinterDefaultTypeInternal _Printers_Printer_default_instance_;
class Processes;
struct ProcessesDefaultTypeInternal;
extern ProcessesDefaultTypeInternal _Processes_default_instance_;
class Processes_Process;
struct Processes_ProcessDefaultTypeInternal;
extern Processes_ProcessDefaultTypeInternal _Processes_Process_default_instance_;
class Processor;
struct ProcessorDefaultTypeInternal;
extern ProcessorDefaultTypeInternal _Processor_default_instance_;
class Routes;
struct RoutesDefaultTypeInternal;
extern RoutesDefaultTypeInternal _Routes_default_instance_;
class Routes_Route;
struct Routes_RouteDefaultTypeInternal;
extern Routes_RouteDefaultTypeInternal _Routes_Route_default_instance_;
class Services;
struct ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Services_Service;
struct Services_ServiceDefaultTypeInternal;
extern Services_ServiceDefaultTypeInternal _Services_Service_default_instance_;
class SystemInfo;
struct SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
class SystemInfoFooter;
struct SystemInfoFooterDefaultTypeInternal;
extern SystemInfoFooterDefaultTypeInternal _SystemInfoFooter_default_instance_;
class SystemInfoRequest;
struct SystemInfoRequestDefaultTypeInternal;
extern SystemInfoRequestDefaultTypeInternal _SystemInfoRequest_default_instance_;
class VideoAdapters;
struct VideoAdaptersDefaultTypeInternal;
extern VideoAdaptersDefaultTypeInternal _VideoAdapters_default_instance_;
class VideoAdapters_Adapter;
struct VideoAdapters_AdapterDefaultTypeInternal;
extern VideoAdapters_AdapterDefaultTypeInternal _VideoAdapters_Adapter_default_instance_;
class WindowsDevices;
struct WindowsDevicesDefaultTypeInternal;
extern WindowsDevicesDefaultTypeInternal _WindowsDevices_default_instance_;
class WindowsDevices_Device;
struct WindowsDevices_DeviceDefaultTypeInternal;
extern WindowsDevices_DeviceDefaultTypeInternal _WindowsDevices_Device_default_instance_;
}  // namespace system_info
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::system_info::Applications* Arena::CreateMaybeMessage<::proto::system_info::Applications>(Arena*);
template<> ::proto::system_info::Applications_Application* Arena::CreateMaybeMessage<::proto::system_info::Applications_Application>(Arena*);
template<> ::proto::system_info::Bios* Arena::CreateMaybeMessage<::proto::system_info::Bios>(Arena*);
template<> ::proto::system_info::Computer* Arena::CreateMaybeMessage<::proto::system_info::Computer>(Arena*);
template<> ::proto::system_info::Connections* Arena::CreateMaybeMessage<::proto::system_info::Connections>(Arena*);
template<> ::proto::system_info::Connections_Connection* Arena::CreateMaybeMessage<::proto::system_info::Connections_Connection>(Arena*);
template<> ::proto::system_info::Drivers* Arena::CreateMaybeMessage<::proto::system_info::Drivers>(Arena*);
template<> ::proto::system_info::Drivers_Driver* Arena::CreateMaybeMessage<::proto::system_info::Drivers_Driver>(Arena*);
template<> ::proto::system_info::EnvironmentVariables* Arena::CreateMaybeMessage<::proto::system_info::EnvironmentVariables>(Arena*);
template<> ::proto::system_info::EnvironmentVariables_Variable* Arena::CreateMaybeMessage<::proto::system_info::EnvironmentVariables_Variable>(Arena*);
template<> ::proto::system_info::EventLogs* Arena::CreateMaybeMessage<::proto::system_info::EventLogs>(Arena*);
template<> ::proto::system_info::EventLogsData* Arena::CreateMaybeMessage<::proto::system_info::EventLogsData>(Arena*);
template<> ::proto::system_info::EventLogs_Event* Arena::CreateMaybeMessage<::proto::system_info::EventLogs_Event>(Arena*);
template<> ::proto::system_info::Licenses* Arena::CreateMaybeMessage<::proto::system_info::Licenses>(Arena*);
template<> ::proto::system_info::Licenses_License* Arena::CreateMaybeMessage<::proto::system_info::Licenses_License>(Arena*);
template<> ::proto::system_info::Licenses_License_Field* Arena::CreateMaybeMessage<::proto::system_info::Licenses_License_Field>(Arena*);
template<> ::proto::system_info::LocalUserGroups* Arena::CreateMaybeMessage<::proto::system_info::LocalUserGroups>(Arena*);
template<> ::proto::system_info::LocalUserGroups_LocalUserGroup* Arena::CreateMaybeMessage<::proto::system_info::LocalUserGroups_LocalUserGroup>(Arena*);
template<> ::proto::system_info::LocalUsers* Arena::CreateMaybeMessage<::proto::system_info::LocalUsers>(Arena*);
template<> ::proto::system_info::LocalUsers_LocalUser* Arena::CreateMaybeMessage<::proto::system_info::LocalUsers_LocalUser>(Arena*);
template<> ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* Arena::CreateMaybeMessage<::proto::system_info::LocalUsers_LocalUser_LocalUserGroup>(Arena*);
template<> ::proto::system_info::LogicalDrives* Arena::CreateMaybeMessage<::proto::system_info::LogicalDrives>(Arena*);
template<> ::proto::system_info::LogicalDrives_Drive* Arena::CreateMaybeMessage<::proto::system_info::LogicalDrives_Drive>(Arena*);
template<> ::proto::system_info::Memory* Arena::CreateMaybeMessage<::proto::system_info::Memory>(Arena*);
template<> ::proto::system_info::Memory_Module* Arena::CreateMaybeMessage<::proto::system_info::Memory_Module>(Arena*);
template<> ::proto::system_info::Monitors* Arena::CreateMaybeMessage<::proto::system_info::Monitors>(Arena*);
template<> ::proto::system_info::Monitors_Monitor* Arena::CreateMaybeMessage<::proto::system_info::Monitors_Monitor>(Arena*);
template<> ::proto::system_info::Monitors_Monitor_Timing* Arena::CreateMaybeMessage<::proto::system_info::Monitors_Monitor_Timing>(Arena*);
template<> ::proto::system_info::Motherboard* Arena::CreateMaybeMessage<::proto::system_info::Motherboard>(Arena*);
template<> ::proto::system_info::NetworkAdapters* Arena::CreateMaybeMessage<::proto::system_info::NetworkAdapters>(Arena*);
template<> ::proto::system_info::NetworkAdapters_Adapter* Arena::CreateMaybeMessage<::proto::system_info::NetworkAdapters_Adapter>(Arena*);
template<> ::proto::system_info::NetworkAdapters_Adapter_Address* Arena::CreateMaybeMessage<::proto::system_info::NetworkAdapters_Adapter_Address>(Arena*);
template<> ::proto::system_info::NetworkShares* Arena::CreateMaybeMessage<::proto::system_info::NetworkShares>(Arena*);
template<> ::proto::system_info::NetworkShares_Share* Arena::CreateMaybeMessage<::proto::system_info::NetworkShares_Share>(Arena*);
template<> ::proto::system_info::OpenFiles* Arena::CreateMaybeMessage<::proto::system_info::OpenFiles>(Arena*);
template<> ::proto::system_info::OpenFiles_OpenFile* Arena::CreateMaybeMessage<::proto::system_info::OpenFiles_OpenFile>(Arena*);
template<> ::proto::system_info::OperatingSystem* Arena::CreateMaybeMessage<::proto::system_info::OperatingSystem>(Arena*);
template<> ::proto::system_info::PowerOptions* Arena::CreateMaybeMessage<::proto::system_info::PowerOptions>(Arena*);
template<> ::proto::system_info::PowerOptions_Battery* Arena::CreateMaybeMessage<::proto::system_info::PowerOptions_Battery>(Arena*);
template<> ::proto::system_info::Printers* Arena::CreateMaybeMessage<::proto::system_info::Printers>(Arena*);
template<> ::proto::system_info::Printers_Printer* Arena::CreateMaybeMessage<::proto::system_info::Printers_Printer>(Arena*);
template<> ::proto::system_info::Processes* Arena::CreateMaybeMessage<::proto::system_info::Processes>(Arena*);
template<> ::proto::system_info::Processes_Process* Arena::CreateMaybeMessage<::proto::system_info::Processes_Process>(Arena*);
template<> ::proto::system_info::Processor* Arena::CreateMaybeMessage<::proto::system_info::Processor>(Arena*);
template<> ::proto::system_info::Routes* Arena::CreateMaybeMessage<::proto::system_info::Routes>(Arena*);
template<> ::proto::system_info::Routes_Route* Arena::CreateMaybeMessage<::proto::system_info::Routes_Route>(Arena*);
template<> ::proto::system_info::Services* Arena::CreateMaybeMessage<::proto::system_info::Services>(Arena*);
template<> ::proto::system_info::Services_Service* Arena::CreateMaybeMessage<::proto::system_info::Services_Service>(Arena*);
template<> ::proto::system_info::SystemInfo* Arena::CreateMaybeMessage<::proto::system_info::SystemInfo>(Arena*);
template<> ::proto::system_info::SystemInfoFooter* Arena::CreateMaybeMessage<::proto::system_info::SystemInfoFooter>(Arena*);
template<> ::proto::system_info::SystemInfoRequest* Arena::CreateMaybeMessage<::proto::system_info::SystemInfoRequest>(Arena*);
template<> ::proto::system_info::VideoAdapters* Arena::CreateMaybeMessage<::proto::system_info::VideoAdapters>(Arena*);
template<> ::proto::system_info::VideoAdapters_Adapter* Arena::CreateMaybeMessage<::proto::system_info::VideoAdapters_Adapter>(Arena*);
template<> ::proto::system_info::WindowsDevices* Arena::CreateMaybeMessage<::proto::system_info::WindowsDevices>(Arena*);
template<> ::proto::system_info::WindowsDevices_Device* Arena::CreateMaybeMessage<::proto::system_info::WindowsDevices_Device>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace system_info {

enum Monitors_Monitor_InputSignalType : int {
  Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN = 0,
  Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_ANALOG = 1,
  Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL = 2,
  Monitors_Monitor_InputSignalType_Monitors_Monitor_InputSignalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Monitors_Monitor_InputSignalType_Monitors_Monitor_InputSignalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Monitors_Monitor_InputSignalType_IsValid(int value);
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor_InputSignalType_InputSignalType_MIN = Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN;
constexpr Monitors_Monitor_InputSignalType Monitors_Monitor_InputSignalType_InputSignalType_MAX = Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL;
constexpr int Monitors_Monitor_InputSignalType_InputSignalType_ARRAYSIZE = Monitors_Monitor_InputSignalType_InputSignalType_MAX + 1;

const std::string& Monitors_Monitor_InputSignalType_Name(Monitors_Monitor_InputSignalType value);
template<typename T>
inline const std::string& Monitors_Monitor_InputSignalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Monitors_Monitor_InputSignalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Monitors_Monitor_InputSignalType_Name.");
  return Monitors_Monitor_InputSignalType_Name(static_cast<Monitors_Monitor_InputSignalType>(enum_t_value));
}
bool Monitors_Monitor_InputSignalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Monitors_Monitor_InputSignalType* value);
enum PowerOptions_Battery_State : int {
  PowerOptions_Battery_State_STATE_UNKNOWN = 0,
  PowerOptions_Battery_State_STATE_CHARGING = 1,
  PowerOptions_Battery_State_STATE_CRITICAL = 2,
  PowerOptions_Battery_State_STATE_DISCHARGING = 4,
  PowerOptions_Battery_State_STATE_POWER_ONLINE = 8,
  PowerOptions_Battery_State_PowerOptions_Battery_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerOptions_Battery_State_PowerOptions_Battery_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerOptions_Battery_State_IsValid(int value);
constexpr PowerOptions_Battery_State PowerOptions_Battery_State_State_MIN = PowerOptions_Battery_State_STATE_UNKNOWN;
constexpr PowerOptions_Battery_State PowerOptions_Battery_State_State_MAX = PowerOptions_Battery_State_STATE_POWER_ONLINE;
constexpr int PowerOptions_Battery_State_State_ARRAYSIZE = PowerOptions_Battery_State_State_MAX + 1;

const std::string& PowerOptions_Battery_State_Name(PowerOptions_Battery_State value);
template<typename T>
inline const std::string& PowerOptions_Battery_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerOptions_Battery_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerOptions_Battery_State_Name.");
  return PowerOptions_Battery_State_Name(static_cast<PowerOptions_Battery_State>(enum_t_value));
}
bool PowerOptions_Battery_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerOptions_Battery_State* value);
enum PowerOptions_PowerSource : int {
  PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN = 0,
  PowerOptions_PowerSource_POWER_SOURCE_DC_BATTERY = 1,
  PowerOptions_PowerSource_POWER_SOURCE_AC_LINE = 2,
  PowerOptions_PowerSource_PowerOptions_PowerSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerOptions_PowerSource_PowerOptions_PowerSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerOptions_PowerSource_IsValid(int value);
constexpr PowerOptions_PowerSource PowerOptions_PowerSource_PowerSource_MIN = PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN;
constexpr PowerOptions_PowerSource PowerOptions_PowerSource_PowerSource_MAX = PowerOptions_PowerSource_POWER_SOURCE_AC_LINE;
constexpr int PowerOptions_PowerSource_PowerSource_ARRAYSIZE = PowerOptions_PowerSource_PowerSource_MAX + 1;

const std::string& PowerOptions_PowerSource_Name(PowerOptions_PowerSource value);
template<typename T>
inline const std::string& PowerOptions_PowerSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerOptions_PowerSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerOptions_PowerSource_Name.");
  return PowerOptions_PowerSource_Name(static_cast<PowerOptions_PowerSource>(enum_t_value));
}
bool PowerOptions_PowerSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerOptions_PowerSource* value);
enum PowerOptions_BatteryStatus : int {
  PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN = 0,
  PowerOptions_BatteryStatus_BATTERY_STATUS_HIGH = 1,
  PowerOptions_BatteryStatus_BATTERY_STATUS_LOW = 2,
  PowerOptions_BatteryStatus_BATTERY_STATUS_CRITICAL = 3,
  PowerOptions_BatteryStatus_BATTERY_STATUS_CHARGING = 4,
  PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY = 5,
  PowerOptions_BatteryStatus_PowerOptions_BatteryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PowerOptions_BatteryStatus_PowerOptions_BatteryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PowerOptions_BatteryStatus_IsValid(int value);
constexpr PowerOptions_BatteryStatus PowerOptions_BatteryStatus_BatteryStatus_MIN = PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN;
constexpr PowerOptions_BatteryStatus PowerOptions_BatteryStatus_BatteryStatus_MAX = PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY;
constexpr int PowerOptions_BatteryStatus_BatteryStatus_ARRAYSIZE = PowerOptions_BatteryStatus_BatteryStatus_MAX + 1;

const std::string& PowerOptions_BatteryStatus_Name(PowerOptions_BatteryStatus value);
template<typename T>
inline const std::string& PowerOptions_BatteryStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerOptions_BatteryStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerOptions_BatteryStatus_Name.");
  return PowerOptions_BatteryStatus_Name(static_cast<PowerOptions_BatteryStatus>(enum_t_value));
}
bool PowerOptions_BatteryStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerOptions_BatteryStatus* value);
enum Drivers_Driver_Status : int {
  Drivers_Driver_Status_STATUS_UNKNOWN = 0,
  Drivers_Driver_Status_STATUS_CONTINUE_PENDING = 1,
  Drivers_Driver_Status_STATUS_PAUSE_PENDING = 2,
  Drivers_Driver_Status_STATUS_PAUSED = 3,
  Drivers_Driver_Status_STATUS_RUNNING = 4,
  Drivers_Driver_Status_STATUS_START_PENDING = 5,
  Drivers_Driver_Status_STATUS_STOP_PENDING = 6,
  Drivers_Driver_Status_STATUS_STOPPED = 7,
  Drivers_Driver_Status_Drivers_Driver_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Drivers_Driver_Status_Drivers_Driver_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Drivers_Driver_Status_IsValid(int value);
constexpr Drivers_Driver_Status Drivers_Driver_Status_Status_MIN = Drivers_Driver_Status_STATUS_UNKNOWN;
constexpr Drivers_Driver_Status Drivers_Driver_Status_Status_MAX = Drivers_Driver_Status_STATUS_STOPPED;
constexpr int Drivers_Driver_Status_Status_ARRAYSIZE = Drivers_Driver_Status_Status_MAX + 1;

const std::string& Drivers_Driver_Status_Name(Drivers_Driver_Status value);
template<typename T>
inline const std::string& Drivers_Driver_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Drivers_Driver_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Drivers_Driver_Status_Name.");
  return Drivers_Driver_Status_Name(static_cast<Drivers_Driver_Status>(enum_t_value));
}
bool Drivers_Driver_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Drivers_Driver_Status* value);
enum Drivers_Driver_StartupType : int {
  Drivers_Driver_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Drivers_Driver_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Drivers_Driver_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Drivers_Driver_StartupType_STARTUP_TYPE_DISABLED = 3,
  Drivers_Driver_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Drivers_Driver_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Drivers_Driver_StartupType_Drivers_Driver_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Drivers_Driver_StartupType_Drivers_Driver_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Drivers_Driver_StartupType_IsValid(int value);
constexpr Drivers_Driver_StartupType Drivers_Driver_StartupType_StartupType_MIN = Drivers_Driver_StartupType_STARTUP_TYPE_UNKNOWN;
constexpr Drivers_Driver_StartupType Drivers_Driver_StartupType_StartupType_MAX = Drivers_Driver_StartupType_STARTUP_TYPE_SYSTEM_START;
constexpr int Drivers_Driver_StartupType_StartupType_ARRAYSIZE = Drivers_Driver_StartupType_StartupType_MAX + 1;

const std::string& Drivers_Driver_StartupType_Name(Drivers_Driver_StartupType value);
template<typename T>
inline const std::string& Drivers_Driver_StartupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Drivers_Driver_StartupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Drivers_Driver_StartupType_Name.");
  return Drivers_Driver_StartupType_Name(static_cast<Drivers_Driver_StartupType>(enum_t_value));
}
bool Drivers_Driver_StartupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Drivers_Driver_StartupType* value);
enum Services_Service_Status : int {
  Services_Service_Status_STATUS_UNKNOWN = 0,
  Services_Service_Status_STATUS_CONTINUE_PENDING = 1,
  Services_Service_Status_STATUS_PAUSE_PENDING = 2,
  Services_Service_Status_STATUS_PAUSED = 3,
  Services_Service_Status_STATUS_RUNNING = 4,
  Services_Service_Status_STATUS_START_PENDING = 5,
  Services_Service_Status_STATUS_STOP_PENDING = 6,
  Services_Service_Status_STATUS_STOPPED = 7,
  Services_Service_Status_Services_Service_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Services_Service_Status_Services_Service_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Services_Service_Status_IsValid(int value);
constexpr Services_Service_Status Services_Service_Status_Status_MIN = Services_Service_Status_STATUS_UNKNOWN;
constexpr Services_Service_Status Services_Service_Status_Status_MAX = Services_Service_Status_STATUS_STOPPED;
constexpr int Services_Service_Status_Status_ARRAYSIZE = Services_Service_Status_Status_MAX + 1;

const std::string& Services_Service_Status_Name(Services_Service_Status value);
template<typename T>
inline const std::string& Services_Service_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Services_Service_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Services_Service_Status_Name.");
  return Services_Service_Status_Name(static_cast<Services_Service_Status>(enum_t_value));
}
bool Services_Service_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Services_Service_Status* value);
enum Services_Service_StartupType : int {
  Services_Service_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Services_Service_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Services_Service_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Services_Service_StartupType_STARTUP_TYPE_DISABLED = 3,
  Services_Service_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Services_Service_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Services_Service_StartupType_Services_Service_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Services_Service_StartupType_Services_Service_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Services_Service_StartupType_IsValid(int value);
constexpr Services_Service_StartupType Services_Service_StartupType_StartupType_MIN = Services_Service_StartupType_STARTUP_TYPE_UNKNOWN;
constexpr Services_Service_StartupType Services_Service_StartupType_StartupType_MAX = Services_Service_StartupType_STARTUP_TYPE_SYSTEM_START;
constexpr int Services_Service_StartupType_StartupType_ARRAYSIZE = Services_Service_StartupType_StartupType_MAX + 1;

const std::string& Services_Service_StartupType_Name(Services_Service_StartupType value);
template<typename T>
inline const std::string& Services_Service_StartupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Services_Service_StartupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Services_Service_StartupType_Name.");
  return Services_Service_StartupType_Name(static_cast<Services_Service_StartupType>(enum_t_value));
}
bool Services_Service_StartupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Services_Service_StartupType* value);
enum EventLogs_Event_Type : int {
  EventLogs_Event_Type_TYPE_UNKNOWN = 0,
  EventLogs_Event_Type_TYPE_APPLICATION = 1,
  EventLogs_Event_Type_TYPE_SECURITY = 2,
  EventLogs_Event_Type_TYPE_SYSTEM = 3,
  EventLogs_Event_Type_EventLogs_Event_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventLogs_Event_Type_EventLogs_Event_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventLogs_Event_Type_IsValid(int value);
constexpr EventLogs_Event_Type EventLogs_Event_Type_Type_MIN = EventLogs_Event_Type_TYPE_UNKNOWN;
constexpr EventLogs_Event_Type EventLogs_Event_Type_Type_MAX = EventLogs_Event_Type_TYPE_SYSTEM;
constexpr int EventLogs_Event_Type_Type_ARRAYSIZE = EventLogs_Event_Type_Type_MAX + 1;

const std::string& EventLogs_Event_Type_Name(EventLogs_Event_Type value);
template<typename T>
inline const std::string& EventLogs_Event_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventLogs_Event_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventLogs_Event_Type_Name.");
  return EventLogs_Event_Type_Name(static_cast<EventLogs_Event_Type>(enum_t_value));
}
bool EventLogs_Event_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventLogs_Event_Type* value);
enum EventLogs_Event_Level : int {
  EventLogs_Event_Level_LEVEL_UNKNOWN = 0,
  EventLogs_Event_Level_LEVEL_SUCCESS = 1,
  EventLogs_Event_Level_LEVEL_INFORMATION = 2,
  EventLogs_Event_Level_LEVEL_WARNING = 4,
  EventLogs_Event_Level_LEVEL_ERROR = 8,
  EventLogs_Event_Level_LEVEL_AUDIT_SUCCESS = 16,
  EventLogs_Event_Level_LEVEL_AUDIT_FAILURE = 32,
  EventLogs_Event_Level_EventLogs_Event_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventLogs_Event_Level_EventLogs_Event_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventLogs_Event_Level_IsValid(int value);
constexpr EventLogs_Event_Level EventLogs_Event_Level_Level_MIN = EventLogs_Event_Level_LEVEL_UNKNOWN;
constexpr EventLogs_Event_Level EventLogs_Event_Level_Level_MAX = EventLogs_Event_Level_LEVEL_AUDIT_FAILURE;
constexpr int EventLogs_Event_Level_Level_ARRAYSIZE = EventLogs_Event_Level_Level_MAX + 1;

const std::string& EventLogs_Event_Level_Name(EventLogs_Event_Level value);
template<typename T>
inline const std::string& EventLogs_Event_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventLogs_Event_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventLogs_Event_Level_Name.");
  return EventLogs_Event_Level_Name(static_cast<EventLogs_Event_Level>(enum_t_value));
}
bool EventLogs_Event_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventLogs_Event_Level* value);
enum Licenses_License_Field_Type : int {
  Licenses_License_Field_Type_TYPE_UNKNOWN = 0,
  Licenses_License_Field_Type_TYPE_OWNER = 2,
  Licenses_License_Field_Type_TYPE_ORGANIZATION = 3,
  Licenses_License_Field_Type_TYPE_PRODUCT_KEY = 4,
  Licenses_License_Field_Type_TYPE_PRODUCT_ID = 5,
  Licenses_License_Field_Type_TYPE_LICENSE_VERSION = 6,
  Licenses_License_Field_Type_TYPE_LICENSE_TYPE = 7,
  Licenses_License_Field_Type_Licenses_License_Field_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Licenses_License_Field_Type_Licenses_License_Field_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Licenses_License_Field_Type_IsValid(int value);
constexpr Licenses_License_Field_Type Licenses_License_Field_Type_Type_MIN = Licenses_License_Field_Type_TYPE_UNKNOWN;
constexpr Licenses_License_Field_Type Licenses_License_Field_Type_Type_MAX = Licenses_License_Field_Type_TYPE_LICENSE_TYPE;
constexpr int Licenses_License_Field_Type_Type_ARRAYSIZE = Licenses_License_Field_Type_Type_MAX + 1;

const std::string& Licenses_License_Field_Type_Name(Licenses_License_Field_Type value);
template<typename T>
inline const std::string& Licenses_License_Field_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Licenses_License_Field_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Licenses_License_Field_Type_Name.");
  return Licenses_License_Field_Type_Name(static_cast<Licenses_License_Field_Type>(enum_t_value));
}
bool Licenses_License_Field_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Licenses_License_Field_Type* value);
// ===================================================================

class Computer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Computer) */ {
 public:
  inline Computer() : Computer(nullptr) {}
  ~Computer() override;
  explicit PROTOBUF_CONSTEXPR Computer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Computer(const Computer& from);
  Computer(Computer&& from) noexcept
    : Computer() {
    *this = ::std::move(from);
  }

  inline Computer& operator=(const Computer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Computer& operator=(Computer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Computer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Computer* internal_default_instance() {
    return reinterpret_cast<const Computer*>(
               &_Computer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Computer& a, Computer& b) {
    a.Swap(&b);
  }
  inline void Swap(Computer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Computer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Computer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Computer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Computer& from);
  void MergeFrom(const Computer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Computer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Computer";
  }
  protected:
  explicit Computer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDomainFieldNumber = 2,
    kWorkgroupFieldNumber = 3,
    kUptimeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string domain = 2;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string workgroup = 3;
  void clear_workgroup();
  const std::string& workgroup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workgroup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workgroup();
  PROTOBUF_NODISCARD std::string* release_workgroup();
  void set_allocated_workgroup(std::string* workgroup);
  private:
  const std::string& _internal_workgroup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workgroup(const std::string& value);
  std::string* _internal_mutable_workgroup();
  public:

  // uint64 uptime = 4;
  void clear_uptime();
  uint64_t uptime() const;
  void set_uptime(uint64_t value);
  private:
  uint64_t _internal_uptime() const;
  void _internal_set_uptime(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Computer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workgroup_;
    uint64_t uptime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class OperatingSystem final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.OperatingSystem) */ {
 public:
  inline OperatingSystem() : OperatingSystem(nullptr) {}
  ~OperatingSystem() override;
  explicit PROTOBUF_CONSTEXPR OperatingSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperatingSystem(const OperatingSystem& from);
  OperatingSystem(OperatingSystem&& from) noexcept
    : OperatingSystem() {
    *this = ::std::move(from);
  }

  inline OperatingSystem& operator=(const OperatingSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatingSystem& operator=(OperatingSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const OperatingSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperatingSystem* internal_default_instance() {
    return reinterpret_cast<const OperatingSystem*>(
               &_OperatingSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OperatingSystem& a, OperatingSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatingSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatingSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperatingSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperatingSystem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OperatingSystem& from);
  void MergeFrom(const OperatingSystem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperatingSystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.OperatingSystem";
  }
  protected:
  explicit OperatingSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kArchFieldNumber = 3,
    kKeyFieldNumber = 4,
    kInstallDateFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string arch = 3;
  void clear_arch();
  const std::string& arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arch();
  PROTOBUF_NODISCARD std::string* release_arch();
  void set_allocated_arch(std::string* arch);
  private:
  const std::string& _internal_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arch(const std::string& value);
  std::string* _internal_mutable_arch();
  public:

  // string key = 4;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int64 install_date = 5;
  void clear_install_date();
  int64_t install_date() const;
  void set_install_date(int64_t value);
  private:
  int64_t _internal_install_date() const;
  void _internal_set_install_date(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.OperatingSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int64_t install_date_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Motherboard final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Motherboard) */ {
 public:
  inline Motherboard() : Motherboard(nullptr) {}
  ~Motherboard() override;
  explicit PROTOBUF_CONSTEXPR Motherboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Motherboard(const Motherboard& from);
  Motherboard(Motherboard&& from) noexcept
    : Motherboard() {
    *this = ::std::move(from);
  }

  inline Motherboard& operator=(const Motherboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Motherboard& operator=(Motherboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Motherboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const Motherboard* internal_default_instance() {
    return reinterpret_cast<const Motherboard*>(
               &_Motherboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Motherboard& a, Motherboard& b) {
    a.Swap(&b);
  }
  inline void Swap(Motherboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Motherboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Motherboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Motherboard>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Motherboard& from);
  void MergeFrom(const Motherboard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Motherboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Motherboard";
  }
  protected:
  explicit Motherboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturerFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string manufacturer = 1;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Motherboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Bios final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Bios) */ {
 public:
  inline Bios() : Bios(nullptr) {}
  ~Bios() override;
  explicit PROTOBUF_CONSTEXPR Bios(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bios(const Bios& from);
  Bios(Bios&& from) noexcept
    : Bios() {
    *this = ::std::move(from);
  }

  inline Bios& operator=(const Bios& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bios& operator=(Bios&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Bios& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bios* internal_default_instance() {
    return reinterpret_cast<const Bios*>(
               &_Bios_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Bios& a, Bios& b) {
    a.Swap(&b);
  }
  inline void Swap(Bios* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bios* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bios* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bios>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Bios& from);
  void MergeFrom(const Bios& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bios* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Bios";
  }
  protected:
  explicit Bios(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 1,
    kVersionFieldNumber = 2,
    kDateFieldNumber = 3,
  };
  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string date = 3;
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Bios)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Processor final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Processor) */ {
 public:
  inline Processor() : Processor(nullptr) {}
  ~Processor() override;
  explicit PROTOBUF_CONSTEXPR Processor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Processor(const Processor& from);
  Processor(Processor&& from) noexcept
    : Processor() {
    *this = ::std::move(from);
  }

  inline Processor& operator=(const Processor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Processor& operator=(Processor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Processor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Processor* internal_default_instance() {
    return reinterpret_cast<const Processor*>(
               &_Processor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Processor& a, Processor& b) {
    a.Swap(&b);
  }
  inline void Swap(Processor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Processor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Processor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Processor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Processor& from);
  void MergeFrom(const Processor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Processor";
  }
  protected:
  explicit Processor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 1,
    kModelFieldNumber = 2,
    kPackagesFieldNumber = 3,
    kCoresFieldNumber = 4,
    kThreadsFieldNumber = 5,
  };
  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // uint32 packages = 3;
  void clear_packages();
  uint32_t packages() const;
  void set_packages(uint32_t value);
  private:
  uint32_t _internal_packages() const;
  void _internal_set_packages(uint32_t value);
  public:

  // uint32 cores = 4;
  void clear_cores();
  uint32_t cores() const;
  void set_cores(uint32_t value);
  private:
  uint32_t _internal_cores() const;
  void _internal_set_cores(uint32_t value);
  public:

  // uint32 threads = 5;
  void clear_threads();
  uint32_t threads() const;
  void set_threads(uint32_t value);
  private:
  uint32_t _internal_threads() const;
  void _internal_set_threads(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Processor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    uint32_t packages_;
    uint32_t cores_;
    uint32_t threads_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Memory_Module final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Memory.Module) */ {
 public:
  inline Memory_Module() : Memory_Module(nullptr) {}
  ~Memory_Module() override;
  explicit PROTOBUF_CONSTEXPR Memory_Module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Memory_Module(const Memory_Module& from);
  Memory_Module(Memory_Module&& from) noexcept
    : Memory_Module() {
    *this = ::std::move(from);
  }

  inline Memory_Module& operator=(const Memory_Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Memory_Module& operator=(Memory_Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Memory_Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const Memory_Module* internal_default_instance() {
    return reinterpret_cast<const Memory_Module*>(
               &_Memory_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Memory_Module& a, Memory_Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Memory_Module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Memory_Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Memory_Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Memory_Module>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Memory_Module& from);
  void MergeFrom(const Memory_Module& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Memory_Module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Memory.Module";
  }
  protected:
  explicit Memory_Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kManufacturerFieldNumber = 3,
    kTypeFieldNumber = 5,
    kFormFactorFieldNumber = 6,
    kPartNumberFieldNumber = 7,
    kSizeFieldNumber = 4,
    kPresentFieldNumber = 1,
    kSpeedFieldNumber = 8,
  };
  // string location = 2;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string manufacturer = 3;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // string type = 5;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string form_factor = 6;
  void clear_form_factor();
  const std::string& form_factor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_form_factor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_form_factor();
  PROTOBUF_NODISCARD std::string* release_form_factor();
  void set_allocated_form_factor(std::string* form_factor);
  private:
  const std::string& _internal_form_factor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_form_factor(const std::string& value);
  std::string* _internal_mutable_form_factor();
  public:

  // string part_number = 7;
  void clear_part_number();
  const std::string& part_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_number();
  PROTOBUF_NODISCARD std::string* release_part_number();
  void set_allocated_part_number(std::string* part_number);
  private:
  const std::string& _internal_part_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_number(const std::string& value);
  std::string* _internal_mutable_part_number();
  public:

  // uint64 size = 4;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // bool present = 1;
  void clear_present();
  bool present() const;
  void set_present(bool value);
  private:
  bool _internal_present() const;
  void _internal_set_present(bool value);
  public:

  // uint32 speed = 8;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Memory.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_factor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_number_;
    uint64_t size_;
    bool present_;
    uint32_t speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Memory final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Memory) */ {
 public:
  inline Memory() : Memory(nullptr) {}
  ~Memory() override;
  explicit PROTOBUF_CONSTEXPR Memory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Memory(const Memory& from);
  Memory(Memory&& from) noexcept
    : Memory() {
    *this = ::std::move(from);
  }

  inline Memory& operator=(const Memory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Memory& operator=(Memory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Memory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Memory* internal_default_instance() {
    return reinterpret_cast<const Memory*>(
               &_Memory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Memory& a, Memory& b) {
    a.Swap(&b);
  }
  inline void Swap(Memory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Memory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Memory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Memory>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Memory& from);
  void MergeFrom(const Memory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Memory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Memory";
  }
  protected:
  explicit Memory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Memory_Module Module;

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFieldNumber = 1,
  };
  // repeated .proto.system_info.Memory.Module module = 1;
  int module_size() const;
  private:
  int _internal_module_size() const;
  public:
  void clear_module();
  ::proto::system_info::Memory_Module* mutable_module(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Memory_Module >*
      mutable_module();
  private:
  const ::proto::system_info::Memory_Module& _internal_module(int index) const;
  ::proto::system_info::Memory_Module* _internal_add_module();
  public:
  const ::proto::system_info::Memory_Module& module(int index) const;
  ::proto::system_info::Memory_Module* add_module();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Memory_Module >&
      module() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Memory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Memory_Module > module_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LogicalDrives_Drive final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LogicalDrives.Drive) */ {
 public:
  inline LogicalDrives_Drive() : LogicalDrives_Drive(nullptr) {}
  ~LogicalDrives_Drive() override;
  explicit PROTOBUF_CONSTEXPR LogicalDrives_Drive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalDrives_Drive(const LogicalDrives_Drive& from);
  LogicalDrives_Drive(LogicalDrives_Drive&& from) noexcept
    : LogicalDrives_Drive() {
    *this = ::std::move(from);
  }

  inline LogicalDrives_Drive& operator=(const LogicalDrives_Drive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalDrives_Drive& operator=(LogicalDrives_Drive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LogicalDrives_Drive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalDrives_Drive* internal_default_instance() {
    return reinterpret_cast<const LogicalDrives_Drive*>(
               &_LogicalDrives_Drive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogicalDrives_Drive& a, LogicalDrives_Drive& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalDrives_Drive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalDrives_Drive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalDrives_Drive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogicalDrives_Drive>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LogicalDrives_Drive& from);
  void MergeFrom(const LogicalDrives_Drive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogicalDrives_Drive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LogicalDrives.Drive";
  }
  protected:
  explicit LogicalDrives_Drive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFileSystemFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
    kFreeSizeFieldNumber = 4,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string file_system = 2;
  void clear_file_system();
  const std::string& file_system() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_system(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_system();
  PROTOBUF_NODISCARD std::string* release_file_system();
  void set_allocated_file_system(std::string* file_system);
  private:
  const std::string& _internal_file_system() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_system(const std::string& value);
  std::string* _internal_mutable_file_system();
  public:

  // uint64 total_size = 3;
  void clear_total_size();
  uint64_t total_size() const;
  void set_total_size(uint64_t value);
  private:
  uint64_t _internal_total_size() const;
  void _internal_set_total_size(uint64_t value);
  public:

  // uint64 free_size = 4;
  void clear_free_size();
  uint64_t free_size() const;
  void set_free_size(uint64_t value);
  private:
  uint64_t _internal_free_size() const;
  void _internal_set_free_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.LogicalDrives.Drive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_system_;
    uint64_t total_size_;
    uint64_t free_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LogicalDrives final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LogicalDrives) */ {
 public:
  inline LogicalDrives() : LogicalDrives(nullptr) {}
  ~LogicalDrives() override;
  explicit PROTOBUF_CONSTEXPR LogicalDrives(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalDrives(const LogicalDrives& from);
  LogicalDrives(LogicalDrives&& from) noexcept
    : LogicalDrives() {
    *this = ::std::move(from);
  }

  inline LogicalDrives& operator=(const LogicalDrives& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalDrives& operator=(LogicalDrives&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LogicalDrives& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalDrives* internal_default_instance() {
    return reinterpret_cast<const LogicalDrives*>(
               &_LogicalDrives_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LogicalDrives& a, LogicalDrives& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalDrives* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalDrives* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalDrives* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogicalDrives>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LogicalDrives& from);
  void MergeFrom(const LogicalDrives& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogicalDrives* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LogicalDrives";
  }
  protected:
  explicit LogicalDrives(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LogicalDrives_Drive Drive;

  // accessors -------------------------------------------------------

  enum : int {
    kDriveFieldNumber = 1,
  };
  // repeated .proto.system_info.LogicalDrives.Drive drive = 1;
  int drive_size() const;
  private:
  int _internal_drive_size() const;
  public:
  void clear_drive();
  ::proto::system_info::LogicalDrives_Drive* mutable_drive(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LogicalDrives_Drive >*
      mutable_drive();
  private:
  const ::proto::system_info::LogicalDrives_Drive& _internal_drive(int index) const;
  ::proto::system_info::LogicalDrives_Drive* _internal_add_drive();
  public:
  const ::proto::system_info::LogicalDrives_Drive& drive(int index) const;
  ::proto::system_info::LogicalDrives_Drive* add_drive();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LogicalDrives_Drive >&
      drive() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.LogicalDrives)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LogicalDrives_Drive > drive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Printers_Printer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Printers.Printer) */ {
 public:
  inline Printers_Printer() : Printers_Printer(nullptr) {}
  ~Printers_Printer() override;
  explicit PROTOBUF_CONSTEXPR Printers_Printer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Printers_Printer(const Printers_Printer& from);
  Printers_Printer(Printers_Printer&& from) noexcept
    : Printers_Printer() {
    *this = ::std::move(from);
  }

  inline Printers_Printer& operator=(const Printers_Printer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Printers_Printer& operator=(Printers_Printer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Printers_Printer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Printers_Printer* internal_default_instance() {
    return reinterpret_cast<const Printers_Printer*>(
               &_Printers_Printer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Printers_Printer& a, Printers_Printer& b) {
    a.Swap(&b);
  }
  inline void Swap(Printers_Printer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Printers_Printer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Printers_Printer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Printers_Printer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Printers_Printer& from);
  void MergeFrom(const Printers_Printer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers_Printer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Printers.Printer";
  }
  protected:
  explicit Printers_Printer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPortFieldNumber = 4,
    kDriverFieldNumber = 5,
    kShareNameFieldNumber = 7,
    kDefaultFieldNumber = 2,
    kSharedFieldNumber = 3,
    kJobsCountFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string port = 4;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // string driver = 5;
  void clear_driver();
  const std::string& driver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver();
  PROTOBUF_NODISCARD std::string* release_driver();
  void set_allocated_driver(std::string* driver);
  private:
  const std::string& _internal_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver(const std::string& value);
  std::string* _internal_mutable_driver();
  public:

  // string share_name = 7;
  void clear_share_name();
  const std::string& share_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_share_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_share_name();
  PROTOBUF_NODISCARD std::string* release_share_name();
  void set_allocated_share_name(std::string* share_name);
  private:
  const std::string& _internal_share_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_share_name(const std::string& value);
  std::string* _internal_mutable_share_name();
  public:

  // bool default = 2;
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // bool shared = 3;
  void clear_shared();
  bool shared() const;
  void set_shared(bool value);
  private:
  bool _internal_shared() const;
  void _internal_set_shared(bool value);
  public:

  // uint32 jobs_count = 6;
  void clear_jobs_count();
  uint32_t jobs_count() const;
  void set_jobs_count(uint32_t value);
  private:
  uint32_t _internal_jobs_count() const;
  void _internal_set_jobs_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Printers.Printer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_name_;
    bool default__;
    bool shared_;
    uint32_t jobs_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Printers final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Printers) */ {
 public:
  inline Printers() : Printers(nullptr) {}
  ~Printers() override;
  explicit PROTOBUF_CONSTEXPR Printers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Printers(const Printers& from);
  Printers(Printers&& from) noexcept
    : Printers() {
    *this = ::std::move(from);
  }

  inline Printers& operator=(const Printers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Printers& operator=(Printers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Printers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Printers* internal_default_instance() {
    return reinterpret_cast<const Printers*>(
               &_Printers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Printers& a, Printers& b) {
    a.Swap(&b);
  }
  inline void Swap(Printers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Printers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Printers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Printers>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Printers& from);
  void MergeFrom(const Printers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Printers";
  }
  protected:
  explicit Printers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Printers_Printer Printer;

  // accessors -------------------------------------------------------

  enum : int {
    kPrinterFieldNumber = 1,
  };
  // repeated .proto.system_info.Printers.Printer printer = 1;
  int printer_size() const;
  private:
  int _internal_printer_size() const;
  public:
  void clear_printer();
  ::proto::system_info::Printers_Printer* mutable_printer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Printers_Printer >*
      mutable_printer();
  private:
  const ::proto::system_info::Printers_Printer& _internal_printer(int index) const;
  ::proto::system_info::Printers_Printer* _internal_add_printer();
  public:
  const ::proto::system_info::Printers_Printer& printer(int index) const;
  ::proto::system_info::Printers_Printer* add_printer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Printers_Printer >&
      printer() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Printers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Printers_Printer > printer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class NetworkAdapters_Adapter_Address final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.NetworkAdapters.Adapter.Address) */ {
 public:
  inline NetworkAdapters_Adapter_Address() : NetworkAdapters_Adapter_Address(nullptr) {}
  ~NetworkAdapters_Adapter_Address() override;
  explicit PROTOBUF_CONSTEXPR NetworkAdapters_Adapter_Address(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkAdapters_Adapter_Address(const NetworkAdapters_Adapter_Address& from);
  NetworkAdapters_Adapter_Address(NetworkAdapters_Adapter_Address&& from) noexcept
    : NetworkAdapters_Adapter_Address() {
    *this = ::std::move(from);
  }

  inline NetworkAdapters_Adapter_Address& operator=(const NetworkAdapters_Adapter_Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkAdapters_Adapter_Address& operator=(NetworkAdapters_Adapter_Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NetworkAdapters_Adapter_Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkAdapters_Adapter_Address* internal_default_instance() {
    return reinterpret_cast<const NetworkAdapters_Adapter_Address*>(
               &_NetworkAdapters_Adapter_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NetworkAdapters_Adapter_Address& a, NetworkAdapters_Adapter_Address& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkAdapters_Adapter_Address* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkAdapters_Adapter_Address* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkAdapters_Adapter_Address* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkAdapters_Adapter_Address>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkAdapters_Adapter_Address& from);
  void MergeFrom(const NetworkAdapters_Adapter_Address& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkAdapters_Adapter_Address* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.NetworkAdapters.Adapter.Address";
  }
  protected:
  explicit NetworkAdapters_Adapter_Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kMaskFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string mask = 2;
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.NetworkAdapters.Adapter.Address)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class NetworkAdapters_Adapter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.NetworkAdapters.Adapter) */ {
 public:
  inline NetworkAdapters_Adapter() : NetworkAdapters_Adapter(nullptr) {}
  ~NetworkAdapters_Adapter() override;
  explicit PROTOBUF_CONSTEXPR NetworkAdapters_Adapter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkAdapters_Adapter(const NetworkAdapters_Adapter& from);
  NetworkAdapters_Adapter(NetworkAdapters_Adapter&& from) noexcept
    : NetworkAdapters_Adapter() {
    *this = ::std::move(from);
  }

  inline NetworkAdapters_Adapter& operator=(const NetworkAdapters_Adapter& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkAdapters_Adapter& operator=(NetworkAdapters_Adapter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NetworkAdapters_Adapter& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkAdapters_Adapter* internal_default_instance() {
    return reinterpret_cast<const NetworkAdapters_Adapter*>(
               &_NetworkAdapters_Adapter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NetworkAdapters_Adapter& a, NetworkAdapters_Adapter& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkAdapters_Adapter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkAdapters_Adapter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkAdapters_Adapter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkAdapters_Adapter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkAdapters_Adapter& from);
  void MergeFrom(const NetworkAdapters_Adapter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkAdapters_Adapter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.NetworkAdapters.Adapter";
  }
  protected:
  explicit NetworkAdapters_Adapter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetworkAdapters_Adapter_Address Address;

  // accessors -------------------------------------------------------

  enum : int {
    kGatewayFieldNumber = 7,
    kAddressFieldNumber = 8,
    kDnsFieldNumber = 9,
    kDhcpFieldNumber = 10,
    kAdapterNameFieldNumber = 1,
    kConnectionNameFieldNumber = 2,
    kIfaceFieldNumber = 3,
    kMacFieldNumber = 5,
    kSpeedFieldNumber = 4,
    kDhcpEnabledFieldNumber = 6,
  };
  // repeated string gateway = 7;
  int gateway_size() const;
  private:
  int _internal_gateway_size() const;
  public:
  void clear_gateway();
  const std::string& gateway(int index) const;
  std::string* mutable_gateway(int index);
  void set_gateway(int index, const std::string& value);
  void set_gateway(int index, std::string&& value);
  void set_gateway(int index, const char* value);
  void set_gateway(int index, const char* value, size_t size);
  std::string* add_gateway();
  void add_gateway(const std::string& value);
  void add_gateway(std::string&& value);
  void add_gateway(const char* value);
  void add_gateway(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& gateway() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_gateway();
  private:
  const std::string& _internal_gateway(int index) const;
  std::string* _internal_add_gateway();
  public:

  // repeated .proto.system_info.NetworkAdapters.Adapter.Address address = 8;
  int address_size() const;
  private:
  int _internal_address_size() const;
  public:
  void clear_address();
  ::proto::system_info::NetworkAdapters_Adapter_Address* mutable_address(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter_Address >*
      mutable_address();
  private:
  const ::proto::system_info::NetworkAdapters_Adapter_Address& _internal_address(int index) const;
  ::proto::system_info::NetworkAdapters_Adapter_Address* _internal_add_address();
  public:
  const ::proto::system_info::NetworkAdapters_Adapter_Address& address(int index) const;
  ::proto::system_info::NetworkAdapters_Adapter_Address* add_address();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter_Address >&
      address() const;

  // repeated string dns = 9;
  int dns_size() const;
  private:
  int _internal_dns_size() const;
  public:
  void clear_dns();
  const std::string& dns(int index) const;
  std::string* mutable_dns(int index);
  void set_dns(int index, const std::string& value);
  void set_dns(int index, std::string&& value);
  void set_dns(int index, const char* value);
  void set_dns(int index, const char* value, size_t size);
  std::string* add_dns();
  void add_dns(const std::string& value);
  void add_dns(std::string&& value);
  void add_dns(const char* value);
  void add_dns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dns();
  private:
  const std::string& _internal_dns(int index) const;
  std::string* _internal_add_dns();
  public:

  // repeated string dhcp = 10;
  int dhcp_size() const;
  private:
  int _internal_dhcp_size() const;
  public:
  void clear_dhcp();
  const std::string& dhcp(int index) const;
  std::string* mutable_dhcp(int index);
  void set_dhcp(int index, const std::string& value);
  void set_dhcp(int index, std::string&& value);
  void set_dhcp(int index, const char* value);
  void set_dhcp(int index, const char* value, size_t size);
  std::string* add_dhcp();
  void add_dhcp(const std::string& value);
  void add_dhcp(std::string&& value);
  void add_dhcp(const char* value);
  void add_dhcp(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dhcp() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dhcp();
  private:
  const std::string& _internal_dhcp(int index) const;
  std::string* _internal_add_dhcp();
  public:

  // string adapter_name = 1;
  void clear_adapter_name();
  const std::string& adapter_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adapter_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adapter_name();
  PROTOBUF_NODISCARD std::string* release_adapter_name();
  void set_allocated_adapter_name(std::string* adapter_name);
  private:
  const std::string& _internal_adapter_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adapter_name(const std::string& value);
  std::string* _internal_mutable_adapter_name();
  public:

  // string connection_name = 2;
  void clear_connection_name();
  const std::string& connection_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_name();
  PROTOBUF_NODISCARD std::string* release_connection_name();
  void set_allocated_connection_name(std::string* connection_name);
  private:
  const std::string& _internal_connection_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_name(const std::string& value);
  std::string* _internal_mutable_connection_name();
  public:

  // string iface = 3;
  void clear_iface();
  const std::string& iface() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iface(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iface();
  PROTOBUF_NODISCARD std::string* release_iface();
  void set_allocated_iface(std::string* iface);
  private:
  const std::string& _internal_iface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iface(const std::string& value);
  std::string* _internal_mutable_iface();
  public:

  // string mac = 5;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // uint64 speed = 4;
  void clear_speed();
  uint64_t speed() const;
  void set_speed(uint64_t value);
  private:
  uint64_t _internal_speed() const;
  void _internal_set_speed(uint64_t value);
  public:

  // bool dhcp_enabled = 6;
  void clear_dhcp_enabled();
  bool dhcp_enabled() const;
  void set_dhcp_enabled(bool value);
  private:
  bool _internal_dhcp_enabled() const;
  void _internal_set_dhcp_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.NetworkAdapters.Adapter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> gateway_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter_Address > address_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dhcp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adapter_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iface_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    uint64_t speed_;
    bool dhcp_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class NetworkAdapters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.NetworkAdapters) */ {
 public:
  inline NetworkAdapters() : NetworkAdapters(nullptr) {}
  ~NetworkAdapters() override;
  explicit PROTOBUF_CONSTEXPR NetworkAdapters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkAdapters(const NetworkAdapters& from);
  NetworkAdapters(NetworkAdapters&& from) noexcept
    : NetworkAdapters() {
    *this = ::std::move(from);
  }

  inline NetworkAdapters& operator=(const NetworkAdapters& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkAdapters& operator=(NetworkAdapters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NetworkAdapters& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkAdapters* internal_default_instance() {
    return reinterpret_cast<const NetworkAdapters*>(
               &_NetworkAdapters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NetworkAdapters& a, NetworkAdapters& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkAdapters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkAdapters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkAdapters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkAdapters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkAdapters& from);
  void MergeFrom(const NetworkAdapters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkAdapters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.NetworkAdapters";
  }
  protected:
  explicit NetworkAdapters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetworkAdapters_Adapter Adapter;

  // accessors -------------------------------------------------------

  enum : int {
    kAdapterFieldNumber = 1,
  };
  // repeated .proto.system_info.NetworkAdapters.Adapter adapter = 1;
  int adapter_size() const;
  private:
  int _internal_adapter_size() const;
  public:
  void clear_adapter();
  ::proto::system_info::NetworkAdapters_Adapter* mutable_adapter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter >*
      mutable_adapter();
  private:
  const ::proto::system_info::NetworkAdapters_Adapter& _internal_adapter(int index) const;
  ::proto::system_info::NetworkAdapters_Adapter* _internal_add_adapter();
  public:
  const ::proto::system_info::NetworkAdapters_Adapter& adapter(int index) const;
  ::proto::system_info::NetworkAdapters_Adapter* add_adapter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter >&
      adapter() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.NetworkAdapters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter > adapter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class NetworkShares_Share final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.NetworkShares.Share) */ {
 public:
  inline NetworkShares_Share() : NetworkShares_Share(nullptr) {}
  ~NetworkShares_Share() override;
  explicit PROTOBUF_CONSTEXPR NetworkShares_Share(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkShares_Share(const NetworkShares_Share& from);
  NetworkShares_Share(NetworkShares_Share&& from) noexcept
    : NetworkShares_Share() {
    *this = ::std::move(from);
  }

  inline NetworkShares_Share& operator=(const NetworkShares_Share& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkShares_Share& operator=(NetworkShares_Share&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NetworkShares_Share& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkShares_Share* internal_default_instance() {
    return reinterpret_cast<const NetworkShares_Share*>(
               &_NetworkShares_Share_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NetworkShares_Share& a, NetworkShares_Share& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkShares_Share* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkShares_Share* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkShares_Share* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkShares_Share>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkShares_Share& from);
  void MergeFrom(const NetworkShares_Share& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkShares_Share* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.NetworkShares.Share";
  }
  protected:
  explicit NetworkShares_Share(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTypeFieldNumber = 3,
    kLocalPathFieldNumber = 4,
    kCurrentUsesFieldNumber = 5,
    kMaxUsesFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string local_path = 4;
  void clear_local_path();
  const std::string& local_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_path();
  PROTOBUF_NODISCARD std::string* release_local_path();
  void set_allocated_local_path(std::string* local_path);
  private:
  const std::string& _internal_local_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_path(const std::string& value);
  std::string* _internal_mutable_local_path();
  public:

  // uint32 current_uses = 5;
  void clear_current_uses();
  uint32_t current_uses() const;
  void set_current_uses(uint32_t value);
  private:
  uint32_t _internal_current_uses() const;
  void _internal_set_current_uses(uint32_t value);
  public:

  // uint32 max_uses = 6;
  void clear_max_uses();
  uint32_t max_uses() const;
  void set_max_uses(uint32_t value);
  private:
  uint32_t _internal_max_uses() const;
  void _internal_set_max_uses(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.NetworkShares.Share)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_path_;
    uint32_t current_uses_;
    uint32_t max_uses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class NetworkShares final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.NetworkShares) */ {
 public:
  inline NetworkShares() : NetworkShares(nullptr) {}
  ~NetworkShares() override;
  explicit PROTOBUF_CONSTEXPR NetworkShares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkShares(const NetworkShares& from);
  NetworkShares(NetworkShares&& from) noexcept
    : NetworkShares() {
    *this = ::std::move(from);
  }

  inline NetworkShares& operator=(const NetworkShares& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkShares& operator=(NetworkShares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NetworkShares& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkShares* internal_default_instance() {
    return reinterpret_cast<const NetworkShares*>(
               &_NetworkShares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NetworkShares& a, NetworkShares& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkShares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkShares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkShares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkShares>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NetworkShares& from);
  void MergeFrom(const NetworkShares& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkShares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.NetworkShares";
  }
  protected:
  explicit NetworkShares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetworkShares_Share Share;

  // accessors -------------------------------------------------------

  enum : int {
    kShareFieldNumber = 1,
  };
  // repeated .proto.system_info.NetworkShares.Share share = 1;
  int share_size() const;
  private:
  int _internal_share_size() const;
  public:
  void clear_share();
  ::proto::system_info::NetworkShares_Share* mutable_share(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkShares_Share >*
      mutable_share();
  private:
  const ::proto::system_info::NetworkShares_Share& _internal_share(int index) const;
  ::proto::system_info::NetworkShares_Share* _internal_add_share();
  public:
  const ::proto::system_info::NetworkShares_Share& share(int index) const;
  ::proto::system_info::NetworkShares_Share* add_share();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkShares_Share >&
      share() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.NetworkShares)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkShares_Share > share_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class WindowsDevices_Device final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.WindowsDevices.Device) */ {
 public:
  inline WindowsDevices_Device() : WindowsDevices_Device(nullptr) {}
  ~WindowsDevices_Device() override;
  explicit PROTOBUF_CONSTEXPR WindowsDevices_Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowsDevices_Device(const WindowsDevices_Device& from);
  WindowsDevices_Device(WindowsDevices_Device&& from) noexcept
    : WindowsDevices_Device() {
    *this = ::std::move(from);
  }

  inline WindowsDevices_Device& operator=(const WindowsDevices_Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowsDevices_Device& operator=(WindowsDevices_Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const WindowsDevices_Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowsDevices_Device* internal_default_instance() {
    return reinterpret_cast<const WindowsDevices_Device*>(
               &_WindowsDevices_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WindowsDevices_Device& a, WindowsDevices_Device& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowsDevices_Device* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowsDevices_Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowsDevices_Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowsDevices_Device>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WindowsDevices_Device& from);
  void MergeFrom(const WindowsDevices_Device& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WindowsDevices_Device* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.WindowsDevices.Device";
  }
  protected:
  explicit WindowsDevices_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendlyNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kDriverVersionFieldNumber = 3,
    kDriverDateFieldNumber = 4,
    kDriverVendorFieldNumber = 5,
    kDeviceIdFieldNumber = 6,
  };
  // string friendly_name = 1;
  void clear_friendly_name();
  const std::string& friendly_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_friendly_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_friendly_name();
  PROTOBUF_NODISCARD std::string* release_friendly_name();
  void set_allocated_friendly_name(std::string* friendly_name);
  private:
  const std::string& _internal_friendly_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friendly_name(const std::string& value);
  std::string* _internal_mutable_friendly_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string driver_version = 3;
  void clear_driver_version();
  const std::string& driver_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_version();
  PROTOBUF_NODISCARD std::string* release_driver_version();
  void set_allocated_driver_version(std::string* driver_version);
  private:
  const std::string& _internal_driver_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_version(const std::string& value);
  std::string* _internal_mutable_driver_version();
  public:

  // string driver_date = 4;
  void clear_driver_date();
  const std::string& driver_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_date();
  PROTOBUF_NODISCARD std::string* release_driver_date();
  void set_allocated_driver_date(std::string* driver_date);
  private:
  const std::string& _internal_driver_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_date(const std::string& value);
  std::string* _internal_mutable_driver_date();
  public:

  // string driver_vendor = 5;
  void clear_driver_vendor();
  const std::string& driver_vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_vendor();
  PROTOBUF_NODISCARD std::string* release_driver_vendor();
  void set_allocated_driver_vendor(std::string* driver_vendor);
  private:
  const std::string& _internal_driver_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_vendor(const std::string& value);
  std::string* _internal_mutable_driver_vendor();
  public:

  // string device_id = 6;
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.WindowsDevices.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friendly_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class WindowsDevices final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.WindowsDevices) */ {
 public:
  inline WindowsDevices() : WindowsDevices(nullptr) {}
  ~WindowsDevices() override;
  explicit PROTOBUF_CONSTEXPR WindowsDevices(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowsDevices(const WindowsDevices& from);
  WindowsDevices(WindowsDevices&& from) noexcept
    : WindowsDevices() {
    *this = ::std::move(from);
  }

  inline WindowsDevices& operator=(const WindowsDevices& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowsDevices& operator=(WindowsDevices&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const WindowsDevices& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowsDevices* internal_default_instance() {
    return reinterpret_cast<const WindowsDevices*>(
               &_WindowsDevices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WindowsDevices& a, WindowsDevices& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowsDevices* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowsDevices* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowsDevices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowsDevices>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WindowsDevices& from);
  void MergeFrom(const WindowsDevices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WindowsDevices* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.WindowsDevices";
  }
  protected:
  explicit WindowsDevices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WindowsDevices_Device Device;

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
  };
  // repeated .proto.system_info.WindowsDevices.Device device = 1;
  int device_size() const;
  private:
  int _internal_device_size() const;
  public:
  void clear_device();
  ::proto::system_info::WindowsDevices_Device* mutable_device(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::WindowsDevices_Device >*
      mutable_device();
  private:
  const ::proto::system_info::WindowsDevices_Device& _internal_device(int index) const;
  ::proto::system_info::WindowsDevices_Device* _internal_add_device();
  public:
  const ::proto::system_info::WindowsDevices_Device& device(int index) const;
  ::proto::system_info::WindowsDevices_Device* add_device();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::WindowsDevices_Device >&
      device() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.WindowsDevices)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::WindowsDevices_Device > device_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class VideoAdapters_Adapter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.VideoAdapters.Adapter) */ {
 public:
  inline VideoAdapters_Adapter() : VideoAdapters_Adapter(nullptr) {}
  ~VideoAdapters_Adapter() override;
  explicit PROTOBUF_CONSTEXPR VideoAdapters_Adapter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoAdapters_Adapter(const VideoAdapters_Adapter& from);
  VideoAdapters_Adapter(VideoAdapters_Adapter&& from) noexcept
    : VideoAdapters_Adapter() {
    *this = ::std::move(from);
  }

  inline VideoAdapters_Adapter& operator=(const VideoAdapters_Adapter& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoAdapters_Adapter& operator=(VideoAdapters_Adapter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoAdapters_Adapter& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoAdapters_Adapter* internal_default_instance() {
    return reinterpret_cast<const VideoAdapters_Adapter*>(
               &_VideoAdapters_Adapter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VideoAdapters_Adapter& a, VideoAdapters_Adapter& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoAdapters_Adapter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoAdapters_Adapter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoAdapters_Adapter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoAdapters_Adapter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoAdapters_Adapter& from);
  void MergeFrom(const VideoAdapters_Adapter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoAdapters_Adapter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.VideoAdapters.Adapter";
  }
  protected:
  explicit VideoAdapters_Adapter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kAdapterStringFieldNumber = 2,
    kBiosStringFieldNumber = 3,
    kChipTypeFieldNumber = 4,
    kDacTypeFieldNumber = 5,
    kDriverDateFieldNumber = 6,
    kDriverVersionFieldNumber = 7,
    kDriverProviderFieldNumber = 8,
    kMemorySizeFieldNumber = 9,
  };
  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string adapter_string = 2;
  void clear_adapter_string();
  const std::string& adapter_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adapter_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adapter_string();
  PROTOBUF_NODISCARD std::string* release_adapter_string();
  void set_allocated_adapter_string(std::string* adapter_string);
  private:
  const std::string& _internal_adapter_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adapter_string(const std::string& value);
  std::string* _internal_mutable_adapter_string();
  public:

  // string bios_string = 3;
  void clear_bios_string();
  const std::string& bios_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bios_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bios_string();
  PROTOBUF_NODISCARD std::string* release_bios_string();
  void set_allocated_bios_string(std::string* bios_string);
  private:
  const std::string& _internal_bios_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bios_string(const std::string& value);
  std::string* _internal_mutable_bios_string();
  public:

  // string chip_type = 4;
  void clear_chip_type();
  const std::string& chip_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chip_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chip_type();
  PROTOBUF_NODISCARD std::string* release_chip_type();
  void set_allocated_chip_type(std::string* chip_type);
  private:
  const std::string& _internal_chip_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chip_type(const std::string& value);
  std::string* _internal_mutable_chip_type();
  public:

  // string dac_type = 5;
  void clear_dac_type();
  const std::string& dac_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dac_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dac_type();
  PROTOBUF_NODISCARD std::string* release_dac_type();
  void set_allocated_dac_type(std::string* dac_type);
  private:
  const std::string& _internal_dac_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dac_type(const std::string& value);
  std::string* _internal_mutable_dac_type();
  public:

  // string driver_date = 6;
  void clear_driver_date();
  const std::string& driver_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_date();
  PROTOBUF_NODISCARD std::string* release_driver_date();
  void set_allocated_driver_date(std::string* driver_date);
  private:
  const std::string& _internal_driver_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_date(const std::string& value);
  std::string* _internal_mutable_driver_date();
  public:

  // string driver_version = 7;
  void clear_driver_version();
  const std::string& driver_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_version();
  PROTOBUF_NODISCARD std::string* release_driver_version();
  void set_allocated_driver_version(std::string* driver_version);
  private:
  const std::string& _internal_driver_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_version(const std::string& value);
  std::string* _internal_mutable_driver_version();
  public:

  // string driver_provider = 8;
  void clear_driver_provider();
  const std::string& driver_provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_provider();
  PROTOBUF_NODISCARD std::string* release_driver_provider();
  void set_allocated_driver_provider(std::string* driver_provider);
  private:
  const std::string& _internal_driver_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_provider(const std::string& value);
  std::string* _internal_mutable_driver_provider();
  public:

  // uint64 memory_size = 9;
  void clear_memory_size();
  uint64_t memory_size() const;
  void set_memory_size(uint64_t value);
  private:
  uint64_t _internal_memory_size() const;
  void _internal_set_memory_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.VideoAdapters.Adapter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adapter_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bios_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chip_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dac_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_provider_;
    uint64_t memory_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class VideoAdapters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.VideoAdapters) */ {
 public:
  inline VideoAdapters() : VideoAdapters(nullptr) {}
  ~VideoAdapters() override;
  explicit PROTOBUF_CONSTEXPR VideoAdapters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoAdapters(const VideoAdapters& from);
  VideoAdapters(VideoAdapters&& from) noexcept
    : VideoAdapters() {
    *this = ::std::move(from);
  }

  inline VideoAdapters& operator=(const VideoAdapters& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoAdapters& operator=(VideoAdapters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoAdapters& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoAdapters* internal_default_instance() {
    return reinterpret_cast<const VideoAdapters*>(
               &_VideoAdapters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VideoAdapters& a, VideoAdapters& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoAdapters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoAdapters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoAdapters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoAdapters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoAdapters& from);
  void MergeFrom(const VideoAdapters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoAdapters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.VideoAdapters";
  }
  protected:
  explicit VideoAdapters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VideoAdapters_Adapter Adapter;

  // accessors -------------------------------------------------------

  enum : int {
    kAdapterFieldNumber = 1,
  };
  // repeated .proto.system_info.VideoAdapters.Adapter adapter = 1;
  int adapter_size() const;
  private:
  int _internal_adapter_size() const;
  public:
  void clear_adapter();
  ::proto::system_info::VideoAdapters_Adapter* mutable_adapter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::VideoAdapters_Adapter >*
      mutable_adapter();
  private:
  const ::proto::system_info::VideoAdapters_Adapter& _internal_adapter(int index) const;
  ::proto::system_info::VideoAdapters_Adapter* _internal_add_adapter();
  public:
  const ::proto::system_info::VideoAdapters_Adapter& adapter(int index) const;
  ::proto::system_info::VideoAdapters_Adapter* add_adapter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::VideoAdapters_Adapter >&
      adapter() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.VideoAdapters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::VideoAdapters_Adapter > adapter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Monitors_Monitor_Timing final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Monitors.Monitor.Timing) */ {
 public:
  inline Monitors_Monitor_Timing() : Monitors_Monitor_Timing(nullptr) {}
  ~Monitors_Monitor_Timing() override;
  explicit PROTOBUF_CONSTEXPR Monitors_Monitor_Timing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Monitors_Monitor_Timing(const Monitors_Monitor_Timing& from);
  Monitors_Monitor_Timing(Monitors_Monitor_Timing&& from) noexcept
    : Monitors_Monitor_Timing() {
    *this = ::std::move(from);
  }

  inline Monitors_Monitor_Timing& operator=(const Monitors_Monitor_Timing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monitors_Monitor_Timing& operator=(Monitors_Monitor_Timing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Monitors_Monitor_Timing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monitors_Monitor_Timing* internal_default_instance() {
    return reinterpret_cast<const Monitors_Monitor_Timing*>(
               &_Monitors_Monitor_Timing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Monitors_Monitor_Timing& a, Monitors_Monitor_Timing& b) {
    a.Swap(&b);
  }
  inline void Swap(Monitors_Monitor_Timing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monitors_Monitor_Timing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monitors_Monitor_Timing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Monitors_Monitor_Timing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Monitors_Monitor_Timing& from);
  void MergeFrom(const Monitors_Monitor_Timing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Monitor_Timing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Monitors.Monitor.Timing";
  }
  protected:
  explicit Monitors_Monitor_Timing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFrequencyFieldNumber = 3,
  };
  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 frequency = 3;
  void clear_frequency();
  int32_t frequency() const;
  void set_frequency(int32_t value);
  private:
  int32_t _internal_frequency() const;
  void _internal_set_frequency(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Monitors.Monitor.Timing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t width_;
    int32_t height_;
    int32_t frequency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Monitors_Monitor final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Monitors.Monitor) */ {
 public:
  inline Monitors_Monitor() : Monitors_Monitor(nullptr) {}
  ~Monitors_Monitor() override;
  explicit PROTOBUF_CONSTEXPR Monitors_Monitor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Monitors_Monitor(const Monitors_Monitor& from);
  Monitors_Monitor(Monitors_Monitor&& from) noexcept
    : Monitors_Monitor() {
    *this = ::std::move(from);
  }

  inline Monitors_Monitor& operator=(const Monitors_Monitor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monitors_Monitor& operator=(Monitors_Monitor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Monitors_Monitor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monitors_Monitor* internal_default_instance() {
    return reinterpret_cast<const Monitors_Monitor*>(
               &_Monitors_Monitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Monitors_Monitor& a, Monitors_Monitor& b) {
    a.Swap(&b);
  }
  inline void Swap(Monitors_Monitor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monitors_Monitor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monitors_Monitor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Monitors_Monitor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Monitors_Monitor& from);
  void MergeFrom(const Monitors_Monitor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Monitor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Monitors.Monitor";
  }
  protected:
  explicit Monitors_Monitor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Monitors_Monitor_Timing Timing;

  typedef Monitors_Monitor_InputSignalType InputSignalType;
  static constexpr InputSignalType INPUT_SIGNAL_TYPE_UNKNOWN =
    Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN;
  static constexpr InputSignalType INPUT_SIGNAL_TYPE_ANALOG =
    Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_ANALOG;
  static constexpr InputSignalType INPUT_SIGNAL_TYPE_DIGITAL =
    Monitors_Monitor_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL;
  static inline bool InputSignalType_IsValid(int value) {
    return Monitors_Monitor_InputSignalType_IsValid(value);
  }
  static constexpr InputSignalType InputSignalType_MIN =
    Monitors_Monitor_InputSignalType_InputSignalType_MIN;
  static constexpr InputSignalType InputSignalType_MAX =
    Monitors_Monitor_InputSignalType_InputSignalType_MAX;
  static constexpr int InputSignalType_ARRAYSIZE =
    Monitors_Monitor_InputSignalType_InputSignalType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InputSignalType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InputSignalType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InputSignalType_Name.");
    return Monitors_Monitor_InputSignalType_Name(enum_t_value);
  }
  static inline bool InputSignalType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InputSignalType* value) {
    return Monitors_Monitor_InputSignalType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimingsFieldNumber = 28,
    kSystemNameFieldNumber = 1,
    kMonitorNameFieldNumber = 2,
    kManufacturerNameFieldNumber = 3,
    kMonitorIdFieldNumber = 4,
    kSerialNumberFieldNumber = 5,
    kEdidVersionFieldNumber = 6,
    kEdidRevisionFieldNumber = 7,
    kWeekOfManufactureFieldNumber = 8,
    kYearOfManufactureFieldNumber = 9,
    kMaxHorizontalImageSizeFieldNumber = 10,
    kMaxVerticalImageSizeFieldNumber = 11,
    kHorizontalResolutionFieldNumber = 12,
    kVerticalResoulutionFieldNumber = 13,
    kGammaFieldNumber = 14,
    kMinHorizontalRateFieldNumber = 15,
    kMaxHorizontalRateFieldNumber = 16,
    kMinVerticalRateFieldNumber = 17,
    kMaxVerticalRateFieldNumber = 18,
    kPixelClockFieldNumber = 19,
    kMaxPixelClockFieldNumber = 20,
    kInputSignalTypeFieldNumber = 21,
    kDefaultGtfSupportedFieldNumber = 22,
    kSuspendSupportedFieldNumber = 23,
    kStandbySupportedFieldNumber = 24,
    kActiveOffSupportedFieldNumber = 25,
    kPreferredTimingModeSupportedFieldNumber = 26,
    kSrgbSupportedFieldNumber = 27,
  };
  // repeated .proto.system_info.Monitors.Monitor.Timing timings = 28;
  int timings_size() const;
  private:
  int _internal_timings_size() const;
  public:
  void clear_timings();
  ::proto::system_info::Monitors_Monitor_Timing* mutable_timings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor_Timing >*
      mutable_timings();
  private:
  const ::proto::system_info::Monitors_Monitor_Timing& _internal_timings(int index) const;
  ::proto::system_info::Monitors_Monitor_Timing* _internal_add_timings();
  public:
  const ::proto::system_info::Monitors_Monitor_Timing& timings(int index) const;
  ::proto::system_info::Monitors_Monitor_Timing* add_timings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor_Timing >&
      timings() const;

  // string system_name = 1;
  void clear_system_name();
  const std::string& system_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_name();
  PROTOBUF_NODISCARD std::string* release_system_name();
  void set_allocated_system_name(std::string* system_name);
  private:
  const std::string& _internal_system_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_name(const std::string& value);
  std::string* _internal_mutable_system_name();
  public:

  // string monitor_name = 2;
  void clear_monitor_name();
  const std::string& monitor_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_monitor_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_monitor_name();
  PROTOBUF_NODISCARD std::string* release_monitor_name();
  void set_allocated_monitor_name(std::string* monitor_name);
  private:
  const std::string& _internal_monitor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_monitor_name(const std::string& value);
  std::string* _internal_mutable_monitor_name();
  public:

  // string manufacturer_name = 3;
  void clear_manufacturer_name();
  const std::string& manufacturer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer_name();
  PROTOBUF_NODISCARD std::string* release_manufacturer_name();
  void set_allocated_manufacturer_name(std::string* manufacturer_name);
  private:
  const std::string& _internal_manufacturer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer_name(const std::string& value);
  std::string* _internal_mutable_manufacturer_name();
  public:

  // string monitor_id = 4;
  void clear_monitor_id();
  const std::string& monitor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_monitor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_monitor_id();
  PROTOBUF_NODISCARD std::string* release_monitor_id();
  void set_allocated_monitor_id(std::string* monitor_id);
  private:
  const std::string& _internal_monitor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_monitor_id(const std::string& value);
  std::string* _internal_mutable_monitor_id();
  public:

  // string serial_number = 5;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // int32 edid_version = 6;
  void clear_edid_version();
  int32_t edid_version() const;
  void set_edid_version(int32_t value);
  private:
  int32_t _internal_edid_version() const;
  void _internal_set_edid_version(int32_t value);
  public:

  // int32 edid_revision = 7;
  void clear_edid_revision();
  int32_t edid_revision() const;
  void set_edid_revision(int32_t value);
  private:
  int32_t _internal_edid_revision() const;
  void _internal_set_edid_revision(int32_t value);
  public:

  // int32 week_of_manufacture = 8;
  void clear_week_of_manufacture();
  int32_t week_of_manufacture() const;
  void set_week_of_manufacture(int32_t value);
  private:
  int32_t _internal_week_of_manufacture() const;
  void _internal_set_week_of_manufacture(int32_t value);
  public:

  // int32 year_of_manufacture = 9;
  void clear_year_of_manufacture();
  int32_t year_of_manufacture() const;
  void set_year_of_manufacture(int32_t value);
  private:
  int32_t _internal_year_of_manufacture() const;
  void _internal_set_year_of_manufacture(int32_t value);
  public:

  // int32 max_horizontal_image_size = 10;
  void clear_max_horizontal_image_size();
  int32_t max_horizontal_image_size() const;
  void set_max_horizontal_image_size(int32_t value);
  private:
  int32_t _internal_max_horizontal_image_size() const;
  void _internal_set_max_horizontal_image_size(int32_t value);
  public:

  // int32 max_vertical_image_size = 11;
  void clear_max_vertical_image_size();
  int32_t max_vertical_image_size() const;
  void set_max_vertical_image_size(int32_t value);
  private:
  int32_t _internal_max_vertical_image_size() const;
  void _internal_set_max_vertical_image_size(int32_t value);
  public:

  // int32 horizontal_resolution = 12;
  void clear_horizontal_resolution();
  int32_t horizontal_resolution() const;
  void set_horizontal_resolution(int32_t value);
  private:
  int32_t _internal_horizontal_resolution() const;
  void _internal_set_horizontal_resolution(int32_t value);
  public:

  // int32 vertical_resoulution = 13;
  void clear_vertical_resoulution();
  int32_t vertical_resoulution() const;
  void set_vertical_resoulution(int32_t value);
  private:
  int32_t _internal_vertical_resoulution() const;
  void _internal_set_vertical_resoulution(int32_t value);
  public:

  // double gamma = 14;
  void clear_gamma();
  double gamma() const;
  void set_gamma(double value);
  private:
  double _internal_gamma() const;
  void _internal_set_gamma(double value);
  public:

  // int32 min_horizontal_rate = 15;
  void clear_min_horizontal_rate();
  int32_t min_horizontal_rate() const;
  void set_min_horizontal_rate(int32_t value);
  private:
  int32_t _internal_min_horizontal_rate() const;
  void _internal_set_min_horizontal_rate(int32_t value);
  public:

  // int32 max_horizontal_rate = 16;
  void clear_max_horizontal_rate();
  int32_t max_horizontal_rate() const;
  void set_max_horizontal_rate(int32_t value);
  private:
  int32_t _internal_max_horizontal_rate() const;
  void _internal_set_max_horizontal_rate(int32_t value);
  public:

  // int32 min_vertical_rate = 17;
  void clear_min_vertical_rate();
  int32_t min_vertical_rate() const;
  void set_min_vertical_rate(int32_t value);
  private:
  int32_t _internal_min_vertical_rate() const;
  void _internal_set_min_vertical_rate(int32_t value);
  public:

  // int32 max_vertical_rate = 18;
  void clear_max_vertical_rate();
  int32_t max_vertical_rate() const;
  void set_max_vertical_rate(int32_t value);
  private:
  int32_t _internal_max_vertical_rate() const;
  void _internal_set_max_vertical_rate(int32_t value);
  public:

  // double pixel_clock = 19;
  void clear_pixel_clock();
  double pixel_clock() const;
  void set_pixel_clock(double value);
  private:
  double _internal_pixel_clock() const;
  void _internal_set_pixel_clock(double value);
  public:

  // int32 max_pixel_clock = 20;
  void clear_max_pixel_clock();
  int32_t max_pixel_clock() const;
  void set_max_pixel_clock(int32_t value);
  private:
  int32_t _internal_max_pixel_clock() const;
  void _internal_set_max_pixel_clock(int32_t value);
  public:

  // .proto.system_info.Monitors.Monitor.InputSignalType input_signal_type = 21;
  void clear_input_signal_type();
  ::proto::system_info::Monitors_Monitor_InputSignalType input_signal_type() const;
  void set_input_signal_type(::proto::system_info::Monitors_Monitor_InputSignalType value);
  private:
  ::proto::system_info::Monitors_Monitor_InputSignalType _internal_input_signal_type() const;
  void _internal_set_input_signal_type(::proto::system_info::Monitors_Monitor_InputSignalType value);
  public:

  // bool default_gtf_supported = 22;
  void clear_default_gtf_supported();
  bool default_gtf_supported() const;
  void set_default_gtf_supported(bool value);
  private:
  bool _internal_default_gtf_supported() const;
  void _internal_set_default_gtf_supported(bool value);
  public:

  // bool suspend_supported = 23;
  void clear_suspend_supported();
  bool suspend_supported() const;
  void set_suspend_supported(bool value);
  private:
  bool _internal_suspend_supported() const;
  void _internal_set_suspend_supported(bool value);
  public:

  // bool standby_supported = 24;
  void clear_standby_supported();
  bool standby_supported() const;
  void set_standby_supported(bool value);
  private:
  bool _internal_standby_supported() const;
  void _internal_set_standby_supported(bool value);
  public:

  // bool active_off_supported = 25;
  void clear_active_off_supported();
  bool active_off_supported() const;
  void set_active_off_supported(bool value);
  private:
  bool _internal_active_off_supported() const;
  void _internal_set_active_off_supported(bool value);
  public:

  // bool preferred_timing_mode_supported = 26;
  void clear_preferred_timing_mode_supported();
  bool preferred_timing_mode_supported() const;
  void set_preferred_timing_mode_supported(bool value);
  private:
  bool _internal_preferred_timing_mode_supported() const;
  void _internal_set_preferred_timing_mode_supported(bool value);
  public:

  // bool srgb_supported = 27;
  void clear_srgb_supported();
  bool srgb_supported() const;
  void set_srgb_supported(bool value);
  private:
  bool _internal_srgb_supported() const;
  void _internal_set_srgb_supported(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Monitors.Monitor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor_Timing > timings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr monitor_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr monitor_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    int32_t edid_version_;
    int32_t edid_revision_;
    int32_t week_of_manufacture_;
    int32_t year_of_manufacture_;
    int32_t max_horizontal_image_size_;
    int32_t max_vertical_image_size_;
    int32_t horizontal_resolution_;
    int32_t vertical_resoulution_;
    double gamma_;
    int32_t min_horizontal_rate_;
    int32_t max_horizontal_rate_;
    int32_t min_vertical_rate_;
    int32_t max_vertical_rate_;
    double pixel_clock_;
    int32_t max_pixel_clock_;
    int input_signal_type_;
    bool default_gtf_supported_;
    bool suspend_supported_;
    bool standby_supported_;
    bool active_off_supported_;
    bool preferred_timing_mode_supported_;
    bool srgb_supported_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Monitors final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Monitors) */ {
 public:
  inline Monitors() : Monitors(nullptr) {}
  ~Monitors() override;
  explicit PROTOBUF_CONSTEXPR Monitors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Monitors(const Monitors& from);
  Monitors(Monitors&& from) noexcept
    : Monitors() {
    *this = ::std::move(from);
  }

  inline Monitors& operator=(const Monitors& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monitors& operator=(Monitors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Monitors& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monitors* internal_default_instance() {
    return reinterpret_cast<const Monitors*>(
               &_Monitors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Monitors& a, Monitors& b) {
    a.Swap(&b);
  }
  inline void Swap(Monitors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monitors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monitors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Monitors>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Monitors& from);
  void MergeFrom(const Monitors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Monitors";
  }
  protected:
  explicit Monitors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Monitors_Monitor Monitor;

  // accessors -------------------------------------------------------

  enum : int {
    kMonitorFieldNumber = 1,
  };
  // repeated .proto.system_info.Monitors.Monitor monitor = 1;
  int monitor_size() const;
  private:
  int _internal_monitor_size() const;
  public:
  void clear_monitor();
  ::proto::system_info::Monitors_Monitor* mutable_monitor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor >*
      mutable_monitor();
  private:
  const ::proto::system_info::Monitors_Monitor& _internal_monitor(int index) const;
  ::proto::system_info::Monitors_Monitor* _internal_add_monitor();
  public:
  const ::proto::system_info::Monitors_Monitor& monitor(int index) const;
  ::proto::system_info::Monitors_Monitor* add_monitor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor >&
      monitor() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Monitors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor > monitor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class PowerOptions_Battery final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.PowerOptions.Battery) */ {
 public:
  inline PowerOptions_Battery() : PowerOptions_Battery(nullptr) {}
  ~PowerOptions_Battery() override;
  explicit PROTOBUF_CONSTEXPR PowerOptions_Battery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerOptions_Battery(const PowerOptions_Battery& from);
  PowerOptions_Battery(PowerOptions_Battery&& from) noexcept
    : PowerOptions_Battery() {
    *this = ::std::move(from);
  }

  inline PowerOptions_Battery& operator=(const PowerOptions_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerOptions_Battery& operator=(PowerOptions_Battery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PowerOptions_Battery& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerOptions_Battery* internal_default_instance() {
    return reinterpret_cast<const PowerOptions_Battery*>(
               &_PowerOptions_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PowerOptions_Battery& a, PowerOptions_Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerOptions_Battery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerOptions_Battery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerOptions_Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerOptions_Battery>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PowerOptions_Battery& from);
  void MergeFrom(const PowerOptions_Battery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerOptions_Battery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.PowerOptions.Battery";
  }
  protected:
  explicit PowerOptions_Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PowerOptions_Battery_State State;
  static constexpr State STATE_UNKNOWN =
    PowerOptions_Battery_State_STATE_UNKNOWN;
  static constexpr State STATE_CHARGING =
    PowerOptions_Battery_State_STATE_CHARGING;
  static constexpr State STATE_CRITICAL =
    PowerOptions_Battery_State_STATE_CRITICAL;
  static constexpr State STATE_DISCHARGING =
    PowerOptions_Battery_State_STATE_DISCHARGING;
  static constexpr State STATE_POWER_ONLINE =
    PowerOptions_Battery_State_STATE_POWER_ONLINE;
  static inline bool State_IsValid(int value) {
    return PowerOptions_Battery_State_IsValid(value);
  }
  static constexpr State State_MIN =
    PowerOptions_Battery_State_State_MIN;
  static constexpr State State_MAX =
    PowerOptions_Battery_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    PowerOptions_Battery_State_State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return PowerOptions_Battery_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return PowerOptions_Battery_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceNameFieldNumber = 1,
    kManufacturerFieldNumber = 2,
    kManufactureDateFieldNumber = 3,
    kUniqueIdFieldNumber = 4,
    kSerialNumberFieldNumber = 5,
    kTemperatureFieldNumber = 6,
    kTypeFieldNumber = 8,
    kDesignCapacityFieldNumber = 7,
    kFullChargedCapacityFieldNumber = 9,
    kDepreciationFieldNumber = 10,
    kCurrentCapacityFieldNumber = 11,
    kVoltageFieldNumber = 12,
    kStateFieldNumber = 13,
  };
  // string device_name = 1;
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // string manufacturer = 2;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // string manufacture_date = 3;
  void clear_manufacture_date();
  const std::string& manufacture_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacture_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacture_date();
  PROTOBUF_NODISCARD std::string* release_manufacture_date();
  void set_allocated_manufacture_date(std::string* manufacture_date);
  private:
  const std::string& _internal_manufacture_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacture_date(const std::string& value);
  std::string* _internal_mutable_manufacture_date();
  public:

  // string unique_id = 4;
  void clear_unique_id();
  const std::string& unique_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_id();
  PROTOBUF_NODISCARD std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // string serial_number = 5;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string temperature = 6;
  void clear_temperature();
  const std::string& temperature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_temperature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_temperature();
  PROTOBUF_NODISCARD std::string* release_temperature();
  void set_allocated_temperature(std::string* temperature);
  private:
  const std::string& _internal_temperature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_temperature(const std::string& value);
  std::string* _internal_mutable_temperature();
  public:

  // string type = 8;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint32 design_capacity = 7;
  void clear_design_capacity();
  uint32_t design_capacity() const;
  void set_design_capacity(uint32_t value);
  private:
  uint32_t _internal_design_capacity() const;
  void _internal_set_design_capacity(uint32_t value);
  public:

  // uint32 full_charged_capacity = 9;
  void clear_full_charged_capacity();
  uint32_t full_charged_capacity() const;
  void set_full_charged_capacity(uint32_t value);
  private:
  uint32_t _internal_full_charged_capacity() const;
  void _internal_set_full_charged_capacity(uint32_t value);
  public:

  // uint32 depreciation = 10;
  void clear_depreciation();
  uint32_t depreciation() const;
  void set_depreciation(uint32_t value);
  private:
  uint32_t _internal_depreciation() const;
  void _internal_set_depreciation(uint32_t value);
  public:

  // uint32 current_capacity = 11;
  void clear_current_capacity();
  uint32_t current_capacity() const;
  void set_current_capacity(uint32_t value);
  private:
  uint32_t _internal_current_capacity() const;
  void _internal_set_current_capacity(uint32_t value);
  public:

  // uint32 voltage = 12;
  void clear_voltage();
  uint32_t voltage() const;
  void set_voltage(uint32_t value);
  private:
  uint32_t _internal_voltage() const;
  void _internal_set_voltage(uint32_t value);
  public:

  // uint32 state = 13;
  void clear_state();
  uint32_t state() const;
  void set_state(uint32_t value);
  private:
  uint32_t _internal_state() const;
  void _internal_set_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.PowerOptions.Battery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacture_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr temperature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    uint32_t design_capacity_;
    uint32_t full_charged_capacity_;
    uint32_t depreciation_;
    uint32_t current_capacity_;
    uint32_t voltage_;
    uint32_t state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class PowerOptions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.PowerOptions) */ {
 public:
  inline PowerOptions() : PowerOptions(nullptr) {}
  ~PowerOptions() override;
  explicit PROTOBUF_CONSTEXPR PowerOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerOptions(const PowerOptions& from);
  PowerOptions(PowerOptions&& from) noexcept
    : PowerOptions() {
    *this = ::std::move(from);
  }

  inline PowerOptions& operator=(const PowerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerOptions& operator=(PowerOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PowerOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerOptions* internal_default_instance() {
    return reinterpret_cast<const PowerOptions*>(
               &_PowerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PowerOptions& a, PowerOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PowerOptions& from);
  void MergeFrom(const PowerOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.PowerOptions";
  }
  protected:
  explicit PowerOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PowerOptions_Battery Battery;

  typedef PowerOptions_PowerSource PowerSource;
  static constexpr PowerSource POWER_SOURCE_UNKNOWN =
    PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN;
  static constexpr PowerSource POWER_SOURCE_DC_BATTERY =
    PowerOptions_PowerSource_POWER_SOURCE_DC_BATTERY;
  static constexpr PowerSource POWER_SOURCE_AC_LINE =
    PowerOptions_PowerSource_POWER_SOURCE_AC_LINE;
  static inline bool PowerSource_IsValid(int value) {
    return PowerOptions_PowerSource_IsValid(value);
  }
  static constexpr PowerSource PowerSource_MIN =
    PowerOptions_PowerSource_PowerSource_MIN;
  static constexpr PowerSource PowerSource_MAX =
    PowerOptions_PowerSource_PowerSource_MAX;
  static constexpr int PowerSource_ARRAYSIZE =
    PowerOptions_PowerSource_PowerSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PowerSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PowerSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PowerSource_Name.");
    return PowerOptions_PowerSource_Name(enum_t_value);
  }
  static inline bool PowerSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PowerSource* value) {
    return PowerOptions_PowerSource_Parse(name, value);
  }

  typedef PowerOptions_BatteryStatus BatteryStatus;
  static constexpr BatteryStatus BATTERY_STATUS_UNKNOWN =
    PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN;
  static constexpr BatteryStatus BATTERY_STATUS_HIGH =
    PowerOptions_BatteryStatus_BATTERY_STATUS_HIGH;
  static constexpr BatteryStatus BATTERY_STATUS_LOW =
    PowerOptions_BatteryStatus_BATTERY_STATUS_LOW;
  static constexpr BatteryStatus BATTERY_STATUS_CRITICAL =
    PowerOptions_BatteryStatus_BATTERY_STATUS_CRITICAL;
  static constexpr BatteryStatus BATTERY_STATUS_CHARGING =
    PowerOptions_BatteryStatus_BATTERY_STATUS_CHARGING;
  static constexpr BatteryStatus BATTERY_STATUS_NO_BATTERY =
    PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY;
  static inline bool BatteryStatus_IsValid(int value) {
    return PowerOptions_BatteryStatus_IsValid(value);
  }
  static constexpr BatteryStatus BatteryStatus_MIN =
    PowerOptions_BatteryStatus_BatteryStatus_MIN;
  static constexpr BatteryStatus BatteryStatus_MAX =
    PowerOptions_BatteryStatus_BatteryStatus_MAX;
  static constexpr int BatteryStatus_ARRAYSIZE =
    PowerOptions_BatteryStatus_BatteryStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BatteryStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BatteryStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BatteryStatus_Name.");
    return PowerOptions_BatteryStatus_Name(enum_t_value);
  }
  static inline bool BatteryStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BatteryStatus* value) {
    return PowerOptions_BatteryStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryFieldNumber = 6,
    kPowerSourceFieldNumber = 1,
    kBatteryStatusFieldNumber = 2,
    kFullBatteryLifeTimeFieldNumber = 3,
    kRemainingBatteryLifeTimeFieldNumber = 4,
    kBatteryLifePercentFieldNumber = 5,
  };
  // repeated .proto.system_info.PowerOptions.Battery battery = 6;
  int battery_size() const;
  private:
  int _internal_battery_size() const;
  public:
  void clear_battery();
  ::proto::system_info::PowerOptions_Battery* mutable_battery(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::PowerOptions_Battery >*
      mutable_battery();
  private:
  const ::proto::system_info::PowerOptions_Battery& _internal_battery(int index) const;
  ::proto::system_info::PowerOptions_Battery* _internal_add_battery();
  public:
  const ::proto::system_info::PowerOptions_Battery& battery(int index) const;
  ::proto::system_info::PowerOptions_Battery* add_battery();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::PowerOptions_Battery >&
      battery() const;

  // .proto.system_info.PowerOptions.PowerSource power_source = 1;
  void clear_power_source();
  ::proto::system_info::PowerOptions_PowerSource power_source() const;
  void set_power_source(::proto::system_info::PowerOptions_PowerSource value);
  private:
  ::proto::system_info::PowerOptions_PowerSource _internal_power_source() const;
  void _internal_set_power_source(::proto::system_info::PowerOptions_PowerSource value);
  public:

  // .proto.system_info.PowerOptions.BatteryStatus battery_status = 2;
  void clear_battery_status();
  ::proto::system_info::PowerOptions_BatteryStatus battery_status() const;
  void set_battery_status(::proto::system_info::PowerOptions_BatteryStatus value);
  private:
  ::proto::system_info::PowerOptions_BatteryStatus _internal_battery_status() const;
  void _internal_set_battery_status(::proto::system_info::PowerOptions_BatteryStatus value);
  public:

  // uint64 full_battery_life_time = 3;
  void clear_full_battery_life_time();
  uint64_t full_battery_life_time() const;
  void set_full_battery_life_time(uint64_t value);
  private:
  uint64_t _internal_full_battery_life_time() const;
  void _internal_set_full_battery_life_time(uint64_t value);
  public:

  // uint64 remaining_battery_life_time = 4;
  void clear_remaining_battery_life_time();
  uint64_t remaining_battery_life_time() const;
  void set_remaining_battery_life_time(uint64_t value);
  private:
  uint64_t _internal_remaining_battery_life_time() const;
  void _internal_set_remaining_battery_life_time(uint64_t value);
  public:

  // uint32 battery_life_percent = 5;
  void clear_battery_life_percent();
  uint32_t battery_life_percent() const;
  void set_battery_life_percent(uint32_t value);
  private:
  uint32_t _internal_battery_life_percent() const;
  void _internal_set_battery_life_percent(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.PowerOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::PowerOptions_Battery > battery_;
    int power_source_;
    int battery_status_;
    uint64_t full_battery_life_time_;
    uint64_t remaining_battery_life_time_;
    uint32_t battery_life_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Drivers_Driver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Drivers.Driver) */ {
 public:
  inline Drivers_Driver() : Drivers_Driver(nullptr) {}
  ~Drivers_Driver() override;
  explicit PROTOBUF_CONSTEXPR Drivers_Driver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Drivers_Driver(const Drivers_Driver& from);
  Drivers_Driver(Drivers_Driver&& from) noexcept
    : Drivers_Driver() {
    *this = ::std::move(from);
  }

  inline Drivers_Driver& operator=(const Drivers_Driver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Drivers_Driver& operator=(Drivers_Driver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Drivers_Driver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Drivers_Driver* internal_default_instance() {
    return reinterpret_cast<const Drivers_Driver*>(
               &_Drivers_Driver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Drivers_Driver& a, Drivers_Driver& b) {
    a.Swap(&b);
  }
  inline void Swap(Drivers_Driver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Drivers_Driver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Drivers_Driver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Drivers_Driver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Drivers_Driver& from);
  void MergeFrom(const Drivers_Driver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Drivers_Driver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Drivers.Driver";
  }
  protected:
  explicit Drivers_Driver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Drivers_Driver_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    Drivers_Driver_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_CONTINUE_PENDING =
    Drivers_Driver_Status_STATUS_CONTINUE_PENDING;
  static constexpr Status STATUS_PAUSE_PENDING =
    Drivers_Driver_Status_STATUS_PAUSE_PENDING;
  static constexpr Status STATUS_PAUSED =
    Drivers_Driver_Status_STATUS_PAUSED;
  static constexpr Status STATUS_RUNNING =
    Drivers_Driver_Status_STATUS_RUNNING;
  static constexpr Status STATUS_START_PENDING =
    Drivers_Driver_Status_STATUS_START_PENDING;
  static constexpr Status STATUS_STOP_PENDING =
    Drivers_Driver_Status_STATUS_STOP_PENDING;
  static constexpr Status STATUS_STOPPED =
    Drivers_Driver_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Drivers_Driver_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    Drivers_Driver_Status_Status_MIN;
  static constexpr Status Status_MAX =
    Drivers_Driver_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    Drivers_Driver_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return Drivers_Driver_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return Drivers_Driver_Status_Parse(name, value);
  }

  typedef Drivers_Driver_StartupType StartupType;
  static constexpr StartupType STARTUP_TYPE_UNKNOWN =
    Drivers_Driver_StartupType_STARTUP_TYPE_UNKNOWN;
  static constexpr StartupType STARTUP_TYPE_AUTO_START =
    Drivers_Driver_StartupType_STARTUP_TYPE_AUTO_START;
  static constexpr StartupType STARTUP_TYPE_DEMAND_START =
    Drivers_Driver_StartupType_STARTUP_TYPE_DEMAND_START;
  static constexpr StartupType STARTUP_TYPE_DISABLED =
    Drivers_Driver_StartupType_STARTUP_TYPE_DISABLED;
  static constexpr StartupType STARTUP_TYPE_BOOT_START =
    Drivers_Driver_StartupType_STARTUP_TYPE_BOOT_START;
  static constexpr StartupType STARTUP_TYPE_SYSTEM_START =
    Drivers_Driver_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Drivers_Driver_StartupType_IsValid(value);
  }
  static constexpr StartupType StartupType_MIN =
    Drivers_Driver_StartupType_StartupType_MIN;
  static constexpr StartupType StartupType_MAX =
    Drivers_Driver_StartupType_StartupType_MAX;
  static constexpr int StartupType_ARRAYSIZE =
    Drivers_Driver_StartupType_StartupType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StartupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StartupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StartupType_Name.");
    return Drivers_Driver_StartupType_Name(enum_t_value);
  }
  static inline bool StartupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StartupType* value) {
    return Drivers_Driver_StartupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kBinaryPathFieldNumber = 6,
    kStatusFieldNumber = 4,
    kStartupTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string binary_path = 6;
  void clear_binary_path();
  const std::string& binary_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_path();
  PROTOBUF_NODISCARD std::string* release_binary_path();
  void set_allocated_binary_path(std::string* binary_path);
  private:
  const std::string& _internal_binary_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_path(const std::string& value);
  std::string* _internal_mutable_binary_path();
  public:

  // .proto.system_info.Drivers.Driver.Status status = 4;
  void clear_status();
  ::proto::system_info::Drivers_Driver_Status status() const;
  void set_status(::proto::system_info::Drivers_Driver_Status value);
  private:
  ::proto::system_info::Drivers_Driver_Status _internal_status() const;
  void _internal_set_status(::proto::system_info::Drivers_Driver_Status value);
  public:

  // .proto.system_info.Drivers.Driver.StartupType startup_type = 5;
  void clear_startup_type();
  ::proto::system_info::Drivers_Driver_StartupType startup_type() const;
  void set_startup_type(::proto::system_info::Drivers_Driver_StartupType value);
  private:
  ::proto::system_info::Drivers_Driver_StartupType _internal_startup_type() const;
  void _internal_set_startup_type(::proto::system_info::Drivers_Driver_StartupType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Drivers.Driver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_path_;
    int status_;
    int startup_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Drivers final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Drivers) */ {
 public:
  inline Drivers() : Drivers(nullptr) {}
  ~Drivers() override;
  explicit PROTOBUF_CONSTEXPR Drivers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Drivers(const Drivers& from);
  Drivers(Drivers&& from) noexcept
    : Drivers() {
    *this = ::std::move(from);
  }

  inline Drivers& operator=(const Drivers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Drivers& operator=(Drivers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Drivers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Drivers* internal_default_instance() {
    return reinterpret_cast<const Drivers*>(
               &_Drivers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Drivers& a, Drivers& b) {
    a.Swap(&b);
  }
  inline void Swap(Drivers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Drivers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Drivers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Drivers>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Drivers& from);
  void MergeFrom(const Drivers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Drivers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Drivers";
  }
  protected:
  explicit Drivers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Drivers_Driver Driver;

  // accessors -------------------------------------------------------

  enum : int {
    kDriverFieldNumber = 1,
  };
  // repeated .proto.system_info.Drivers.Driver driver = 1;
  int driver_size() const;
  private:
  int _internal_driver_size() const;
  public:
  void clear_driver();
  ::proto::system_info::Drivers_Driver* mutable_driver(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Drivers_Driver >*
      mutable_driver();
  private:
  const ::proto::system_info::Drivers_Driver& _internal_driver(int index) const;
  ::proto::system_info::Drivers_Driver* _internal_add_driver();
  public:
  const ::proto::system_info::Drivers_Driver& driver(int index) const;
  ::proto::system_info::Drivers_Driver* add_driver();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Drivers_Driver >&
      driver() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Drivers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Drivers_Driver > driver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Services_Service final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Services.Service) */ {
 public:
  inline Services_Service() : Services_Service(nullptr) {}
  ~Services_Service() override;
  explicit PROTOBUF_CONSTEXPR Services_Service(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Services_Service(const Services_Service& from);
  Services_Service(Services_Service&& from) noexcept
    : Services_Service() {
    *this = ::std::move(from);
  }

  inline Services_Service& operator=(const Services_Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline Services_Service& operator=(Services_Service&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Services_Service& default_instance() {
    return *internal_default_instance();
  }
  static inline const Services_Service* internal_default_instance() {
    return reinterpret_cast<const Services_Service*>(
               &_Services_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Services_Service& a, Services_Service& b) {
    a.Swap(&b);
  }
  inline void Swap(Services_Service* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Services_Service* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Services_Service* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Services_Service>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Services_Service& from);
  void MergeFrom(const Services_Service& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services_Service* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Services.Service";
  }
  protected:
  explicit Services_Service(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Services_Service_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    Services_Service_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_CONTINUE_PENDING =
    Services_Service_Status_STATUS_CONTINUE_PENDING;
  static constexpr Status STATUS_PAUSE_PENDING =
    Services_Service_Status_STATUS_PAUSE_PENDING;
  static constexpr Status STATUS_PAUSED =
    Services_Service_Status_STATUS_PAUSED;
  static constexpr Status STATUS_RUNNING =
    Services_Service_Status_STATUS_RUNNING;
  static constexpr Status STATUS_START_PENDING =
    Services_Service_Status_STATUS_START_PENDING;
  static constexpr Status STATUS_STOP_PENDING =
    Services_Service_Status_STATUS_STOP_PENDING;
  static constexpr Status STATUS_STOPPED =
    Services_Service_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Services_Service_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    Services_Service_Status_Status_MIN;
  static constexpr Status Status_MAX =
    Services_Service_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    Services_Service_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return Services_Service_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return Services_Service_Status_Parse(name, value);
  }

  typedef Services_Service_StartupType StartupType;
  static constexpr StartupType STARTUP_TYPE_UNKNOWN =
    Services_Service_StartupType_STARTUP_TYPE_UNKNOWN;
  static constexpr StartupType STARTUP_TYPE_AUTO_START =
    Services_Service_StartupType_STARTUP_TYPE_AUTO_START;
  static constexpr StartupType STARTUP_TYPE_DEMAND_START =
    Services_Service_StartupType_STARTUP_TYPE_DEMAND_START;
  static constexpr StartupType STARTUP_TYPE_DISABLED =
    Services_Service_StartupType_STARTUP_TYPE_DISABLED;
  static constexpr StartupType STARTUP_TYPE_BOOT_START =
    Services_Service_StartupType_STARTUP_TYPE_BOOT_START;
  static constexpr StartupType STARTUP_TYPE_SYSTEM_START =
    Services_Service_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Services_Service_StartupType_IsValid(value);
  }
  static constexpr StartupType StartupType_MIN =
    Services_Service_StartupType_StartupType_MIN;
  static constexpr StartupType StartupType_MAX =
    Services_Service_StartupType_StartupType_MAX;
  static constexpr int StartupType_ARRAYSIZE =
    Services_Service_StartupType_StartupType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& StartupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StartupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StartupType_Name.");
    return Services_Service_StartupType_Name(enum_t_value);
  }
  static inline bool StartupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StartupType* value) {
    return Services_Service_StartupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kBinaryPathFieldNumber = 6,
    kStartNameFieldNumber = 7,
    kStatusFieldNumber = 4,
    kStartupTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string binary_path = 6;
  void clear_binary_path();
  const std::string& binary_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_path();
  PROTOBUF_NODISCARD std::string* release_binary_path();
  void set_allocated_binary_path(std::string* binary_path);
  private:
  const std::string& _internal_binary_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_path(const std::string& value);
  std::string* _internal_mutable_binary_path();
  public:

  // string start_name = 7;
  void clear_start_name();
  const std::string& start_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_name();
  PROTOBUF_NODISCARD std::string* release_start_name();
  void set_allocated_start_name(std::string* start_name);
  private:
  const std::string& _internal_start_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_name(const std::string& value);
  std::string* _internal_mutable_start_name();
  public:

  // .proto.system_info.Services.Service.Status status = 4;
  void clear_status();
  ::proto::system_info::Services_Service_Status status() const;
  void set_status(::proto::system_info::Services_Service_Status value);
  private:
  ::proto::system_info::Services_Service_Status _internal_status() const;
  void _internal_set_status(::proto::system_info::Services_Service_Status value);
  public:

  // .proto.system_info.Services.Service.StartupType startup_type = 5;
  void clear_startup_type();
  ::proto::system_info::Services_Service_StartupType startup_type() const;
  void set_startup_type(::proto::system_info::Services_Service_StartupType value);
  private:
  ::proto::system_info::Services_Service_StartupType _internal_startup_type() const;
  void _internal_set_startup_type(::proto::system_info::Services_Service_StartupType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Services.Service)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_name_;
    int status_;
    int startup_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Services final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Services) */ {
 public:
  inline Services() : Services(nullptr) {}
  ~Services() override;
  explicit PROTOBUF_CONSTEXPR Services(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Services(const Services& from);
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  inline Services& operator=(Services&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Services& default_instance() {
    return *internal_default_instance();
  }
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }
  inline void Swap(Services* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Services* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Services* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Services>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Services";
  }
  protected:
  explicit Services(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Services_Service Service;

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // repeated .proto.system_info.Services.Service service = 1;
  int service_size() const;
  private:
  int _internal_service_size() const;
  public:
  void clear_service();
  ::proto::system_info::Services_Service* mutable_service(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Services_Service >*
      mutable_service();
  private:
  const ::proto::system_info::Services_Service& _internal_service(int index) const;
  ::proto::system_info::Services_Service* _internal_add_service();
  public:
  const ::proto::system_info::Services_Service& service(int index) const;
  ::proto::system_info::Services_Service* add_service();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Services_Service >&
      service() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Services)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Services_Service > service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EnvironmentVariables_Variable final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.EnvironmentVariables.Variable) */ {
 public:
  inline EnvironmentVariables_Variable() : EnvironmentVariables_Variable(nullptr) {}
  ~EnvironmentVariables_Variable() override;
  explicit PROTOBUF_CONSTEXPR EnvironmentVariables_Variable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvironmentVariables_Variable(const EnvironmentVariables_Variable& from);
  EnvironmentVariables_Variable(EnvironmentVariables_Variable&& from) noexcept
    : EnvironmentVariables_Variable() {
    *this = ::std::move(from);
  }

  inline EnvironmentVariables_Variable& operator=(const EnvironmentVariables_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvironmentVariables_Variable& operator=(EnvironmentVariables_Variable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EnvironmentVariables_Variable& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvironmentVariables_Variable* internal_default_instance() {
    return reinterpret_cast<const EnvironmentVariables_Variable*>(
               &_EnvironmentVariables_Variable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(EnvironmentVariables_Variable& a, EnvironmentVariables_Variable& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvironmentVariables_Variable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvironmentVariables_Variable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvironmentVariables_Variable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvironmentVariables_Variable>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EnvironmentVariables_Variable& from);
  void MergeFrom(const EnvironmentVariables_Variable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnvironmentVariables_Variable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.EnvironmentVariables.Variable";
  }
  protected:
  explicit EnvironmentVariables_Variable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.EnvironmentVariables.Variable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EnvironmentVariables final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.EnvironmentVariables) */ {
 public:
  inline EnvironmentVariables() : EnvironmentVariables(nullptr) {}
  ~EnvironmentVariables() override;
  explicit PROTOBUF_CONSTEXPR EnvironmentVariables(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvironmentVariables(const EnvironmentVariables& from);
  EnvironmentVariables(EnvironmentVariables&& from) noexcept
    : EnvironmentVariables() {
    *this = ::std::move(from);
  }

  inline EnvironmentVariables& operator=(const EnvironmentVariables& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvironmentVariables& operator=(EnvironmentVariables&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EnvironmentVariables& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvironmentVariables* internal_default_instance() {
    return reinterpret_cast<const EnvironmentVariables*>(
               &_EnvironmentVariables_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(EnvironmentVariables& a, EnvironmentVariables& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvironmentVariables* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvironmentVariables* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvironmentVariables* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvironmentVariables>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EnvironmentVariables& from);
  void MergeFrom(const EnvironmentVariables& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnvironmentVariables* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.EnvironmentVariables";
  }
  protected:
  explicit EnvironmentVariables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EnvironmentVariables_Variable Variable;

  // accessors -------------------------------------------------------

  enum : int {
    kVariableFieldNumber = 1,
  };
  // repeated .proto.system_info.EnvironmentVariables.Variable variable = 1;
  int variable_size() const;
  private:
  int _internal_variable_size() const;
  public:
  void clear_variable();
  ::proto::system_info::EnvironmentVariables_Variable* mutable_variable(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EnvironmentVariables_Variable >*
      mutable_variable();
  private:
  const ::proto::system_info::EnvironmentVariables_Variable& _internal_variable(int index) const;
  ::proto::system_info::EnvironmentVariables_Variable* _internal_add_variable();
  public:
  const ::proto::system_info::EnvironmentVariables_Variable& variable(int index) const;
  ::proto::system_info::EnvironmentVariables_Variable* add_variable();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EnvironmentVariables_Variable >&
      variable() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.EnvironmentVariables)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EnvironmentVariables_Variable > variable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EventLogs_Event final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.EventLogs.Event) */ {
 public:
  inline EventLogs_Event() : EventLogs_Event(nullptr) {}
  ~EventLogs_Event() override;
  explicit PROTOBUF_CONSTEXPR EventLogs_Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventLogs_Event(const EventLogs_Event& from);
  EventLogs_Event(EventLogs_Event&& from) noexcept
    : EventLogs_Event() {
    *this = ::std::move(from);
  }

  inline EventLogs_Event& operator=(const EventLogs_Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventLogs_Event& operator=(EventLogs_Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EventLogs_Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventLogs_Event* internal_default_instance() {
    return reinterpret_cast<const EventLogs_Event*>(
               &_EventLogs_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(EventLogs_Event& a, EventLogs_Event& b) {
    a.Swap(&b);
  }
  inline void Swap(EventLogs_Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventLogs_Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventLogs_Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventLogs_Event>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventLogs_Event& from);
  void MergeFrom(const EventLogs_Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventLogs_Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.EventLogs.Event";
  }
  protected:
  explicit EventLogs_Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EventLogs_Event_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    EventLogs_Event_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_APPLICATION =
    EventLogs_Event_Type_TYPE_APPLICATION;
  static constexpr Type TYPE_SECURITY =
    EventLogs_Event_Type_TYPE_SECURITY;
  static constexpr Type TYPE_SYSTEM =
    EventLogs_Event_Type_TYPE_SYSTEM;
  static inline bool Type_IsValid(int value) {
    return EventLogs_Event_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    EventLogs_Event_Type_Type_MIN;
  static constexpr Type Type_MAX =
    EventLogs_Event_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    EventLogs_Event_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return EventLogs_Event_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return EventLogs_Event_Type_Parse(name, value);
  }

  typedef EventLogs_Event_Level Level;
  static constexpr Level LEVEL_UNKNOWN =
    EventLogs_Event_Level_LEVEL_UNKNOWN;
  static constexpr Level LEVEL_SUCCESS =
    EventLogs_Event_Level_LEVEL_SUCCESS;
  static constexpr Level LEVEL_INFORMATION =
    EventLogs_Event_Level_LEVEL_INFORMATION;
  static constexpr Level LEVEL_WARNING =
    EventLogs_Event_Level_LEVEL_WARNING;
  static constexpr Level LEVEL_ERROR =
    EventLogs_Event_Level_LEVEL_ERROR;
  static constexpr Level LEVEL_AUDIT_SUCCESS =
    EventLogs_Event_Level_LEVEL_AUDIT_SUCCESS;
  static constexpr Level LEVEL_AUDIT_FAILURE =
    EventLogs_Event_Level_LEVEL_AUDIT_FAILURE;
  static inline bool Level_IsValid(int value) {
    return EventLogs_Event_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    EventLogs_Event_Level_Level_MIN;
  static constexpr Level Level_MAX =
    EventLogs_Event_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    EventLogs_Event_Level_Level_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return EventLogs_Event_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return EventLogs_Event_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 3,
    kSourceFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kTimeFieldNumber = 2,
    kLevelFieldNumber = 1,
    kEventIdFieldNumber = 4,
  };
  // string category = 3;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string source = 5;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string description = 6;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int64 time = 2;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // .proto.system_info.EventLogs.Event.Level level = 1;
  void clear_level();
  ::proto::system_info::EventLogs_Event_Level level() const;
  void set_level(::proto::system_info::EventLogs_Event_Level value);
  private:
  ::proto::system_info::EventLogs_Event_Level _internal_level() const;
  void _internal_set_level(::proto::system_info::EventLogs_Event_Level value);
  public:

  // uint32 event_id = 4;
  void clear_event_id();
  uint32_t event_id() const;
  void set_event_id(uint32_t value);
  private:
  uint32_t _internal_event_id() const;
  void _internal_set_event_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.EventLogs.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int64_t time_;
    int level_;
    uint32_t event_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EventLogs final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.EventLogs) */ {
 public:
  inline EventLogs() : EventLogs(nullptr) {}
  ~EventLogs() override;
  explicit PROTOBUF_CONSTEXPR EventLogs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventLogs(const EventLogs& from);
  EventLogs(EventLogs&& from) noexcept
    : EventLogs() {
    *this = ::std::move(from);
  }

  inline EventLogs& operator=(const EventLogs& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventLogs& operator=(EventLogs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EventLogs& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventLogs* internal_default_instance() {
    return reinterpret_cast<const EventLogs*>(
               &_EventLogs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(EventLogs& a, EventLogs& b) {
    a.Swap(&b);
  }
  inline void Swap(EventLogs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventLogs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventLogs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventLogs>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventLogs& from);
  void MergeFrom(const EventLogs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventLogs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.EventLogs";
  }
  protected:
  explicit EventLogs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EventLogs_Event Event;

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 3,
    kTypeFieldNumber = 1,
    kTotalRecordsFieldNumber = 2,
  };
  // repeated .proto.system_info.EventLogs.Event event = 3;
  int event_size() const;
  private:
  int _internal_event_size() const;
  public:
  void clear_event();
  ::proto::system_info::EventLogs_Event* mutable_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EventLogs_Event >*
      mutable_event();
  private:
  const ::proto::system_info::EventLogs_Event& _internal_event(int index) const;
  ::proto::system_info::EventLogs_Event* _internal_add_event();
  public:
  const ::proto::system_info::EventLogs_Event& event(int index) const;
  ::proto::system_info::EventLogs_Event* add_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EventLogs_Event >&
      event() const;

  // .proto.system_info.EventLogs.Event.Type type = 1;
  void clear_type();
  ::proto::system_info::EventLogs_Event_Type type() const;
  void set_type(::proto::system_info::EventLogs_Event_Type value);
  private:
  ::proto::system_info::EventLogs_Event_Type _internal_type() const;
  void _internal_set_type(::proto::system_info::EventLogs_Event_Type value);
  public:

  // uint32 total_records = 2;
  void clear_total_records();
  uint32_t total_records() const;
  void set_total_records(uint32_t value);
  private:
  uint32_t _internal_total_records() const;
  void _internal_set_total_records(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.EventLogs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EventLogs_Event > event_;
    int type_;
    uint32_t total_records_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EventLogsData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.EventLogsData) */ {
 public:
  inline EventLogsData() : EventLogsData(nullptr) {}
  ~EventLogsData() override;
  explicit PROTOBUF_CONSTEXPR EventLogsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventLogsData(const EventLogsData& from);
  EventLogsData(EventLogsData&& from) noexcept
    : EventLogsData() {
    *this = ::std::move(from);
  }

  inline EventLogsData& operator=(const EventLogsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventLogsData& operator=(EventLogsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EventLogsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventLogsData* internal_default_instance() {
    return reinterpret_cast<const EventLogsData*>(
               &_EventLogsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(EventLogsData& a, EventLogsData& b) {
    a.Swap(&b);
  }
  inline void Swap(EventLogsData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventLogsData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventLogsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventLogsData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventLogsData& from);
  void MergeFrom(const EventLogsData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventLogsData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.EventLogsData";
  }
  protected:
  explicit EventLogsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kRecordStartFieldNumber = 2,
    kRecordCountFieldNumber = 3,
  };
  // .proto.system_info.EventLogs.Event.Type type = 1;
  void clear_type();
  ::proto::system_info::EventLogs_Event_Type type() const;
  void set_type(::proto::system_info::EventLogs_Event_Type value);
  private:
  ::proto::system_info::EventLogs_Event_Type _internal_type() const;
  void _internal_set_type(::proto::system_info::EventLogs_Event_Type value);
  public:

  // uint32 record_start = 2;
  void clear_record_start();
  uint32_t record_start() const;
  void set_record_start(uint32_t value);
  private:
  uint32_t _internal_record_start() const;
  void _internal_set_record_start(uint32_t value);
  public:

  // uint32 record_count = 3;
  void clear_record_count();
  uint32_t record_count() const;
  void set_record_count(uint32_t value);
  private:
  uint32_t _internal_record_count() const;
  void _internal_set_record_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.EventLogsData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    uint32_t record_start_;
    uint32_t record_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Routes_Route final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Routes.Route) */ {
 public:
  inline Routes_Route() : Routes_Route(nullptr) {}
  ~Routes_Route() override;
  explicit PROTOBUF_CONSTEXPR Routes_Route(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routes_Route(const Routes_Route& from);
  Routes_Route(Routes_Route&& from) noexcept
    : Routes_Route() {
    *this = ::std::move(from);
  }

  inline Routes_Route& operator=(const Routes_Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routes_Route& operator=(Routes_Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Routes_Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const Routes_Route* internal_default_instance() {
    return reinterpret_cast<const Routes_Route*>(
               &_Routes_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Routes_Route& a, Routes_Route& b) {
    a.Swap(&b);
  }
  inline void Swap(Routes_Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routes_Route* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routes_Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routes_Route>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Routes_Route& from);
  void MergeFrom(const Routes_Route& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes_Route* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Routes.Route";
  }
  protected:
  explicit Routes_Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestonationFieldNumber = 1,
    kMaskFieldNumber = 2,
    kGatewayFieldNumber = 3,
    kMetricFieldNumber = 4,
  };
  // string destonation = 1;
  void clear_destonation();
  const std::string& destonation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destonation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destonation();
  PROTOBUF_NODISCARD std::string* release_destonation();
  void set_allocated_destonation(std::string* destonation);
  private:
  const std::string& _internal_destonation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destonation(const std::string& value);
  std::string* _internal_mutable_destonation();
  public:

  // string mask = 2;
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // string gateway = 3;
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // uint32 metric = 4;
  void clear_metric();
  uint32_t metric() const;
  void set_metric(uint32_t value);
  private:
  uint32_t _internal_metric() const;
  void _internal_set_metric(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Routes.Route)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destonation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    uint32_t metric_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Routes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Routes) */ {
 public:
  inline Routes() : Routes(nullptr) {}
  ~Routes() override;
  explicit PROTOBUF_CONSTEXPR Routes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routes(const Routes& from);
  Routes(Routes&& from) noexcept
    : Routes() {
    *this = ::std::move(from);
  }

  inline Routes& operator=(const Routes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routes& operator=(Routes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Routes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Routes* internal_default_instance() {
    return reinterpret_cast<const Routes*>(
               &_Routes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Routes& a, Routes& b) {
    a.Swap(&b);
  }
  inline void Swap(Routes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Routes& from);
  void MergeFrom(const Routes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Routes";
  }
  protected:
  explicit Routes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Routes_Route Route;

  // accessors -------------------------------------------------------

  enum : int {
    kRouteFieldNumber = 1,
  };
  // repeated .proto.system_info.Routes.Route route = 1;
  int route_size() const;
  private:
  int _internal_route_size() const;
  public:
  void clear_route();
  ::proto::system_info::Routes_Route* mutable_route(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Routes_Route >*
      mutable_route();
  private:
  const ::proto::system_info::Routes_Route& _internal_route(int index) const;
  ::proto::system_info::Routes_Route* _internal_add_route();
  public:
  const ::proto::system_info::Routes_Route& route(int index) const;
  ::proto::system_info::Routes_Route* add_route();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Routes_Route >&
      route() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Routes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Routes_Route > route_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Connections_Connection final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Connections.Connection) */ {
 public:
  inline Connections_Connection() : Connections_Connection(nullptr) {}
  ~Connections_Connection() override;
  explicit PROTOBUF_CONSTEXPR Connections_Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connections_Connection(const Connections_Connection& from);
  Connections_Connection(Connections_Connection&& from) noexcept
    : Connections_Connection() {
    *this = ::std::move(from);
  }

  inline Connections_Connection& operator=(const Connections_Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connections_Connection& operator=(Connections_Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Connections_Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connections_Connection* internal_default_instance() {
    return reinterpret_cast<const Connections_Connection*>(
               &_Connections_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Connections_Connection& a, Connections_Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connections_Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connections_Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connections_Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connections_Connection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Connections_Connection& from);
  void MergeFrom(const Connections_Connection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Connections_Connection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Connections.Connection";
  }
  protected:
  explicit Connections_Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessNameFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kLocalAddressFieldNumber = 3,
    kRemoteAddressFieldNumber = 4,
    kStateFieldNumber = 7,
    kLocalPortFieldNumber = 5,
    kRemotePortFieldNumber = 6,
  };
  // string process_name = 1;
  void clear_process_name();
  const std::string& process_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_process_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_process_name();
  PROTOBUF_NODISCARD std::string* release_process_name();
  void set_allocated_process_name(std::string* process_name);
  private:
  const std::string& _internal_process_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_name(const std::string& value);
  std::string* _internal_mutable_process_name();
  public:

  // string protocol = 2;
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // string local_address = 3;
  void clear_local_address();
  const std::string& local_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_address();
  PROTOBUF_NODISCARD std::string* release_local_address();
  void set_allocated_local_address(std::string* local_address);
  private:
  const std::string& _internal_local_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_address(const std::string& value);
  std::string* _internal_mutable_local_address();
  public:

  // string remote_address = 4;
  void clear_remote_address();
  const std::string& remote_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_address();
  PROTOBUF_NODISCARD std::string* release_remote_address();
  void set_allocated_remote_address(std::string* remote_address);
  private:
  const std::string& _internal_remote_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_address(const std::string& value);
  std::string* _internal_mutable_remote_address();
  public:

  // string state = 7;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // uint32 local_port = 5;
  void clear_local_port();
  uint32_t local_port() const;
  void set_local_port(uint32_t value);
  private:
  uint32_t _internal_local_port() const;
  void _internal_set_local_port(uint32_t value);
  public:

  // uint32 remote_port = 6;
  void clear_remote_port();
  uint32_t remote_port() const;
  void set_remote_port(uint32_t value);
  private:
  uint32_t _internal_remote_port() const;
  void _internal_set_remote_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Connections.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    uint32_t local_port_;
    uint32_t remote_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Connections final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Connections) */ {
 public:
  inline Connections() : Connections(nullptr) {}
  ~Connections() override;
  explicit PROTOBUF_CONSTEXPR Connections(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connections(const Connections& from);
  Connections(Connections&& from) noexcept
    : Connections() {
    *this = ::std::move(from);
  }

  inline Connections& operator=(const Connections& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connections& operator=(Connections&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Connections& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connections* internal_default_instance() {
    return reinterpret_cast<const Connections*>(
               &_Connections_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Connections& a, Connections& b) {
    a.Swap(&b);
  }
  inline void Swap(Connections* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connections* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connections* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connections>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Connections& from);
  void MergeFrom(const Connections& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Connections* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Connections";
  }
  protected:
  explicit Connections(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Connections_Connection Connection;

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionFieldNumber = 1,
  };
  // repeated .proto.system_info.Connections.Connection connection = 1;
  int connection_size() const;
  private:
  int _internal_connection_size() const;
  public:
  void clear_connection();
  ::proto::system_info::Connections_Connection* mutable_connection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Connections_Connection >*
      mutable_connection();
  private:
  const ::proto::system_info::Connections_Connection& _internal_connection(int index) const;
  ::proto::system_info::Connections_Connection* _internal_add_connection();
  public:
  const ::proto::system_info::Connections_Connection& connection(int index) const;
  ::proto::system_info::Connections_Connection* add_connection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Connections_Connection >&
      connection() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Connections)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Connections_Connection > connection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Licenses_License_Field final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Licenses.License.Field) */ {
 public:
  inline Licenses_License_Field() : Licenses_License_Field(nullptr) {}
  ~Licenses_License_Field() override;
  explicit PROTOBUF_CONSTEXPR Licenses_License_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Licenses_License_Field(const Licenses_License_Field& from);
  Licenses_License_Field(Licenses_License_Field&& from) noexcept
    : Licenses_License_Field() {
    *this = ::std::move(from);
  }

  inline Licenses_License_Field& operator=(const Licenses_License_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Licenses_License_Field& operator=(Licenses_License_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Licenses_License_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Licenses_License_Field* internal_default_instance() {
    return reinterpret_cast<const Licenses_License_Field*>(
               &_Licenses_License_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Licenses_License_Field& a, Licenses_License_Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Licenses_License_Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Licenses_License_Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Licenses_License_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Licenses_License_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Licenses_License_Field& from);
  void MergeFrom(const Licenses_License_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Licenses_License_Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Licenses.License.Field";
  }
  protected:
  explicit Licenses_License_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Licenses_License_Field_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    Licenses_License_Field_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_OWNER =
    Licenses_License_Field_Type_TYPE_OWNER;
  static constexpr Type TYPE_ORGANIZATION =
    Licenses_License_Field_Type_TYPE_ORGANIZATION;
  static constexpr Type TYPE_PRODUCT_KEY =
    Licenses_License_Field_Type_TYPE_PRODUCT_KEY;
  static constexpr Type TYPE_PRODUCT_ID =
    Licenses_License_Field_Type_TYPE_PRODUCT_ID;
  static constexpr Type TYPE_LICENSE_VERSION =
    Licenses_License_Field_Type_TYPE_LICENSE_VERSION;
  static constexpr Type TYPE_LICENSE_TYPE =
    Licenses_License_Field_Type_TYPE_LICENSE_TYPE;
  static inline bool Type_IsValid(int value) {
    return Licenses_License_Field_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Licenses_License_Field_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Licenses_License_Field_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Licenses_License_Field_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Licenses_License_Field_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Licenses_License_Field_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .proto.system_info.Licenses.License.Field.Type type = 1;
  void clear_type();
  ::proto::system_info::Licenses_License_Field_Type type() const;
  void set_type(::proto::system_info::Licenses_License_Field_Type value);
  private:
  ::proto::system_info::Licenses_License_Field_Type _internal_type() const;
  void _internal_set_type(::proto::system_info::Licenses_License_Field_Type value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Licenses.License.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Licenses_License final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Licenses.License) */ {
 public:
  inline Licenses_License() : Licenses_License(nullptr) {}
  ~Licenses_License() override;
  explicit PROTOBUF_CONSTEXPR Licenses_License(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Licenses_License(const Licenses_License& from);
  Licenses_License(Licenses_License&& from) noexcept
    : Licenses_License() {
    *this = ::std::move(from);
  }

  inline Licenses_License& operator=(const Licenses_License& from) {
    CopyFrom(from);
    return *this;
  }
  inline Licenses_License& operator=(Licenses_License&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Licenses_License& default_instance() {
    return *internal_default_instance();
  }
  static inline const Licenses_License* internal_default_instance() {
    return reinterpret_cast<const Licenses_License*>(
               &_Licenses_License_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Licenses_License& a, Licenses_License& b) {
    a.Swap(&b);
  }
  inline void Swap(Licenses_License* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Licenses_License* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Licenses_License* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Licenses_License>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Licenses_License& from);
  void MergeFrom(const Licenses_License& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Licenses_License* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Licenses.License";
  }
  protected:
  explicit Licenses_License(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Licenses_License_Field Field;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 2,
    kProductNameFieldNumber = 1,
  };
  // repeated .proto.system_info.Licenses.License.Field field = 2;
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::proto::system_info::Licenses_License_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License_Field >*
      mutable_field();
  private:
  const ::proto::system_info::Licenses_License_Field& _internal_field(int index) const;
  ::proto::system_info::Licenses_License_Field* _internal_add_field();
  public:
  const ::proto::system_info::Licenses_License_Field& field(int index) const;
  ::proto::system_info::Licenses_License_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License_Field >&
      field() const;

  // string product_name = 1;
  void clear_product_name();
  const std::string& product_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_name();
  PROTOBUF_NODISCARD std::string* release_product_name();
  void set_allocated_product_name(std::string* product_name);
  private:
  const std::string& _internal_product_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_name(const std::string& value);
  std::string* _internal_mutable_product_name();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Licenses.License)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License_Field > field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Licenses final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Licenses) */ {
 public:
  inline Licenses() : Licenses(nullptr) {}
  ~Licenses() override;
  explicit PROTOBUF_CONSTEXPR Licenses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Licenses(const Licenses& from);
  Licenses(Licenses&& from) noexcept
    : Licenses() {
    *this = ::std::move(from);
  }

  inline Licenses& operator=(const Licenses& from) {
    CopyFrom(from);
    return *this;
  }
  inline Licenses& operator=(Licenses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Licenses& default_instance() {
    return *internal_default_instance();
  }
  static inline const Licenses* internal_default_instance() {
    return reinterpret_cast<const Licenses*>(
               &_Licenses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Licenses& a, Licenses& b) {
    a.Swap(&b);
  }
  inline void Swap(Licenses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Licenses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Licenses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Licenses>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Licenses& from);
  void MergeFrom(const Licenses& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Licenses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Licenses";
  }
  protected:
  explicit Licenses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Licenses_License License;

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseFieldNumber = 1,
  };
  // repeated .proto.system_info.Licenses.License license = 1;
  int license_size() const;
  private:
  int _internal_license_size() const;
  public:
  void clear_license();
  ::proto::system_info::Licenses_License* mutable_license(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License >*
      mutable_license();
  private:
  const ::proto::system_info::Licenses_License& _internal_license(int index) const;
  ::proto::system_info::Licenses_License* _internal_add_license();
  public:
  const ::proto::system_info::Licenses_License& license(int index) const;
  ::proto::system_info::Licenses_License* add_license();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License >&
      license() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Licenses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License > license_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Applications_Application final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Applications.Application) */ {
 public:
  inline Applications_Application() : Applications_Application(nullptr) {}
  ~Applications_Application() override;
  explicit PROTOBUF_CONSTEXPR Applications_Application(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Applications_Application(const Applications_Application& from);
  Applications_Application(Applications_Application&& from) noexcept
    : Applications_Application() {
    *this = ::std::move(from);
  }

  inline Applications_Application& operator=(const Applications_Application& from) {
    CopyFrom(from);
    return *this;
  }
  inline Applications_Application& operator=(Applications_Application&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Applications_Application& default_instance() {
    return *internal_default_instance();
  }
  static inline const Applications_Application* internal_default_instance() {
    return reinterpret_cast<const Applications_Application*>(
               &_Applications_Application_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Applications_Application& a, Applications_Application& b) {
    a.Swap(&b);
  }
  inline void Swap(Applications_Application* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Applications_Application* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Applications_Application* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Applications_Application>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Applications_Application& from);
  void MergeFrom(const Applications_Application& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Applications_Application* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Applications.Application";
  }
  protected:
  explicit Applications_Application(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPublisherFieldNumber = 3,
    kInstallDateFieldNumber = 4,
    kInstallLocationFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string publisher = 3;
  void clear_publisher();
  const std::string& publisher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publisher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* publisher);
  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(const std::string& value);
  std::string* _internal_mutable_publisher();
  public:

  // string install_date = 4;
  void clear_install_date();
  const std::string& install_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_install_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_install_date();
  PROTOBUF_NODISCARD std::string* release_install_date();
  void set_allocated_install_date(std::string* install_date);
  private:
  const std::string& _internal_install_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_install_date(const std::string& value);
  std::string* _internal_mutable_install_date();
  public:

  // string install_location = 5;
  void clear_install_location();
  const std::string& install_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_install_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_install_location();
  PROTOBUF_NODISCARD std::string* release_install_location();
  void set_allocated_install_location(std::string* install_location);
  private:
  const std::string& _internal_install_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_install_location(const std::string& value);
  std::string* _internal_mutable_install_location();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Applications.Application)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publisher_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr install_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr install_location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Applications final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Applications) */ {
 public:
  inline Applications() : Applications(nullptr) {}
  ~Applications() override;
  explicit PROTOBUF_CONSTEXPR Applications(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Applications(const Applications& from);
  Applications(Applications&& from) noexcept
    : Applications() {
    *this = ::std::move(from);
  }

  inline Applications& operator=(const Applications& from) {
    CopyFrom(from);
    return *this;
  }
  inline Applications& operator=(Applications&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Applications& default_instance() {
    return *internal_default_instance();
  }
  static inline const Applications* internal_default_instance() {
    return reinterpret_cast<const Applications*>(
               &_Applications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Applications& a, Applications& b) {
    a.Swap(&b);
  }
  inline void Swap(Applications* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Applications* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Applications* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Applications>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Applications& from);
  void MergeFrom(const Applications& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Applications* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Applications";
  }
  protected:
  explicit Applications(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Applications_Application Application;

  // accessors -------------------------------------------------------

  enum : int {
    kApplicationFieldNumber = 1,
  };
  // repeated .proto.system_info.Applications.Application application = 1;
  int application_size() const;
  private:
  int _internal_application_size() const;
  public:
  void clear_application();
  ::proto::system_info::Applications_Application* mutable_application(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Applications_Application >*
      mutable_application();
  private:
  const ::proto::system_info::Applications_Application& _internal_application(int index) const;
  ::proto::system_info::Applications_Application* _internal_add_application();
  public:
  const ::proto::system_info::Applications_Application& application(int index) const;
  ::proto::system_info::Applications_Application* add_application();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Applications_Application >&
      application() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Applications)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Applications_Application > application_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class OpenFiles_OpenFile final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.OpenFiles.OpenFile) */ {
 public:
  inline OpenFiles_OpenFile() : OpenFiles_OpenFile(nullptr) {}
  ~OpenFiles_OpenFile() override;
  explicit PROTOBUF_CONSTEXPR OpenFiles_OpenFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenFiles_OpenFile(const OpenFiles_OpenFile& from);
  OpenFiles_OpenFile(OpenFiles_OpenFile&& from) noexcept
    : OpenFiles_OpenFile() {
    *this = ::std::move(from);
  }

  inline OpenFiles_OpenFile& operator=(const OpenFiles_OpenFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenFiles_OpenFile& operator=(OpenFiles_OpenFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const OpenFiles_OpenFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenFiles_OpenFile* internal_default_instance() {
    return reinterpret_cast<const OpenFiles_OpenFile*>(
               &_OpenFiles_OpenFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(OpenFiles_OpenFile& a, OpenFiles_OpenFile& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenFiles_OpenFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenFiles_OpenFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenFiles_OpenFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenFiles_OpenFile>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OpenFiles_OpenFile& from);
  void MergeFrom(const OpenFiles_OpenFile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenFiles_OpenFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.OpenFiles.OpenFile";
  }
  protected:
  explicit OpenFiles_OpenFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kFilePathFieldNumber = 4,
    kIdFieldNumber = 1,
    kLockCountFieldNumber = 3,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string file_path = 4;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 lock_count = 3;
  void clear_lock_count();
  uint32_t lock_count() const;
  void set_lock_count(uint32_t value);
  private:
  uint32_t _internal_lock_count() const;
  void _internal_set_lock_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.OpenFiles.OpenFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    uint32_t id_;
    uint32_t lock_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class OpenFiles final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.OpenFiles) */ {
 public:
  inline OpenFiles() : OpenFiles(nullptr) {}
  ~OpenFiles() override;
  explicit PROTOBUF_CONSTEXPR OpenFiles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenFiles(const OpenFiles& from);
  OpenFiles(OpenFiles&& from) noexcept
    : OpenFiles() {
    *this = ::std::move(from);
  }

  inline OpenFiles& operator=(const OpenFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenFiles& operator=(OpenFiles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const OpenFiles& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenFiles* internal_default_instance() {
    return reinterpret_cast<const OpenFiles*>(
               &_OpenFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(OpenFiles& a, OpenFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenFiles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenFiles>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OpenFiles& from);
  void MergeFrom(const OpenFiles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenFiles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.OpenFiles";
  }
  protected:
  explicit OpenFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef OpenFiles_OpenFile OpenFile;

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFileFieldNumber = 1,
  };
  // repeated .proto.system_info.OpenFiles.OpenFile open_file = 1;
  int open_file_size() const;
  private:
  int _internal_open_file_size() const;
  public:
  void clear_open_file();
  ::proto::system_info::OpenFiles_OpenFile* mutable_open_file(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::OpenFiles_OpenFile >*
      mutable_open_file();
  private:
  const ::proto::system_info::OpenFiles_OpenFile& _internal_open_file(int index) const;
  ::proto::system_info::OpenFiles_OpenFile* _internal_add_open_file();
  public:
  const ::proto::system_info::OpenFiles_OpenFile& open_file(int index) const;
  ::proto::system_info::OpenFiles_OpenFile* add_open_file();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::OpenFiles_OpenFile >&
      open_file() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.OpenFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::OpenFiles_OpenFile > open_file_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LocalUsers_LocalUser_LocalUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LocalUsers.LocalUser.LocalUserGroup) */ {
 public:
  inline LocalUsers_LocalUser_LocalUserGroup() : LocalUsers_LocalUser_LocalUserGroup(nullptr) {}
  ~LocalUsers_LocalUser_LocalUserGroup() override;
  explicit PROTOBUF_CONSTEXPR LocalUsers_LocalUser_LocalUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalUsers_LocalUser_LocalUserGroup(const LocalUsers_LocalUser_LocalUserGroup& from);
  LocalUsers_LocalUser_LocalUserGroup(LocalUsers_LocalUser_LocalUserGroup&& from) noexcept
    : LocalUsers_LocalUser_LocalUserGroup() {
    *this = ::std::move(from);
  }

  inline LocalUsers_LocalUser_LocalUserGroup& operator=(const LocalUsers_LocalUser_LocalUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalUsers_LocalUser_LocalUserGroup& operator=(LocalUsers_LocalUser_LocalUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LocalUsers_LocalUser_LocalUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalUsers_LocalUser_LocalUserGroup* internal_default_instance() {
    return reinterpret_cast<const LocalUsers_LocalUser_LocalUserGroup*>(
               &_LocalUsers_LocalUser_LocalUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(LocalUsers_LocalUser_LocalUserGroup& a, LocalUsers_LocalUser_LocalUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalUsers_LocalUser_LocalUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalUsers_LocalUser_LocalUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalUsers_LocalUser_LocalUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalUsers_LocalUser_LocalUserGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocalUsers_LocalUser_LocalUserGroup& from);
  void MergeFrom(const LocalUsers_LocalUser_LocalUserGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalUsers_LocalUser_LocalUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LocalUsers.LocalUser.LocalUserGroup";
  }
  protected:
  explicit LocalUsers_LocalUser_LocalUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommentFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.LocalUsers.LocalUser.LocalUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LocalUsers_LocalUser final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LocalUsers.LocalUser) */ {
 public:
  inline LocalUsers_LocalUser() : LocalUsers_LocalUser(nullptr) {}
  ~LocalUsers_LocalUser() override;
  explicit PROTOBUF_CONSTEXPR LocalUsers_LocalUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalUsers_LocalUser(const LocalUsers_LocalUser& from);
  LocalUsers_LocalUser(LocalUsers_LocalUser&& from) noexcept
    : LocalUsers_LocalUser() {
    *this = ::std::move(from);
  }

  inline LocalUsers_LocalUser& operator=(const LocalUsers_LocalUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalUsers_LocalUser& operator=(LocalUsers_LocalUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LocalUsers_LocalUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalUsers_LocalUser* internal_default_instance() {
    return reinterpret_cast<const LocalUsers_LocalUser*>(
               &_LocalUsers_LocalUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(LocalUsers_LocalUser& a, LocalUsers_LocalUser& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalUsers_LocalUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalUsers_LocalUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalUsers_LocalUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalUsers_LocalUser>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocalUsers_LocalUser& from);
  void MergeFrom(const LocalUsers_LocalUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalUsers_LocalUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LocalUsers.LocalUser";
  }
  protected:
  explicit LocalUsers_LocalUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LocalUsers_LocalUser_LocalUserGroup LocalUserGroup;

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 5,
    kNameFieldNumber = 1,
    kFullNameFieldNumber = 2,
    kCommentFieldNumber = 3,
    kHomeDirFieldNumber = 4,
    kDisabledFieldNumber = 6,
    kPasswordCantChangeFieldNumber = 7,
    kPasswordExpiredFieldNumber = 8,
    kDontExpirePasswordFieldNumber = 9,
    kLockoutFieldNumber = 10,
    kNumberLogonsFieldNumber = 11,
    kBadPasswordCountFieldNumber = 12,
    kLastLogonTimeFieldNumber = 13,
  };
  // repeated .proto.system_info.LocalUsers.LocalUser.LocalUserGroup group = 5;
  int group_size() const;
  private:
  int _internal_group_size() const;
  public:
  void clear_group();
  ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* mutable_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup >*
      mutable_group();
  private:
  const ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup& _internal_group(int index) const;
  ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* _internal_add_group();
  public:
  const ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup& group(int index) const;
  ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* add_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup >&
      group() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string full_name = 2;
  void clear_full_name();
  const std::string& full_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_name();
  PROTOBUF_NODISCARD std::string* release_full_name();
  void set_allocated_full_name(std::string* full_name);
  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(const std::string& value);
  std::string* _internal_mutable_full_name();
  public:

  // string comment = 3;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string home_dir = 4;
  void clear_home_dir();
  const std::string& home_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_home_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_home_dir();
  PROTOBUF_NODISCARD std::string* release_home_dir();
  void set_allocated_home_dir(std::string* home_dir);
  private:
  const std::string& _internal_home_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_home_dir(const std::string& value);
  std::string* _internal_mutable_home_dir();
  public:

  // bool disabled = 6;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // bool password_cant_change = 7;
  void clear_password_cant_change();
  bool password_cant_change() const;
  void set_password_cant_change(bool value);
  private:
  bool _internal_password_cant_change() const;
  void _internal_set_password_cant_change(bool value);
  public:

  // bool password_expired = 8;
  void clear_password_expired();
  bool password_expired() const;
  void set_password_expired(bool value);
  private:
  bool _internal_password_expired() const;
  void _internal_set_password_expired(bool value);
  public:

  // bool dont_expire_password = 9;
  void clear_dont_expire_password();
  bool dont_expire_password() const;
  void set_dont_expire_password(bool value);
  private:
  bool _internal_dont_expire_password() const;
  void _internal_set_dont_expire_password(bool value);
  public:

  // bool lockout = 10;
  void clear_lockout();
  bool lockout() const;
  void set_lockout(bool value);
  private:
  bool _internal_lockout() const;
  void _internal_set_lockout(bool value);
  public:

  // uint32 number_logons = 11;
  void clear_number_logons();
  uint32_t number_logons() const;
  void set_number_logons(uint32_t value);
  private:
  uint32_t _internal_number_logons() const;
  void _internal_set_number_logons(uint32_t value);
  public:

  // uint32 bad_password_count = 12;
  void clear_bad_password_count();
  uint32_t bad_password_count() const;
  void set_bad_password_count(uint32_t value);
  private:
  uint32_t _internal_bad_password_count() const;
  void _internal_set_bad_password_count(uint32_t value);
  public:

  // uint64 last_logon_time = 13;
  void clear_last_logon_time();
  uint64_t last_logon_time() const;
  void set_last_logon_time(uint64_t value);
  private:
  uint64_t _internal_last_logon_time() const;
  void _internal_set_last_logon_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.LocalUsers.LocalUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup > group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr home_dir_;
    bool disabled_;
    bool password_cant_change_;
    bool password_expired_;
    bool dont_expire_password_;
    bool lockout_;
    uint32_t number_logons_;
    uint32_t bad_password_count_;
    uint64_t last_logon_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LocalUsers final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LocalUsers) */ {
 public:
  inline LocalUsers() : LocalUsers(nullptr) {}
  ~LocalUsers() override;
  explicit PROTOBUF_CONSTEXPR LocalUsers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalUsers(const LocalUsers& from);
  LocalUsers(LocalUsers&& from) noexcept
    : LocalUsers() {
    *this = ::std::move(from);
  }

  inline LocalUsers& operator=(const LocalUsers& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalUsers& operator=(LocalUsers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LocalUsers& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalUsers* internal_default_instance() {
    return reinterpret_cast<const LocalUsers*>(
               &_LocalUsers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(LocalUsers& a, LocalUsers& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalUsers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalUsers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalUsers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalUsers>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocalUsers& from);
  void MergeFrom(const LocalUsers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalUsers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LocalUsers";
  }
  protected:
  explicit LocalUsers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LocalUsers_LocalUser LocalUser;

  // accessors -------------------------------------------------------

  enum : int {
    kLocalUserFieldNumber = 1,
  };
  // repeated .proto.system_info.LocalUsers.LocalUser local_user = 1;
  int local_user_size() const;
  private:
  int _internal_local_user_size() const;
  public:
  void clear_local_user();
  ::proto::system_info::LocalUsers_LocalUser* mutable_local_user(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser >*
      mutable_local_user();
  private:
  const ::proto::system_info::LocalUsers_LocalUser& _internal_local_user(int index) const;
  ::proto::system_info::LocalUsers_LocalUser* _internal_add_local_user();
  public:
  const ::proto::system_info::LocalUsers_LocalUser& local_user(int index) const;
  ::proto::system_info::LocalUsers_LocalUser* add_local_user();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser >&
      local_user() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.LocalUsers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser > local_user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LocalUserGroups_LocalUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LocalUserGroups.LocalUserGroup) */ {
 public:
  inline LocalUserGroups_LocalUserGroup() : LocalUserGroups_LocalUserGroup(nullptr) {}
  ~LocalUserGroups_LocalUserGroup() override;
  explicit PROTOBUF_CONSTEXPR LocalUserGroups_LocalUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalUserGroups_LocalUserGroup(const LocalUserGroups_LocalUserGroup& from);
  LocalUserGroups_LocalUserGroup(LocalUserGroups_LocalUserGroup&& from) noexcept
    : LocalUserGroups_LocalUserGroup() {
    *this = ::std::move(from);
  }

  inline LocalUserGroups_LocalUserGroup& operator=(const LocalUserGroups_LocalUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalUserGroups_LocalUserGroup& operator=(LocalUserGroups_LocalUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LocalUserGroups_LocalUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalUserGroups_LocalUserGroup* internal_default_instance() {
    return reinterpret_cast<const LocalUserGroups_LocalUserGroup*>(
               &_LocalUserGroups_LocalUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(LocalUserGroups_LocalUserGroup& a, LocalUserGroups_LocalUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalUserGroups_LocalUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalUserGroups_LocalUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalUserGroups_LocalUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalUserGroups_LocalUserGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocalUserGroups_LocalUserGroup& from);
  void MergeFrom(const LocalUserGroups_LocalUserGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalUserGroups_LocalUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LocalUserGroups.LocalUserGroup";
  }
  protected:
  explicit LocalUserGroups_LocalUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommentFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string comment = 2;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.LocalUserGroups.LocalUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class LocalUserGroups final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.LocalUserGroups) */ {
 public:
  inline LocalUserGroups() : LocalUserGroups(nullptr) {}
  ~LocalUserGroups() override;
  explicit PROTOBUF_CONSTEXPR LocalUserGroups(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalUserGroups(const LocalUserGroups& from);
  LocalUserGroups(LocalUserGroups&& from) noexcept
    : LocalUserGroups() {
    *this = ::std::move(from);
  }

  inline LocalUserGroups& operator=(const LocalUserGroups& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalUserGroups& operator=(LocalUserGroups&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LocalUserGroups& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalUserGroups* internal_default_instance() {
    return reinterpret_cast<const LocalUserGroups*>(
               &_LocalUserGroups_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(LocalUserGroups& a, LocalUserGroups& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalUserGroups* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalUserGroups* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalUserGroups* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalUserGroups>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocalUserGroups& from);
  void MergeFrom(const LocalUserGroups& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalUserGroups* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.LocalUserGroups";
  }
  protected:
  explicit LocalUserGroups(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LocalUserGroups_LocalUserGroup LocalUserGroup;

  // accessors -------------------------------------------------------

  enum : int {
    kLocalUserGroupFieldNumber = 1,
  };
  // repeated .proto.system_info.LocalUserGroups.LocalUserGroup local_user_group = 1;
  int local_user_group_size() const;
  private:
  int _internal_local_user_group_size() const;
  public:
  void clear_local_user_group();
  ::proto::system_info::LocalUserGroups_LocalUserGroup* mutable_local_user_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUserGroups_LocalUserGroup >*
      mutable_local_user_group();
  private:
  const ::proto::system_info::LocalUserGroups_LocalUserGroup& _internal_local_user_group(int index) const;
  ::proto::system_info::LocalUserGroups_LocalUserGroup* _internal_add_local_user_group();
  public:
  const ::proto::system_info::LocalUserGroups_LocalUserGroup& local_user_group(int index) const;
  ::proto::system_info::LocalUserGroups_LocalUserGroup* add_local_user_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUserGroups_LocalUserGroup >&
      local_user_group() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.LocalUserGroups)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUserGroups_LocalUserGroup > local_user_group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Processes_Process final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Processes.Process) */ {
 public:
  inline Processes_Process() : Processes_Process(nullptr) {}
  ~Processes_Process() override;
  explicit PROTOBUF_CONSTEXPR Processes_Process(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Processes_Process(const Processes_Process& from);
  Processes_Process(Processes_Process&& from) noexcept
    : Processes_Process() {
    *this = ::std::move(from);
  }

  inline Processes_Process& operator=(const Processes_Process& from) {
    CopyFrom(from);
    return *this;
  }
  inline Processes_Process& operator=(Processes_Process&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Processes_Process& default_instance() {
    return *internal_default_instance();
  }
  static inline const Processes_Process* internal_default_instance() {
    return reinterpret_cast<const Processes_Process*>(
               &_Processes_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Processes_Process& a, Processes_Process& b) {
    a.Swap(&b);
  }
  inline void Swap(Processes_Process* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Processes_Process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Processes_Process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Processes_Process>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Processes_Process& from);
  void MergeFrom(const Processes_Process& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processes_Process* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Processes.Process";
  }
  protected:
  explicit Processes_Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUserFieldNumber = 4,
    kPathFieldNumber = 5,
    kPidFieldNumber = 2,
    kSidFieldNumber = 3,
    kMemoryFieldNumber = 7,
    kCpuFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string user = 4;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string path = 5;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint32 pid = 2;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // uint32 sid = 3;
  void clear_sid();
  uint32_t sid() const;
  void set_sid(uint32_t value);
  private:
  uint32_t _internal_sid() const;
  void _internal_set_sid(uint32_t value);
  public:

  // int64 memory = 7;
  void clear_memory();
  int64_t memory() const;
  void set_memory(int64_t value);
  private:
  int64_t _internal_memory() const;
  void _internal_set_memory(int64_t value);
  public:

  // int32 cpu = 6;
  void clear_cpu();
  int32_t cpu() const;
  void set_cpu(int32_t value);
  private:
  int32_t _internal_cpu() const;
  void _internal_set_cpu(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.Processes.Process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    uint32_t pid_;
    uint32_t sid_;
    int64_t memory_;
    int32_t cpu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Processes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.Processes) */ {
 public:
  inline Processes() : Processes(nullptr) {}
  ~Processes() override;
  explicit PROTOBUF_CONSTEXPR Processes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Processes(const Processes& from);
  Processes(Processes&& from) noexcept
    : Processes() {
    *this = ::std::move(from);
  }

  inline Processes& operator=(const Processes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Processes& operator=(Processes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Processes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Processes* internal_default_instance() {
    return reinterpret_cast<const Processes*>(
               &_Processes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(Processes& a, Processes& b) {
    a.Swap(&b);
  }
  inline void Swap(Processes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Processes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Processes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Processes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Processes& from);
  void MergeFrom(const Processes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.Processes";
  }
  protected:
  explicit Processes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Processes_Process Process;

  // accessors -------------------------------------------------------

  enum : int {
    kProcessFieldNumber = 1,
  };
  // repeated .proto.system_info.Processes.Process process = 1;
  int process_size() const;
  private:
  int _internal_process_size() const;
  public:
  void clear_process();
  ::proto::system_info::Processes_Process* mutable_process(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Processes_Process >*
      mutable_process();
  private:
  const ::proto::system_info::Processes_Process& _internal_process(int index) const;
  ::proto::system_info::Processes_Process* _internal_add_process();
  public:
  const ::proto::system_info::Processes_Process& process(int index) const;
  ::proto::system_info::Processes_Process* add_process();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Processes_Process >&
      process() const;

  // @@protoc_insertion_point(class_scope:proto.system_info.Processes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Processes_Process > process_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SystemInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.SystemInfoRequest) */ {
 public:
  inline SystemInfoRequest() : SystemInfoRequest(nullptr) {}
  ~SystemInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR SystemInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemInfoRequest(const SystemInfoRequest& from);
  SystemInfoRequest(SystemInfoRequest&& from) noexcept
    : SystemInfoRequest() {
    *this = ::std::move(from);
  }

  inline SystemInfoRequest& operator=(const SystemInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfoRequest& operator=(SystemInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SystemInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SystemInfoRequest*>(
               &_SystemInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(SystemInfoRequest& a, SystemInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemInfoRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemInfoRequest& from);
  void MergeFrom(const SystemInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.SystemInfoRequest";
  }
  protected:
  explicit SystemInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 1,
    kEventLogsDataFieldNumber = 11,
  };
  // string category = 1;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .proto.system_info.EventLogsData event_logs_data = 11;
  bool has_event_logs_data() const;
  private:
  bool _internal_has_event_logs_data() const;
  public:
  void clear_event_logs_data();
  const ::proto::system_info::EventLogsData& event_logs_data() const;
  PROTOBUF_NODISCARD ::proto::system_info::EventLogsData* release_event_logs_data();
  ::proto::system_info::EventLogsData* mutable_event_logs_data();
  void set_allocated_event_logs_data(::proto::system_info::EventLogsData* event_logs_data);
  private:
  const ::proto::system_info::EventLogsData& _internal_event_logs_data() const;
  ::proto::system_info::EventLogsData* _internal_mutable_event_logs_data();
  public:
  void unsafe_arena_set_allocated_event_logs_data(
      ::proto::system_info::EventLogsData* event_logs_data);
  ::proto::system_info::EventLogsData* unsafe_arena_release_event_logs_data();

  // @@protoc_insertion_point(class_scope:proto.system_info.SystemInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::proto::system_info::EventLogsData* event_logs_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SystemInfoFooter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.SystemInfoFooter) */ {
 public:
  inline SystemInfoFooter() : SystemInfoFooter(nullptr) {}
  ~SystemInfoFooter() override;
  explicit PROTOBUF_CONSTEXPR SystemInfoFooter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemInfoFooter(const SystemInfoFooter& from);
  SystemInfoFooter(SystemInfoFooter&& from) noexcept
    : SystemInfoFooter() {
    *this = ::std::move(from);
  }

  inline SystemInfoFooter& operator=(const SystemInfoFooter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfoFooter& operator=(SystemInfoFooter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SystemInfoFooter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfoFooter* internal_default_instance() {
    return reinterpret_cast<const SystemInfoFooter*>(
               &_SystemInfoFooter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(SystemInfoFooter& a, SystemInfoFooter& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfoFooter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfoFooter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfoFooter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemInfoFooter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemInfoFooter& from);
  void MergeFrom(const SystemInfoFooter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfoFooter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.SystemInfoFooter";
  }
  protected:
  explicit SystemInfoFooter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 1,
  };
  // string category = 1;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // @@protoc_insertion_point(class_scope:proto.system_info.SystemInfoFooter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SystemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.system_info.SystemInfo) */ {
 public:
  inline SystemInfo() : SystemInfo(nullptr) {}
  ~SystemInfo() override;
  explicit PROTOBUF_CONSTEXPR SystemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemInfo(const SystemInfo& from);
  SystemInfo(SystemInfo&& from) noexcept
    : SystemInfo() {
    *this = ::std::move(from);
  }

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfo& operator=(SystemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SystemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
               &_SystemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(SystemInfo& a, SystemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SystemInfo& from);
  void MergeFrom(const SystemInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.system_info.SystemInfo";
  }
  protected:
  explicit SystemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComputerFieldNumber = 1,
    kOperatingSystemFieldNumber = 2,
    kMotherboardFieldNumber = 3,
    kBiosFieldNumber = 4,
    kProcessorFieldNumber = 5,
    kMemoryFieldNumber = 6,
    kLogicalDrivesFieldNumber = 7,
    kPrintersFieldNumber = 8,
    kNetworkAdaptersFieldNumber = 9,
    kNetworkSharesFieldNumber = 10,
    kWindowsDevicesFieldNumber = 11,
    kVideoAdaptersFieldNumber = 12,
    kMonitorsFieldNumber = 13,
    kPowerOptionsFieldNumber = 14,
    kDriversFieldNumber = 15,
    kServicesFieldNumber = 16,
    kEnvVarsFieldNumber = 17,
    kEventLogsFieldNumber = 18,
    kRoutesFieldNumber = 19,
    kConnectionsFieldNumber = 20,
    kLicensesFieldNumber = 21,
    kApplicationsFieldNumber = 22,
    kOpenFilesFieldNumber = 23,
    kLocalUsersFieldNumber = 24,
    kLocalUserGroupsFieldNumber = 25,
    kProcessesFieldNumber = 26,
    kFooterFieldNumber = 128000,
  };
  // .proto.system_info.Computer computer = 1;
  bool has_computer() const;
  private:
  bool _internal_has_computer() const;
  public:
  void clear_computer();
  const ::proto::system_info::Computer& computer() const;
  PROTOBUF_NODISCARD ::proto::system_info::Computer* release_computer();
  ::proto::system_info::Computer* mutable_computer();
  void set_allocated_computer(::proto::system_info::Computer* computer);
  private:
  const ::proto::system_info::Computer& _internal_computer() const;
  ::proto::system_info::Computer* _internal_mutable_computer();
  public:
  void unsafe_arena_set_allocated_computer(
      ::proto::system_info::Computer* computer);
  ::proto::system_info::Computer* unsafe_arena_release_computer();

  // .proto.system_info.OperatingSystem operating_system = 2;
  bool has_operating_system() const;
  private:
  bool _internal_has_operating_system() const;
  public:
  void clear_operating_system();
  const ::proto::system_info::OperatingSystem& operating_system() const;
  PROTOBUF_NODISCARD ::proto::system_info::OperatingSystem* release_operating_system();
  ::proto::system_info::OperatingSystem* mutable_operating_system();
  void set_allocated_operating_system(::proto::system_info::OperatingSystem* operating_system);
  private:
  const ::proto::system_info::OperatingSystem& _internal_operating_system() const;
  ::proto::system_info::OperatingSystem* _internal_mutable_operating_system();
  public:
  void unsafe_arena_set_allocated_operating_system(
      ::proto::system_info::OperatingSystem* operating_system);
  ::proto::system_info::OperatingSystem* unsafe_arena_release_operating_system();

  // .proto.system_info.Motherboard motherboard = 3;
  bool has_motherboard() const;
  private:
  bool _internal_has_motherboard() const;
  public:
  void clear_motherboard();
  const ::proto::system_info::Motherboard& motherboard() const;
  PROTOBUF_NODISCARD ::proto::system_info::Motherboard* release_motherboard();
  ::proto::system_info::Motherboard* mutable_motherboard();
  void set_allocated_motherboard(::proto::system_info::Motherboard* motherboard);
  private:
  const ::proto::system_info::Motherboard& _internal_motherboard() const;
  ::proto::system_info::Motherboard* _internal_mutable_motherboard();
  public:
  void unsafe_arena_set_allocated_motherboard(
      ::proto::system_info::Motherboard* motherboard);
  ::proto::system_info::Motherboard* unsafe_arena_release_motherboard();

  // .proto.system_info.Bios bios = 4;
  bool has_bios() const;
  private:
  bool _internal_has_bios() const;
  public:
  void clear_bios();
  const ::proto::system_info::Bios& bios() const;
  PROTOBUF_NODISCARD ::proto::system_info::Bios* release_bios();
  ::proto::system_info::Bios* mutable_bios();
  void set_allocated_bios(::proto::system_info::Bios* bios);
  private:
  const ::proto::system_info::Bios& _internal_bios() const;
  ::proto::system_info::Bios* _internal_mutable_bios();
  public:
  void unsafe_arena_set_allocated_bios(
      ::proto::system_info::Bios* bios);
  ::proto::system_info::Bios* unsafe_arena_release_bios();

  // .proto.system_info.Processor processor = 5;
  bool has_processor() const;
  private:
  bool _internal_has_processor() const;
  public:
  void clear_processor();
  const ::proto::system_info::Processor& processor() const;
  PROTOBUF_NODISCARD ::proto::system_info::Processor* release_processor();
  ::proto::system_info::Processor* mutable_processor();
  void set_allocated_processor(::proto::system_info::Processor* processor);
  private:
  const ::proto::system_info::Processor& _internal_processor() const;
  ::proto::system_info::Processor* _internal_mutable_processor();
  public:
  void unsafe_arena_set_allocated_processor(
      ::proto::system_info::Processor* processor);
  ::proto::system_info::Processor* unsafe_arena_release_processor();

  // .proto.system_info.Memory memory = 6;
  bool has_memory() const;
  private:
  bool _internal_has_memory() const;
  public:
  void clear_memory();
  const ::proto::system_info::Memory& memory() const;
  PROTOBUF_NODISCARD ::proto::system_info::Memory* release_memory();
  ::proto::system_info::Memory* mutable_memory();
  void set_allocated_memory(::proto::system_info::Memory* memory);
  private:
  const ::proto::system_info::Memory& _internal_memory() const;
  ::proto::system_info::Memory* _internal_mutable_memory();
  public:
  void unsafe_arena_set_allocated_memory(
      ::proto::system_info::Memory* memory);
  ::proto::system_info::Memory* unsafe_arena_release_memory();

  // .proto.system_info.LogicalDrives logical_drives = 7;
  bool has_logical_drives() const;
  private:
  bool _internal_has_logical_drives() const;
  public:
  void clear_logical_drives();
  const ::proto::system_info::LogicalDrives& logical_drives() const;
  PROTOBUF_NODISCARD ::proto::system_info::LogicalDrives* release_logical_drives();
  ::proto::system_info::LogicalDrives* mutable_logical_drives();
  void set_allocated_logical_drives(::proto::system_info::LogicalDrives* logical_drives);
  private:
  const ::proto::system_info::LogicalDrives& _internal_logical_drives() const;
  ::proto::system_info::LogicalDrives* _internal_mutable_logical_drives();
  public:
  void unsafe_arena_set_allocated_logical_drives(
      ::proto::system_info::LogicalDrives* logical_drives);
  ::proto::system_info::LogicalDrives* unsafe_arena_release_logical_drives();

  // .proto.system_info.Printers printers = 8;
  bool has_printers() const;
  private:
  bool _internal_has_printers() const;
  public:
  void clear_printers();
  const ::proto::system_info::Printers& printers() const;
  PROTOBUF_NODISCARD ::proto::system_info::Printers* release_printers();
  ::proto::system_info::Printers* mutable_printers();
  void set_allocated_printers(::proto::system_info::Printers* printers);
  private:
  const ::proto::system_info::Printers& _internal_printers() const;
  ::proto::system_info::Printers* _internal_mutable_printers();
  public:
  void unsafe_arena_set_allocated_printers(
      ::proto::system_info::Printers* printers);
  ::proto::system_info::Printers* unsafe_arena_release_printers();

  // .proto.system_info.NetworkAdapters network_adapters = 9;
  bool has_network_adapters() const;
  private:
  bool _internal_has_network_adapters() const;
  public:
  void clear_network_adapters();
  const ::proto::system_info::NetworkAdapters& network_adapters() const;
  PROTOBUF_NODISCARD ::proto::system_info::NetworkAdapters* release_network_adapters();
  ::proto::system_info::NetworkAdapters* mutable_network_adapters();
  void set_allocated_network_adapters(::proto::system_info::NetworkAdapters* network_adapters);
  private:
  const ::proto::system_info::NetworkAdapters& _internal_network_adapters() const;
  ::proto::system_info::NetworkAdapters* _internal_mutable_network_adapters();
  public:
  void unsafe_arena_set_allocated_network_adapters(
      ::proto::system_info::NetworkAdapters* network_adapters);
  ::proto::system_info::NetworkAdapters* unsafe_arena_release_network_adapters();

  // .proto.system_info.NetworkShares network_shares = 10;
  bool has_network_shares() const;
  private:
  bool _internal_has_network_shares() const;
  public:
  void clear_network_shares();
  const ::proto::system_info::NetworkShares& network_shares() const;
  PROTOBUF_NODISCARD ::proto::system_info::NetworkShares* release_network_shares();
  ::proto::system_info::NetworkShares* mutable_network_shares();
  void set_allocated_network_shares(::proto::system_info::NetworkShares* network_shares);
  private:
  const ::proto::system_info::NetworkShares& _internal_network_shares() const;
  ::proto::system_info::NetworkShares* _internal_mutable_network_shares();
  public:
  void unsafe_arena_set_allocated_network_shares(
      ::proto::system_info::NetworkShares* network_shares);
  ::proto::system_info::NetworkShares* unsafe_arena_release_network_shares();

  // .proto.system_info.WindowsDevices windows_devices = 11;
  bool has_windows_devices() const;
  private:
  bool _internal_has_windows_devices() const;
  public:
  void clear_windows_devices();
  const ::proto::system_info::WindowsDevices& windows_devices() const;
  PROTOBUF_NODISCARD ::proto::system_info::WindowsDevices* release_windows_devices();
  ::proto::system_info::WindowsDevices* mutable_windows_devices();
  void set_allocated_windows_devices(::proto::system_info::WindowsDevices* windows_devices);
  private:
  const ::proto::system_info::WindowsDevices& _internal_windows_devices() const;
  ::proto::system_info::WindowsDevices* _internal_mutable_windows_devices();
  public:
  void unsafe_arena_set_allocated_windows_devices(
      ::proto::system_info::WindowsDevices* windows_devices);
  ::proto::system_info::WindowsDevices* unsafe_arena_release_windows_devices();

  // .proto.system_info.VideoAdapters video_adapters = 12;
  bool has_video_adapters() const;
  private:
  bool _internal_has_video_adapters() const;
  public:
  void clear_video_adapters();
  const ::proto::system_info::VideoAdapters& video_adapters() const;
  PROTOBUF_NODISCARD ::proto::system_info::VideoAdapters* release_video_adapters();
  ::proto::system_info::VideoAdapters* mutable_video_adapters();
  void set_allocated_video_adapters(::proto::system_info::VideoAdapters* video_adapters);
  private:
  const ::proto::system_info::VideoAdapters& _internal_video_adapters() const;
  ::proto::system_info::VideoAdapters* _internal_mutable_video_adapters();
  public:
  void unsafe_arena_set_allocated_video_adapters(
      ::proto::system_info::VideoAdapters* video_adapters);
  ::proto::system_info::VideoAdapters* unsafe_arena_release_video_adapters();

  // .proto.system_info.Monitors monitors = 13;
  bool has_monitors() const;
  private:
  bool _internal_has_monitors() const;
  public:
  void clear_monitors();
  const ::proto::system_info::Monitors& monitors() const;
  PROTOBUF_NODISCARD ::proto::system_info::Monitors* release_monitors();
  ::proto::system_info::Monitors* mutable_monitors();
  void set_allocated_monitors(::proto::system_info::Monitors* monitors);
  private:
  const ::proto::system_info::Monitors& _internal_monitors() const;
  ::proto::system_info::Monitors* _internal_mutable_monitors();
  public:
  void unsafe_arena_set_allocated_monitors(
      ::proto::system_info::Monitors* monitors);
  ::proto::system_info::Monitors* unsafe_arena_release_monitors();

  // .proto.system_info.PowerOptions power_options = 14;
  bool has_power_options() const;
  private:
  bool _internal_has_power_options() const;
  public:
  void clear_power_options();
  const ::proto::system_info::PowerOptions& power_options() const;
  PROTOBUF_NODISCARD ::proto::system_info::PowerOptions* release_power_options();
  ::proto::system_info::PowerOptions* mutable_power_options();
  void set_allocated_power_options(::proto::system_info::PowerOptions* power_options);
  private:
  const ::proto::system_info::PowerOptions& _internal_power_options() const;
  ::proto::system_info::PowerOptions* _internal_mutable_power_options();
  public:
  void unsafe_arena_set_allocated_power_options(
      ::proto::system_info::PowerOptions* power_options);
  ::proto::system_info::PowerOptions* unsafe_arena_release_power_options();

  // .proto.system_info.Drivers drivers = 15;
  bool has_drivers() const;
  private:
  bool _internal_has_drivers() const;
  public:
  void clear_drivers();
  const ::proto::system_info::Drivers& drivers() const;
  PROTOBUF_NODISCARD ::proto::system_info::Drivers* release_drivers();
  ::proto::system_info::Drivers* mutable_drivers();
  void set_allocated_drivers(::proto::system_info::Drivers* drivers);
  private:
  const ::proto::system_info::Drivers& _internal_drivers() const;
  ::proto::system_info::Drivers* _internal_mutable_drivers();
  public:
  void unsafe_arena_set_allocated_drivers(
      ::proto::system_info::Drivers* drivers);
  ::proto::system_info::Drivers* unsafe_arena_release_drivers();

  // .proto.system_info.Services services = 16;
  bool has_services() const;
  private:
  bool _internal_has_services() const;
  public:
  void clear_services();
  const ::proto::system_info::Services& services() const;
  PROTOBUF_NODISCARD ::proto::system_info::Services* release_services();
  ::proto::system_info::Services* mutable_services();
  void set_allocated_services(::proto::system_info::Services* services);
  private:
  const ::proto::system_info::Services& _internal_services() const;
  ::proto::system_info::Services* _internal_mutable_services();
  public:
  void unsafe_arena_set_allocated_services(
      ::proto::system_info::Services* services);
  ::proto::system_info::Services* unsafe_arena_release_services();

  // .proto.system_info.EnvironmentVariables env_vars = 17;
  bool has_env_vars() const;
  private:
  bool _internal_has_env_vars() const;
  public:
  void clear_env_vars();
  const ::proto::system_info::EnvironmentVariables& env_vars() const;
  PROTOBUF_NODISCARD ::proto::system_info::EnvironmentVariables* release_env_vars();
  ::proto::system_info::EnvironmentVariables* mutable_env_vars();
  void set_allocated_env_vars(::proto::system_info::EnvironmentVariables* env_vars);
  private:
  const ::proto::system_info::EnvironmentVariables& _internal_env_vars() const;
  ::proto::system_info::EnvironmentVariables* _internal_mutable_env_vars();
  public:
  void unsafe_arena_set_allocated_env_vars(
      ::proto::system_info::EnvironmentVariables* env_vars);
  ::proto::system_info::EnvironmentVariables* unsafe_arena_release_env_vars();

  // .proto.system_info.EventLogs event_logs = 18;
  bool has_event_logs() const;
  private:
  bool _internal_has_event_logs() const;
  public:
  void clear_event_logs();
  const ::proto::system_info::EventLogs& event_logs() const;
  PROTOBUF_NODISCARD ::proto::system_info::EventLogs* release_event_logs();
  ::proto::system_info::EventLogs* mutable_event_logs();
  void set_allocated_event_logs(::proto::system_info::EventLogs* event_logs);
  private:
  const ::proto::system_info::EventLogs& _internal_event_logs() const;
  ::proto::system_info::EventLogs* _internal_mutable_event_logs();
  public:
  void unsafe_arena_set_allocated_event_logs(
      ::proto::system_info::EventLogs* event_logs);
  ::proto::system_info::EventLogs* unsafe_arena_release_event_logs();

  // .proto.system_info.Routes routes = 19;
  bool has_routes() const;
  private:
  bool _internal_has_routes() const;
  public:
  void clear_routes();
  const ::proto::system_info::Routes& routes() const;
  PROTOBUF_NODISCARD ::proto::system_info::Routes* release_routes();
  ::proto::system_info::Routes* mutable_routes();
  void set_allocated_routes(::proto::system_info::Routes* routes);
  private:
  const ::proto::system_info::Routes& _internal_routes() const;
  ::proto::system_info::Routes* _internal_mutable_routes();
  public:
  void unsafe_arena_set_allocated_routes(
      ::proto::system_info::Routes* routes);
  ::proto::system_info::Routes* unsafe_arena_release_routes();

  // .proto.system_info.Connections connections = 20;
  bool has_connections() const;
  private:
  bool _internal_has_connections() const;
  public:
  void clear_connections();
  const ::proto::system_info::Connections& connections() const;
  PROTOBUF_NODISCARD ::proto::system_info::Connections* release_connections();
  ::proto::system_info::Connections* mutable_connections();
  void set_allocated_connections(::proto::system_info::Connections* connections);
  private:
  const ::proto::system_info::Connections& _internal_connections() const;
  ::proto::system_info::Connections* _internal_mutable_connections();
  public:
  void unsafe_arena_set_allocated_connections(
      ::proto::system_info::Connections* connections);
  ::proto::system_info::Connections* unsafe_arena_release_connections();

  // .proto.system_info.Licenses licenses = 21;
  bool has_licenses() const;
  private:
  bool _internal_has_licenses() const;
  public:
  void clear_licenses();
  const ::proto::system_info::Licenses& licenses() const;
  PROTOBUF_NODISCARD ::proto::system_info::Licenses* release_licenses();
  ::proto::system_info::Licenses* mutable_licenses();
  void set_allocated_licenses(::proto::system_info::Licenses* licenses);
  private:
  const ::proto::system_info::Licenses& _internal_licenses() const;
  ::proto::system_info::Licenses* _internal_mutable_licenses();
  public:
  void unsafe_arena_set_allocated_licenses(
      ::proto::system_info::Licenses* licenses);
  ::proto::system_info::Licenses* unsafe_arena_release_licenses();

  // .proto.system_info.Applications applications = 22;
  bool has_applications() const;
  private:
  bool _internal_has_applications() const;
  public:
  void clear_applications();
  const ::proto::system_info::Applications& applications() const;
  PROTOBUF_NODISCARD ::proto::system_info::Applications* release_applications();
  ::proto::system_info::Applications* mutable_applications();
  void set_allocated_applications(::proto::system_info::Applications* applications);
  private:
  const ::proto::system_info::Applications& _internal_applications() const;
  ::proto::system_info::Applications* _internal_mutable_applications();
  public:
  void unsafe_arena_set_allocated_applications(
      ::proto::system_info::Applications* applications);
  ::proto::system_info::Applications* unsafe_arena_release_applications();

  // .proto.system_info.OpenFiles open_files = 23;
  bool has_open_files() const;
  private:
  bool _internal_has_open_files() const;
  public:
  void clear_open_files();
  const ::proto::system_info::OpenFiles& open_files() const;
  PROTOBUF_NODISCARD ::proto::system_info::OpenFiles* release_open_files();
  ::proto::system_info::OpenFiles* mutable_open_files();
  void set_allocated_open_files(::proto::system_info::OpenFiles* open_files);
  private:
  const ::proto::system_info::OpenFiles& _internal_open_files() const;
  ::proto::system_info::OpenFiles* _internal_mutable_open_files();
  public:
  void unsafe_arena_set_allocated_open_files(
      ::proto::system_info::OpenFiles* open_files);
  ::proto::system_info::OpenFiles* unsafe_arena_release_open_files();

  // .proto.system_info.LocalUsers local_users = 24;
  bool has_local_users() const;
  private:
  bool _internal_has_local_users() const;
  public:
  void clear_local_users();
  const ::proto::system_info::LocalUsers& local_users() const;
  PROTOBUF_NODISCARD ::proto::system_info::LocalUsers* release_local_users();
  ::proto::system_info::LocalUsers* mutable_local_users();
  void set_allocated_local_users(::proto::system_info::LocalUsers* local_users);
  private:
  const ::proto::system_info::LocalUsers& _internal_local_users() const;
  ::proto::system_info::LocalUsers* _internal_mutable_local_users();
  public:
  void unsafe_arena_set_allocated_local_users(
      ::proto::system_info::LocalUsers* local_users);
  ::proto::system_info::LocalUsers* unsafe_arena_release_local_users();

  // .proto.system_info.LocalUserGroups local_user_groups = 25;
  bool has_local_user_groups() const;
  private:
  bool _internal_has_local_user_groups() const;
  public:
  void clear_local_user_groups();
  const ::proto::system_info::LocalUserGroups& local_user_groups() const;
  PROTOBUF_NODISCARD ::proto::system_info::LocalUserGroups* release_local_user_groups();
  ::proto::system_info::LocalUserGroups* mutable_local_user_groups();
  void set_allocated_local_user_groups(::proto::system_info::LocalUserGroups* local_user_groups);
  private:
  const ::proto::system_info::LocalUserGroups& _internal_local_user_groups() const;
  ::proto::system_info::LocalUserGroups* _internal_mutable_local_user_groups();
  public:
  void unsafe_arena_set_allocated_local_user_groups(
      ::proto::system_info::LocalUserGroups* local_user_groups);
  ::proto::system_info::LocalUserGroups* unsafe_arena_release_local_user_groups();

  // .proto.system_info.Processes processes = 26;
  bool has_processes() const;
  private:
  bool _internal_has_processes() const;
  public:
  void clear_processes();
  const ::proto::system_info::Processes& processes() const;
  PROTOBUF_NODISCARD ::proto::system_info::Processes* release_processes();
  ::proto::system_info::Processes* mutable_processes();
  void set_allocated_processes(::proto::system_info::Processes* processes);
  private:
  const ::proto::system_info::Processes& _internal_processes() const;
  ::proto::system_info::Processes* _internal_mutable_processes();
  public:
  void unsafe_arena_set_allocated_processes(
      ::proto::system_info::Processes* processes);
  ::proto::system_info::Processes* unsafe_arena_release_processes();

  // .proto.system_info.SystemInfoFooter footer = 128000;
  bool has_footer() const;
  private:
  bool _internal_has_footer() const;
  public:
  void clear_footer();
  const ::proto::system_info::SystemInfoFooter& footer() const;
  PROTOBUF_NODISCARD ::proto::system_info::SystemInfoFooter* release_footer();
  ::proto::system_info::SystemInfoFooter* mutable_footer();
  void set_allocated_footer(::proto::system_info::SystemInfoFooter* footer);
  private:
  const ::proto::system_info::SystemInfoFooter& _internal_footer() const;
  ::proto::system_info::SystemInfoFooter* _internal_mutable_footer();
  public:
  void unsafe_arena_set_allocated_footer(
      ::proto::system_info::SystemInfoFooter* footer);
  ::proto::system_info::SystemInfoFooter* unsafe_arena_release_footer();

  // @@protoc_insertion_point(class_scope:proto.system_info.SystemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::system_info::Computer* computer_;
    ::proto::system_info::OperatingSystem* operating_system_;
    ::proto::system_info::Motherboard* motherboard_;
    ::proto::system_info::Bios* bios_;
    ::proto::system_info::Processor* processor_;
    ::proto::system_info::Memory* memory_;
    ::proto::system_info::LogicalDrives* logical_drives_;
    ::proto::system_info::Printers* printers_;
    ::proto::system_info::NetworkAdapters* network_adapters_;
    ::proto::system_info::NetworkShares* network_shares_;
    ::proto::system_info::WindowsDevices* windows_devices_;
    ::proto::system_info::VideoAdapters* video_adapters_;
    ::proto::system_info::Monitors* monitors_;
    ::proto::system_info::PowerOptions* power_options_;
    ::proto::system_info::Drivers* drivers_;
    ::proto::system_info::Services* services_;
    ::proto::system_info::EnvironmentVariables* env_vars_;
    ::proto::system_info::EventLogs* event_logs_;
    ::proto::system_info::Routes* routes_;
    ::proto::system_info::Connections* connections_;
    ::proto::system_info::Licenses* licenses_;
    ::proto::system_info::Applications* applications_;
    ::proto::system_info::OpenFiles* open_files_;
    ::proto::system_info::LocalUsers* local_users_;
    ::proto::system_info::LocalUserGroups* local_user_groups_;
    ::proto::system_info::Processes* processes_;
    ::proto::system_info::SystemInfoFooter* footer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_system_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Computer

// string name = 1;
inline void Computer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Computer::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Computer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Computer.name)
}
inline std::string* Computer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Computer.name)
  return _s;
}
inline const std::string& Computer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Computer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Computer.name)
  return _impl_.name_.Release();
}
inline void Computer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Computer.name)
}

// string domain = 2;
inline void Computer::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& Computer::domain() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Computer.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_domain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Computer.domain)
}
inline std::string* Computer::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Computer.domain)
  return _s;
}
inline const std::string& Computer::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void Computer::_internal_set_domain(const std::string& value) {
  
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_domain() {
  
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_domain() {
  // @@protoc_insertion_point(field_release:proto.system_info.Computer.domain)
  return _impl_.domain_.Release();
}
inline void Computer::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Computer.domain)
}

// string workgroup = 3;
inline void Computer::clear_workgroup() {
  _impl_.workgroup_.ClearToEmpty();
}
inline const std::string& Computer::workgroup() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Computer.workgroup)
  return _internal_workgroup();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Computer::set_workgroup(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workgroup_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Computer.workgroup)
}
inline std::string* Computer::mutable_workgroup() {
  std::string* _s = _internal_mutable_workgroup();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Computer.workgroup)
  return _s;
}
inline const std::string& Computer::_internal_workgroup() const {
  return _impl_.workgroup_.Get();
}
inline void Computer::_internal_set_workgroup(const std::string& value) {
  
  _impl_.workgroup_.Set(value, GetArenaForAllocation());
}
inline std::string* Computer::_internal_mutable_workgroup() {
  
  return _impl_.workgroup_.Mutable(GetArenaForAllocation());
}
inline std::string* Computer::release_workgroup() {
  // @@protoc_insertion_point(field_release:proto.system_info.Computer.workgroup)
  return _impl_.workgroup_.Release();
}
inline void Computer::set_allocated_workgroup(std::string* workgroup) {
  if (workgroup != nullptr) {
    
  } else {
    
  }
  _impl_.workgroup_.SetAllocated(workgroup, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workgroup_.IsDefault()) {
    _impl_.workgroup_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Computer.workgroup)
}

// uint64 uptime = 4;
inline void Computer::clear_uptime() {
  _impl_.uptime_ = uint64_t{0u};
}
inline uint64_t Computer::_internal_uptime() const {
  return _impl_.uptime_;
}
inline uint64_t Computer::uptime() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Computer.uptime)
  return _internal_uptime();
}
inline void Computer::_internal_set_uptime(uint64_t value) {
  
  _impl_.uptime_ = value;
}
inline void Computer::set_uptime(uint64_t value) {
  _internal_set_uptime(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Computer.uptime)
}

// -------------------------------------------------------------------

// OperatingSystem

// string name = 1;
inline void OperatingSystem::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OperatingSystem::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OperatingSystem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatingSystem::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.OperatingSystem.name)
}
inline std::string* OperatingSystem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.OperatingSystem.name)
  return _s;
}
inline const std::string& OperatingSystem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OperatingSystem::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatingSystem::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatingSystem::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.OperatingSystem.name)
  return _impl_.name_.Release();
}
inline void OperatingSystem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.OperatingSystem.name)
}

// string version = 2;
inline void OperatingSystem::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& OperatingSystem::version() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OperatingSystem.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatingSystem::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.OperatingSystem.version)
}
inline std::string* OperatingSystem::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:proto.system_info.OperatingSystem.version)
  return _s;
}
inline const std::string& OperatingSystem::_internal_version() const {
  return _impl_.version_.Get();
}
inline void OperatingSystem::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatingSystem::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatingSystem::release_version() {
  // @@protoc_insertion_point(field_release:proto.system_info.OperatingSystem.version)
  return _impl_.version_.Release();
}
inline void OperatingSystem::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.OperatingSystem.version)
}

// string arch = 3;
inline void OperatingSystem::clear_arch() {
  _impl_.arch_.ClearToEmpty();
}
inline const std::string& OperatingSystem::arch() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OperatingSystem.arch)
  return _internal_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatingSystem::set_arch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.OperatingSystem.arch)
}
inline std::string* OperatingSystem::mutable_arch() {
  std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:proto.system_info.OperatingSystem.arch)
  return _s;
}
inline const std::string& OperatingSystem::_internal_arch() const {
  return _impl_.arch_.Get();
}
inline void OperatingSystem::_internal_set_arch(const std::string& value) {
  
  _impl_.arch_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatingSystem::_internal_mutable_arch() {
  
  return _impl_.arch_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatingSystem::release_arch() {
  // @@protoc_insertion_point(field_release:proto.system_info.OperatingSystem.arch)
  return _impl_.arch_.Release();
}
inline void OperatingSystem::set_allocated_arch(std::string* arch) {
  if (arch != nullptr) {
    
  } else {
    
  }
  _impl_.arch_.SetAllocated(arch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arch_.IsDefault()) {
    _impl_.arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.OperatingSystem.arch)
}

// string key = 4;
inline void OperatingSystem::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& OperatingSystem::key() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OperatingSystem.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperatingSystem::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.OperatingSystem.key)
}
inline std::string* OperatingSystem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.system_info.OperatingSystem.key)
  return _s;
}
inline const std::string& OperatingSystem::_internal_key() const {
  return _impl_.key_.Get();
}
inline void OperatingSystem::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatingSystem::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* OperatingSystem::release_key() {
  // @@protoc_insertion_point(field_release:proto.system_info.OperatingSystem.key)
  return _impl_.key_.Release();
}
inline void OperatingSystem::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.OperatingSystem.key)
}

// int64 install_date = 5;
inline void OperatingSystem::clear_install_date() {
  _impl_.install_date_ = int64_t{0};
}
inline int64_t OperatingSystem::_internal_install_date() const {
  return _impl_.install_date_;
}
inline int64_t OperatingSystem::install_date() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OperatingSystem.install_date)
  return _internal_install_date();
}
inline void OperatingSystem::_internal_set_install_date(int64_t value) {
  
  _impl_.install_date_ = value;
}
inline void OperatingSystem::set_install_date(int64_t value) {
  _internal_set_install_date(value);
  // @@protoc_insertion_point(field_set:proto.system_info.OperatingSystem.install_date)
}

// -------------------------------------------------------------------

// Motherboard

// string manufacturer = 1;
inline void Motherboard::clear_manufacturer() {
  _impl_.manufacturer_.ClearToEmpty();
}
inline const std::string& Motherboard::manufacturer() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Motherboard.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Motherboard::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Motherboard.manufacturer)
}
inline std::string* Motherboard::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Motherboard.manufacturer)
  return _s;
}
inline const std::string& Motherboard::_internal_manufacturer() const {
  return _impl_.manufacturer_.Get();
}
inline void Motherboard::_internal_set_manufacturer(const std::string& value) {
  
  _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* Motherboard::_internal_mutable_manufacturer() {
  
  return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* Motherboard::release_manufacturer() {
  // @@protoc_insertion_point(field_release:proto.system_info.Motherboard.manufacturer)
  return _impl_.manufacturer_.Release();
}
inline void Motherboard::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    
  } else {
    
  }
  _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Motherboard.manufacturer)
}

// string model = 2;
inline void Motherboard::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& Motherboard::model() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Motherboard.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Motherboard::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Motherboard.model)
}
inline std::string* Motherboard::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Motherboard.model)
  return _s;
}
inline const std::string& Motherboard::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Motherboard::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Motherboard::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Motherboard::release_model() {
  // @@protoc_insertion_point(field_release:proto.system_info.Motherboard.model)
  return _impl_.model_.Release();
}
inline void Motherboard::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Motherboard.model)
}

// -------------------------------------------------------------------

// Bios

// string vendor = 1;
inline void Bios::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& Bios::vendor() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Bios.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Bios::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Bios.vendor)
}
inline std::string* Bios::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Bios.vendor)
  return _s;
}
inline const std::string& Bios::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Bios::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Bios::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Bios::release_vendor() {
  // @@protoc_insertion_point(field_release:proto.system_info.Bios.vendor)
  return _impl_.vendor_.Release();
}
inline void Bios::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Bios.vendor)
}

// string version = 2;
inline void Bios::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Bios::version() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Bios.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Bios::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Bios.version)
}
inline std::string* Bios::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Bios.version)
  return _s;
}
inline const std::string& Bios::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Bios::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Bios::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Bios::release_version() {
  // @@protoc_insertion_point(field_release:proto.system_info.Bios.version)
  return _impl_.version_.Release();
}
inline void Bios::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Bios.version)
}

// string date = 3;
inline void Bios::clear_date() {
  _impl_.date_.ClearToEmpty();
}
inline const std::string& Bios::date() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Bios.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Bios::set_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Bios.date)
}
inline std::string* Bios::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Bios.date)
  return _s;
}
inline const std::string& Bios::_internal_date() const {
  return _impl_.date_.Get();
}
inline void Bios::_internal_set_date(const std::string& value) {
  
  _impl_.date_.Set(value, GetArenaForAllocation());
}
inline std::string* Bios::_internal_mutable_date() {
  
  return _impl_.date_.Mutable(GetArenaForAllocation());
}
inline std::string* Bios::release_date() {
  // @@protoc_insertion_point(field_release:proto.system_info.Bios.date)
  return _impl_.date_.Release();
}
inline void Bios::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  _impl_.date_.SetAllocated(date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_.IsDefault()) {
    _impl_.date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Bios.date)
}

// -------------------------------------------------------------------

// Processor

// string vendor = 1;
inline void Processor::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& Processor::vendor() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processor.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Processor::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Processor.vendor)
}
inline std::string* Processor::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Processor.vendor)
  return _s;
}
inline const std::string& Processor::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Processor::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Processor::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Processor::release_vendor() {
  // @@protoc_insertion_point(field_release:proto.system_info.Processor.vendor)
  return _impl_.vendor_.Release();
}
inline void Processor::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Processor.vendor)
}

// string model = 2;
inline void Processor::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& Processor::model() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processor.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Processor::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Processor.model)
}
inline std::string* Processor::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Processor.model)
  return _s;
}
inline const std::string& Processor::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Processor::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Processor::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Processor::release_model() {
  // @@protoc_insertion_point(field_release:proto.system_info.Processor.model)
  return _impl_.model_.Release();
}
inline void Processor::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Processor.model)
}

// uint32 packages = 3;
inline void Processor::clear_packages() {
  _impl_.packages_ = 0u;
}
inline uint32_t Processor::_internal_packages() const {
  return _impl_.packages_;
}
inline uint32_t Processor::packages() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processor.packages)
  return _internal_packages();
}
inline void Processor::_internal_set_packages(uint32_t value) {
  
  _impl_.packages_ = value;
}
inline void Processor::set_packages(uint32_t value) {
  _internal_set_packages(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processor.packages)
}

// uint32 cores = 4;
inline void Processor::clear_cores() {
  _impl_.cores_ = 0u;
}
inline uint32_t Processor::_internal_cores() const {
  return _impl_.cores_;
}
inline uint32_t Processor::cores() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processor.cores)
  return _internal_cores();
}
inline void Processor::_internal_set_cores(uint32_t value) {
  
  _impl_.cores_ = value;
}
inline void Processor::set_cores(uint32_t value) {
  _internal_set_cores(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processor.cores)
}

// uint32 threads = 5;
inline void Processor::clear_threads() {
  _impl_.threads_ = 0u;
}
inline uint32_t Processor::_internal_threads() const {
  return _impl_.threads_;
}
inline uint32_t Processor::threads() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processor.threads)
  return _internal_threads();
}
inline void Processor::_internal_set_threads(uint32_t value) {
  
  _impl_.threads_ = value;
}
inline void Processor::set_threads(uint32_t value) {
  _internal_set_threads(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processor.threads)
}

// -------------------------------------------------------------------

// Memory_Module

// bool present = 1;
inline void Memory_Module::clear_present() {
  _impl_.present_ = false;
}
inline bool Memory_Module::_internal_present() const {
  return _impl_.present_;
}
inline bool Memory_Module::present() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.present)
  return _internal_present();
}
inline void Memory_Module::_internal_set_present(bool value) {
  
  _impl_.present_ = value;
}
inline void Memory_Module::set_present(bool value) {
  _internal_set_present(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.present)
}

// string location = 2;
inline void Memory_Module::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& Memory_Module::location() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Memory_Module::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.location)
}
inline std::string* Memory_Module::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Memory.Module.location)
  return _s;
}
inline const std::string& Memory_Module::_internal_location() const {
  return _impl_.location_.Get();
}
inline void Memory_Module::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* Memory_Module::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* Memory_Module::release_location() {
  // @@protoc_insertion_point(field_release:proto.system_info.Memory.Module.location)
  return _impl_.location_.Release();
}
inline void Memory_Module::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Memory.Module.location)
}

// string manufacturer = 3;
inline void Memory_Module::clear_manufacturer() {
  _impl_.manufacturer_.ClearToEmpty();
}
inline const std::string& Memory_Module::manufacturer() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Memory_Module::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.manufacturer)
}
inline std::string* Memory_Module::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Memory.Module.manufacturer)
  return _s;
}
inline const std::string& Memory_Module::_internal_manufacturer() const {
  return _impl_.manufacturer_.Get();
}
inline void Memory_Module::_internal_set_manufacturer(const std::string& value) {
  
  _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* Memory_Module::_internal_mutable_manufacturer() {
  
  return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* Memory_Module::release_manufacturer() {
  // @@protoc_insertion_point(field_release:proto.system_info.Memory.Module.manufacturer)
  return _impl_.manufacturer_.Release();
}
inline void Memory_Module::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    
  } else {
    
  }
  _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Memory.Module.manufacturer)
}

// uint64 size = 4;
inline void Memory_Module::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t Memory_Module::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t Memory_Module::size() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.size)
  return _internal_size();
}
inline void Memory_Module::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void Memory_Module::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.size)
}

// string type = 5;
inline void Memory_Module::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Memory_Module::type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Memory_Module::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.type)
}
inline std::string* Memory_Module::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Memory.Module.type)
  return _s;
}
inline const std::string& Memory_Module::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Memory_Module::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Memory_Module::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Memory_Module::release_type() {
  // @@protoc_insertion_point(field_release:proto.system_info.Memory.Module.type)
  return _impl_.type_.Release();
}
inline void Memory_Module::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Memory.Module.type)
}

// string form_factor = 6;
inline void Memory_Module::clear_form_factor() {
  _impl_.form_factor_.ClearToEmpty();
}
inline const std::string& Memory_Module::form_factor() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.form_factor)
  return _internal_form_factor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Memory_Module::set_form_factor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.form_factor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.form_factor)
}
inline std::string* Memory_Module::mutable_form_factor() {
  std::string* _s = _internal_mutable_form_factor();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Memory.Module.form_factor)
  return _s;
}
inline const std::string& Memory_Module::_internal_form_factor() const {
  return _impl_.form_factor_.Get();
}
inline void Memory_Module::_internal_set_form_factor(const std::string& value) {
  
  _impl_.form_factor_.Set(value, GetArenaForAllocation());
}
inline std::string* Memory_Module::_internal_mutable_form_factor() {
  
  return _impl_.form_factor_.Mutable(GetArenaForAllocation());
}
inline std::string* Memory_Module::release_form_factor() {
  // @@protoc_insertion_point(field_release:proto.system_info.Memory.Module.form_factor)
  return _impl_.form_factor_.Release();
}
inline void Memory_Module::set_allocated_form_factor(std::string* form_factor) {
  if (form_factor != nullptr) {
    
  } else {
    
  }
  _impl_.form_factor_.SetAllocated(form_factor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.form_factor_.IsDefault()) {
    _impl_.form_factor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Memory.Module.form_factor)
}

// string part_number = 7;
inline void Memory_Module::clear_part_number() {
  _impl_.part_number_.ClearToEmpty();
}
inline const std::string& Memory_Module::part_number() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.part_number)
  return _internal_part_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Memory_Module::set_part_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.part_number)
}
inline std::string* Memory_Module::mutable_part_number() {
  std::string* _s = _internal_mutable_part_number();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Memory.Module.part_number)
  return _s;
}
inline const std::string& Memory_Module::_internal_part_number() const {
  return _impl_.part_number_.Get();
}
inline void Memory_Module::_internal_set_part_number(const std::string& value) {
  
  _impl_.part_number_.Set(value, GetArenaForAllocation());
}
inline std::string* Memory_Module::_internal_mutable_part_number() {
  
  return _impl_.part_number_.Mutable(GetArenaForAllocation());
}
inline std::string* Memory_Module::release_part_number() {
  // @@protoc_insertion_point(field_release:proto.system_info.Memory.Module.part_number)
  return _impl_.part_number_.Release();
}
inline void Memory_Module::set_allocated_part_number(std::string* part_number) {
  if (part_number != nullptr) {
    
  } else {
    
  }
  _impl_.part_number_.SetAllocated(part_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_number_.IsDefault()) {
    _impl_.part_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Memory.Module.part_number)
}

// uint32 speed = 8;
inline void Memory_Module::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t Memory_Module::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t Memory_Module::speed() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.Module.speed)
  return _internal_speed();
}
inline void Memory_Module::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void Memory_Module::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Memory.Module.speed)
}

// -------------------------------------------------------------------

// Memory

// repeated .proto.system_info.Memory.Module module = 1;
inline int Memory::_internal_module_size() const {
  return _impl_.module_.size();
}
inline int Memory::module_size() const {
  return _internal_module_size();
}
inline void Memory::clear_module() {
  _impl_.module_.Clear();
}
inline ::proto::system_info::Memory_Module* Memory::mutable_module(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Memory.module)
  return _impl_.module_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Memory_Module >*
Memory::mutable_module() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Memory.module)
  return &_impl_.module_;
}
inline const ::proto::system_info::Memory_Module& Memory::_internal_module(int index) const {
  return _impl_.module_.Get(index);
}
inline const ::proto::system_info::Memory_Module& Memory::module(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Memory.module)
  return _internal_module(index);
}
inline ::proto::system_info::Memory_Module* Memory::_internal_add_module() {
  return _impl_.module_.Add();
}
inline ::proto::system_info::Memory_Module* Memory::add_module() {
  ::proto::system_info::Memory_Module* _add = _internal_add_module();
  // @@protoc_insertion_point(field_add:proto.system_info.Memory.module)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Memory_Module >&
Memory::module() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Memory.module)
  return _impl_.module_;
}

// -------------------------------------------------------------------

// LogicalDrives_Drive

// string path = 1;
inline void LogicalDrives_Drive::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& LogicalDrives_Drive::path() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LogicalDrives.Drive.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogicalDrives_Drive::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LogicalDrives.Drive.path)
}
inline std::string* LogicalDrives_Drive::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LogicalDrives.Drive.path)
  return _s;
}
inline const std::string& LogicalDrives_Drive::_internal_path() const {
  return _impl_.path_.Get();
}
inline void LogicalDrives_Drive::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* LogicalDrives_Drive::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* LogicalDrives_Drive::release_path() {
  // @@protoc_insertion_point(field_release:proto.system_info.LogicalDrives.Drive.path)
  return _impl_.path_.Release();
}
inline void LogicalDrives_Drive::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LogicalDrives.Drive.path)
}

// string file_system = 2;
inline void LogicalDrives_Drive::clear_file_system() {
  _impl_.file_system_.ClearToEmpty();
}
inline const std::string& LogicalDrives_Drive::file_system() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LogicalDrives.Drive.file_system)
  return _internal_file_system();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogicalDrives_Drive::set_file_system(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_system_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LogicalDrives.Drive.file_system)
}
inline std::string* LogicalDrives_Drive::mutable_file_system() {
  std::string* _s = _internal_mutable_file_system();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LogicalDrives.Drive.file_system)
  return _s;
}
inline const std::string& LogicalDrives_Drive::_internal_file_system() const {
  return _impl_.file_system_.Get();
}
inline void LogicalDrives_Drive::_internal_set_file_system(const std::string& value) {
  
  _impl_.file_system_.Set(value, GetArenaForAllocation());
}
inline std::string* LogicalDrives_Drive::_internal_mutable_file_system() {
  
  return _impl_.file_system_.Mutable(GetArenaForAllocation());
}
inline std::string* LogicalDrives_Drive::release_file_system() {
  // @@protoc_insertion_point(field_release:proto.system_info.LogicalDrives.Drive.file_system)
  return _impl_.file_system_.Release();
}
inline void LogicalDrives_Drive::set_allocated_file_system(std::string* file_system) {
  if (file_system != nullptr) {
    
  } else {
    
  }
  _impl_.file_system_.SetAllocated(file_system, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_system_.IsDefault()) {
    _impl_.file_system_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LogicalDrives.Drive.file_system)
}

// uint64 total_size = 3;
inline void LogicalDrives_Drive::clear_total_size() {
  _impl_.total_size_ = uint64_t{0u};
}
inline uint64_t LogicalDrives_Drive::_internal_total_size() const {
  return _impl_.total_size_;
}
inline uint64_t LogicalDrives_Drive::total_size() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LogicalDrives.Drive.total_size)
  return _internal_total_size();
}
inline void LogicalDrives_Drive::_internal_set_total_size(uint64_t value) {
  
  _impl_.total_size_ = value;
}
inline void LogicalDrives_Drive::set_total_size(uint64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LogicalDrives.Drive.total_size)
}

// uint64 free_size = 4;
inline void LogicalDrives_Drive::clear_free_size() {
  _impl_.free_size_ = uint64_t{0u};
}
inline uint64_t LogicalDrives_Drive::_internal_free_size() const {
  return _impl_.free_size_;
}
inline uint64_t LogicalDrives_Drive::free_size() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LogicalDrives.Drive.free_size)
  return _internal_free_size();
}
inline void LogicalDrives_Drive::_internal_set_free_size(uint64_t value) {
  
  _impl_.free_size_ = value;
}
inline void LogicalDrives_Drive::set_free_size(uint64_t value) {
  _internal_set_free_size(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LogicalDrives.Drive.free_size)
}

// -------------------------------------------------------------------

// LogicalDrives

// repeated .proto.system_info.LogicalDrives.Drive drive = 1;
inline int LogicalDrives::_internal_drive_size() const {
  return _impl_.drive_.size();
}
inline int LogicalDrives::drive_size() const {
  return _internal_drive_size();
}
inline void LogicalDrives::clear_drive() {
  _impl_.drive_.Clear();
}
inline ::proto::system_info::LogicalDrives_Drive* LogicalDrives::mutable_drive(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.LogicalDrives.drive)
  return _impl_.drive_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LogicalDrives_Drive >*
LogicalDrives::mutable_drive() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.LogicalDrives.drive)
  return &_impl_.drive_;
}
inline const ::proto::system_info::LogicalDrives_Drive& LogicalDrives::_internal_drive(int index) const {
  return _impl_.drive_.Get(index);
}
inline const ::proto::system_info::LogicalDrives_Drive& LogicalDrives::drive(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.LogicalDrives.drive)
  return _internal_drive(index);
}
inline ::proto::system_info::LogicalDrives_Drive* LogicalDrives::_internal_add_drive() {
  return _impl_.drive_.Add();
}
inline ::proto::system_info::LogicalDrives_Drive* LogicalDrives::add_drive() {
  ::proto::system_info::LogicalDrives_Drive* _add = _internal_add_drive();
  // @@protoc_insertion_point(field_add:proto.system_info.LogicalDrives.drive)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LogicalDrives_Drive >&
LogicalDrives::drive() const {
  // @@protoc_insertion_point(field_list:proto.system_info.LogicalDrives.drive)
  return _impl_.drive_;
}

// -------------------------------------------------------------------

// Printers_Printer

// string name = 1;
inline void Printers_Printer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Printers_Printer::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Printers_Printer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.name)
}
inline std::string* Printers_Printer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Printers.Printer.name)
  return _s;
}
inline const std::string& Printers_Printer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Printers_Printer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Printers_Printer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Printers_Printer::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Printers.Printer.name)
  return _impl_.name_.Release();
}
inline void Printers_Printer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Printers.Printer.name)
}

// bool default = 2;
inline void Printers_Printer::clear_default_() {
  _impl_.default__ = false;
}
inline bool Printers_Printer::_internal_default_() const {
  return _impl_.default__;
}
inline bool Printers_Printer::default_() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.default)
  return _internal_default_();
}
inline void Printers_Printer::_internal_set_default_(bool value) {
  
  _impl_.default__ = value;
}
inline void Printers_Printer::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.default)
}

// bool shared = 3;
inline void Printers_Printer::clear_shared() {
  _impl_.shared_ = false;
}
inline bool Printers_Printer::_internal_shared() const {
  return _impl_.shared_;
}
inline bool Printers_Printer::shared() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.shared)
  return _internal_shared();
}
inline void Printers_Printer::_internal_set_shared(bool value) {
  
  _impl_.shared_ = value;
}
inline void Printers_Printer::set_shared(bool value) {
  _internal_set_shared(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.shared)
}

// string port = 4;
inline void Printers_Printer::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& Printers_Printer::port() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Printers_Printer::set_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.port)
}
inline std::string* Printers_Printer::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Printers.Printer.port)
  return _s;
}
inline const std::string& Printers_Printer::_internal_port() const {
  return _impl_.port_.Get();
}
inline void Printers_Printer::_internal_set_port(const std::string& value) {
  
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* Printers_Printer::_internal_mutable_port() {
  
  return _impl_.port_.Mutable(GetArenaForAllocation());
}
inline std::string* Printers_Printer::release_port() {
  // @@protoc_insertion_point(field_release:proto.system_info.Printers.Printer.port)
  return _impl_.port_.Release();
}
inline void Printers_Printer::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  _impl_.port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Printers.Printer.port)
}

// string driver = 5;
inline void Printers_Printer::clear_driver() {
  _impl_.driver_.ClearToEmpty();
}
inline const std::string& Printers_Printer::driver() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.driver)
  return _internal_driver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Printers_Printer::set_driver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.driver)
}
inline std::string* Printers_Printer::mutable_driver() {
  std::string* _s = _internal_mutable_driver();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Printers.Printer.driver)
  return _s;
}
inline const std::string& Printers_Printer::_internal_driver() const {
  return _impl_.driver_.Get();
}
inline void Printers_Printer::_internal_set_driver(const std::string& value) {
  
  _impl_.driver_.Set(value, GetArenaForAllocation());
}
inline std::string* Printers_Printer::_internal_mutable_driver() {
  
  return _impl_.driver_.Mutable(GetArenaForAllocation());
}
inline std::string* Printers_Printer::release_driver() {
  // @@protoc_insertion_point(field_release:proto.system_info.Printers.Printer.driver)
  return _impl_.driver_.Release();
}
inline void Printers_Printer::set_allocated_driver(std::string* driver) {
  if (driver != nullptr) {
    
  } else {
    
  }
  _impl_.driver_.SetAllocated(driver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_.IsDefault()) {
    _impl_.driver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Printers.Printer.driver)
}

// uint32 jobs_count = 6;
inline void Printers_Printer::clear_jobs_count() {
  _impl_.jobs_count_ = 0u;
}
inline uint32_t Printers_Printer::_internal_jobs_count() const {
  return _impl_.jobs_count_;
}
inline uint32_t Printers_Printer::jobs_count() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.jobs_count)
  return _internal_jobs_count();
}
inline void Printers_Printer::_internal_set_jobs_count(uint32_t value) {
  
  _impl_.jobs_count_ = value;
}
inline void Printers_Printer::set_jobs_count(uint32_t value) {
  _internal_set_jobs_count(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.jobs_count)
}

// string share_name = 7;
inline void Printers_Printer::clear_share_name() {
  _impl_.share_name_.ClearToEmpty();
}
inline const std::string& Printers_Printer::share_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.Printer.share_name)
  return _internal_share_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Printers_Printer::set_share_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.share_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Printers.Printer.share_name)
}
inline std::string* Printers_Printer::mutable_share_name() {
  std::string* _s = _internal_mutable_share_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Printers.Printer.share_name)
  return _s;
}
inline const std::string& Printers_Printer::_internal_share_name() const {
  return _impl_.share_name_.Get();
}
inline void Printers_Printer::_internal_set_share_name(const std::string& value) {
  
  _impl_.share_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Printers_Printer::_internal_mutable_share_name() {
  
  return _impl_.share_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Printers_Printer::release_share_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Printers.Printer.share_name)
  return _impl_.share_name_.Release();
}
inline void Printers_Printer::set_allocated_share_name(std::string* share_name) {
  if (share_name != nullptr) {
    
  } else {
    
  }
  _impl_.share_name_.SetAllocated(share_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_name_.IsDefault()) {
    _impl_.share_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Printers.Printer.share_name)
}

// -------------------------------------------------------------------

// Printers

// repeated .proto.system_info.Printers.Printer printer = 1;
inline int Printers::_internal_printer_size() const {
  return _impl_.printer_.size();
}
inline int Printers::printer_size() const {
  return _internal_printer_size();
}
inline void Printers::clear_printer() {
  _impl_.printer_.Clear();
}
inline ::proto::system_info::Printers_Printer* Printers::mutable_printer(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Printers.printer)
  return _impl_.printer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Printers_Printer >*
Printers::mutable_printer() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Printers.printer)
  return &_impl_.printer_;
}
inline const ::proto::system_info::Printers_Printer& Printers::_internal_printer(int index) const {
  return _impl_.printer_.Get(index);
}
inline const ::proto::system_info::Printers_Printer& Printers::printer(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Printers.printer)
  return _internal_printer(index);
}
inline ::proto::system_info::Printers_Printer* Printers::_internal_add_printer() {
  return _impl_.printer_.Add();
}
inline ::proto::system_info::Printers_Printer* Printers::add_printer() {
  ::proto::system_info::Printers_Printer* _add = _internal_add_printer();
  // @@protoc_insertion_point(field_add:proto.system_info.Printers.printer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Printers_Printer >&
Printers::printer() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Printers.printer)
  return _impl_.printer_;
}

// -------------------------------------------------------------------

// NetworkAdapters_Adapter_Address

// string ip = 1;
inline void NetworkAdapters_Adapter_Address::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& NetworkAdapters_Adapter_Address::ip() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.Address.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapters_Adapter_Address::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.Address.ip)
}
inline std::string* NetworkAdapters_Adapter_Address::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.Address.ip)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter_Address::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void NetworkAdapters_Adapter_Address::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter_Address::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter_Address::release_ip() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkAdapters.Adapter.Address.ip)
  return _impl_.ip_.Release();
}
inline void NetworkAdapters_Adapter_Address::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkAdapters.Adapter.Address.ip)
}

// string mask = 2;
inline void NetworkAdapters_Adapter_Address::clear_mask() {
  _impl_.mask_.ClearToEmpty();
}
inline const std::string& NetworkAdapters_Adapter_Address::mask() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.Address.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapters_Adapter_Address::set_mask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.Address.mask)
}
inline std::string* NetworkAdapters_Adapter_Address::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.Address.mask)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter_Address::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void NetworkAdapters_Adapter_Address::_internal_set_mask(const std::string& value) {
  
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter_Address::_internal_mutable_mask() {
  
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter_Address::release_mask() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkAdapters.Adapter.Address.mask)
  return _impl_.mask_.Release();
}
inline void NetworkAdapters_Adapter_Address::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkAdapters.Adapter.Address.mask)
}

// -------------------------------------------------------------------

// NetworkAdapters_Adapter

// string adapter_name = 1;
inline void NetworkAdapters_Adapter::clear_adapter_name() {
  _impl_.adapter_name_.ClearToEmpty();
}
inline const std::string& NetworkAdapters_Adapter::adapter_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.adapter_name)
  return _internal_adapter_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapters_Adapter::set_adapter_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.adapter_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.adapter_name)
}
inline std::string* NetworkAdapters_Adapter::mutable_adapter_name() {
  std::string* _s = _internal_mutable_adapter_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.adapter_name)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_adapter_name() const {
  return _impl_.adapter_name_.Get();
}
inline void NetworkAdapters_Adapter::_internal_set_adapter_name(const std::string& value) {
  
  _impl_.adapter_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::_internal_mutable_adapter_name() {
  
  return _impl_.adapter_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::release_adapter_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkAdapters.Adapter.adapter_name)
  return _impl_.adapter_name_.Release();
}
inline void NetworkAdapters_Adapter::set_allocated_adapter_name(std::string* adapter_name) {
  if (adapter_name != nullptr) {
    
  } else {
    
  }
  _impl_.adapter_name_.SetAllocated(adapter_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.adapter_name_.IsDefault()) {
    _impl_.adapter_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkAdapters.Adapter.adapter_name)
}

// string connection_name = 2;
inline void NetworkAdapters_Adapter::clear_connection_name() {
  _impl_.connection_name_.ClearToEmpty();
}
inline const std::string& NetworkAdapters_Adapter::connection_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.connection_name)
  return _internal_connection_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapters_Adapter::set_connection_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connection_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.connection_name)
}
inline std::string* NetworkAdapters_Adapter::mutable_connection_name() {
  std::string* _s = _internal_mutable_connection_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.connection_name)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_connection_name() const {
  return _impl_.connection_name_.Get();
}
inline void NetworkAdapters_Adapter::_internal_set_connection_name(const std::string& value) {
  
  _impl_.connection_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::_internal_mutable_connection_name() {
  
  return _impl_.connection_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::release_connection_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkAdapters.Adapter.connection_name)
  return _impl_.connection_name_.Release();
}
inline void NetworkAdapters_Adapter::set_allocated_connection_name(std::string* connection_name) {
  if (connection_name != nullptr) {
    
  } else {
    
  }
  _impl_.connection_name_.SetAllocated(connection_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_name_.IsDefault()) {
    _impl_.connection_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkAdapters.Adapter.connection_name)
}

// string iface = 3;
inline void NetworkAdapters_Adapter::clear_iface() {
  _impl_.iface_.ClearToEmpty();
}
inline const std::string& NetworkAdapters_Adapter::iface() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.iface)
  return _internal_iface();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapters_Adapter::set_iface(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iface_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.iface)
}
inline std::string* NetworkAdapters_Adapter::mutable_iface() {
  std::string* _s = _internal_mutable_iface();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.iface)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_iface() const {
  return _impl_.iface_.Get();
}
inline void NetworkAdapters_Adapter::_internal_set_iface(const std::string& value) {
  
  _impl_.iface_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::_internal_mutable_iface() {
  
  return _impl_.iface_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::release_iface() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkAdapters.Adapter.iface)
  return _impl_.iface_.Release();
}
inline void NetworkAdapters_Adapter::set_allocated_iface(std::string* iface) {
  if (iface != nullptr) {
    
  } else {
    
  }
  _impl_.iface_.SetAllocated(iface, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iface_.IsDefault()) {
    _impl_.iface_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkAdapters.Adapter.iface)
}

// uint64 speed = 4;
inline void NetworkAdapters_Adapter::clear_speed() {
  _impl_.speed_ = uint64_t{0u};
}
inline uint64_t NetworkAdapters_Adapter::_internal_speed() const {
  return _impl_.speed_;
}
inline uint64_t NetworkAdapters_Adapter::speed() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.speed)
  return _internal_speed();
}
inline void NetworkAdapters_Adapter::_internal_set_speed(uint64_t value) {
  
  _impl_.speed_ = value;
}
inline void NetworkAdapters_Adapter::set_speed(uint64_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.speed)
}

// string mac = 5;
inline void NetworkAdapters_Adapter::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& NetworkAdapters_Adapter::mac() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkAdapters_Adapter::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.mac)
}
inline std::string* NetworkAdapters_Adapter::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.mac)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void NetworkAdapters_Adapter::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkAdapters_Adapter::release_mac() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkAdapters.Adapter.mac)
  return _impl_.mac_.Release();
}
inline void NetworkAdapters_Adapter::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkAdapters.Adapter.mac)
}

// bool dhcp_enabled = 6;
inline void NetworkAdapters_Adapter::clear_dhcp_enabled() {
  _impl_.dhcp_enabled_ = false;
}
inline bool NetworkAdapters_Adapter::_internal_dhcp_enabled() const {
  return _impl_.dhcp_enabled_;
}
inline bool NetworkAdapters_Adapter::dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.dhcp_enabled)
  return _internal_dhcp_enabled();
}
inline void NetworkAdapters_Adapter::_internal_set_dhcp_enabled(bool value) {
  
  _impl_.dhcp_enabled_ = value;
}
inline void NetworkAdapters_Adapter::set_dhcp_enabled(bool value) {
  _internal_set_dhcp_enabled(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.dhcp_enabled)
}

// repeated string gateway = 7;
inline int NetworkAdapters_Adapter::_internal_gateway_size() const {
  return _impl_.gateway_.size();
}
inline int NetworkAdapters_Adapter::gateway_size() const {
  return _internal_gateway_size();
}
inline void NetworkAdapters_Adapter::clear_gateway() {
  _impl_.gateway_.Clear();
}
inline std::string* NetworkAdapters_Adapter::add_gateway() {
  std::string* _s = _internal_add_gateway();
  // @@protoc_insertion_point(field_add_mutable:proto.system_info.NetworkAdapters.Adapter.gateway)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_gateway(int index) const {
  return _impl_.gateway_.Get(index);
}
inline const std::string& NetworkAdapters_Adapter::gateway(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.gateway)
  return _internal_gateway(index);
}
inline std::string* NetworkAdapters_Adapter::mutable_gateway(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.gateway)
  return _impl_.gateway_.Mutable(index);
}
inline void NetworkAdapters_Adapter::set_gateway(int index, const std::string& value) {
  _impl_.gateway_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline void NetworkAdapters_Adapter::set_gateway(int index, std::string&& value) {
  _impl_.gateway_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline void NetworkAdapters_Adapter::set_gateway(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.gateway_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline void NetworkAdapters_Adapter::set_gateway(int index, const char* value, size_t size) {
  _impl_.gateway_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline std::string* NetworkAdapters_Adapter::_internal_add_gateway() {
  return _impl_.gateway_.Add();
}
inline void NetworkAdapters_Adapter::add_gateway(const std::string& value) {
  _impl_.gateway_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline void NetworkAdapters_Adapter::add_gateway(std::string&& value) {
  _impl_.gateway_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline void NetworkAdapters_Adapter::add_gateway(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.gateway_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline void NetworkAdapters_Adapter::add_gateway(const char* value, size_t size) {
  _impl_.gateway_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.system_info.NetworkAdapters.Adapter.gateway)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkAdapters_Adapter::gateway() const {
  // @@protoc_insertion_point(field_list:proto.system_info.NetworkAdapters.Adapter.gateway)
  return _impl_.gateway_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkAdapters_Adapter::mutable_gateway() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.NetworkAdapters.Adapter.gateway)
  return &_impl_.gateway_;
}

// repeated .proto.system_info.NetworkAdapters.Adapter.Address address = 8;
inline int NetworkAdapters_Adapter::_internal_address_size() const {
  return _impl_.address_.size();
}
inline int NetworkAdapters_Adapter::address_size() const {
  return _internal_address_size();
}
inline void NetworkAdapters_Adapter::clear_address() {
  _impl_.address_.Clear();
}
inline ::proto::system_info::NetworkAdapters_Adapter_Address* NetworkAdapters_Adapter::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.address)
  return _impl_.address_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter_Address >*
NetworkAdapters_Adapter::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.NetworkAdapters.Adapter.address)
  return &_impl_.address_;
}
inline const ::proto::system_info::NetworkAdapters_Adapter_Address& NetworkAdapters_Adapter::_internal_address(int index) const {
  return _impl_.address_.Get(index);
}
inline const ::proto::system_info::NetworkAdapters_Adapter_Address& NetworkAdapters_Adapter::address(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.address)
  return _internal_address(index);
}
inline ::proto::system_info::NetworkAdapters_Adapter_Address* NetworkAdapters_Adapter::_internal_add_address() {
  return _impl_.address_.Add();
}
inline ::proto::system_info::NetworkAdapters_Adapter_Address* NetworkAdapters_Adapter::add_address() {
  ::proto::system_info::NetworkAdapters_Adapter_Address* _add = _internal_add_address();
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.address)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter_Address >&
NetworkAdapters_Adapter::address() const {
  // @@protoc_insertion_point(field_list:proto.system_info.NetworkAdapters.Adapter.address)
  return _impl_.address_;
}

// repeated string dns = 9;
inline int NetworkAdapters_Adapter::_internal_dns_size() const {
  return _impl_.dns_.size();
}
inline int NetworkAdapters_Adapter::dns_size() const {
  return _internal_dns_size();
}
inline void NetworkAdapters_Adapter::clear_dns() {
  _impl_.dns_.Clear();
}
inline std::string* NetworkAdapters_Adapter::add_dns() {
  std::string* _s = _internal_add_dns();
  // @@protoc_insertion_point(field_add_mutable:proto.system_info.NetworkAdapters.Adapter.dns)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_dns(int index) const {
  return _impl_.dns_.Get(index);
}
inline const std::string& NetworkAdapters_Adapter::dns(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.dns)
  return _internal_dns(index);
}
inline std::string* NetworkAdapters_Adapter::mutable_dns(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.dns)
  return _impl_.dns_.Mutable(index);
}
inline void NetworkAdapters_Adapter::set_dns(int index, const std::string& value) {
  _impl_.dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline void NetworkAdapters_Adapter::set_dns(int index, std::string&& value) {
  _impl_.dns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline void NetworkAdapters_Adapter::set_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline void NetworkAdapters_Adapter::set_dns(int index, const char* value, size_t size) {
  _impl_.dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline std::string* NetworkAdapters_Adapter::_internal_add_dns() {
  return _impl_.dns_.Add();
}
inline void NetworkAdapters_Adapter::add_dns(const std::string& value) {
  _impl_.dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline void NetworkAdapters_Adapter::add_dns(std::string&& value) {
  _impl_.dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline void NetworkAdapters_Adapter::add_dns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline void NetworkAdapters_Adapter::add_dns(const char* value, size_t size) {
  _impl_.dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.system_info.NetworkAdapters.Adapter.dns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkAdapters_Adapter::dns() const {
  // @@protoc_insertion_point(field_list:proto.system_info.NetworkAdapters.Adapter.dns)
  return _impl_.dns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkAdapters_Adapter::mutable_dns() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.NetworkAdapters.Adapter.dns)
  return &_impl_.dns_;
}

// repeated string dhcp = 10;
inline int NetworkAdapters_Adapter::_internal_dhcp_size() const {
  return _impl_.dhcp_.size();
}
inline int NetworkAdapters_Adapter::dhcp_size() const {
  return _internal_dhcp_size();
}
inline void NetworkAdapters_Adapter::clear_dhcp() {
  _impl_.dhcp_.Clear();
}
inline std::string* NetworkAdapters_Adapter::add_dhcp() {
  std::string* _s = _internal_add_dhcp();
  // @@protoc_insertion_point(field_add_mutable:proto.system_info.NetworkAdapters.Adapter.dhcp)
  return _s;
}
inline const std::string& NetworkAdapters_Adapter::_internal_dhcp(int index) const {
  return _impl_.dhcp_.Get(index);
}
inline const std::string& NetworkAdapters_Adapter::dhcp(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.Adapter.dhcp)
  return _internal_dhcp(index);
}
inline std::string* NetworkAdapters_Adapter::mutable_dhcp(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.Adapter.dhcp)
  return _impl_.dhcp_.Mutable(index);
}
inline void NetworkAdapters_Adapter::set_dhcp(int index, const std::string& value) {
  _impl_.dhcp_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline void NetworkAdapters_Adapter::set_dhcp(int index, std::string&& value) {
  _impl_.dhcp_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline void NetworkAdapters_Adapter::set_dhcp(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dhcp_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline void NetworkAdapters_Adapter::set_dhcp(int index, const char* value, size_t size) {
  _impl_.dhcp_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline std::string* NetworkAdapters_Adapter::_internal_add_dhcp() {
  return _impl_.dhcp_.Add();
}
inline void NetworkAdapters_Adapter::add_dhcp(const std::string& value) {
  _impl_.dhcp_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline void NetworkAdapters_Adapter::add_dhcp(std::string&& value) {
  _impl_.dhcp_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline void NetworkAdapters_Adapter::add_dhcp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dhcp_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline void NetworkAdapters_Adapter::add_dhcp(const char* value, size_t size) {
  _impl_.dhcp_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.system_info.NetworkAdapters.Adapter.dhcp)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkAdapters_Adapter::dhcp() const {
  // @@protoc_insertion_point(field_list:proto.system_info.NetworkAdapters.Adapter.dhcp)
  return _impl_.dhcp_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkAdapters_Adapter::mutable_dhcp() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.NetworkAdapters.Adapter.dhcp)
  return &_impl_.dhcp_;
}

// -------------------------------------------------------------------

// NetworkAdapters

// repeated .proto.system_info.NetworkAdapters.Adapter adapter = 1;
inline int NetworkAdapters::_internal_adapter_size() const {
  return _impl_.adapter_.size();
}
inline int NetworkAdapters::adapter_size() const {
  return _internal_adapter_size();
}
inline void NetworkAdapters::clear_adapter() {
  _impl_.adapter_.Clear();
}
inline ::proto::system_info::NetworkAdapters_Adapter* NetworkAdapters::mutable_adapter(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkAdapters.adapter)
  return _impl_.adapter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter >*
NetworkAdapters::mutable_adapter() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.NetworkAdapters.adapter)
  return &_impl_.adapter_;
}
inline const ::proto::system_info::NetworkAdapters_Adapter& NetworkAdapters::_internal_adapter(int index) const {
  return _impl_.adapter_.Get(index);
}
inline const ::proto::system_info::NetworkAdapters_Adapter& NetworkAdapters::adapter(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkAdapters.adapter)
  return _internal_adapter(index);
}
inline ::proto::system_info::NetworkAdapters_Adapter* NetworkAdapters::_internal_add_adapter() {
  return _impl_.adapter_.Add();
}
inline ::proto::system_info::NetworkAdapters_Adapter* NetworkAdapters::add_adapter() {
  ::proto::system_info::NetworkAdapters_Adapter* _add = _internal_add_adapter();
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkAdapters.adapter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkAdapters_Adapter >&
NetworkAdapters::adapter() const {
  // @@protoc_insertion_point(field_list:proto.system_info.NetworkAdapters.adapter)
  return _impl_.adapter_;
}

// -------------------------------------------------------------------

// NetworkShares_Share

// string name = 1;
inline void NetworkShares_Share::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NetworkShares_Share::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.Share.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkShares_Share::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkShares.Share.name)
}
inline std::string* NetworkShares_Share::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkShares.Share.name)
  return _s;
}
inline const std::string& NetworkShares_Share::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NetworkShares_Share::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkShares.Share.name)
  return _impl_.name_.Release();
}
inline void NetworkShares_Share::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkShares.Share.name)
}

// string description = 2;
inline void NetworkShares_Share::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& NetworkShares_Share::description() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.Share.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkShares_Share::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkShares.Share.description)
}
inline std::string* NetworkShares_Share::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkShares.Share.description)
  return _s;
}
inline const std::string& NetworkShares_Share::_internal_description() const {
  return _impl_.description_.Get();
}
inline void NetworkShares_Share::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::release_description() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkShares.Share.description)
  return _impl_.description_.Release();
}
inline void NetworkShares_Share::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkShares.Share.description)
}

// string type = 3;
inline void NetworkShares_Share::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& NetworkShares_Share::type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.Share.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkShares_Share::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkShares.Share.type)
}
inline std::string* NetworkShares_Share::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkShares.Share.type)
  return _s;
}
inline const std::string& NetworkShares_Share::_internal_type() const {
  return _impl_.type_.Get();
}
inline void NetworkShares_Share::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::release_type() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkShares.Share.type)
  return _impl_.type_.Release();
}
inline void NetworkShares_Share::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkShares.Share.type)
}

// string local_path = 4;
inline void NetworkShares_Share::clear_local_path() {
  _impl_.local_path_.ClearToEmpty();
}
inline const std::string& NetworkShares_Share::local_path() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.Share.local_path)
  return _internal_local_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkShares_Share::set_local_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkShares.Share.local_path)
}
inline std::string* NetworkShares_Share::mutable_local_path() {
  std::string* _s = _internal_mutable_local_path();
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkShares.Share.local_path)
  return _s;
}
inline const std::string& NetworkShares_Share::_internal_local_path() const {
  return _impl_.local_path_.Get();
}
inline void NetworkShares_Share::_internal_set_local_path(const std::string& value) {
  
  _impl_.local_path_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::_internal_mutable_local_path() {
  
  return _impl_.local_path_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkShares_Share::release_local_path() {
  // @@protoc_insertion_point(field_release:proto.system_info.NetworkShares.Share.local_path)
  return _impl_.local_path_.Release();
}
inline void NetworkShares_Share::set_allocated_local_path(std::string* local_path) {
  if (local_path != nullptr) {
    
  } else {
    
  }
  _impl_.local_path_.SetAllocated(local_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_path_.IsDefault()) {
    _impl_.local_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.NetworkShares.Share.local_path)
}

// uint32 current_uses = 5;
inline void NetworkShares_Share::clear_current_uses() {
  _impl_.current_uses_ = 0u;
}
inline uint32_t NetworkShares_Share::_internal_current_uses() const {
  return _impl_.current_uses_;
}
inline uint32_t NetworkShares_Share::current_uses() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.Share.current_uses)
  return _internal_current_uses();
}
inline void NetworkShares_Share::_internal_set_current_uses(uint32_t value) {
  
  _impl_.current_uses_ = value;
}
inline void NetworkShares_Share::set_current_uses(uint32_t value) {
  _internal_set_current_uses(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkShares.Share.current_uses)
}

// uint32 max_uses = 6;
inline void NetworkShares_Share::clear_max_uses() {
  _impl_.max_uses_ = 0u;
}
inline uint32_t NetworkShares_Share::_internal_max_uses() const {
  return _impl_.max_uses_;
}
inline uint32_t NetworkShares_Share::max_uses() const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.Share.max_uses)
  return _internal_max_uses();
}
inline void NetworkShares_Share::_internal_set_max_uses(uint32_t value) {
  
  _impl_.max_uses_ = value;
}
inline void NetworkShares_Share::set_max_uses(uint32_t value) {
  _internal_set_max_uses(value);
  // @@protoc_insertion_point(field_set:proto.system_info.NetworkShares.Share.max_uses)
}

// -------------------------------------------------------------------

// NetworkShares

// repeated .proto.system_info.NetworkShares.Share share = 1;
inline int NetworkShares::_internal_share_size() const {
  return _impl_.share_.size();
}
inline int NetworkShares::share_size() const {
  return _internal_share_size();
}
inline void NetworkShares::clear_share() {
  _impl_.share_.Clear();
}
inline ::proto::system_info::NetworkShares_Share* NetworkShares::mutable_share(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.NetworkShares.share)
  return _impl_.share_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkShares_Share >*
NetworkShares::mutable_share() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.NetworkShares.share)
  return &_impl_.share_;
}
inline const ::proto::system_info::NetworkShares_Share& NetworkShares::_internal_share(int index) const {
  return _impl_.share_.Get(index);
}
inline const ::proto::system_info::NetworkShares_Share& NetworkShares::share(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.NetworkShares.share)
  return _internal_share(index);
}
inline ::proto::system_info::NetworkShares_Share* NetworkShares::_internal_add_share() {
  return _impl_.share_.Add();
}
inline ::proto::system_info::NetworkShares_Share* NetworkShares::add_share() {
  ::proto::system_info::NetworkShares_Share* _add = _internal_add_share();
  // @@protoc_insertion_point(field_add:proto.system_info.NetworkShares.share)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::NetworkShares_Share >&
NetworkShares::share() const {
  // @@protoc_insertion_point(field_list:proto.system_info.NetworkShares.share)
  return _impl_.share_;
}

// -------------------------------------------------------------------

// WindowsDevices_Device

// string friendly_name = 1;
inline void WindowsDevices_Device::clear_friendly_name() {
  _impl_.friendly_name_.ClearToEmpty();
}
inline const std::string& WindowsDevices_Device::friendly_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.Device.friendly_name)
  return _internal_friendly_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsDevices_Device::set_friendly_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.friendly_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.WindowsDevices.Device.friendly_name)
}
inline std::string* WindowsDevices_Device::mutable_friendly_name() {
  std::string* _s = _internal_mutable_friendly_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.Device.friendly_name)
  return _s;
}
inline const std::string& WindowsDevices_Device::_internal_friendly_name() const {
  return _impl_.friendly_name_.Get();
}
inline void WindowsDevices_Device::_internal_set_friendly_name(const std::string& value) {
  
  _impl_.friendly_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::_internal_mutable_friendly_name() {
  
  return _impl_.friendly_name_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::release_friendly_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.WindowsDevices.Device.friendly_name)
  return _impl_.friendly_name_.Release();
}
inline void WindowsDevices_Device::set_allocated_friendly_name(std::string* friendly_name) {
  if (friendly_name != nullptr) {
    
  } else {
    
  }
  _impl_.friendly_name_.SetAllocated(friendly_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.friendly_name_.IsDefault()) {
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.WindowsDevices.Device.friendly_name)
}

// string description = 2;
inline void WindowsDevices_Device::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& WindowsDevices_Device::description() const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.Device.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsDevices_Device::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.WindowsDevices.Device.description)
}
inline std::string* WindowsDevices_Device::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.Device.description)
  return _s;
}
inline const std::string& WindowsDevices_Device::_internal_description() const {
  return _impl_.description_.Get();
}
inline void WindowsDevices_Device::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::release_description() {
  // @@protoc_insertion_point(field_release:proto.system_info.WindowsDevices.Device.description)
  return _impl_.description_.Release();
}
inline void WindowsDevices_Device::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.WindowsDevices.Device.description)
}

// string driver_version = 3;
inline void WindowsDevices_Device::clear_driver_version() {
  _impl_.driver_version_.ClearToEmpty();
}
inline const std::string& WindowsDevices_Device::driver_version() const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.Device.driver_version)
  return _internal_driver_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsDevices_Device::set_driver_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.WindowsDevices.Device.driver_version)
}
inline std::string* WindowsDevices_Device::mutable_driver_version() {
  std::string* _s = _internal_mutable_driver_version();
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.Device.driver_version)
  return _s;
}
inline const std::string& WindowsDevices_Device::_internal_driver_version() const {
  return _impl_.driver_version_.Get();
}
inline void WindowsDevices_Device::_internal_set_driver_version(const std::string& value) {
  
  _impl_.driver_version_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::_internal_mutable_driver_version() {
  
  return _impl_.driver_version_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::release_driver_version() {
  // @@protoc_insertion_point(field_release:proto.system_info.WindowsDevices.Device.driver_version)
  return _impl_.driver_version_.Release();
}
inline void WindowsDevices_Device::set_allocated_driver_version(std::string* driver_version) {
  if (driver_version != nullptr) {
    
  } else {
    
  }
  _impl_.driver_version_.SetAllocated(driver_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_version_.IsDefault()) {
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.WindowsDevices.Device.driver_version)
}

// string driver_date = 4;
inline void WindowsDevices_Device::clear_driver_date() {
  _impl_.driver_date_.ClearToEmpty();
}
inline const std::string& WindowsDevices_Device::driver_date() const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.Device.driver_date)
  return _internal_driver_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsDevices_Device::set_driver_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.WindowsDevices.Device.driver_date)
}
inline std::string* WindowsDevices_Device::mutable_driver_date() {
  std::string* _s = _internal_mutable_driver_date();
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.Device.driver_date)
  return _s;
}
inline const std::string& WindowsDevices_Device::_internal_driver_date() const {
  return _impl_.driver_date_.Get();
}
inline void WindowsDevices_Device::_internal_set_driver_date(const std::string& value) {
  
  _impl_.driver_date_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::_internal_mutable_driver_date() {
  
  return _impl_.driver_date_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::release_driver_date() {
  // @@protoc_insertion_point(field_release:proto.system_info.WindowsDevices.Device.driver_date)
  return _impl_.driver_date_.Release();
}
inline void WindowsDevices_Device::set_allocated_driver_date(std::string* driver_date) {
  if (driver_date != nullptr) {
    
  } else {
    
  }
  _impl_.driver_date_.SetAllocated(driver_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_date_.IsDefault()) {
    _impl_.driver_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.WindowsDevices.Device.driver_date)
}

// string driver_vendor = 5;
inline void WindowsDevices_Device::clear_driver_vendor() {
  _impl_.driver_vendor_.ClearToEmpty();
}
inline const std::string& WindowsDevices_Device::driver_vendor() const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.Device.driver_vendor)
  return _internal_driver_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsDevices_Device::set_driver_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.WindowsDevices.Device.driver_vendor)
}
inline std::string* WindowsDevices_Device::mutable_driver_vendor() {
  std::string* _s = _internal_mutable_driver_vendor();
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.Device.driver_vendor)
  return _s;
}
inline const std::string& WindowsDevices_Device::_internal_driver_vendor() const {
  return _impl_.driver_vendor_.Get();
}
inline void WindowsDevices_Device::_internal_set_driver_vendor(const std::string& value) {
  
  _impl_.driver_vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::_internal_mutable_driver_vendor() {
  
  return _impl_.driver_vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::release_driver_vendor() {
  // @@protoc_insertion_point(field_release:proto.system_info.WindowsDevices.Device.driver_vendor)
  return _impl_.driver_vendor_.Release();
}
inline void WindowsDevices_Device::set_allocated_driver_vendor(std::string* driver_vendor) {
  if (driver_vendor != nullptr) {
    
  } else {
    
  }
  _impl_.driver_vendor_.SetAllocated(driver_vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_vendor_.IsDefault()) {
    _impl_.driver_vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.WindowsDevices.Device.driver_vendor)
}

// string device_id = 6;
inline void WindowsDevices_Device::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& WindowsDevices_Device::device_id() const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.Device.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsDevices_Device::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.WindowsDevices.Device.device_id)
}
inline std::string* WindowsDevices_Device::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.Device.device_id)
  return _s;
}
inline const std::string& WindowsDevices_Device::_internal_device_id() const {
  return _impl_.device_id_.Get();
}
inline void WindowsDevices_Device::_internal_set_device_id(const std::string& value) {
  
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::_internal_mutable_device_id() {
  
  return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsDevices_Device::release_device_id() {
  // @@protoc_insertion_point(field_release:proto.system_info.WindowsDevices.Device.device_id)
  return _impl_.device_id_.Release();
}
inline void WindowsDevices_Device::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.WindowsDevices.Device.device_id)
}

// -------------------------------------------------------------------

// WindowsDevices

// repeated .proto.system_info.WindowsDevices.Device device = 1;
inline int WindowsDevices::_internal_device_size() const {
  return _impl_.device_.size();
}
inline int WindowsDevices::device_size() const {
  return _internal_device_size();
}
inline void WindowsDevices::clear_device() {
  _impl_.device_.Clear();
}
inline ::proto::system_info::WindowsDevices_Device* WindowsDevices::mutable_device(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.WindowsDevices.device)
  return _impl_.device_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::WindowsDevices_Device >*
WindowsDevices::mutable_device() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.WindowsDevices.device)
  return &_impl_.device_;
}
inline const ::proto::system_info::WindowsDevices_Device& WindowsDevices::_internal_device(int index) const {
  return _impl_.device_.Get(index);
}
inline const ::proto::system_info::WindowsDevices_Device& WindowsDevices::device(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.WindowsDevices.device)
  return _internal_device(index);
}
inline ::proto::system_info::WindowsDevices_Device* WindowsDevices::_internal_add_device() {
  return _impl_.device_.Add();
}
inline ::proto::system_info::WindowsDevices_Device* WindowsDevices::add_device() {
  ::proto::system_info::WindowsDevices_Device* _add = _internal_add_device();
  // @@protoc_insertion_point(field_add:proto.system_info.WindowsDevices.device)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::WindowsDevices_Device >&
WindowsDevices::device() const {
  // @@protoc_insertion_point(field_list:proto.system_info.WindowsDevices.device)
  return _impl_.device_;
}

// -------------------------------------------------------------------

// VideoAdapters_Adapter

// string description = 1;
inline void VideoAdapters_Adapter::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::description() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.description)
}
inline std::string* VideoAdapters_Adapter::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.description)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_description() const {
  return _impl_.description_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_description() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.description)
  return _impl_.description_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.description)
}

// string adapter_string = 2;
inline void VideoAdapters_Adapter::clear_adapter_string() {
  _impl_.adapter_string_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::adapter_string() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.adapter_string)
  return _internal_adapter_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_adapter_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.adapter_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.adapter_string)
}
inline std::string* VideoAdapters_Adapter::mutable_adapter_string() {
  std::string* _s = _internal_mutable_adapter_string();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.adapter_string)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_adapter_string() const {
  return _impl_.adapter_string_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_adapter_string(const std::string& value) {
  
  _impl_.adapter_string_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_adapter_string() {
  
  return _impl_.adapter_string_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_adapter_string() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.adapter_string)
  return _impl_.adapter_string_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_adapter_string(std::string* adapter_string) {
  if (adapter_string != nullptr) {
    
  } else {
    
  }
  _impl_.adapter_string_.SetAllocated(adapter_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.adapter_string_.IsDefault()) {
    _impl_.adapter_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.adapter_string)
}

// string bios_string = 3;
inline void VideoAdapters_Adapter::clear_bios_string() {
  _impl_.bios_string_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::bios_string() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.bios_string)
  return _internal_bios_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_bios_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bios_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.bios_string)
}
inline std::string* VideoAdapters_Adapter::mutable_bios_string() {
  std::string* _s = _internal_mutable_bios_string();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.bios_string)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_bios_string() const {
  return _impl_.bios_string_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_bios_string(const std::string& value) {
  
  _impl_.bios_string_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_bios_string() {
  
  return _impl_.bios_string_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_bios_string() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.bios_string)
  return _impl_.bios_string_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_bios_string(std::string* bios_string) {
  if (bios_string != nullptr) {
    
  } else {
    
  }
  _impl_.bios_string_.SetAllocated(bios_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bios_string_.IsDefault()) {
    _impl_.bios_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.bios_string)
}

// string chip_type = 4;
inline void VideoAdapters_Adapter::clear_chip_type() {
  _impl_.chip_type_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::chip_type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.chip_type)
  return _internal_chip_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_chip_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chip_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.chip_type)
}
inline std::string* VideoAdapters_Adapter::mutable_chip_type() {
  std::string* _s = _internal_mutable_chip_type();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.chip_type)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_chip_type() const {
  return _impl_.chip_type_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_chip_type(const std::string& value) {
  
  _impl_.chip_type_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_chip_type() {
  
  return _impl_.chip_type_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_chip_type() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.chip_type)
  return _impl_.chip_type_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_chip_type(std::string* chip_type) {
  if (chip_type != nullptr) {
    
  } else {
    
  }
  _impl_.chip_type_.SetAllocated(chip_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chip_type_.IsDefault()) {
    _impl_.chip_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.chip_type)
}

// string dac_type = 5;
inline void VideoAdapters_Adapter::clear_dac_type() {
  _impl_.dac_type_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::dac_type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.dac_type)
  return _internal_dac_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_dac_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dac_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.dac_type)
}
inline std::string* VideoAdapters_Adapter::mutable_dac_type() {
  std::string* _s = _internal_mutable_dac_type();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.dac_type)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_dac_type() const {
  return _impl_.dac_type_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_dac_type(const std::string& value) {
  
  _impl_.dac_type_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_dac_type() {
  
  return _impl_.dac_type_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_dac_type() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.dac_type)
  return _impl_.dac_type_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_dac_type(std::string* dac_type) {
  if (dac_type != nullptr) {
    
  } else {
    
  }
  _impl_.dac_type_.SetAllocated(dac_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dac_type_.IsDefault()) {
    _impl_.dac_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.dac_type)
}

// string driver_date = 6;
inline void VideoAdapters_Adapter::clear_driver_date() {
  _impl_.driver_date_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::driver_date() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.driver_date)
  return _internal_driver_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_driver_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.driver_date)
}
inline std::string* VideoAdapters_Adapter::mutable_driver_date() {
  std::string* _s = _internal_mutable_driver_date();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.driver_date)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_driver_date() const {
  return _impl_.driver_date_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_driver_date(const std::string& value) {
  
  _impl_.driver_date_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_driver_date() {
  
  return _impl_.driver_date_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_driver_date() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.driver_date)
  return _impl_.driver_date_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_driver_date(std::string* driver_date) {
  if (driver_date != nullptr) {
    
  } else {
    
  }
  _impl_.driver_date_.SetAllocated(driver_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_date_.IsDefault()) {
    _impl_.driver_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.driver_date)
}

// string driver_version = 7;
inline void VideoAdapters_Adapter::clear_driver_version() {
  _impl_.driver_version_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::driver_version() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.driver_version)
  return _internal_driver_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_driver_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.driver_version)
}
inline std::string* VideoAdapters_Adapter::mutable_driver_version() {
  std::string* _s = _internal_mutable_driver_version();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.driver_version)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_driver_version() const {
  return _impl_.driver_version_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_driver_version(const std::string& value) {
  
  _impl_.driver_version_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_driver_version() {
  
  return _impl_.driver_version_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_driver_version() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.driver_version)
  return _impl_.driver_version_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_driver_version(std::string* driver_version) {
  if (driver_version != nullptr) {
    
  } else {
    
  }
  _impl_.driver_version_.SetAllocated(driver_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_version_.IsDefault()) {
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.driver_version)
}

// string driver_provider = 8;
inline void VideoAdapters_Adapter::clear_driver_provider() {
  _impl_.driver_provider_.ClearToEmpty();
}
inline const std::string& VideoAdapters_Adapter::driver_provider() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.driver_provider)
  return _internal_driver_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAdapters_Adapter::set_driver_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.driver_provider)
}
inline std::string* VideoAdapters_Adapter::mutable_driver_provider() {
  std::string* _s = _internal_mutable_driver_provider();
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.Adapter.driver_provider)
  return _s;
}
inline const std::string& VideoAdapters_Adapter::_internal_driver_provider() const {
  return _impl_.driver_provider_.Get();
}
inline void VideoAdapters_Adapter::_internal_set_driver_provider(const std::string& value) {
  
  _impl_.driver_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::_internal_mutable_driver_provider() {
  
  return _impl_.driver_provider_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAdapters_Adapter::release_driver_provider() {
  // @@protoc_insertion_point(field_release:proto.system_info.VideoAdapters.Adapter.driver_provider)
  return _impl_.driver_provider_.Release();
}
inline void VideoAdapters_Adapter::set_allocated_driver_provider(std::string* driver_provider) {
  if (driver_provider != nullptr) {
    
  } else {
    
  }
  _impl_.driver_provider_.SetAllocated(driver_provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_provider_.IsDefault()) {
    _impl_.driver_provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.VideoAdapters.Adapter.driver_provider)
}

// uint64 memory_size = 9;
inline void VideoAdapters_Adapter::clear_memory_size() {
  _impl_.memory_size_ = uint64_t{0u};
}
inline uint64_t VideoAdapters_Adapter::_internal_memory_size() const {
  return _impl_.memory_size_;
}
inline uint64_t VideoAdapters_Adapter::memory_size() const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.Adapter.memory_size)
  return _internal_memory_size();
}
inline void VideoAdapters_Adapter::_internal_set_memory_size(uint64_t value) {
  
  _impl_.memory_size_ = value;
}
inline void VideoAdapters_Adapter::set_memory_size(uint64_t value) {
  _internal_set_memory_size(value);
  // @@protoc_insertion_point(field_set:proto.system_info.VideoAdapters.Adapter.memory_size)
}

// -------------------------------------------------------------------

// VideoAdapters

// repeated .proto.system_info.VideoAdapters.Adapter adapter = 1;
inline int VideoAdapters::_internal_adapter_size() const {
  return _impl_.adapter_.size();
}
inline int VideoAdapters::adapter_size() const {
  return _internal_adapter_size();
}
inline void VideoAdapters::clear_adapter() {
  _impl_.adapter_.Clear();
}
inline ::proto::system_info::VideoAdapters_Adapter* VideoAdapters::mutable_adapter(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.VideoAdapters.adapter)
  return _impl_.adapter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::VideoAdapters_Adapter >*
VideoAdapters::mutable_adapter() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.VideoAdapters.adapter)
  return &_impl_.adapter_;
}
inline const ::proto::system_info::VideoAdapters_Adapter& VideoAdapters::_internal_adapter(int index) const {
  return _impl_.adapter_.Get(index);
}
inline const ::proto::system_info::VideoAdapters_Adapter& VideoAdapters::adapter(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.VideoAdapters.adapter)
  return _internal_adapter(index);
}
inline ::proto::system_info::VideoAdapters_Adapter* VideoAdapters::_internal_add_adapter() {
  return _impl_.adapter_.Add();
}
inline ::proto::system_info::VideoAdapters_Adapter* VideoAdapters::add_adapter() {
  ::proto::system_info::VideoAdapters_Adapter* _add = _internal_add_adapter();
  // @@protoc_insertion_point(field_add:proto.system_info.VideoAdapters.adapter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::VideoAdapters_Adapter >&
VideoAdapters::adapter() const {
  // @@protoc_insertion_point(field_list:proto.system_info.VideoAdapters.adapter)
  return _impl_.adapter_;
}

// -------------------------------------------------------------------

// Monitors_Monitor_Timing

// int32 width = 1;
inline void Monitors_Monitor_Timing::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t Monitors_Monitor_Timing::_internal_width() const {
  return _impl_.width_;
}
inline int32_t Monitors_Monitor_Timing::width() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.Timing.width)
  return _internal_width();
}
inline void Monitors_Monitor_Timing::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void Monitors_Monitor_Timing::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.Timing.width)
}

// int32 height = 2;
inline void Monitors_Monitor_Timing::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t Monitors_Monitor_Timing::_internal_height() const {
  return _impl_.height_;
}
inline int32_t Monitors_Monitor_Timing::height() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.Timing.height)
  return _internal_height();
}
inline void Monitors_Monitor_Timing::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void Monitors_Monitor_Timing::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.Timing.height)
}

// int32 frequency = 3;
inline void Monitors_Monitor_Timing::clear_frequency() {
  _impl_.frequency_ = 0;
}
inline int32_t Monitors_Monitor_Timing::_internal_frequency() const {
  return _impl_.frequency_;
}
inline int32_t Monitors_Monitor_Timing::frequency() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.Timing.frequency)
  return _internal_frequency();
}
inline void Monitors_Monitor_Timing::_internal_set_frequency(int32_t value) {
  
  _impl_.frequency_ = value;
}
inline void Monitors_Monitor_Timing::set_frequency(int32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.Timing.frequency)
}

// -------------------------------------------------------------------

// Monitors_Monitor

// string system_name = 1;
inline void Monitors_Monitor::clear_system_name() {
  _impl_.system_name_.ClearToEmpty();
}
inline const std::string& Monitors_Monitor::system_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.system_name)
  return _internal_system_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitors_Monitor::set_system_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.system_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.system_name)
}
inline std::string* Monitors_Monitor::mutable_system_name() {
  std::string* _s = _internal_mutable_system_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.Monitor.system_name)
  return _s;
}
inline const std::string& Monitors_Monitor::_internal_system_name() const {
  return _impl_.system_name_.Get();
}
inline void Monitors_Monitor::_internal_set_system_name(const std::string& value) {
  
  _impl_.system_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::_internal_mutable_system_name() {
  
  return _impl_.system_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::release_system_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Monitors.Monitor.system_name)
  return _impl_.system_name_.Release();
}
inline void Monitors_Monitor::set_allocated_system_name(std::string* system_name) {
  if (system_name != nullptr) {
    
  } else {
    
  }
  _impl_.system_name_.SetAllocated(system_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_name_.IsDefault()) {
    _impl_.system_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Monitors.Monitor.system_name)
}

// string monitor_name = 2;
inline void Monitors_Monitor::clear_monitor_name() {
  _impl_.monitor_name_.ClearToEmpty();
}
inline const std::string& Monitors_Monitor::monitor_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.monitor_name)
  return _internal_monitor_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitors_Monitor::set_monitor_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.monitor_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.monitor_name)
}
inline std::string* Monitors_Monitor::mutable_monitor_name() {
  std::string* _s = _internal_mutable_monitor_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.Monitor.monitor_name)
  return _s;
}
inline const std::string& Monitors_Monitor::_internal_monitor_name() const {
  return _impl_.monitor_name_.Get();
}
inline void Monitors_Monitor::_internal_set_monitor_name(const std::string& value) {
  
  _impl_.monitor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::_internal_mutable_monitor_name() {
  
  return _impl_.monitor_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::release_monitor_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Monitors.Monitor.monitor_name)
  return _impl_.monitor_name_.Release();
}
inline void Monitors_Monitor::set_allocated_monitor_name(std::string* monitor_name) {
  if (monitor_name != nullptr) {
    
  } else {
    
  }
  _impl_.monitor_name_.SetAllocated(monitor_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.monitor_name_.IsDefault()) {
    _impl_.monitor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Monitors.Monitor.monitor_name)
}

// string manufacturer_name = 3;
inline void Monitors_Monitor::clear_manufacturer_name() {
  _impl_.manufacturer_name_.ClearToEmpty();
}
inline const std::string& Monitors_Monitor::manufacturer_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.manufacturer_name)
  return _internal_manufacturer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitors_Monitor::set_manufacturer_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manufacturer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.manufacturer_name)
}
inline std::string* Monitors_Monitor::mutable_manufacturer_name() {
  std::string* _s = _internal_mutable_manufacturer_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.Monitor.manufacturer_name)
  return _s;
}
inline const std::string& Monitors_Monitor::_internal_manufacturer_name() const {
  return _impl_.manufacturer_name_.Get();
}
inline void Monitors_Monitor::_internal_set_manufacturer_name(const std::string& value) {
  
  _impl_.manufacturer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::_internal_mutable_manufacturer_name() {
  
  return _impl_.manufacturer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::release_manufacturer_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Monitors.Monitor.manufacturer_name)
  return _impl_.manufacturer_name_.Release();
}
inline void Monitors_Monitor::set_allocated_manufacturer_name(std::string* manufacturer_name) {
  if (manufacturer_name != nullptr) {
    
  } else {
    
  }
  _impl_.manufacturer_name_.SetAllocated(manufacturer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_name_.IsDefault()) {
    _impl_.manufacturer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Monitors.Monitor.manufacturer_name)
}

// string monitor_id = 4;
inline void Monitors_Monitor::clear_monitor_id() {
  _impl_.monitor_id_.ClearToEmpty();
}
inline const std::string& Monitors_Monitor::monitor_id() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.monitor_id)
  return _internal_monitor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitors_Monitor::set_monitor_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.monitor_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.monitor_id)
}
inline std::string* Monitors_Monitor::mutable_monitor_id() {
  std::string* _s = _internal_mutable_monitor_id();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.Monitor.monitor_id)
  return _s;
}
inline const std::string& Monitors_Monitor::_internal_monitor_id() const {
  return _impl_.monitor_id_.Get();
}
inline void Monitors_Monitor::_internal_set_monitor_id(const std::string& value) {
  
  _impl_.monitor_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::_internal_mutable_monitor_id() {
  
  return _impl_.monitor_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::release_monitor_id() {
  // @@protoc_insertion_point(field_release:proto.system_info.Monitors.Monitor.monitor_id)
  return _impl_.monitor_id_.Release();
}
inline void Monitors_Monitor::set_allocated_monitor_id(std::string* monitor_id) {
  if (monitor_id != nullptr) {
    
  } else {
    
  }
  _impl_.monitor_id_.SetAllocated(monitor_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.monitor_id_.IsDefault()) {
    _impl_.monitor_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Monitors.Monitor.monitor_id)
}

// string serial_number = 5;
inline void Monitors_Monitor::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
}
inline const std::string& Monitors_Monitor::serial_number() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitors_Monitor::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.serial_number)
}
inline std::string* Monitors_Monitor::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.Monitor.serial_number)
  return _s;
}
inline const std::string& Monitors_Monitor::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void Monitors_Monitor::_internal_set_serial_number(const std::string& value) {
  
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::_internal_mutable_serial_number() {
  
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* Monitors_Monitor::release_serial_number() {
  // @@protoc_insertion_point(field_release:proto.system_info.Monitors.Monitor.serial_number)
  return _impl_.serial_number_.Release();
}
inline void Monitors_Monitor::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Monitors.Monitor.serial_number)
}

// int32 edid_version = 6;
inline void Monitors_Monitor::clear_edid_version() {
  _impl_.edid_version_ = 0;
}
inline int32_t Monitors_Monitor::_internal_edid_version() const {
  return _impl_.edid_version_;
}
inline int32_t Monitors_Monitor::edid_version() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.edid_version)
  return _internal_edid_version();
}
inline void Monitors_Monitor::_internal_set_edid_version(int32_t value) {
  
  _impl_.edid_version_ = value;
}
inline void Monitors_Monitor::set_edid_version(int32_t value) {
  _internal_set_edid_version(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.edid_version)
}

// int32 edid_revision = 7;
inline void Monitors_Monitor::clear_edid_revision() {
  _impl_.edid_revision_ = 0;
}
inline int32_t Monitors_Monitor::_internal_edid_revision() const {
  return _impl_.edid_revision_;
}
inline int32_t Monitors_Monitor::edid_revision() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.edid_revision)
  return _internal_edid_revision();
}
inline void Monitors_Monitor::_internal_set_edid_revision(int32_t value) {
  
  _impl_.edid_revision_ = value;
}
inline void Monitors_Monitor::set_edid_revision(int32_t value) {
  _internal_set_edid_revision(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.edid_revision)
}

// int32 week_of_manufacture = 8;
inline void Monitors_Monitor::clear_week_of_manufacture() {
  _impl_.week_of_manufacture_ = 0;
}
inline int32_t Monitors_Monitor::_internal_week_of_manufacture() const {
  return _impl_.week_of_manufacture_;
}
inline int32_t Monitors_Monitor::week_of_manufacture() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.week_of_manufacture)
  return _internal_week_of_manufacture();
}
inline void Monitors_Monitor::_internal_set_week_of_manufacture(int32_t value) {
  
  _impl_.week_of_manufacture_ = value;
}
inline void Monitors_Monitor::set_week_of_manufacture(int32_t value) {
  _internal_set_week_of_manufacture(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.week_of_manufacture)
}

// int32 year_of_manufacture = 9;
inline void Monitors_Monitor::clear_year_of_manufacture() {
  _impl_.year_of_manufacture_ = 0;
}
inline int32_t Monitors_Monitor::_internal_year_of_manufacture() const {
  return _impl_.year_of_manufacture_;
}
inline int32_t Monitors_Monitor::year_of_manufacture() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.year_of_manufacture)
  return _internal_year_of_manufacture();
}
inline void Monitors_Monitor::_internal_set_year_of_manufacture(int32_t value) {
  
  _impl_.year_of_manufacture_ = value;
}
inline void Monitors_Monitor::set_year_of_manufacture(int32_t value) {
  _internal_set_year_of_manufacture(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.year_of_manufacture)
}

// int32 max_horizontal_image_size = 10;
inline void Monitors_Monitor::clear_max_horizontal_image_size() {
  _impl_.max_horizontal_image_size_ = 0;
}
inline int32_t Monitors_Monitor::_internal_max_horizontal_image_size() const {
  return _impl_.max_horizontal_image_size_;
}
inline int32_t Monitors_Monitor::max_horizontal_image_size() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.max_horizontal_image_size)
  return _internal_max_horizontal_image_size();
}
inline void Monitors_Monitor::_internal_set_max_horizontal_image_size(int32_t value) {
  
  _impl_.max_horizontal_image_size_ = value;
}
inline void Monitors_Monitor::set_max_horizontal_image_size(int32_t value) {
  _internal_set_max_horizontal_image_size(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.max_horizontal_image_size)
}

// int32 max_vertical_image_size = 11;
inline void Monitors_Monitor::clear_max_vertical_image_size() {
  _impl_.max_vertical_image_size_ = 0;
}
inline int32_t Monitors_Monitor::_internal_max_vertical_image_size() const {
  return _impl_.max_vertical_image_size_;
}
inline int32_t Monitors_Monitor::max_vertical_image_size() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.max_vertical_image_size)
  return _internal_max_vertical_image_size();
}
inline void Monitors_Monitor::_internal_set_max_vertical_image_size(int32_t value) {
  
  _impl_.max_vertical_image_size_ = value;
}
inline void Monitors_Monitor::set_max_vertical_image_size(int32_t value) {
  _internal_set_max_vertical_image_size(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.max_vertical_image_size)
}

// int32 horizontal_resolution = 12;
inline void Monitors_Monitor::clear_horizontal_resolution() {
  _impl_.horizontal_resolution_ = 0;
}
inline int32_t Monitors_Monitor::_internal_horizontal_resolution() const {
  return _impl_.horizontal_resolution_;
}
inline int32_t Monitors_Monitor::horizontal_resolution() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.horizontal_resolution)
  return _internal_horizontal_resolution();
}
inline void Monitors_Monitor::_internal_set_horizontal_resolution(int32_t value) {
  
  _impl_.horizontal_resolution_ = value;
}
inline void Monitors_Monitor::set_horizontal_resolution(int32_t value) {
  _internal_set_horizontal_resolution(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.horizontal_resolution)
}

// int32 vertical_resoulution = 13;
inline void Monitors_Monitor::clear_vertical_resoulution() {
  _impl_.vertical_resoulution_ = 0;
}
inline int32_t Monitors_Monitor::_internal_vertical_resoulution() const {
  return _impl_.vertical_resoulution_;
}
inline int32_t Monitors_Monitor::vertical_resoulution() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.vertical_resoulution)
  return _internal_vertical_resoulution();
}
inline void Monitors_Monitor::_internal_set_vertical_resoulution(int32_t value) {
  
  _impl_.vertical_resoulution_ = value;
}
inline void Monitors_Monitor::set_vertical_resoulution(int32_t value) {
  _internal_set_vertical_resoulution(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.vertical_resoulution)
}

// double gamma = 14;
inline void Monitors_Monitor::clear_gamma() {
  _impl_.gamma_ = 0;
}
inline double Monitors_Monitor::_internal_gamma() const {
  return _impl_.gamma_;
}
inline double Monitors_Monitor::gamma() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.gamma)
  return _internal_gamma();
}
inline void Monitors_Monitor::_internal_set_gamma(double value) {
  
  _impl_.gamma_ = value;
}
inline void Monitors_Monitor::set_gamma(double value) {
  _internal_set_gamma(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.gamma)
}

// int32 min_horizontal_rate = 15;
inline void Monitors_Monitor::clear_min_horizontal_rate() {
  _impl_.min_horizontal_rate_ = 0;
}
inline int32_t Monitors_Monitor::_internal_min_horizontal_rate() const {
  return _impl_.min_horizontal_rate_;
}
inline int32_t Monitors_Monitor::min_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.min_horizontal_rate)
  return _internal_min_horizontal_rate();
}
inline void Monitors_Monitor::_internal_set_min_horizontal_rate(int32_t value) {
  
  _impl_.min_horizontal_rate_ = value;
}
inline void Monitors_Monitor::set_min_horizontal_rate(int32_t value) {
  _internal_set_min_horizontal_rate(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.min_horizontal_rate)
}

// int32 max_horizontal_rate = 16;
inline void Monitors_Monitor::clear_max_horizontal_rate() {
  _impl_.max_horizontal_rate_ = 0;
}
inline int32_t Monitors_Monitor::_internal_max_horizontal_rate() const {
  return _impl_.max_horizontal_rate_;
}
inline int32_t Monitors_Monitor::max_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.max_horizontal_rate)
  return _internal_max_horizontal_rate();
}
inline void Monitors_Monitor::_internal_set_max_horizontal_rate(int32_t value) {
  
  _impl_.max_horizontal_rate_ = value;
}
inline void Monitors_Monitor::set_max_horizontal_rate(int32_t value) {
  _internal_set_max_horizontal_rate(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.max_horizontal_rate)
}

// int32 min_vertical_rate = 17;
inline void Monitors_Monitor::clear_min_vertical_rate() {
  _impl_.min_vertical_rate_ = 0;
}
inline int32_t Monitors_Monitor::_internal_min_vertical_rate() const {
  return _impl_.min_vertical_rate_;
}
inline int32_t Monitors_Monitor::min_vertical_rate() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.min_vertical_rate)
  return _internal_min_vertical_rate();
}
inline void Monitors_Monitor::_internal_set_min_vertical_rate(int32_t value) {
  
  _impl_.min_vertical_rate_ = value;
}
inline void Monitors_Monitor::set_min_vertical_rate(int32_t value) {
  _internal_set_min_vertical_rate(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.min_vertical_rate)
}

// int32 max_vertical_rate = 18;
inline void Monitors_Monitor::clear_max_vertical_rate() {
  _impl_.max_vertical_rate_ = 0;
}
inline int32_t Monitors_Monitor::_internal_max_vertical_rate() const {
  return _impl_.max_vertical_rate_;
}
inline int32_t Monitors_Monitor::max_vertical_rate() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.max_vertical_rate)
  return _internal_max_vertical_rate();
}
inline void Monitors_Monitor::_internal_set_max_vertical_rate(int32_t value) {
  
  _impl_.max_vertical_rate_ = value;
}
inline void Monitors_Monitor::set_max_vertical_rate(int32_t value) {
  _internal_set_max_vertical_rate(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.max_vertical_rate)
}

// double pixel_clock = 19;
inline void Monitors_Monitor::clear_pixel_clock() {
  _impl_.pixel_clock_ = 0;
}
inline double Monitors_Monitor::_internal_pixel_clock() const {
  return _impl_.pixel_clock_;
}
inline double Monitors_Monitor::pixel_clock() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.pixel_clock)
  return _internal_pixel_clock();
}
inline void Monitors_Monitor::_internal_set_pixel_clock(double value) {
  
  _impl_.pixel_clock_ = value;
}
inline void Monitors_Monitor::set_pixel_clock(double value) {
  _internal_set_pixel_clock(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.pixel_clock)
}

// int32 max_pixel_clock = 20;
inline void Monitors_Monitor::clear_max_pixel_clock() {
  _impl_.max_pixel_clock_ = 0;
}
inline int32_t Monitors_Monitor::_internal_max_pixel_clock() const {
  return _impl_.max_pixel_clock_;
}
inline int32_t Monitors_Monitor::max_pixel_clock() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.max_pixel_clock)
  return _internal_max_pixel_clock();
}
inline void Monitors_Monitor::_internal_set_max_pixel_clock(int32_t value) {
  
  _impl_.max_pixel_clock_ = value;
}
inline void Monitors_Monitor::set_max_pixel_clock(int32_t value) {
  _internal_set_max_pixel_clock(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.max_pixel_clock)
}

// .proto.system_info.Monitors.Monitor.InputSignalType input_signal_type = 21;
inline void Monitors_Monitor::clear_input_signal_type() {
  _impl_.input_signal_type_ = 0;
}
inline ::proto::system_info::Monitors_Monitor_InputSignalType Monitors_Monitor::_internal_input_signal_type() const {
  return static_cast< ::proto::system_info::Monitors_Monitor_InputSignalType >(_impl_.input_signal_type_);
}
inline ::proto::system_info::Monitors_Monitor_InputSignalType Monitors_Monitor::input_signal_type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.input_signal_type)
  return _internal_input_signal_type();
}
inline void Monitors_Monitor::_internal_set_input_signal_type(::proto::system_info::Monitors_Monitor_InputSignalType value) {
  
  _impl_.input_signal_type_ = value;
}
inline void Monitors_Monitor::set_input_signal_type(::proto::system_info::Monitors_Monitor_InputSignalType value) {
  _internal_set_input_signal_type(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.input_signal_type)
}

// bool default_gtf_supported = 22;
inline void Monitors_Monitor::clear_default_gtf_supported() {
  _impl_.default_gtf_supported_ = false;
}
inline bool Monitors_Monitor::_internal_default_gtf_supported() const {
  return _impl_.default_gtf_supported_;
}
inline bool Monitors_Monitor::default_gtf_supported() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.default_gtf_supported)
  return _internal_default_gtf_supported();
}
inline void Monitors_Monitor::_internal_set_default_gtf_supported(bool value) {
  
  _impl_.default_gtf_supported_ = value;
}
inline void Monitors_Monitor::set_default_gtf_supported(bool value) {
  _internal_set_default_gtf_supported(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.default_gtf_supported)
}

// bool suspend_supported = 23;
inline void Monitors_Monitor::clear_suspend_supported() {
  _impl_.suspend_supported_ = false;
}
inline bool Monitors_Monitor::_internal_suspend_supported() const {
  return _impl_.suspend_supported_;
}
inline bool Monitors_Monitor::suspend_supported() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.suspend_supported)
  return _internal_suspend_supported();
}
inline void Monitors_Monitor::_internal_set_suspend_supported(bool value) {
  
  _impl_.suspend_supported_ = value;
}
inline void Monitors_Monitor::set_suspend_supported(bool value) {
  _internal_set_suspend_supported(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.suspend_supported)
}

// bool standby_supported = 24;
inline void Monitors_Monitor::clear_standby_supported() {
  _impl_.standby_supported_ = false;
}
inline bool Monitors_Monitor::_internal_standby_supported() const {
  return _impl_.standby_supported_;
}
inline bool Monitors_Monitor::standby_supported() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.standby_supported)
  return _internal_standby_supported();
}
inline void Monitors_Monitor::_internal_set_standby_supported(bool value) {
  
  _impl_.standby_supported_ = value;
}
inline void Monitors_Monitor::set_standby_supported(bool value) {
  _internal_set_standby_supported(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.standby_supported)
}

// bool active_off_supported = 25;
inline void Monitors_Monitor::clear_active_off_supported() {
  _impl_.active_off_supported_ = false;
}
inline bool Monitors_Monitor::_internal_active_off_supported() const {
  return _impl_.active_off_supported_;
}
inline bool Monitors_Monitor::active_off_supported() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.active_off_supported)
  return _internal_active_off_supported();
}
inline void Monitors_Monitor::_internal_set_active_off_supported(bool value) {
  
  _impl_.active_off_supported_ = value;
}
inline void Monitors_Monitor::set_active_off_supported(bool value) {
  _internal_set_active_off_supported(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.active_off_supported)
}

// bool preferred_timing_mode_supported = 26;
inline void Monitors_Monitor::clear_preferred_timing_mode_supported() {
  _impl_.preferred_timing_mode_supported_ = false;
}
inline bool Monitors_Monitor::_internal_preferred_timing_mode_supported() const {
  return _impl_.preferred_timing_mode_supported_;
}
inline bool Monitors_Monitor::preferred_timing_mode_supported() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.preferred_timing_mode_supported)
  return _internal_preferred_timing_mode_supported();
}
inline void Monitors_Monitor::_internal_set_preferred_timing_mode_supported(bool value) {
  
  _impl_.preferred_timing_mode_supported_ = value;
}
inline void Monitors_Monitor::set_preferred_timing_mode_supported(bool value) {
  _internal_set_preferred_timing_mode_supported(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.preferred_timing_mode_supported)
}

// bool srgb_supported = 27;
inline void Monitors_Monitor::clear_srgb_supported() {
  _impl_.srgb_supported_ = false;
}
inline bool Monitors_Monitor::_internal_srgb_supported() const {
  return _impl_.srgb_supported_;
}
inline bool Monitors_Monitor::srgb_supported() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.srgb_supported)
  return _internal_srgb_supported();
}
inline void Monitors_Monitor::_internal_set_srgb_supported(bool value) {
  
  _impl_.srgb_supported_ = value;
}
inline void Monitors_Monitor::set_srgb_supported(bool value) {
  _internal_set_srgb_supported(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Monitors.Monitor.srgb_supported)
}

// repeated .proto.system_info.Monitors.Monitor.Timing timings = 28;
inline int Monitors_Monitor::_internal_timings_size() const {
  return _impl_.timings_.size();
}
inline int Monitors_Monitor::timings_size() const {
  return _internal_timings_size();
}
inline void Monitors_Monitor::clear_timings() {
  _impl_.timings_.Clear();
}
inline ::proto::system_info::Monitors_Monitor_Timing* Monitors_Monitor::mutable_timings(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.Monitor.timings)
  return _impl_.timings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor_Timing >*
Monitors_Monitor::mutable_timings() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Monitors.Monitor.timings)
  return &_impl_.timings_;
}
inline const ::proto::system_info::Monitors_Monitor_Timing& Monitors_Monitor::_internal_timings(int index) const {
  return _impl_.timings_.Get(index);
}
inline const ::proto::system_info::Monitors_Monitor_Timing& Monitors_Monitor::timings(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.Monitor.timings)
  return _internal_timings(index);
}
inline ::proto::system_info::Monitors_Monitor_Timing* Monitors_Monitor::_internal_add_timings() {
  return _impl_.timings_.Add();
}
inline ::proto::system_info::Monitors_Monitor_Timing* Monitors_Monitor::add_timings() {
  ::proto::system_info::Monitors_Monitor_Timing* _add = _internal_add_timings();
  // @@protoc_insertion_point(field_add:proto.system_info.Monitors.Monitor.timings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor_Timing >&
Monitors_Monitor::timings() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Monitors.Monitor.timings)
  return _impl_.timings_;
}

// -------------------------------------------------------------------

// Monitors

// repeated .proto.system_info.Monitors.Monitor monitor = 1;
inline int Monitors::_internal_monitor_size() const {
  return _impl_.monitor_.size();
}
inline int Monitors::monitor_size() const {
  return _internal_monitor_size();
}
inline void Monitors::clear_monitor() {
  _impl_.monitor_.Clear();
}
inline ::proto::system_info::Monitors_Monitor* Monitors::mutable_monitor(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Monitors.monitor)
  return _impl_.monitor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor >*
Monitors::mutable_monitor() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Monitors.monitor)
  return &_impl_.monitor_;
}
inline const ::proto::system_info::Monitors_Monitor& Monitors::_internal_monitor(int index) const {
  return _impl_.monitor_.Get(index);
}
inline const ::proto::system_info::Monitors_Monitor& Monitors::monitor(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Monitors.monitor)
  return _internal_monitor(index);
}
inline ::proto::system_info::Monitors_Monitor* Monitors::_internal_add_monitor() {
  return _impl_.monitor_.Add();
}
inline ::proto::system_info::Monitors_Monitor* Monitors::add_monitor() {
  ::proto::system_info::Monitors_Monitor* _add = _internal_add_monitor();
  // @@protoc_insertion_point(field_add:proto.system_info.Monitors.monitor)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Monitors_Monitor >&
Monitors::monitor() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Monitors.monitor)
  return _impl_.monitor_;
}

// -------------------------------------------------------------------

// PowerOptions_Battery

// string device_name = 1;
inline void PowerOptions_Battery::clear_device_name() {
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::device_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_device_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.device_name)
}
inline std::string* PowerOptions_Battery::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.device_name)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_device_name() const {
  return _impl_.device_name_.Get();
}
inline void PowerOptions_Battery::_internal_set_device_name(const std::string& value) {
  
  _impl_.device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_device_name() {
  
  return _impl_.device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_device_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.device_name)
  return _impl_.device_name_.Release();
}
inline void PowerOptions_Battery::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    
  } else {
    
  }
  _impl_.device_name_.SetAllocated(device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_name_.IsDefault()) {
    _impl_.device_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.device_name)
}

// string manufacturer = 2;
inline void PowerOptions_Battery::clear_manufacturer() {
  _impl_.manufacturer_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::manufacturer() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.manufacturer)
}
inline std::string* PowerOptions_Battery::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.manufacturer)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_manufacturer() const {
  return _impl_.manufacturer_.Get();
}
inline void PowerOptions_Battery::_internal_set_manufacturer(const std::string& value) {
  
  _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_manufacturer() {
  
  return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_manufacturer() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.manufacturer)
  return _impl_.manufacturer_.Release();
}
inline void PowerOptions_Battery::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    
  } else {
    
  }
  _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.manufacturer)
}

// string manufacture_date = 3;
inline void PowerOptions_Battery::clear_manufacture_date() {
  _impl_.manufacture_date_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::manufacture_date() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.manufacture_date)
  return _internal_manufacture_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_manufacture_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manufacture_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.manufacture_date)
}
inline std::string* PowerOptions_Battery::mutable_manufacture_date() {
  std::string* _s = _internal_mutable_manufacture_date();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.manufacture_date)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_manufacture_date() const {
  return _impl_.manufacture_date_.Get();
}
inline void PowerOptions_Battery::_internal_set_manufacture_date(const std::string& value) {
  
  _impl_.manufacture_date_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_manufacture_date() {
  
  return _impl_.manufacture_date_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.manufacture_date)
  return _impl_.manufacture_date_.Release();
}
inline void PowerOptions_Battery::set_allocated_manufacture_date(std::string* manufacture_date) {
  if (manufacture_date != nullptr) {
    
  } else {
    
  }
  _impl_.manufacture_date_.SetAllocated(manufacture_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacture_date_.IsDefault()) {
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.manufacture_date)
}

// string unique_id = 4;
inline void PowerOptions_Battery::clear_unique_id() {
  _impl_.unique_id_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::unique_id() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.unique_id)
  return _internal_unique_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_unique_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.unique_id)
}
inline std::string* PowerOptions_Battery::mutable_unique_id() {
  std::string* _s = _internal_mutable_unique_id();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.unique_id)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_unique_id() const {
  return _impl_.unique_id_.Get();
}
inline void PowerOptions_Battery::_internal_set_unique_id(const std::string& value) {
  
  _impl_.unique_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_unique_id() {
  
  return _impl_.unique_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_unique_id() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.unique_id)
  return _impl_.unique_id_.Release();
}
inline void PowerOptions_Battery::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  _impl_.unique_id_.SetAllocated(unique_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_id_.IsDefault()) {
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.unique_id)
}

// string serial_number = 5;
inline void PowerOptions_Battery::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::serial_number() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.serial_number)
}
inline std::string* PowerOptions_Battery::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.serial_number)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void PowerOptions_Battery::_internal_set_serial_number(const std::string& value) {
  
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_serial_number() {
  
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_serial_number() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.serial_number)
  return _impl_.serial_number_.Release();
}
inline void PowerOptions_Battery::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.serial_number)
}

// string temperature = 6;
inline void PowerOptions_Battery::clear_temperature() {
  _impl_.temperature_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::temperature() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.temperature)
  return _internal_temperature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_temperature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.temperature_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.temperature)
}
inline std::string* PowerOptions_Battery::mutable_temperature() {
  std::string* _s = _internal_mutable_temperature();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.temperature)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_temperature() const {
  return _impl_.temperature_.Get();
}
inline void PowerOptions_Battery::_internal_set_temperature(const std::string& value) {
  
  _impl_.temperature_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_temperature() {
  
  return _impl_.temperature_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_temperature() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.temperature)
  return _impl_.temperature_.Release();
}
inline void PowerOptions_Battery::set_allocated_temperature(std::string* temperature) {
  if (temperature != nullptr) {
    
  } else {
    
  }
  _impl_.temperature_.SetAllocated(temperature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.temperature_.IsDefault()) {
    _impl_.temperature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.temperature)
}

// uint32 design_capacity = 7;
inline void PowerOptions_Battery::clear_design_capacity() {
  _impl_.design_capacity_ = 0u;
}
inline uint32_t PowerOptions_Battery::_internal_design_capacity() const {
  return _impl_.design_capacity_;
}
inline uint32_t PowerOptions_Battery::design_capacity() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.design_capacity)
  return _internal_design_capacity();
}
inline void PowerOptions_Battery::_internal_set_design_capacity(uint32_t value) {
  
  _impl_.design_capacity_ = value;
}
inline void PowerOptions_Battery::set_design_capacity(uint32_t value) {
  _internal_set_design_capacity(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.design_capacity)
}

// string type = 8;
inline void PowerOptions_Battery::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& PowerOptions_Battery::type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerOptions_Battery::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.type)
}
inline std::string* PowerOptions_Battery::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.Battery.type)
  return _s;
}
inline const std::string& PowerOptions_Battery::_internal_type() const {
  return _impl_.type_.Get();
}
inline void PowerOptions_Battery::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* PowerOptions_Battery::release_type() {
  // @@protoc_insertion_point(field_release:proto.system_info.PowerOptions.Battery.type)
  return _impl_.type_.Release();
}
inline void PowerOptions_Battery::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.PowerOptions.Battery.type)
}

// uint32 full_charged_capacity = 9;
inline void PowerOptions_Battery::clear_full_charged_capacity() {
  _impl_.full_charged_capacity_ = 0u;
}
inline uint32_t PowerOptions_Battery::_internal_full_charged_capacity() const {
  return _impl_.full_charged_capacity_;
}
inline uint32_t PowerOptions_Battery::full_charged_capacity() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.full_charged_capacity)
  return _internal_full_charged_capacity();
}
inline void PowerOptions_Battery::_internal_set_full_charged_capacity(uint32_t value) {
  
  _impl_.full_charged_capacity_ = value;
}
inline void PowerOptions_Battery::set_full_charged_capacity(uint32_t value) {
  _internal_set_full_charged_capacity(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.full_charged_capacity)
}

// uint32 depreciation = 10;
inline void PowerOptions_Battery::clear_depreciation() {
  _impl_.depreciation_ = 0u;
}
inline uint32_t PowerOptions_Battery::_internal_depreciation() const {
  return _impl_.depreciation_;
}
inline uint32_t PowerOptions_Battery::depreciation() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.depreciation)
  return _internal_depreciation();
}
inline void PowerOptions_Battery::_internal_set_depreciation(uint32_t value) {
  
  _impl_.depreciation_ = value;
}
inline void PowerOptions_Battery::set_depreciation(uint32_t value) {
  _internal_set_depreciation(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.depreciation)
}

// uint32 current_capacity = 11;
inline void PowerOptions_Battery::clear_current_capacity() {
  _impl_.current_capacity_ = 0u;
}
inline uint32_t PowerOptions_Battery::_internal_current_capacity() const {
  return _impl_.current_capacity_;
}
inline uint32_t PowerOptions_Battery::current_capacity() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.current_capacity)
  return _internal_current_capacity();
}
inline void PowerOptions_Battery::_internal_set_current_capacity(uint32_t value) {
  
  _impl_.current_capacity_ = value;
}
inline void PowerOptions_Battery::set_current_capacity(uint32_t value) {
  _internal_set_current_capacity(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.current_capacity)
}

// uint32 voltage = 12;
inline void PowerOptions_Battery::clear_voltage() {
  _impl_.voltage_ = 0u;
}
inline uint32_t PowerOptions_Battery::_internal_voltage() const {
  return _impl_.voltage_;
}
inline uint32_t PowerOptions_Battery::voltage() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.voltage)
  return _internal_voltage();
}
inline void PowerOptions_Battery::_internal_set_voltage(uint32_t value) {
  
  _impl_.voltage_ = value;
}
inline void PowerOptions_Battery::set_voltage(uint32_t value) {
  _internal_set_voltage(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.voltage)
}

// uint32 state = 13;
inline void PowerOptions_Battery::clear_state() {
  _impl_.state_ = 0u;
}
inline uint32_t PowerOptions_Battery::_internal_state() const {
  return _impl_.state_;
}
inline uint32_t PowerOptions_Battery::state() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.Battery.state)
  return _internal_state();
}
inline void PowerOptions_Battery::_internal_set_state(uint32_t value) {
  
  _impl_.state_ = value;
}
inline void PowerOptions_Battery::set_state(uint32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.Battery.state)
}

// -------------------------------------------------------------------

// PowerOptions

// .proto.system_info.PowerOptions.PowerSource power_source = 1;
inline void PowerOptions::clear_power_source() {
  _impl_.power_source_ = 0;
}
inline ::proto::system_info::PowerOptions_PowerSource PowerOptions::_internal_power_source() const {
  return static_cast< ::proto::system_info::PowerOptions_PowerSource >(_impl_.power_source_);
}
inline ::proto::system_info::PowerOptions_PowerSource PowerOptions::power_source() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.power_source)
  return _internal_power_source();
}
inline void PowerOptions::_internal_set_power_source(::proto::system_info::PowerOptions_PowerSource value) {
  
  _impl_.power_source_ = value;
}
inline void PowerOptions::set_power_source(::proto::system_info::PowerOptions_PowerSource value) {
  _internal_set_power_source(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.power_source)
}

// .proto.system_info.PowerOptions.BatteryStatus battery_status = 2;
inline void PowerOptions::clear_battery_status() {
  _impl_.battery_status_ = 0;
}
inline ::proto::system_info::PowerOptions_BatteryStatus PowerOptions::_internal_battery_status() const {
  return static_cast< ::proto::system_info::PowerOptions_BatteryStatus >(_impl_.battery_status_);
}
inline ::proto::system_info::PowerOptions_BatteryStatus PowerOptions::battery_status() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.battery_status)
  return _internal_battery_status();
}
inline void PowerOptions::_internal_set_battery_status(::proto::system_info::PowerOptions_BatteryStatus value) {
  
  _impl_.battery_status_ = value;
}
inline void PowerOptions::set_battery_status(::proto::system_info::PowerOptions_BatteryStatus value) {
  _internal_set_battery_status(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.battery_status)
}

// uint64 full_battery_life_time = 3;
inline void PowerOptions::clear_full_battery_life_time() {
  _impl_.full_battery_life_time_ = uint64_t{0u};
}
inline uint64_t PowerOptions::_internal_full_battery_life_time() const {
  return _impl_.full_battery_life_time_;
}
inline uint64_t PowerOptions::full_battery_life_time() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.full_battery_life_time)
  return _internal_full_battery_life_time();
}
inline void PowerOptions::_internal_set_full_battery_life_time(uint64_t value) {
  
  _impl_.full_battery_life_time_ = value;
}
inline void PowerOptions::set_full_battery_life_time(uint64_t value) {
  _internal_set_full_battery_life_time(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.full_battery_life_time)
}

// uint64 remaining_battery_life_time = 4;
inline void PowerOptions::clear_remaining_battery_life_time() {
  _impl_.remaining_battery_life_time_ = uint64_t{0u};
}
inline uint64_t PowerOptions::_internal_remaining_battery_life_time() const {
  return _impl_.remaining_battery_life_time_;
}
inline uint64_t PowerOptions::remaining_battery_life_time() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.remaining_battery_life_time)
  return _internal_remaining_battery_life_time();
}
inline void PowerOptions::_internal_set_remaining_battery_life_time(uint64_t value) {
  
  _impl_.remaining_battery_life_time_ = value;
}
inline void PowerOptions::set_remaining_battery_life_time(uint64_t value) {
  _internal_set_remaining_battery_life_time(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.remaining_battery_life_time)
}

// uint32 battery_life_percent = 5;
inline void PowerOptions::clear_battery_life_percent() {
  _impl_.battery_life_percent_ = 0u;
}
inline uint32_t PowerOptions::_internal_battery_life_percent() const {
  return _impl_.battery_life_percent_;
}
inline uint32_t PowerOptions::battery_life_percent() const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.battery_life_percent)
  return _internal_battery_life_percent();
}
inline void PowerOptions::_internal_set_battery_life_percent(uint32_t value) {
  
  _impl_.battery_life_percent_ = value;
}
inline void PowerOptions::set_battery_life_percent(uint32_t value) {
  _internal_set_battery_life_percent(value);
  // @@protoc_insertion_point(field_set:proto.system_info.PowerOptions.battery_life_percent)
}

// repeated .proto.system_info.PowerOptions.Battery battery = 6;
inline int PowerOptions::_internal_battery_size() const {
  return _impl_.battery_.size();
}
inline int PowerOptions::battery_size() const {
  return _internal_battery_size();
}
inline void PowerOptions::clear_battery() {
  _impl_.battery_.Clear();
}
inline ::proto::system_info::PowerOptions_Battery* PowerOptions::mutable_battery(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.PowerOptions.battery)
  return _impl_.battery_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::PowerOptions_Battery >*
PowerOptions::mutable_battery() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.PowerOptions.battery)
  return &_impl_.battery_;
}
inline const ::proto::system_info::PowerOptions_Battery& PowerOptions::_internal_battery(int index) const {
  return _impl_.battery_.Get(index);
}
inline const ::proto::system_info::PowerOptions_Battery& PowerOptions::battery(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.PowerOptions.battery)
  return _internal_battery(index);
}
inline ::proto::system_info::PowerOptions_Battery* PowerOptions::_internal_add_battery() {
  return _impl_.battery_.Add();
}
inline ::proto::system_info::PowerOptions_Battery* PowerOptions::add_battery() {
  ::proto::system_info::PowerOptions_Battery* _add = _internal_add_battery();
  // @@protoc_insertion_point(field_add:proto.system_info.PowerOptions.battery)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::PowerOptions_Battery >&
PowerOptions::battery() const {
  // @@protoc_insertion_point(field_list:proto.system_info.PowerOptions.battery)
  return _impl_.battery_;
}

// -------------------------------------------------------------------

// Drivers_Driver

// string name = 1;
inline void Drivers_Driver::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Drivers_Driver::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.Driver.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drivers_Driver::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Drivers.Driver.name)
}
inline std::string* Drivers_Driver::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Drivers.Driver.name)
  return _s;
}
inline const std::string& Drivers_Driver::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Drivers_Driver::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Drivers_Driver::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Drivers_Driver::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Drivers.Driver.name)
  return _impl_.name_.Release();
}
inline void Drivers_Driver::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Drivers.Driver.name)
}

// string display_name = 2;
inline void Drivers_Driver::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Drivers_Driver::display_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.Driver.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drivers_Driver::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Drivers.Driver.display_name)
}
inline std::string* Drivers_Driver::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Drivers.Driver.display_name)
  return _s;
}
inline const std::string& Drivers_Driver::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Drivers_Driver::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Drivers_Driver::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Drivers_Driver::release_display_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Drivers.Driver.display_name)
  return _impl_.display_name_.Release();
}
inline void Drivers_Driver::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Drivers.Driver.display_name)
}

// string description = 3;
inline void Drivers_Driver::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Drivers_Driver::description() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.Driver.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drivers_Driver::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Drivers.Driver.description)
}
inline std::string* Drivers_Driver::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Drivers.Driver.description)
  return _s;
}
inline const std::string& Drivers_Driver::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Drivers_Driver::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Drivers_Driver::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Drivers_Driver::release_description() {
  // @@protoc_insertion_point(field_release:proto.system_info.Drivers.Driver.description)
  return _impl_.description_.Release();
}
inline void Drivers_Driver::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Drivers.Driver.description)
}

// .proto.system_info.Drivers.Driver.Status status = 4;
inline void Drivers_Driver::clear_status() {
  _impl_.status_ = 0;
}
inline ::proto::system_info::Drivers_Driver_Status Drivers_Driver::_internal_status() const {
  return static_cast< ::proto::system_info::Drivers_Driver_Status >(_impl_.status_);
}
inline ::proto::system_info::Drivers_Driver_Status Drivers_Driver::status() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.Driver.status)
  return _internal_status();
}
inline void Drivers_Driver::_internal_set_status(::proto::system_info::Drivers_Driver_Status value) {
  
  _impl_.status_ = value;
}
inline void Drivers_Driver::set_status(::proto::system_info::Drivers_Driver_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Drivers.Driver.status)
}

// .proto.system_info.Drivers.Driver.StartupType startup_type = 5;
inline void Drivers_Driver::clear_startup_type() {
  _impl_.startup_type_ = 0;
}
inline ::proto::system_info::Drivers_Driver_StartupType Drivers_Driver::_internal_startup_type() const {
  return static_cast< ::proto::system_info::Drivers_Driver_StartupType >(_impl_.startup_type_);
}
inline ::proto::system_info::Drivers_Driver_StartupType Drivers_Driver::startup_type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.Driver.startup_type)
  return _internal_startup_type();
}
inline void Drivers_Driver::_internal_set_startup_type(::proto::system_info::Drivers_Driver_StartupType value) {
  
  _impl_.startup_type_ = value;
}
inline void Drivers_Driver::set_startup_type(::proto::system_info::Drivers_Driver_StartupType value) {
  _internal_set_startup_type(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Drivers.Driver.startup_type)
}

// string binary_path = 6;
inline void Drivers_Driver::clear_binary_path() {
  _impl_.binary_path_.ClearToEmpty();
}
inline const std::string& Drivers_Driver::binary_path() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.Driver.binary_path)
  return _internal_binary_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Drivers_Driver::set_binary_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binary_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Drivers.Driver.binary_path)
}
inline std::string* Drivers_Driver::mutable_binary_path() {
  std::string* _s = _internal_mutable_binary_path();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Drivers.Driver.binary_path)
  return _s;
}
inline const std::string& Drivers_Driver::_internal_binary_path() const {
  return _impl_.binary_path_.Get();
}
inline void Drivers_Driver::_internal_set_binary_path(const std::string& value) {
  
  _impl_.binary_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Drivers_Driver::_internal_mutable_binary_path() {
  
  return _impl_.binary_path_.Mutable(GetArenaForAllocation());
}
inline std::string* Drivers_Driver::release_binary_path() {
  // @@protoc_insertion_point(field_release:proto.system_info.Drivers.Driver.binary_path)
  return _impl_.binary_path_.Release();
}
inline void Drivers_Driver::set_allocated_binary_path(std::string* binary_path) {
  if (binary_path != nullptr) {
    
  } else {
    
  }
  _impl_.binary_path_.SetAllocated(binary_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binary_path_.IsDefault()) {
    _impl_.binary_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Drivers.Driver.binary_path)
}

// -------------------------------------------------------------------

// Drivers

// repeated .proto.system_info.Drivers.Driver driver = 1;
inline int Drivers::_internal_driver_size() const {
  return _impl_.driver_.size();
}
inline int Drivers::driver_size() const {
  return _internal_driver_size();
}
inline void Drivers::clear_driver() {
  _impl_.driver_.Clear();
}
inline ::proto::system_info::Drivers_Driver* Drivers::mutable_driver(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Drivers.driver)
  return _impl_.driver_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Drivers_Driver >*
Drivers::mutable_driver() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Drivers.driver)
  return &_impl_.driver_;
}
inline const ::proto::system_info::Drivers_Driver& Drivers::_internal_driver(int index) const {
  return _impl_.driver_.Get(index);
}
inline const ::proto::system_info::Drivers_Driver& Drivers::driver(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Drivers.driver)
  return _internal_driver(index);
}
inline ::proto::system_info::Drivers_Driver* Drivers::_internal_add_driver() {
  return _impl_.driver_.Add();
}
inline ::proto::system_info::Drivers_Driver* Drivers::add_driver() {
  ::proto::system_info::Drivers_Driver* _add = _internal_add_driver();
  // @@protoc_insertion_point(field_add:proto.system_info.Drivers.driver)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Drivers_Driver >&
Drivers::driver() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Drivers.driver)
  return _impl_.driver_;
}

// -------------------------------------------------------------------

// Services_Service

// string name = 1;
inline void Services_Service::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Services_Service::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Services_Service::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.name)
}
inline std::string* Services_Service::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Services.Service.name)
  return _s;
}
inline const std::string& Services_Service::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Services_Service::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Services_Service::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Services_Service::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Services.Service.name)
  return _impl_.name_.Release();
}
inline void Services_Service::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Services.Service.name)
}

// string display_name = 2;
inline void Services_Service::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Services_Service::display_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Services_Service::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.display_name)
}
inline std::string* Services_Service::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Services.Service.display_name)
  return _s;
}
inline const std::string& Services_Service::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Services_Service::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Services_Service::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Services_Service::release_display_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Services.Service.display_name)
  return _impl_.display_name_.Release();
}
inline void Services_Service::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Services.Service.display_name)
}

// string description = 3;
inline void Services_Service::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Services_Service::description() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Services_Service::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.description)
}
inline std::string* Services_Service::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Services.Service.description)
  return _s;
}
inline const std::string& Services_Service::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Services_Service::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Services_Service::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Services_Service::release_description() {
  // @@protoc_insertion_point(field_release:proto.system_info.Services.Service.description)
  return _impl_.description_.Release();
}
inline void Services_Service::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Services.Service.description)
}

// .proto.system_info.Services.Service.Status status = 4;
inline void Services_Service::clear_status() {
  _impl_.status_ = 0;
}
inline ::proto::system_info::Services_Service_Status Services_Service::_internal_status() const {
  return static_cast< ::proto::system_info::Services_Service_Status >(_impl_.status_);
}
inline ::proto::system_info::Services_Service_Status Services_Service::status() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.status)
  return _internal_status();
}
inline void Services_Service::_internal_set_status(::proto::system_info::Services_Service_Status value) {
  
  _impl_.status_ = value;
}
inline void Services_Service::set_status(::proto::system_info::Services_Service_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.status)
}

// .proto.system_info.Services.Service.StartupType startup_type = 5;
inline void Services_Service::clear_startup_type() {
  _impl_.startup_type_ = 0;
}
inline ::proto::system_info::Services_Service_StartupType Services_Service::_internal_startup_type() const {
  return static_cast< ::proto::system_info::Services_Service_StartupType >(_impl_.startup_type_);
}
inline ::proto::system_info::Services_Service_StartupType Services_Service::startup_type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.startup_type)
  return _internal_startup_type();
}
inline void Services_Service::_internal_set_startup_type(::proto::system_info::Services_Service_StartupType value) {
  
  _impl_.startup_type_ = value;
}
inline void Services_Service::set_startup_type(::proto::system_info::Services_Service_StartupType value) {
  _internal_set_startup_type(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.startup_type)
}

// string binary_path = 6;
inline void Services_Service::clear_binary_path() {
  _impl_.binary_path_.ClearToEmpty();
}
inline const std::string& Services_Service::binary_path() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.binary_path)
  return _internal_binary_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Services_Service::set_binary_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binary_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.binary_path)
}
inline std::string* Services_Service::mutable_binary_path() {
  std::string* _s = _internal_mutable_binary_path();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Services.Service.binary_path)
  return _s;
}
inline const std::string& Services_Service::_internal_binary_path() const {
  return _impl_.binary_path_.Get();
}
inline void Services_Service::_internal_set_binary_path(const std::string& value) {
  
  _impl_.binary_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Services_Service::_internal_mutable_binary_path() {
  
  return _impl_.binary_path_.Mutable(GetArenaForAllocation());
}
inline std::string* Services_Service::release_binary_path() {
  // @@protoc_insertion_point(field_release:proto.system_info.Services.Service.binary_path)
  return _impl_.binary_path_.Release();
}
inline void Services_Service::set_allocated_binary_path(std::string* binary_path) {
  if (binary_path != nullptr) {
    
  } else {
    
  }
  _impl_.binary_path_.SetAllocated(binary_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binary_path_.IsDefault()) {
    _impl_.binary_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Services.Service.binary_path)
}

// string start_name = 7;
inline void Services_Service::clear_start_name() {
  _impl_.start_name_.ClearToEmpty();
}
inline const std::string& Services_Service::start_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.Service.start_name)
  return _internal_start_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Services_Service::set_start_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Services.Service.start_name)
}
inline std::string* Services_Service::mutable_start_name() {
  std::string* _s = _internal_mutable_start_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Services.Service.start_name)
  return _s;
}
inline const std::string& Services_Service::_internal_start_name() const {
  return _impl_.start_name_.Get();
}
inline void Services_Service::_internal_set_start_name(const std::string& value) {
  
  _impl_.start_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Services_Service::_internal_mutable_start_name() {
  
  return _impl_.start_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Services_Service::release_start_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Services.Service.start_name)
  return _impl_.start_name_.Release();
}
inline void Services_Service::set_allocated_start_name(std::string* start_name) {
  if (start_name != nullptr) {
    
  } else {
    
  }
  _impl_.start_name_.SetAllocated(start_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_name_.IsDefault()) {
    _impl_.start_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Services.Service.start_name)
}

// -------------------------------------------------------------------

// Services

// repeated .proto.system_info.Services.Service service = 1;
inline int Services::_internal_service_size() const {
  return _impl_.service_.size();
}
inline int Services::service_size() const {
  return _internal_service_size();
}
inline void Services::clear_service() {
  _impl_.service_.Clear();
}
inline ::proto::system_info::Services_Service* Services::mutable_service(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Services.service)
  return _impl_.service_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Services_Service >*
Services::mutable_service() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Services.service)
  return &_impl_.service_;
}
inline const ::proto::system_info::Services_Service& Services::_internal_service(int index) const {
  return _impl_.service_.Get(index);
}
inline const ::proto::system_info::Services_Service& Services::service(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Services.service)
  return _internal_service(index);
}
inline ::proto::system_info::Services_Service* Services::_internal_add_service() {
  return _impl_.service_.Add();
}
inline ::proto::system_info::Services_Service* Services::add_service() {
  ::proto::system_info::Services_Service* _add = _internal_add_service();
  // @@protoc_insertion_point(field_add:proto.system_info.Services.service)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Services_Service >&
Services::service() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Services.service)
  return _impl_.service_;
}

// -------------------------------------------------------------------

// EnvironmentVariables_Variable

// string name = 1;
inline void EnvironmentVariables_Variable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EnvironmentVariables_Variable::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EnvironmentVariables.Variable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnvironmentVariables_Variable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.EnvironmentVariables.Variable.name)
}
inline std::string* EnvironmentVariables_Variable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.EnvironmentVariables.Variable.name)
  return _s;
}
inline const std::string& EnvironmentVariables_Variable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EnvironmentVariables_Variable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EnvironmentVariables_Variable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EnvironmentVariables_Variable::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.EnvironmentVariables.Variable.name)
  return _impl_.name_.Release();
}
inline void EnvironmentVariables_Variable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.EnvironmentVariables.Variable.name)
}

// string value = 2;
inline void EnvironmentVariables_Variable::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& EnvironmentVariables_Variable::value() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EnvironmentVariables.Variable.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnvironmentVariables_Variable::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.EnvironmentVariables.Variable.value)
}
inline std::string* EnvironmentVariables_Variable::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:proto.system_info.EnvironmentVariables.Variable.value)
  return _s;
}
inline const std::string& EnvironmentVariables_Variable::_internal_value() const {
  return _impl_.value_.Get();
}
inline void EnvironmentVariables_Variable::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* EnvironmentVariables_Variable::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* EnvironmentVariables_Variable::release_value() {
  // @@protoc_insertion_point(field_release:proto.system_info.EnvironmentVariables.Variable.value)
  return _impl_.value_.Release();
}
inline void EnvironmentVariables_Variable::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.EnvironmentVariables.Variable.value)
}

// -------------------------------------------------------------------

// EnvironmentVariables

// repeated .proto.system_info.EnvironmentVariables.Variable variable = 1;
inline int EnvironmentVariables::_internal_variable_size() const {
  return _impl_.variable_.size();
}
inline int EnvironmentVariables::variable_size() const {
  return _internal_variable_size();
}
inline void EnvironmentVariables::clear_variable() {
  _impl_.variable_.Clear();
}
inline ::proto::system_info::EnvironmentVariables_Variable* EnvironmentVariables::mutable_variable(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.EnvironmentVariables.variable)
  return _impl_.variable_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EnvironmentVariables_Variable >*
EnvironmentVariables::mutable_variable() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.EnvironmentVariables.variable)
  return &_impl_.variable_;
}
inline const ::proto::system_info::EnvironmentVariables_Variable& EnvironmentVariables::_internal_variable(int index) const {
  return _impl_.variable_.Get(index);
}
inline const ::proto::system_info::EnvironmentVariables_Variable& EnvironmentVariables::variable(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.EnvironmentVariables.variable)
  return _internal_variable(index);
}
inline ::proto::system_info::EnvironmentVariables_Variable* EnvironmentVariables::_internal_add_variable() {
  return _impl_.variable_.Add();
}
inline ::proto::system_info::EnvironmentVariables_Variable* EnvironmentVariables::add_variable() {
  ::proto::system_info::EnvironmentVariables_Variable* _add = _internal_add_variable();
  // @@protoc_insertion_point(field_add:proto.system_info.EnvironmentVariables.variable)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EnvironmentVariables_Variable >&
EnvironmentVariables::variable() const {
  // @@protoc_insertion_point(field_list:proto.system_info.EnvironmentVariables.variable)
  return _impl_.variable_;
}

// -------------------------------------------------------------------

// EventLogs_Event

// .proto.system_info.EventLogs.Event.Level level = 1;
inline void EventLogs_Event::clear_level() {
  _impl_.level_ = 0;
}
inline ::proto::system_info::EventLogs_Event_Level EventLogs_Event::_internal_level() const {
  return static_cast< ::proto::system_info::EventLogs_Event_Level >(_impl_.level_);
}
inline ::proto::system_info::EventLogs_Event_Level EventLogs_Event::level() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.Event.level)
  return _internal_level();
}
inline void EventLogs_Event::_internal_set_level(::proto::system_info::EventLogs_Event_Level value) {
  
  _impl_.level_ = value;
}
inline void EventLogs_Event::set_level(::proto::system_info::EventLogs_Event_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.Event.level)
}

// int64 time = 2;
inline void EventLogs_Event::clear_time() {
  _impl_.time_ = int64_t{0};
}
inline int64_t EventLogs_Event::_internal_time() const {
  return _impl_.time_;
}
inline int64_t EventLogs_Event::time() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.Event.time)
  return _internal_time();
}
inline void EventLogs_Event::_internal_set_time(int64_t value) {
  
  _impl_.time_ = value;
}
inline void EventLogs_Event::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.Event.time)
}

// string category = 3;
inline void EventLogs_Event::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& EventLogs_Event::category() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.Event.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventLogs_Event::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.Event.category)
}
inline std::string* EventLogs_Event::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:proto.system_info.EventLogs.Event.category)
  return _s;
}
inline const std::string& EventLogs_Event::_internal_category() const {
  return _impl_.category_.Get();
}
inline void EventLogs_Event::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLogs_Event::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* EventLogs_Event::release_category() {
  // @@protoc_insertion_point(field_release:proto.system_info.EventLogs.Event.category)
  return _impl_.category_.Release();
}
inline void EventLogs_Event::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.EventLogs.Event.category)
}

// uint32 event_id = 4;
inline void EventLogs_Event::clear_event_id() {
  _impl_.event_id_ = 0u;
}
inline uint32_t EventLogs_Event::_internal_event_id() const {
  return _impl_.event_id_;
}
inline uint32_t EventLogs_Event::event_id() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.Event.event_id)
  return _internal_event_id();
}
inline void EventLogs_Event::_internal_set_event_id(uint32_t value) {
  
  _impl_.event_id_ = value;
}
inline void EventLogs_Event::set_event_id(uint32_t value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.Event.event_id)
}

// string source = 5;
inline void EventLogs_Event::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& EventLogs_Event::source() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.Event.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventLogs_Event::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.Event.source)
}
inline std::string* EventLogs_Event::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:proto.system_info.EventLogs.Event.source)
  return _s;
}
inline const std::string& EventLogs_Event::_internal_source() const {
  return _impl_.source_.Get();
}
inline void EventLogs_Event::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLogs_Event::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* EventLogs_Event::release_source() {
  // @@protoc_insertion_point(field_release:proto.system_info.EventLogs.Event.source)
  return _impl_.source_.Release();
}
inline void EventLogs_Event::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.EventLogs.Event.source)
}

// string description = 6;
inline void EventLogs_Event::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& EventLogs_Event::description() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.Event.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventLogs_Event::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.Event.description)
}
inline std::string* EventLogs_Event::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.system_info.EventLogs.Event.description)
  return _s;
}
inline const std::string& EventLogs_Event::_internal_description() const {
  return _impl_.description_.Get();
}
inline void EventLogs_Event::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLogs_Event::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* EventLogs_Event::release_description() {
  // @@protoc_insertion_point(field_release:proto.system_info.EventLogs.Event.description)
  return _impl_.description_.Release();
}
inline void EventLogs_Event::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.EventLogs.Event.description)
}

// -------------------------------------------------------------------

// EventLogs

// .proto.system_info.EventLogs.Event.Type type = 1;
inline void EventLogs::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::system_info::EventLogs_Event_Type EventLogs::_internal_type() const {
  return static_cast< ::proto::system_info::EventLogs_Event_Type >(_impl_.type_);
}
inline ::proto::system_info::EventLogs_Event_Type EventLogs::type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.type)
  return _internal_type();
}
inline void EventLogs::_internal_set_type(::proto::system_info::EventLogs_Event_Type value) {
  
  _impl_.type_ = value;
}
inline void EventLogs::set_type(::proto::system_info::EventLogs_Event_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.type)
}

// uint32 total_records = 2;
inline void EventLogs::clear_total_records() {
  _impl_.total_records_ = 0u;
}
inline uint32_t EventLogs::_internal_total_records() const {
  return _impl_.total_records_;
}
inline uint32_t EventLogs::total_records() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.total_records)
  return _internal_total_records();
}
inline void EventLogs::_internal_set_total_records(uint32_t value) {
  
  _impl_.total_records_ = value;
}
inline void EventLogs::set_total_records(uint32_t value) {
  _internal_set_total_records(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogs.total_records)
}

// repeated .proto.system_info.EventLogs.Event event = 3;
inline int EventLogs::_internal_event_size() const {
  return _impl_.event_.size();
}
inline int EventLogs::event_size() const {
  return _internal_event_size();
}
inline void EventLogs::clear_event() {
  _impl_.event_.Clear();
}
inline ::proto::system_info::EventLogs_Event* EventLogs::mutable_event(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.EventLogs.event)
  return _impl_.event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EventLogs_Event >*
EventLogs::mutable_event() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.EventLogs.event)
  return &_impl_.event_;
}
inline const ::proto::system_info::EventLogs_Event& EventLogs::_internal_event(int index) const {
  return _impl_.event_.Get(index);
}
inline const ::proto::system_info::EventLogs_Event& EventLogs::event(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogs.event)
  return _internal_event(index);
}
inline ::proto::system_info::EventLogs_Event* EventLogs::_internal_add_event() {
  return _impl_.event_.Add();
}
inline ::proto::system_info::EventLogs_Event* EventLogs::add_event() {
  ::proto::system_info::EventLogs_Event* _add = _internal_add_event();
  // @@protoc_insertion_point(field_add:proto.system_info.EventLogs.event)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::EventLogs_Event >&
EventLogs::event() const {
  // @@protoc_insertion_point(field_list:proto.system_info.EventLogs.event)
  return _impl_.event_;
}

// -------------------------------------------------------------------

// EventLogsData

// .proto.system_info.EventLogs.Event.Type type = 1;
inline void EventLogsData::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::system_info::EventLogs_Event_Type EventLogsData::_internal_type() const {
  return static_cast< ::proto::system_info::EventLogs_Event_Type >(_impl_.type_);
}
inline ::proto::system_info::EventLogs_Event_Type EventLogsData::type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogsData.type)
  return _internal_type();
}
inline void EventLogsData::_internal_set_type(::proto::system_info::EventLogs_Event_Type value) {
  
  _impl_.type_ = value;
}
inline void EventLogsData::set_type(::proto::system_info::EventLogs_Event_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogsData.type)
}

// uint32 record_start = 2;
inline void EventLogsData::clear_record_start() {
  _impl_.record_start_ = 0u;
}
inline uint32_t EventLogsData::_internal_record_start() const {
  return _impl_.record_start_;
}
inline uint32_t EventLogsData::record_start() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogsData.record_start)
  return _internal_record_start();
}
inline void EventLogsData::_internal_set_record_start(uint32_t value) {
  
  _impl_.record_start_ = value;
}
inline void EventLogsData::set_record_start(uint32_t value) {
  _internal_set_record_start(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogsData.record_start)
}

// uint32 record_count = 3;
inline void EventLogsData::clear_record_count() {
  _impl_.record_count_ = 0u;
}
inline uint32_t EventLogsData::_internal_record_count() const {
  return _impl_.record_count_;
}
inline uint32_t EventLogsData::record_count() const {
  // @@protoc_insertion_point(field_get:proto.system_info.EventLogsData.record_count)
  return _internal_record_count();
}
inline void EventLogsData::_internal_set_record_count(uint32_t value) {
  
  _impl_.record_count_ = value;
}
inline void EventLogsData::set_record_count(uint32_t value) {
  _internal_set_record_count(value);
  // @@protoc_insertion_point(field_set:proto.system_info.EventLogsData.record_count)
}

// -------------------------------------------------------------------

// Routes_Route

// string destonation = 1;
inline void Routes_Route::clear_destonation() {
  _impl_.destonation_.ClearToEmpty();
}
inline const std::string& Routes_Route::destonation() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Routes.Route.destonation)
  return _internal_destonation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Routes_Route::set_destonation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destonation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Routes.Route.destonation)
}
inline std::string* Routes_Route::mutable_destonation() {
  std::string* _s = _internal_mutable_destonation();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Routes.Route.destonation)
  return _s;
}
inline const std::string& Routes_Route::_internal_destonation() const {
  return _impl_.destonation_.Get();
}
inline void Routes_Route::_internal_set_destonation(const std::string& value) {
  
  _impl_.destonation_.Set(value, GetArenaForAllocation());
}
inline std::string* Routes_Route::_internal_mutable_destonation() {
  
  return _impl_.destonation_.Mutable(GetArenaForAllocation());
}
inline std::string* Routes_Route::release_destonation() {
  // @@protoc_insertion_point(field_release:proto.system_info.Routes.Route.destonation)
  return _impl_.destonation_.Release();
}
inline void Routes_Route::set_allocated_destonation(std::string* destonation) {
  if (destonation != nullptr) {
    
  } else {
    
  }
  _impl_.destonation_.SetAllocated(destonation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destonation_.IsDefault()) {
    _impl_.destonation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Routes.Route.destonation)
}

// string mask = 2;
inline void Routes_Route::clear_mask() {
  _impl_.mask_.ClearToEmpty();
}
inline const std::string& Routes_Route::mask() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Routes.Route.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Routes_Route::set_mask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Routes.Route.mask)
}
inline std::string* Routes_Route::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Routes.Route.mask)
  return _s;
}
inline const std::string& Routes_Route::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void Routes_Route::_internal_set_mask(const std::string& value) {
  
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* Routes_Route::_internal_mutable_mask() {
  
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* Routes_Route::release_mask() {
  // @@protoc_insertion_point(field_release:proto.system_info.Routes.Route.mask)
  return _impl_.mask_.Release();
}
inline void Routes_Route::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Routes.Route.mask)
}

// string gateway = 3;
inline void Routes_Route::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& Routes_Route::gateway() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Routes.Route.gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Routes_Route::set_gateway(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Routes.Route.gateway)
}
inline std::string* Routes_Route::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Routes.Route.gateway)
  return _s;
}
inline const std::string& Routes_Route::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void Routes_Route::_internal_set_gateway(const std::string& value) {
  
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* Routes_Route::_internal_mutable_gateway() {
  
  return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* Routes_Route::release_gateway() {
  // @@protoc_insertion_point(field_release:proto.system_info.Routes.Route.gateway)
  return _impl_.gateway_.Release();
}
inline void Routes_Route::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Routes.Route.gateway)
}

// uint32 metric = 4;
inline void Routes_Route::clear_metric() {
  _impl_.metric_ = 0u;
}
inline uint32_t Routes_Route::_internal_metric() const {
  return _impl_.metric_;
}
inline uint32_t Routes_Route::metric() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Routes.Route.metric)
  return _internal_metric();
}
inline void Routes_Route::_internal_set_metric(uint32_t value) {
  
  _impl_.metric_ = value;
}
inline void Routes_Route::set_metric(uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Routes.Route.metric)
}

// -------------------------------------------------------------------

// Routes

// repeated .proto.system_info.Routes.Route route = 1;
inline int Routes::_internal_route_size() const {
  return _impl_.route_.size();
}
inline int Routes::route_size() const {
  return _internal_route_size();
}
inline void Routes::clear_route() {
  _impl_.route_.Clear();
}
inline ::proto::system_info::Routes_Route* Routes::mutable_route(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Routes.route)
  return _impl_.route_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Routes_Route >*
Routes::mutable_route() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Routes.route)
  return &_impl_.route_;
}
inline const ::proto::system_info::Routes_Route& Routes::_internal_route(int index) const {
  return _impl_.route_.Get(index);
}
inline const ::proto::system_info::Routes_Route& Routes::route(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Routes.route)
  return _internal_route(index);
}
inline ::proto::system_info::Routes_Route* Routes::_internal_add_route() {
  return _impl_.route_.Add();
}
inline ::proto::system_info::Routes_Route* Routes::add_route() {
  ::proto::system_info::Routes_Route* _add = _internal_add_route();
  // @@protoc_insertion_point(field_add:proto.system_info.Routes.route)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Routes_Route >&
Routes::route() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Routes.route)
  return _impl_.route_;
}

// -------------------------------------------------------------------

// Connections_Connection

// string process_name = 1;
inline void Connections_Connection::clear_process_name() {
  _impl_.process_name_.ClearToEmpty();
}
inline const std::string& Connections_Connection::process_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.process_name)
  return _internal_process_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connections_Connection::set_process_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.process_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.process_name)
}
inline std::string* Connections_Connection::mutable_process_name() {
  std::string* _s = _internal_mutable_process_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Connections.Connection.process_name)
  return _s;
}
inline const std::string& Connections_Connection::_internal_process_name() const {
  return _impl_.process_name_.Get();
}
inline void Connections_Connection::_internal_set_process_name(const std::string& value) {
  
  _impl_.process_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Connections_Connection::_internal_mutable_process_name() {
  
  return _impl_.process_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Connections_Connection::release_process_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Connections.Connection.process_name)
  return _impl_.process_name_.Release();
}
inline void Connections_Connection::set_allocated_process_name(std::string* process_name) {
  if (process_name != nullptr) {
    
  } else {
    
  }
  _impl_.process_name_.SetAllocated(process_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.process_name_.IsDefault()) {
    _impl_.process_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Connections.Connection.process_name)
}

// string protocol = 2;
inline void Connections_Connection::clear_protocol() {
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& Connections_Connection::protocol() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connections_Connection::set_protocol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.protocol)
}
inline std::string* Connections_Connection::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Connections.Connection.protocol)
  return _s;
}
inline const std::string& Connections_Connection::_internal_protocol() const {
  return _impl_.protocol_.Get();
}
inline void Connections_Connection::_internal_set_protocol(const std::string& value) {
  
  _impl_.protocol_.Set(value, GetArenaForAllocation());
}
inline std::string* Connections_Connection::_internal_mutable_protocol() {
  
  return _impl_.protocol_.Mutable(GetArenaForAllocation());
}
inline std::string* Connections_Connection::release_protocol() {
  // @@protoc_insertion_point(field_release:proto.system_info.Connections.Connection.protocol)
  return _impl_.protocol_.Release();
}
inline void Connections_Connection::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    
  } else {
    
  }
  _impl_.protocol_.SetAllocated(protocol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocol_.IsDefault()) {
    _impl_.protocol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Connections.Connection.protocol)
}

// string local_address = 3;
inline void Connections_Connection::clear_local_address() {
  _impl_.local_address_.ClearToEmpty();
}
inline const std::string& Connections_Connection::local_address() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.local_address)
  return _internal_local_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connections_Connection::set_local_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.local_address)
}
inline std::string* Connections_Connection::mutable_local_address() {
  std::string* _s = _internal_mutable_local_address();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Connections.Connection.local_address)
  return _s;
}
inline const std::string& Connections_Connection::_internal_local_address() const {
  return _impl_.local_address_.Get();
}
inline void Connections_Connection::_internal_set_local_address(const std::string& value) {
  
  _impl_.local_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Connections_Connection::_internal_mutable_local_address() {
  
  return _impl_.local_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Connections_Connection::release_local_address() {
  // @@protoc_insertion_point(field_release:proto.system_info.Connections.Connection.local_address)
  return _impl_.local_address_.Release();
}
inline void Connections_Connection::set_allocated_local_address(std::string* local_address) {
  if (local_address != nullptr) {
    
  } else {
    
  }
  _impl_.local_address_.SetAllocated(local_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_address_.IsDefault()) {
    _impl_.local_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Connections.Connection.local_address)
}

// string remote_address = 4;
inline void Connections_Connection::clear_remote_address() {
  _impl_.remote_address_.ClearToEmpty();
}
inline const std::string& Connections_Connection::remote_address() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.remote_address)
  return _internal_remote_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connections_Connection::set_remote_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.remote_address)
}
inline std::string* Connections_Connection::mutable_remote_address() {
  std::string* _s = _internal_mutable_remote_address();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Connections.Connection.remote_address)
  return _s;
}
inline const std::string& Connections_Connection::_internal_remote_address() const {
  return _impl_.remote_address_.Get();
}
inline void Connections_Connection::_internal_set_remote_address(const std::string& value) {
  
  _impl_.remote_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Connections_Connection::_internal_mutable_remote_address() {
  
  return _impl_.remote_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Connections_Connection::release_remote_address() {
  // @@protoc_insertion_point(field_release:proto.system_info.Connections.Connection.remote_address)
  return _impl_.remote_address_.Release();
}
inline void Connections_Connection::set_allocated_remote_address(std::string* remote_address) {
  if (remote_address != nullptr) {
    
  } else {
    
  }
  _impl_.remote_address_.SetAllocated(remote_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_address_.IsDefault()) {
    _impl_.remote_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Connections.Connection.remote_address)
}

// uint32 local_port = 5;
inline void Connections_Connection::clear_local_port() {
  _impl_.local_port_ = 0u;
}
inline uint32_t Connections_Connection::_internal_local_port() const {
  return _impl_.local_port_;
}
inline uint32_t Connections_Connection::local_port() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.local_port)
  return _internal_local_port();
}
inline void Connections_Connection::_internal_set_local_port(uint32_t value) {
  
  _impl_.local_port_ = value;
}
inline void Connections_Connection::set_local_port(uint32_t value) {
  _internal_set_local_port(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.local_port)
}

// uint32 remote_port = 6;
inline void Connections_Connection::clear_remote_port() {
  _impl_.remote_port_ = 0u;
}
inline uint32_t Connections_Connection::_internal_remote_port() const {
  return _impl_.remote_port_;
}
inline uint32_t Connections_Connection::remote_port() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.remote_port)
  return _internal_remote_port();
}
inline void Connections_Connection::_internal_set_remote_port(uint32_t value) {
  
  _impl_.remote_port_ = value;
}
inline void Connections_Connection::set_remote_port(uint32_t value) {
  _internal_set_remote_port(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.remote_port)
}

// string state = 7;
inline void Connections_Connection::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& Connections_Connection::state() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.Connection.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connections_Connection::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Connections.Connection.state)
}
inline std::string* Connections_Connection::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Connections.Connection.state)
  return _s;
}
inline const std::string& Connections_Connection::_internal_state() const {
  return _impl_.state_.Get();
}
inline void Connections_Connection::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* Connections_Connection::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* Connections_Connection::release_state() {
  // @@protoc_insertion_point(field_release:proto.system_info.Connections.Connection.state)
  return _impl_.state_.Release();
}
inline void Connections_Connection::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Connections.Connection.state)
}

// -------------------------------------------------------------------

// Connections

// repeated .proto.system_info.Connections.Connection connection = 1;
inline int Connections::_internal_connection_size() const {
  return _impl_.connection_.size();
}
inline int Connections::connection_size() const {
  return _internal_connection_size();
}
inline void Connections::clear_connection() {
  _impl_.connection_.Clear();
}
inline ::proto::system_info::Connections_Connection* Connections::mutable_connection(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Connections.connection)
  return _impl_.connection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Connections_Connection >*
Connections::mutable_connection() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Connections.connection)
  return &_impl_.connection_;
}
inline const ::proto::system_info::Connections_Connection& Connections::_internal_connection(int index) const {
  return _impl_.connection_.Get(index);
}
inline const ::proto::system_info::Connections_Connection& Connections::connection(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Connections.connection)
  return _internal_connection(index);
}
inline ::proto::system_info::Connections_Connection* Connections::_internal_add_connection() {
  return _impl_.connection_.Add();
}
inline ::proto::system_info::Connections_Connection* Connections::add_connection() {
  ::proto::system_info::Connections_Connection* _add = _internal_add_connection();
  // @@protoc_insertion_point(field_add:proto.system_info.Connections.connection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Connections_Connection >&
Connections::connection() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Connections.connection)
  return _impl_.connection_;
}

// -------------------------------------------------------------------

// Licenses_License_Field

// .proto.system_info.Licenses.License.Field.Type type = 1;
inline void Licenses_License_Field::clear_type() {
  _impl_.type_ = 0;
}
inline ::proto::system_info::Licenses_License_Field_Type Licenses_License_Field::_internal_type() const {
  return static_cast< ::proto::system_info::Licenses_License_Field_Type >(_impl_.type_);
}
inline ::proto::system_info::Licenses_License_Field_Type Licenses_License_Field::type() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Licenses.License.Field.type)
  return _internal_type();
}
inline void Licenses_License_Field::_internal_set_type(::proto::system_info::Licenses_License_Field_Type value) {
  
  _impl_.type_ = value;
}
inline void Licenses_License_Field::set_type(::proto::system_info::Licenses_License_Field_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Licenses.License.Field.type)
}

// string value = 2;
inline void Licenses_License_Field::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Licenses_License_Field::value() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Licenses.License.Field.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Licenses_License_Field::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Licenses.License.Field.value)
}
inline std::string* Licenses_License_Field::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Licenses.License.Field.value)
  return _s;
}
inline const std::string& Licenses_License_Field::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Licenses_License_Field::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Licenses_License_Field::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Licenses_License_Field::release_value() {
  // @@protoc_insertion_point(field_release:proto.system_info.Licenses.License.Field.value)
  return _impl_.value_.Release();
}
inline void Licenses_License_Field::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Licenses.License.Field.value)
}

// -------------------------------------------------------------------

// Licenses_License

// string product_name = 1;
inline void Licenses_License::clear_product_name() {
  _impl_.product_name_.ClearToEmpty();
}
inline const std::string& Licenses_License::product_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Licenses.License.product_name)
  return _internal_product_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Licenses_License::set_product_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.product_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Licenses.License.product_name)
}
inline std::string* Licenses_License::mutable_product_name() {
  std::string* _s = _internal_mutable_product_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Licenses.License.product_name)
  return _s;
}
inline const std::string& Licenses_License::_internal_product_name() const {
  return _impl_.product_name_.Get();
}
inline void Licenses_License::_internal_set_product_name(const std::string& value) {
  
  _impl_.product_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Licenses_License::_internal_mutable_product_name() {
  
  return _impl_.product_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Licenses_License::release_product_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Licenses.License.product_name)
  return _impl_.product_name_.Release();
}
inline void Licenses_License::set_allocated_product_name(std::string* product_name) {
  if (product_name != nullptr) {
    
  } else {
    
  }
  _impl_.product_name_.SetAllocated(product_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_name_.IsDefault()) {
    _impl_.product_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Licenses.License.product_name)
}

// repeated .proto.system_info.Licenses.License.Field field = 2;
inline int Licenses_License::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int Licenses_License::field_size() const {
  return _internal_field_size();
}
inline void Licenses_License::clear_field() {
  _impl_.field_.Clear();
}
inline ::proto::system_info::Licenses_License_Field* Licenses_License::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Licenses.License.field)
  return _impl_.field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License_Field >*
Licenses_License::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Licenses.License.field)
  return &_impl_.field_;
}
inline const ::proto::system_info::Licenses_License_Field& Licenses_License::_internal_field(int index) const {
  return _impl_.field_.Get(index);
}
inline const ::proto::system_info::Licenses_License_Field& Licenses_License::field(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Licenses.License.field)
  return _internal_field(index);
}
inline ::proto::system_info::Licenses_License_Field* Licenses_License::_internal_add_field() {
  return _impl_.field_.Add();
}
inline ::proto::system_info::Licenses_License_Field* Licenses_License::add_field() {
  ::proto::system_info::Licenses_License_Field* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:proto.system_info.Licenses.License.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License_Field >&
Licenses_License::field() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Licenses.License.field)
  return _impl_.field_;
}

// -------------------------------------------------------------------

// Licenses

// repeated .proto.system_info.Licenses.License license = 1;
inline int Licenses::_internal_license_size() const {
  return _impl_.license_.size();
}
inline int Licenses::license_size() const {
  return _internal_license_size();
}
inline void Licenses::clear_license() {
  _impl_.license_.Clear();
}
inline ::proto::system_info::Licenses_License* Licenses::mutable_license(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Licenses.license)
  return _impl_.license_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License >*
Licenses::mutable_license() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Licenses.license)
  return &_impl_.license_;
}
inline const ::proto::system_info::Licenses_License& Licenses::_internal_license(int index) const {
  return _impl_.license_.Get(index);
}
inline const ::proto::system_info::Licenses_License& Licenses::license(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Licenses.license)
  return _internal_license(index);
}
inline ::proto::system_info::Licenses_License* Licenses::_internal_add_license() {
  return _impl_.license_.Add();
}
inline ::proto::system_info::Licenses_License* Licenses::add_license() {
  ::proto::system_info::Licenses_License* _add = _internal_add_license();
  // @@protoc_insertion_point(field_add:proto.system_info.Licenses.license)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Licenses_License >&
Licenses::license() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Licenses.license)
  return _impl_.license_;
}

// -------------------------------------------------------------------

// Applications_Application

// string name = 1;
inline void Applications_Application::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Applications_Application::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Applications.Application.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Applications_Application::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Applications.Application.name)
}
inline std::string* Applications_Application::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Applications.Application.name)
  return _s;
}
inline const std::string& Applications_Application::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Applications_Application::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Applications_Application::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Applications_Application::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Applications.Application.name)
  return _impl_.name_.Release();
}
inline void Applications_Application::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Applications.Application.name)
}

// string version = 2;
inline void Applications_Application::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Applications_Application::version() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Applications.Application.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Applications_Application::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Applications.Application.version)
}
inline std::string* Applications_Application::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Applications.Application.version)
  return _s;
}
inline const std::string& Applications_Application::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Applications_Application::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Applications_Application::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Applications_Application::release_version() {
  // @@protoc_insertion_point(field_release:proto.system_info.Applications.Application.version)
  return _impl_.version_.Release();
}
inline void Applications_Application::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Applications.Application.version)
}

// string publisher = 3;
inline void Applications_Application::clear_publisher() {
  _impl_.publisher_.ClearToEmpty();
}
inline const std::string& Applications_Application::publisher() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Applications.Application.publisher)
  return _internal_publisher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Applications_Application::set_publisher(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publisher_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Applications.Application.publisher)
}
inline std::string* Applications_Application::mutable_publisher() {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Applications.Application.publisher)
  return _s;
}
inline const std::string& Applications_Application::_internal_publisher() const {
  return _impl_.publisher_.Get();
}
inline void Applications_Application::_internal_set_publisher(const std::string& value) {
  
  _impl_.publisher_.Set(value, GetArenaForAllocation());
}
inline std::string* Applications_Application::_internal_mutable_publisher() {
  
  return _impl_.publisher_.Mutable(GetArenaForAllocation());
}
inline std::string* Applications_Application::release_publisher() {
  // @@protoc_insertion_point(field_release:proto.system_info.Applications.Application.publisher)
  return _impl_.publisher_.Release();
}
inline void Applications_Application::set_allocated_publisher(std::string* publisher) {
  if (publisher != nullptr) {
    
  } else {
    
  }
  _impl_.publisher_.SetAllocated(publisher, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publisher_.IsDefault()) {
    _impl_.publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Applications.Application.publisher)
}

// string install_date = 4;
inline void Applications_Application::clear_install_date() {
  _impl_.install_date_.ClearToEmpty();
}
inline const std::string& Applications_Application::install_date() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Applications.Application.install_date)
  return _internal_install_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Applications_Application::set_install_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.install_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Applications.Application.install_date)
}
inline std::string* Applications_Application::mutable_install_date() {
  std::string* _s = _internal_mutable_install_date();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Applications.Application.install_date)
  return _s;
}
inline const std::string& Applications_Application::_internal_install_date() const {
  return _impl_.install_date_.Get();
}
inline void Applications_Application::_internal_set_install_date(const std::string& value) {
  
  _impl_.install_date_.Set(value, GetArenaForAllocation());
}
inline std::string* Applications_Application::_internal_mutable_install_date() {
  
  return _impl_.install_date_.Mutable(GetArenaForAllocation());
}
inline std::string* Applications_Application::release_install_date() {
  // @@protoc_insertion_point(field_release:proto.system_info.Applications.Application.install_date)
  return _impl_.install_date_.Release();
}
inline void Applications_Application::set_allocated_install_date(std::string* install_date) {
  if (install_date != nullptr) {
    
  } else {
    
  }
  _impl_.install_date_.SetAllocated(install_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.install_date_.IsDefault()) {
    _impl_.install_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Applications.Application.install_date)
}

// string install_location = 5;
inline void Applications_Application::clear_install_location() {
  _impl_.install_location_.ClearToEmpty();
}
inline const std::string& Applications_Application::install_location() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Applications.Application.install_location)
  return _internal_install_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Applications_Application::set_install_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.install_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Applications.Application.install_location)
}
inline std::string* Applications_Application::mutable_install_location() {
  std::string* _s = _internal_mutable_install_location();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Applications.Application.install_location)
  return _s;
}
inline const std::string& Applications_Application::_internal_install_location() const {
  return _impl_.install_location_.Get();
}
inline void Applications_Application::_internal_set_install_location(const std::string& value) {
  
  _impl_.install_location_.Set(value, GetArenaForAllocation());
}
inline std::string* Applications_Application::_internal_mutable_install_location() {
  
  return _impl_.install_location_.Mutable(GetArenaForAllocation());
}
inline std::string* Applications_Application::release_install_location() {
  // @@protoc_insertion_point(field_release:proto.system_info.Applications.Application.install_location)
  return _impl_.install_location_.Release();
}
inline void Applications_Application::set_allocated_install_location(std::string* install_location) {
  if (install_location != nullptr) {
    
  } else {
    
  }
  _impl_.install_location_.SetAllocated(install_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.install_location_.IsDefault()) {
    _impl_.install_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Applications.Application.install_location)
}

// -------------------------------------------------------------------

// Applications

// repeated .proto.system_info.Applications.Application application = 1;
inline int Applications::_internal_application_size() const {
  return _impl_.application_.size();
}
inline int Applications::application_size() const {
  return _internal_application_size();
}
inline void Applications::clear_application() {
  _impl_.application_.Clear();
}
inline ::proto::system_info::Applications_Application* Applications::mutable_application(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Applications.application)
  return _impl_.application_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Applications_Application >*
Applications::mutable_application() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Applications.application)
  return &_impl_.application_;
}
inline const ::proto::system_info::Applications_Application& Applications::_internal_application(int index) const {
  return _impl_.application_.Get(index);
}
inline const ::proto::system_info::Applications_Application& Applications::application(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Applications.application)
  return _internal_application(index);
}
inline ::proto::system_info::Applications_Application* Applications::_internal_add_application() {
  return _impl_.application_.Add();
}
inline ::proto::system_info::Applications_Application* Applications::add_application() {
  ::proto::system_info::Applications_Application* _add = _internal_add_application();
  // @@protoc_insertion_point(field_add:proto.system_info.Applications.application)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Applications_Application >&
Applications::application() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Applications.application)
  return _impl_.application_;
}

// -------------------------------------------------------------------

// OpenFiles_OpenFile

// uint32 id = 1;
inline void OpenFiles_OpenFile::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t OpenFiles_OpenFile::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t OpenFiles_OpenFile::id() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OpenFiles.OpenFile.id)
  return _internal_id();
}
inline void OpenFiles_OpenFile::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void OpenFiles_OpenFile::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:proto.system_info.OpenFiles.OpenFile.id)
}

// string user_name = 2;
inline void OpenFiles_OpenFile::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& OpenFiles_OpenFile::user_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OpenFiles.OpenFile.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenFiles_OpenFile::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.OpenFiles.OpenFile.user_name)
}
inline std::string* OpenFiles_OpenFile::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.OpenFiles.OpenFile.user_name)
  return _s;
}
inline const std::string& OpenFiles_OpenFile::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void OpenFiles_OpenFile::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenFiles_OpenFile::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenFiles_OpenFile::release_user_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.OpenFiles.OpenFile.user_name)
  return _impl_.user_name_.Release();
}
inline void OpenFiles_OpenFile::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.OpenFiles.OpenFile.user_name)
}

// uint32 lock_count = 3;
inline void OpenFiles_OpenFile::clear_lock_count() {
  _impl_.lock_count_ = 0u;
}
inline uint32_t OpenFiles_OpenFile::_internal_lock_count() const {
  return _impl_.lock_count_;
}
inline uint32_t OpenFiles_OpenFile::lock_count() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OpenFiles.OpenFile.lock_count)
  return _internal_lock_count();
}
inline void OpenFiles_OpenFile::_internal_set_lock_count(uint32_t value) {
  
  _impl_.lock_count_ = value;
}
inline void OpenFiles_OpenFile::set_lock_count(uint32_t value) {
  _internal_set_lock_count(value);
  // @@protoc_insertion_point(field_set:proto.system_info.OpenFiles.OpenFile.lock_count)
}

// string file_path = 4;
inline void OpenFiles_OpenFile::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& OpenFiles_OpenFile::file_path() const {
  // @@protoc_insertion_point(field_get:proto.system_info.OpenFiles.OpenFile.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenFiles_OpenFile::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.OpenFiles.OpenFile.file_path)
}
inline std::string* OpenFiles_OpenFile::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:proto.system_info.OpenFiles.OpenFile.file_path)
  return _s;
}
inline const std::string& OpenFiles_OpenFile::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void OpenFiles_OpenFile::_internal_set_file_path(const std::string& value) {
  
  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenFiles_OpenFile::_internal_mutable_file_path() {
  
  return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenFiles_OpenFile::release_file_path() {
  // @@protoc_insertion_point(field_release:proto.system_info.OpenFiles.OpenFile.file_path)
  return _impl_.file_path_.Release();
}
inline void OpenFiles_OpenFile::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.OpenFiles.OpenFile.file_path)
}

// -------------------------------------------------------------------

// OpenFiles

// repeated .proto.system_info.OpenFiles.OpenFile open_file = 1;
inline int OpenFiles::_internal_open_file_size() const {
  return _impl_.open_file_.size();
}
inline int OpenFiles::open_file_size() const {
  return _internal_open_file_size();
}
inline void OpenFiles::clear_open_file() {
  _impl_.open_file_.Clear();
}
inline ::proto::system_info::OpenFiles_OpenFile* OpenFiles::mutable_open_file(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.OpenFiles.open_file)
  return _impl_.open_file_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::OpenFiles_OpenFile >*
OpenFiles::mutable_open_file() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.OpenFiles.open_file)
  return &_impl_.open_file_;
}
inline const ::proto::system_info::OpenFiles_OpenFile& OpenFiles::_internal_open_file(int index) const {
  return _impl_.open_file_.Get(index);
}
inline const ::proto::system_info::OpenFiles_OpenFile& OpenFiles::open_file(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.OpenFiles.open_file)
  return _internal_open_file(index);
}
inline ::proto::system_info::OpenFiles_OpenFile* OpenFiles::_internal_add_open_file() {
  return _impl_.open_file_.Add();
}
inline ::proto::system_info::OpenFiles_OpenFile* OpenFiles::add_open_file() {
  ::proto::system_info::OpenFiles_OpenFile* _add = _internal_add_open_file();
  // @@protoc_insertion_point(field_add:proto.system_info.OpenFiles.open_file)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::OpenFiles_OpenFile >&
OpenFiles::open_file() const {
  // @@protoc_insertion_point(field_list:proto.system_info.OpenFiles.open_file)
  return _impl_.open_file_;
}

// -------------------------------------------------------------------

// LocalUsers_LocalUser_LocalUserGroup

// string name = 1;
inline void LocalUsers_LocalUser_LocalUserGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LocalUsers_LocalUser_LocalUserGroup::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUsers_LocalUser_LocalUserGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.name)
}
inline std::string* LocalUsers_LocalUser_LocalUserGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.name)
  return _s;
}
inline const std::string& LocalUsers_LocalUser_LocalUserGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LocalUsers_LocalUser_LocalUserGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser_LocalUserGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser_LocalUserGroup::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.name)
  return _impl_.name_.Release();
}
inline void LocalUsers_LocalUser_LocalUserGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.name)
}

// string comment = 2;
inline void LocalUsers_LocalUser_LocalUserGroup::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& LocalUsers_LocalUser_LocalUserGroup::comment() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUsers_LocalUser_LocalUserGroup::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.comment)
}
inline std::string* LocalUsers_LocalUser_LocalUserGroup::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.comment)
  return _s;
}
inline const std::string& LocalUsers_LocalUser_LocalUserGroup::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void LocalUsers_LocalUser_LocalUserGroup::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser_LocalUserGroup::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser_LocalUserGroup::release_comment() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.comment)
  return _impl_.comment_.Release();
}
inline void LocalUsers_LocalUser_LocalUserGroup::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUsers.LocalUser.LocalUserGroup.comment)
}

// -------------------------------------------------------------------

// LocalUsers_LocalUser

// string name = 1;
inline void LocalUsers_LocalUser::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LocalUsers_LocalUser::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUsers_LocalUser::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.name)
}
inline std::string* LocalUsers_LocalUser::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.name)
  return _s;
}
inline const std::string& LocalUsers_LocalUser::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LocalUsers_LocalUser::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUsers.LocalUser.name)
  return _impl_.name_.Release();
}
inline void LocalUsers_LocalUser::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUsers.LocalUser.name)
}

// string full_name = 2;
inline void LocalUsers_LocalUser::clear_full_name() {
  _impl_.full_name_.ClearToEmpty();
}
inline const std::string& LocalUsers_LocalUser::full_name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.full_name)
  return _internal_full_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUsers_LocalUser::set_full_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.full_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.full_name)
}
inline std::string* LocalUsers_LocalUser::mutable_full_name() {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.full_name)
  return _s;
}
inline const std::string& LocalUsers_LocalUser::_internal_full_name() const {
  return _impl_.full_name_.Get();
}
inline void LocalUsers_LocalUser::_internal_set_full_name(const std::string& value) {
  
  _impl_.full_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::_internal_mutable_full_name() {
  
  return _impl_.full_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::release_full_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUsers.LocalUser.full_name)
  return _impl_.full_name_.Release();
}
inline void LocalUsers_LocalUser::set_allocated_full_name(std::string* full_name) {
  if (full_name != nullptr) {
    
  } else {
    
  }
  _impl_.full_name_.SetAllocated(full_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUsers.LocalUser.full_name)
}

// string comment = 3;
inline void LocalUsers_LocalUser::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& LocalUsers_LocalUser::comment() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUsers_LocalUser::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.comment)
}
inline std::string* LocalUsers_LocalUser::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.comment)
  return _s;
}
inline const std::string& LocalUsers_LocalUser::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void LocalUsers_LocalUser::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::release_comment() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUsers.LocalUser.comment)
  return _impl_.comment_.Release();
}
inline void LocalUsers_LocalUser::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUsers.LocalUser.comment)
}

// string home_dir = 4;
inline void LocalUsers_LocalUser::clear_home_dir() {
  _impl_.home_dir_.ClearToEmpty();
}
inline const std::string& LocalUsers_LocalUser::home_dir() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.home_dir)
  return _internal_home_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUsers_LocalUser::set_home_dir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.home_dir_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.home_dir)
}
inline std::string* LocalUsers_LocalUser::mutable_home_dir() {
  std::string* _s = _internal_mutable_home_dir();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.home_dir)
  return _s;
}
inline const std::string& LocalUsers_LocalUser::_internal_home_dir() const {
  return _impl_.home_dir_.Get();
}
inline void LocalUsers_LocalUser::_internal_set_home_dir(const std::string& value) {
  
  _impl_.home_dir_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::_internal_mutable_home_dir() {
  
  return _impl_.home_dir_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUsers_LocalUser::release_home_dir() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUsers.LocalUser.home_dir)
  return _impl_.home_dir_.Release();
}
inline void LocalUsers_LocalUser::set_allocated_home_dir(std::string* home_dir) {
  if (home_dir != nullptr) {
    
  } else {
    
  }
  _impl_.home_dir_.SetAllocated(home_dir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.home_dir_.IsDefault()) {
    _impl_.home_dir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUsers.LocalUser.home_dir)
}

// repeated .proto.system_info.LocalUsers.LocalUser.LocalUserGroup group = 5;
inline int LocalUsers_LocalUser::_internal_group_size() const {
  return _impl_.group_.size();
}
inline int LocalUsers_LocalUser::group_size() const {
  return _internal_group_size();
}
inline void LocalUsers_LocalUser::clear_group() {
  _impl_.group_.Clear();
}
inline ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* LocalUsers_LocalUser::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.LocalUser.group)
  return _impl_.group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup >*
LocalUsers_LocalUser::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.LocalUsers.LocalUser.group)
  return &_impl_.group_;
}
inline const ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup& LocalUsers_LocalUser::_internal_group(int index) const {
  return _impl_.group_.Get(index);
}
inline const ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup& LocalUsers_LocalUser::group(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.group)
  return _internal_group(index);
}
inline ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* LocalUsers_LocalUser::_internal_add_group() {
  return _impl_.group_.Add();
}
inline ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* LocalUsers_LocalUser::add_group() {
  ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup* _add = _internal_add_group();
  // @@protoc_insertion_point(field_add:proto.system_info.LocalUsers.LocalUser.group)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser_LocalUserGroup >&
LocalUsers_LocalUser::group() const {
  // @@protoc_insertion_point(field_list:proto.system_info.LocalUsers.LocalUser.group)
  return _impl_.group_;
}

// bool disabled = 6;
inline void LocalUsers_LocalUser::clear_disabled() {
  _impl_.disabled_ = false;
}
inline bool LocalUsers_LocalUser::_internal_disabled() const {
  return _impl_.disabled_;
}
inline bool LocalUsers_LocalUser::disabled() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.disabled)
  return _internal_disabled();
}
inline void LocalUsers_LocalUser::_internal_set_disabled(bool value) {
  
  _impl_.disabled_ = value;
}
inline void LocalUsers_LocalUser::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.disabled)
}

// bool password_cant_change = 7;
inline void LocalUsers_LocalUser::clear_password_cant_change() {
  _impl_.password_cant_change_ = false;
}
inline bool LocalUsers_LocalUser::_internal_password_cant_change() const {
  return _impl_.password_cant_change_;
}
inline bool LocalUsers_LocalUser::password_cant_change() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.password_cant_change)
  return _internal_password_cant_change();
}
inline void LocalUsers_LocalUser::_internal_set_password_cant_change(bool value) {
  
  _impl_.password_cant_change_ = value;
}
inline void LocalUsers_LocalUser::set_password_cant_change(bool value) {
  _internal_set_password_cant_change(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.password_cant_change)
}

// bool password_expired = 8;
inline void LocalUsers_LocalUser::clear_password_expired() {
  _impl_.password_expired_ = false;
}
inline bool LocalUsers_LocalUser::_internal_password_expired() const {
  return _impl_.password_expired_;
}
inline bool LocalUsers_LocalUser::password_expired() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.password_expired)
  return _internal_password_expired();
}
inline void LocalUsers_LocalUser::_internal_set_password_expired(bool value) {
  
  _impl_.password_expired_ = value;
}
inline void LocalUsers_LocalUser::set_password_expired(bool value) {
  _internal_set_password_expired(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.password_expired)
}

// bool dont_expire_password = 9;
inline void LocalUsers_LocalUser::clear_dont_expire_password() {
  _impl_.dont_expire_password_ = false;
}
inline bool LocalUsers_LocalUser::_internal_dont_expire_password() const {
  return _impl_.dont_expire_password_;
}
inline bool LocalUsers_LocalUser::dont_expire_password() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.dont_expire_password)
  return _internal_dont_expire_password();
}
inline void LocalUsers_LocalUser::_internal_set_dont_expire_password(bool value) {
  
  _impl_.dont_expire_password_ = value;
}
inline void LocalUsers_LocalUser::set_dont_expire_password(bool value) {
  _internal_set_dont_expire_password(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.dont_expire_password)
}

// bool lockout = 10;
inline void LocalUsers_LocalUser::clear_lockout() {
  _impl_.lockout_ = false;
}
inline bool LocalUsers_LocalUser::_internal_lockout() const {
  return _impl_.lockout_;
}
inline bool LocalUsers_LocalUser::lockout() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.lockout)
  return _internal_lockout();
}
inline void LocalUsers_LocalUser::_internal_set_lockout(bool value) {
  
  _impl_.lockout_ = value;
}
inline void LocalUsers_LocalUser::set_lockout(bool value) {
  _internal_set_lockout(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.lockout)
}

// uint32 number_logons = 11;
inline void LocalUsers_LocalUser::clear_number_logons() {
  _impl_.number_logons_ = 0u;
}
inline uint32_t LocalUsers_LocalUser::_internal_number_logons() const {
  return _impl_.number_logons_;
}
inline uint32_t LocalUsers_LocalUser::number_logons() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.number_logons)
  return _internal_number_logons();
}
inline void LocalUsers_LocalUser::_internal_set_number_logons(uint32_t value) {
  
  _impl_.number_logons_ = value;
}
inline void LocalUsers_LocalUser::set_number_logons(uint32_t value) {
  _internal_set_number_logons(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.number_logons)
}

// uint32 bad_password_count = 12;
inline void LocalUsers_LocalUser::clear_bad_password_count() {
  _impl_.bad_password_count_ = 0u;
}
inline uint32_t LocalUsers_LocalUser::_internal_bad_password_count() const {
  return _impl_.bad_password_count_;
}
inline uint32_t LocalUsers_LocalUser::bad_password_count() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.bad_password_count)
  return _internal_bad_password_count();
}
inline void LocalUsers_LocalUser::_internal_set_bad_password_count(uint32_t value) {
  
  _impl_.bad_password_count_ = value;
}
inline void LocalUsers_LocalUser::set_bad_password_count(uint32_t value) {
  _internal_set_bad_password_count(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.bad_password_count)
}

// uint64 last_logon_time = 13;
inline void LocalUsers_LocalUser::clear_last_logon_time() {
  _impl_.last_logon_time_ = uint64_t{0u};
}
inline uint64_t LocalUsers_LocalUser::_internal_last_logon_time() const {
  return _impl_.last_logon_time_;
}
inline uint64_t LocalUsers_LocalUser::last_logon_time() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.LocalUser.last_logon_time)
  return _internal_last_logon_time();
}
inline void LocalUsers_LocalUser::_internal_set_last_logon_time(uint64_t value) {
  
  _impl_.last_logon_time_ = value;
}
inline void LocalUsers_LocalUser::set_last_logon_time(uint64_t value) {
  _internal_set_last_logon_time(value);
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUsers.LocalUser.last_logon_time)
}

// -------------------------------------------------------------------

// LocalUsers

// repeated .proto.system_info.LocalUsers.LocalUser local_user = 1;
inline int LocalUsers::_internal_local_user_size() const {
  return _impl_.local_user_.size();
}
inline int LocalUsers::local_user_size() const {
  return _internal_local_user_size();
}
inline void LocalUsers::clear_local_user() {
  _impl_.local_user_.Clear();
}
inline ::proto::system_info::LocalUsers_LocalUser* LocalUsers::mutable_local_user(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUsers.local_user)
  return _impl_.local_user_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser >*
LocalUsers::mutable_local_user() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.LocalUsers.local_user)
  return &_impl_.local_user_;
}
inline const ::proto::system_info::LocalUsers_LocalUser& LocalUsers::_internal_local_user(int index) const {
  return _impl_.local_user_.Get(index);
}
inline const ::proto::system_info::LocalUsers_LocalUser& LocalUsers::local_user(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUsers.local_user)
  return _internal_local_user(index);
}
inline ::proto::system_info::LocalUsers_LocalUser* LocalUsers::_internal_add_local_user() {
  return _impl_.local_user_.Add();
}
inline ::proto::system_info::LocalUsers_LocalUser* LocalUsers::add_local_user() {
  ::proto::system_info::LocalUsers_LocalUser* _add = _internal_add_local_user();
  // @@protoc_insertion_point(field_add:proto.system_info.LocalUsers.local_user)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUsers_LocalUser >&
LocalUsers::local_user() const {
  // @@protoc_insertion_point(field_list:proto.system_info.LocalUsers.local_user)
  return _impl_.local_user_;
}

// -------------------------------------------------------------------

// LocalUserGroups_LocalUserGroup

// string name = 1;
inline void LocalUserGroups_LocalUserGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LocalUserGroups_LocalUserGroup::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUserGroups.LocalUserGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUserGroups_LocalUserGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUserGroups.LocalUserGroup.name)
}
inline std::string* LocalUserGroups_LocalUserGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUserGroups.LocalUserGroup.name)
  return _s;
}
inline const std::string& LocalUserGroups_LocalUserGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LocalUserGroups_LocalUserGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUserGroups_LocalUserGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUserGroups_LocalUserGroup::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUserGroups.LocalUserGroup.name)
  return _impl_.name_.Release();
}
inline void LocalUserGroups_LocalUserGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUserGroups.LocalUserGroup.name)
}

// string comment = 2;
inline void LocalUserGroups_LocalUserGroup::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& LocalUserGroups_LocalUserGroup::comment() const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUserGroups.LocalUserGroup.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalUserGroups_LocalUserGroup::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.LocalUserGroups.LocalUserGroup.comment)
}
inline std::string* LocalUserGroups_LocalUserGroup::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUserGroups.LocalUserGroup.comment)
  return _s;
}
inline const std::string& LocalUserGroups_LocalUserGroup::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void LocalUserGroups_LocalUserGroup::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalUserGroups_LocalUserGroup::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalUserGroups_LocalUserGroup::release_comment() {
  // @@protoc_insertion_point(field_release:proto.system_info.LocalUserGroups.LocalUserGroup.comment)
  return _impl_.comment_.Release();
}
inline void LocalUserGroups_LocalUserGroup::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.LocalUserGroups.LocalUserGroup.comment)
}

// -------------------------------------------------------------------

// LocalUserGroups

// repeated .proto.system_info.LocalUserGroups.LocalUserGroup local_user_group = 1;
inline int LocalUserGroups::_internal_local_user_group_size() const {
  return _impl_.local_user_group_.size();
}
inline int LocalUserGroups::local_user_group_size() const {
  return _internal_local_user_group_size();
}
inline void LocalUserGroups::clear_local_user_group() {
  _impl_.local_user_group_.Clear();
}
inline ::proto::system_info::LocalUserGroups_LocalUserGroup* LocalUserGroups::mutable_local_user_group(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.LocalUserGroups.local_user_group)
  return _impl_.local_user_group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUserGroups_LocalUserGroup >*
LocalUserGroups::mutable_local_user_group() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.LocalUserGroups.local_user_group)
  return &_impl_.local_user_group_;
}
inline const ::proto::system_info::LocalUserGroups_LocalUserGroup& LocalUserGroups::_internal_local_user_group(int index) const {
  return _impl_.local_user_group_.Get(index);
}
inline const ::proto::system_info::LocalUserGroups_LocalUserGroup& LocalUserGroups::local_user_group(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.LocalUserGroups.local_user_group)
  return _internal_local_user_group(index);
}
inline ::proto::system_info::LocalUserGroups_LocalUserGroup* LocalUserGroups::_internal_add_local_user_group() {
  return _impl_.local_user_group_.Add();
}
inline ::proto::system_info::LocalUserGroups_LocalUserGroup* LocalUserGroups::add_local_user_group() {
  ::proto::system_info::LocalUserGroups_LocalUserGroup* _add = _internal_add_local_user_group();
  // @@protoc_insertion_point(field_add:proto.system_info.LocalUserGroups.local_user_group)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::LocalUserGroups_LocalUserGroup >&
LocalUserGroups::local_user_group() const {
  // @@protoc_insertion_point(field_list:proto.system_info.LocalUserGroups.local_user_group)
  return _impl_.local_user_group_;
}

// -------------------------------------------------------------------

// Processes_Process

// string name = 1;
inline void Processes_Process::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Processes_Process::name() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Processes_Process::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.name)
}
inline std::string* Processes_Process::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Processes.Process.name)
  return _s;
}
inline const std::string& Processes_Process::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Processes_Process::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Processes_Process::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Processes_Process::release_name() {
  // @@protoc_insertion_point(field_release:proto.system_info.Processes.Process.name)
  return _impl_.name_.Release();
}
inline void Processes_Process::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Processes.Process.name)
}

// uint32 pid = 2;
inline void Processes_Process::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t Processes_Process::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t Processes_Process::pid() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.pid)
  return _internal_pid();
}
inline void Processes_Process::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void Processes_Process::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.pid)
}

// uint32 sid = 3;
inline void Processes_Process::clear_sid() {
  _impl_.sid_ = 0u;
}
inline uint32_t Processes_Process::_internal_sid() const {
  return _impl_.sid_;
}
inline uint32_t Processes_Process::sid() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.sid)
  return _internal_sid();
}
inline void Processes_Process::_internal_set_sid(uint32_t value) {
  
  _impl_.sid_ = value;
}
inline void Processes_Process::set_sid(uint32_t value) {
  _internal_set_sid(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.sid)
}

// string user = 4;
inline void Processes_Process::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& Processes_Process::user() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Processes_Process::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.user)
}
inline std::string* Processes_Process::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Processes.Process.user)
  return _s;
}
inline const std::string& Processes_Process::_internal_user() const {
  return _impl_.user_.Get();
}
inline void Processes_Process::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* Processes_Process::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* Processes_Process::release_user() {
  // @@protoc_insertion_point(field_release:proto.system_info.Processes.Process.user)
  return _impl_.user_.Release();
}
inline void Processes_Process::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Processes.Process.user)
}

// string path = 5;
inline void Processes_Process::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Processes_Process::path() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Processes_Process::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.path)
}
inline std::string* Processes_Process::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:proto.system_info.Processes.Process.path)
  return _s;
}
inline const std::string& Processes_Process::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Processes_Process::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Processes_Process::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Processes_Process::release_path() {
  // @@protoc_insertion_point(field_release:proto.system_info.Processes.Process.path)
  return _impl_.path_.Release();
}
inline void Processes_Process::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.Processes.Process.path)
}

// int32 cpu = 6;
inline void Processes_Process::clear_cpu() {
  _impl_.cpu_ = 0;
}
inline int32_t Processes_Process::_internal_cpu() const {
  return _impl_.cpu_;
}
inline int32_t Processes_Process::cpu() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.cpu)
  return _internal_cpu();
}
inline void Processes_Process::_internal_set_cpu(int32_t value) {
  
  _impl_.cpu_ = value;
}
inline void Processes_Process::set_cpu(int32_t value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.cpu)
}

// int64 memory = 7;
inline void Processes_Process::clear_memory() {
  _impl_.memory_ = int64_t{0};
}
inline int64_t Processes_Process::_internal_memory() const {
  return _impl_.memory_;
}
inline int64_t Processes_Process::memory() const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.Process.memory)
  return _internal_memory();
}
inline void Processes_Process::_internal_set_memory(int64_t value) {
  
  _impl_.memory_ = value;
}
inline void Processes_Process::set_memory(int64_t value) {
  _internal_set_memory(value);
  // @@protoc_insertion_point(field_set:proto.system_info.Processes.Process.memory)
}

// -------------------------------------------------------------------

// Processes

// repeated .proto.system_info.Processes.Process process = 1;
inline int Processes::_internal_process_size() const {
  return _impl_.process_.size();
}
inline int Processes::process_size() const {
  return _internal_process_size();
}
inline void Processes::clear_process() {
  _impl_.process_.Clear();
}
inline ::proto::system_info::Processes_Process* Processes::mutable_process(int index) {
  // @@protoc_insertion_point(field_mutable:proto.system_info.Processes.process)
  return _impl_.process_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Processes_Process >*
Processes::mutable_process() {
  // @@protoc_insertion_point(field_mutable_list:proto.system_info.Processes.process)
  return &_impl_.process_;
}
inline const ::proto::system_info::Processes_Process& Processes::_internal_process(int index) const {
  return _impl_.process_.Get(index);
}
inline const ::proto::system_info::Processes_Process& Processes::process(int index) const {
  // @@protoc_insertion_point(field_get:proto.system_info.Processes.process)
  return _internal_process(index);
}
inline ::proto::system_info::Processes_Process* Processes::_internal_add_process() {
  return _impl_.process_.Add();
}
inline ::proto::system_info::Processes_Process* Processes::add_process() {
  ::proto::system_info::Processes_Process* _add = _internal_add_process();
  // @@protoc_insertion_point(field_add:proto.system_info.Processes.process)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::system_info::Processes_Process >&
Processes::process() const {
  // @@protoc_insertion_point(field_list:proto.system_info.Processes.process)
  return _impl_.process_;
}

// -------------------------------------------------------------------

// SystemInfoRequest

// string category = 1;
inline void SystemInfoRequest::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& SystemInfoRequest::category() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfoRequest.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfoRequest::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.SystemInfoRequest.category)
}
inline std::string* SystemInfoRequest::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfoRequest.category)
  return _s;
}
inline const std::string& SystemInfoRequest::_internal_category() const {
  return _impl_.category_.Get();
}
inline void SystemInfoRequest::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfoRequest::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfoRequest::release_category() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfoRequest.category)
  return _impl_.category_.Release();
}
inline void SystemInfoRequest::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfoRequest.category)
}

// .proto.system_info.EventLogsData event_logs_data = 11;
inline bool SystemInfoRequest::_internal_has_event_logs_data() const {
  return this != internal_default_instance() && _impl_.event_logs_data_ != nullptr;
}
inline bool SystemInfoRequest::has_event_logs_data() const {
  return _internal_has_event_logs_data();
}
inline void SystemInfoRequest::clear_event_logs_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_logs_data_ != nullptr) {
    delete _impl_.event_logs_data_;
  }
  _impl_.event_logs_data_ = nullptr;
}
inline const ::proto::system_info::EventLogsData& SystemInfoRequest::_internal_event_logs_data() const {
  const ::proto::system_info::EventLogsData* p = _impl_.event_logs_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::EventLogsData&>(
      ::proto::system_info::_EventLogsData_default_instance_);
}
inline const ::proto::system_info::EventLogsData& SystemInfoRequest::event_logs_data() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfoRequest.event_logs_data)
  return _internal_event_logs_data();
}
inline void SystemInfoRequest::unsafe_arena_set_allocated_event_logs_data(
    ::proto::system_info::EventLogsData* event_logs_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_logs_data_);
  }
  _impl_.event_logs_data_ = event_logs_data;
  if (event_logs_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfoRequest.event_logs_data)
}
inline ::proto::system_info::EventLogsData* SystemInfoRequest::release_event_logs_data() {
  
  ::proto::system_info::EventLogsData* temp = _impl_.event_logs_data_;
  _impl_.event_logs_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::EventLogsData* SystemInfoRequest::unsafe_arena_release_event_logs_data() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfoRequest.event_logs_data)
  
  ::proto::system_info::EventLogsData* temp = _impl_.event_logs_data_;
  _impl_.event_logs_data_ = nullptr;
  return temp;
}
inline ::proto::system_info::EventLogsData* SystemInfoRequest::_internal_mutable_event_logs_data() {
  
  if (_impl_.event_logs_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::EventLogsData>(GetArenaForAllocation());
    _impl_.event_logs_data_ = p;
  }
  return _impl_.event_logs_data_;
}
inline ::proto::system_info::EventLogsData* SystemInfoRequest::mutable_event_logs_data() {
  ::proto::system_info::EventLogsData* _msg = _internal_mutable_event_logs_data();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfoRequest.event_logs_data)
  return _msg;
}
inline void SystemInfoRequest::set_allocated_event_logs_data(::proto::system_info::EventLogsData* event_logs_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_logs_data_;
  }
  if (event_logs_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event_logs_data);
    if (message_arena != submessage_arena) {
      event_logs_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_logs_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_logs_data_ = event_logs_data;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfoRequest.event_logs_data)
}

// -------------------------------------------------------------------

// SystemInfoFooter

// string category = 1;
inline void SystemInfoFooter::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& SystemInfoFooter::category() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfoFooter.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfoFooter::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.system_info.SystemInfoFooter.category)
}
inline std::string* SystemInfoFooter::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfoFooter.category)
  return _s;
}
inline const std::string& SystemInfoFooter::_internal_category() const {
  return _impl_.category_.Get();
}
inline void SystemInfoFooter::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfoFooter::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfoFooter::release_category() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfoFooter.category)
  return _impl_.category_.Release();
}
inline void SystemInfoFooter::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfoFooter.category)
}

// -------------------------------------------------------------------

// SystemInfo

// .proto.system_info.Computer computer = 1;
inline bool SystemInfo::_internal_has_computer() const {
  return this != internal_default_instance() && _impl_.computer_ != nullptr;
}
inline bool SystemInfo::has_computer() const {
  return _internal_has_computer();
}
inline void SystemInfo::clear_computer() {
  if (GetArenaForAllocation() == nullptr && _impl_.computer_ != nullptr) {
    delete _impl_.computer_;
  }
  _impl_.computer_ = nullptr;
}
inline const ::proto::system_info::Computer& SystemInfo::_internal_computer() const {
  const ::proto::system_info::Computer* p = _impl_.computer_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Computer&>(
      ::proto::system_info::_Computer_default_instance_);
}
inline const ::proto::system_info::Computer& SystemInfo::computer() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.computer)
  return _internal_computer();
}
inline void SystemInfo::unsafe_arena_set_allocated_computer(
    ::proto::system_info::Computer* computer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.computer_);
  }
  _impl_.computer_ = computer;
  if (computer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.computer)
}
inline ::proto::system_info::Computer* SystemInfo::release_computer() {
  
  ::proto::system_info::Computer* temp = _impl_.computer_;
  _impl_.computer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Computer* SystemInfo::unsafe_arena_release_computer() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.computer)
  
  ::proto::system_info::Computer* temp = _impl_.computer_;
  _impl_.computer_ = nullptr;
  return temp;
}
inline ::proto::system_info::Computer* SystemInfo::_internal_mutable_computer() {
  
  if (_impl_.computer_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Computer>(GetArenaForAllocation());
    _impl_.computer_ = p;
  }
  return _impl_.computer_;
}
inline ::proto::system_info::Computer* SystemInfo::mutable_computer() {
  ::proto::system_info::Computer* _msg = _internal_mutable_computer();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.computer)
  return _msg;
}
inline void SystemInfo::set_allocated_computer(::proto::system_info::Computer* computer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.computer_;
  }
  if (computer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(computer);
    if (message_arena != submessage_arena) {
      computer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, computer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.computer_ = computer;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.computer)
}

// .proto.system_info.OperatingSystem operating_system = 2;
inline bool SystemInfo::_internal_has_operating_system() const {
  return this != internal_default_instance() && _impl_.operating_system_ != nullptr;
}
inline bool SystemInfo::has_operating_system() const {
  return _internal_has_operating_system();
}
inline void SystemInfo::clear_operating_system() {
  if (GetArenaForAllocation() == nullptr && _impl_.operating_system_ != nullptr) {
    delete _impl_.operating_system_;
  }
  _impl_.operating_system_ = nullptr;
}
inline const ::proto::system_info::OperatingSystem& SystemInfo::_internal_operating_system() const {
  const ::proto::system_info::OperatingSystem* p = _impl_.operating_system_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::OperatingSystem&>(
      ::proto::system_info::_OperatingSystem_default_instance_);
}
inline const ::proto::system_info::OperatingSystem& SystemInfo::operating_system() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.operating_system)
  return _internal_operating_system();
}
inline void SystemInfo::unsafe_arena_set_allocated_operating_system(
    ::proto::system_info::OperatingSystem* operating_system) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operating_system_);
  }
  _impl_.operating_system_ = operating_system;
  if (operating_system) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.operating_system)
}
inline ::proto::system_info::OperatingSystem* SystemInfo::release_operating_system() {
  
  ::proto::system_info::OperatingSystem* temp = _impl_.operating_system_;
  _impl_.operating_system_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::OperatingSystem* SystemInfo::unsafe_arena_release_operating_system() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.operating_system)
  
  ::proto::system_info::OperatingSystem* temp = _impl_.operating_system_;
  _impl_.operating_system_ = nullptr;
  return temp;
}
inline ::proto::system_info::OperatingSystem* SystemInfo::_internal_mutable_operating_system() {
  
  if (_impl_.operating_system_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::OperatingSystem>(GetArenaForAllocation());
    _impl_.operating_system_ = p;
  }
  return _impl_.operating_system_;
}
inline ::proto::system_info::OperatingSystem* SystemInfo::mutable_operating_system() {
  ::proto::system_info::OperatingSystem* _msg = _internal_mutable_operating_system();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.operating_system)
  return _msg;
}
inline void SystemInfo::set_allocated_operating_system(::proto::system_info::OperatingSystem* operating_system) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.operating_system_;
  }
  if (operating_system) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(operating_system);
    if (message_arena != submessage_arena) {
      operating_system = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operating_system, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.operating_system_ = operating_system;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.operating_system)
}

// .proto.system_info.Motherboard motherboard = 3;
inline bool SystemInfo::_internal_has_motherboard() const {
  return this != internal_default_instance() && _impl_.motherboard_ != nullptr;
}
inline bool SystemInfo::has_motherboard() const {
  return _internal_has_motherboard();
}
inline void SystemInfo::clear_motherboard() {
  if (GetArenaForAllocation() == nullptr && _impl_.motherboard_ != nullptr) {
    delete _impl_.motherboard_;
  }
  _impl_.motherboard_ = nullptr;
}
inline const ::proto::system_info::Motherboard& SystemInfo::_internal_motherboard() const {
  const ::proto::system_info::Motherboard* p = _impl_.motherboard_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Motherboard&>(
      ::proto::system_info::_Motherboard_default_instance_);
}
inline const ::proto::system_info::Motherboard& SystemInfo::motherboard() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.motherboard)
  return _internal_motherboard();
}
inline void SystemInfo::unsafe_arena_set_allocated_motherboard(
    ::proto::system_info::Motherboard* motherboard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.motherboard_);
  }
  _impl_.motherboard_ = motherboard;
  if (motherboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.motherboard)
}
inline ::proto::system_info::Motherboard* SystemInfo::release_motherboard() {
  
  ::proto::system_info::Motherboard* temp = _impl_.motherboard_;
  _impl_.motherboard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Motherboard* SystemInfo::unsafe_arena_release_motherboard() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.motherboard)
  
  ::proto::system_info::Motherboard* temp = _impl_.motherboard_;
  _impl_.motherboard_ = nullptr;
  return temp;
}
inline ::proto::system_info::Motherboard* SystemInfo::_internal_mutable_motherboard() {
  
  if (_impl_.motherboard_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Motherboard>(GetArenaForAllocation());
    _impl_.motherboard_ = p;
  }
  return _impl_.motherboard_;
}
inline ::proto::system_info::Motherboard* SystemInfo::mutable_motherboard() {
  ::proto::system_info::Motherboard* _msg = _internal_mutable_motherboard();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.motherboard)
  return _msg;
}
inline void SystemInfo::set_allocated_motherboard(::proto::system_info::Motherboard* motherboard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.motherboard_;
  }
  if (motherboard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motherboard);
    if (message_arena != submessage_arena) {
      motherboard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motherboard, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.motherboard_ = motherboard;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.motherboard)
}

// .proto.system_info.Bios bios = 4;
inline bool SystemInfo::_internal_has_bios() const {
  return this != internal_default_instance() && _impl_.bios_ != nullptr;
}
inline bool SystemInfo::has_bios() const {
  return _internal_has_bios();
}
inline void SystemInfo::clear_bios() {
  if (GetArenaForAllocation() == nullptr && _impl_.bios_ != nullptr) {
    delete _impl_.bios_;
  }
  _impl_.bios_ = nullptr;
}
inline const ::proto::system_info::Bios& SystemInfo::_internal_bios() const {
  const ::proto::system_info::Bios* p = _impl_.bios_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Bios&>(
      ::proto::system_info::_Bios_default_instance_);
}
inline const ::proto::system_info::Bios& SystemInfo::bios() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.bios)
  return _internal_bios();
}
inline void SystemInfo::unsafe_arena_set_allocated_bios(
    ::proto::system_info::Bios* bios) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bios_);
  }
  _impl_.bios_ = bios;
  if (bios) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.bios)
}
inline ::proto::system_info::Bios* SystemInfo::release_bios() {
  
  ::proto::system_info::Bios* temp = _impl_.bios_;
  _impl_.bios_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Bios* SystemInfo::unsafe_arena_release_bios() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.bios)
  
  ::proto::system_info::Bios* temp = _impl_.bios_;
  _impl_.bios_ = nullptr;
  return temp;
}
inline ::proto::system_info::Bios* SystemInfo::_internal_mutable_bios() {
  
  if (_impl_.bios_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Bios>(GetArenaForAllocation());
    _impl_.bios_ = p;
  }
  return _impl_.bios_;
}
inline ::proto::system_info::Bios* SystemInfo::mutable_bios() {
  ::proto::system_info::Bios* _msg = _internal_mutable_bios();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.bios)
  return _msg;
}
inline void SystemInfo::set_allocated_bios(::proto::system_info::Bios* bios) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bios_;
  }
  if (bios) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bios);
    if (message_arena != submessage_arena) {
      bios = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bios, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bios_ = bios;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.bios)
}

// .proto.system_info.Processor processor = 5;
inline bool SystemInfo::_internal_has_processor() const {
  return this != internal_default_instance() && _impl_.processor_ != nullptr;
}
inline bool SystemInfo::has_processor() const {
  return _internal_has_processor();
}
inline void SystemInfo::clear_processor() {
  if (GetArenaForAllocation() == nullptr && _impl_.processor_ != nullptr) {
    delete _impl_.processor_;
  }
  _impl_.processor_ = nullptr;
}
inline const ::proto::system_info::Processor& SystemInfo::_internal_processor() const {
  const ::proto::system_info::Processor* p = _impl_.processor_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Processor&>(
      ::proto::system_info::_Processor_default_instance_);
}
inline const ::proto::system_info::Processor& SystemInfo::processor() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.processor)
  return _internal_processor();
}
inline void SystemInfo::unsafe_arena_set_allocated_processor(
    ::proto::system_info::Processor* processor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processor_);
  }
  _impl_.processor_ = processor;
  if (processor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.processor)
}
inline ::proto::system_info::Processor* SystemInfo::release_processor() {
  
  ::proto::system_info::Processor* temp = _impl_.processor_;
  _impl_.processor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Processor* SystemInfo::unsafe_arena_release_processor() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.processor)
  
  ::proto::system_info::Processor* temp = _impl_.processor_;
  _impl_.processor_ = nullptr;
  return temp;
}
inline ::proto::system_info::Processor* SystemInfo::_internal_mutable_processor() {
  
  if (_impl_.processor_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Processor>(GetArenaForAllocation());
    _impl_.processor_ = p;
  }
  return _impl_.processor_;
}
inline ::proto::system_info::Processor* SystemInfo::mutable_processor() {
  ::proto::system_info::Processor* _msg = _internal_mutable_processor();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.processor)
  return _msg;
}
inline void SystemInfo::set_allocated_processor(::proto::system_info::Processor* processor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.processor_;
  }
  if (processor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(processor);
    if (message_arena != submessage_arena) {
      processor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processor_ = processor;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.processor)
}

// .proto.system_info.Memory memory = 6;
inline bool SystemInfo::_internal_has_memory() const {
  return this != internal_default_instance() && _impl_.memory_ != nullptr;
}
inline bool SystemInfo::has_memory() const {
  return _internal_has_memory();
}
inline void SystemInfo::clear_memory() {
  if (GetArenaForAllocation() == nullptr && _impl_.memory_ != nullptr) {
    delete _impl_.memory_;
  }
  _impl_.memory_ = nullptr;
}
inline const ::proto::system_info::Memory& SystemInfo::_internal_memory() const {
  const ::proto::system_info::Memory* p = _impl_.memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Memory&>(
      ::proto::system_info::_Memory_default_instance_);
}
inline const ::proto::system_info::Memory& SystemInfo::memory() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.memory)
  return _internal_memory();
}
inline void SystemInfo::unsafe_arena_set_allocated_memory(
    ::proto::system_info::Memory* memory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.memory_);
  }
  _impl_.memory_ = memory;
  if (memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.memory)
}
inline ::proto::system_info::Memory* SystemInfo::release_memory() {
  
  ::proto::system_info::Memory* temp = _impl_.memory_;
  _impl_.memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Memory* SystemInfo::unsafe_arena_release_memory() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.memory)
  
  ::proto::system_info::Memory* temp = _impl_.memory_;
  _impl_.memory_ = nullptr;
  return temp;
}
inline ::proto::system_info::Memory* SystemInfo::_internal_mutable_memory() {
  
  if (_impl_.memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Memory>(GetArenaForAllocation());
    _impl_.memory_ = p;
  }
  return _impl_.memory_;
}
inline ::proto::system_info::Memory* SystemInfo::mutable_memory() {
  ::proto::system_info::Memory* _msg = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.memory)
  return _msg;
}
inline void SystemInfo::set_allocated_memory(::proto::system_info::Memory* memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.memory_;
  }
  if (memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(memory);
    if (message_arena != submessage_arena) {
      memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, memory, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.memory_ = memory;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.memory)
}

// .proto.system_info.LogicalDrives logical_drives = 7;
inline bool SystemInfo::_internal_has_logical_drives() const {
  return this != internal_default_instance() && _impl_.logical_drives_ != nullptr;
}
inline bool SystemInfo::has_logical_drives() const {
  return _internal_has_logical_drives();
}
inline void SystemInfo::clear_logical_drives() {
  if (GetArenaForAllocation() == nullptr && _impl_.logical_drives_ != nullptr) {
    delete _impl_.logical_drives_;
  }
  _impl_.logical_drives_ = nullptr;
}
inline const ::proto::system_info::LogicalDrives& SystemInfo::_internal_logical_drives() const {
  const ::proto::system_info::LogicalDrives* p = _impl_.logical_drives_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::LogicalDrives&>(
      ::proto::system_info::_LogicalDrives_default_instance_);
}
inline const ::proto::system_info::LogicalDrives& SystemInfo::logical_drives() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.logical_drives)
  return _internal_logical_drives();
}
inline void SystemInfo::unsafe_arena_set_allocated_logical_drives(
    ::proto::system_info::LogicalDrives* logical_drives) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logical_drives_);
  }
  _impl_.logical_drives_ = logical_drives;
  if (logical_drives) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.logical_drives)
}
inline ::proto::system_info::LogicalDrives* SystemInfo::release_logical_drives() {
  
  ::proto::system_info::LogicalDrives* temp = _impl_.logical_drives_;
  _impl_.logical_drives_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::LogicalDrives* SystemInfo::unsafe_arena_release_logical_drives() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.logical_drives)
  
  ::proto::system_info::LogicalDrives* temp = _impl_.logical_drives_;
  _impl_.logical_drives_ = nullptr;
  return temp;
}
inline ::proto::system_info::LogicalDrives* SystemInfo::_internal_mutable_logical_drives() {
  
  if (_impl_.logical_drives_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::LogicalDrives>(GetArenaForAllocation());
    _impl_.logical_drives_ = p;
  }
  return _impl_.logical_drives_;
}
inline ::proto::system_info::LogicalDrives* SystemInfo::mutable_logical_drives() {
  ::proto::system_info::LogicalDrives* _msg = _internal_mutable_logical_drives();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.logical_drives)
  return _msg;
}
inline void SystemInfo::set_allocated_logical_drives(::proto::system_info::LogicalDrives* logical_drives) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logical_drives_;
  }
  if (logical_drives) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logical_drives);
    if (message_arena != submessage_arena) {
      logical_drives = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logical_drives, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.logical_drives_ = logical_drives;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.logical_drives)
}

// .proto.system_info.Printers printers = 8;
inline bool SystemInfo::_internal_has_printers() const {
  return this != internal_default_instance() && _impl_.printers_ != nullptr;
}
inline bool SystemInfo::has_printers() const {
  return _internal_has_printers();
}
inline void SystemInfo::clear_printers() {
  if (GetArenaForAllocation() == nullptr && _impl_.printers_ != nullptr) {
    delete _impl_.printers_;
  }
  _impl_.printers_ = nullptr;
}
inline const ::proto::system_info::Printers& SystemInfo::_internal_printers() const {
  const ::proto::system_info::Printers* p = _impl_.printers_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Printers&>(
      ::proto::system_info::_Printers_default_instance_);
}
inline const ::proto::system_info::Printers& SystemInfo::printers() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.printers)
  return _internal_printers();
}
inline void SystemInfo::unsafe_arena_set_allocated_printers(
    ::proto::system_info::Printers* printers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.printers_);
  }
  _impl_.printers_ = printers;
  if (printers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.printers)
}
inline ::proto::system_info::Printers* SystemInfo::release_printers() {
  
  ::proto::system_info::Printers* temp = _impl_.printers_;
  _impl_.printers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Printers* SystemInfo::unsafe_arena_release_printers() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.printers)
  
  ::proto::system_info::Printers* temp = _impl_.printers_;
  _impl_.printers_ = nullptr;
  return temp;
}
inline ::proto::system_info::Printers* SystemInfo::_internal_mutable_printers() {
  
  if (_impl_.printers_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Printers>(GetArenaForAllocation());
    _impl_.printers_ = p;
  }
  return _impl_.printers_;
}
inline ::proto::system_info::Printers* SystemInfo::mutable_printers() {
  ::proto::system_info::Printers* _msg = _internal_mutable_printers();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.printers)
  return _msg;
}
inline void SystemInfo::set_allocated_printers(::proto::system_info::Printers* printers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.printers_;
  }
  if (printers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(printers);
    if (message_arena != submessage_arena) {
      printers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, printers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.printers_ = printers;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.printers)
}

// .proto.system_info.NetworkAdapters network_adapters = 9;
inline bool SystemInfo::_internal_has_network_adapters() const {
  return this != internal_default_instance() && _impl_.network_adapters_ != nullptr;
}
inline bool SystemInfo::has_network_adapters() const {
  return _internal_has_network_adapters();
}
inline void SystemInfo::clear_network_adapters() {
  if (GetArenaForAllocation() == nullptr && _impl_.network_adapters_ != nullptr) {
    delete _impl_.network_adapters_;
  }
  _impl_.network_adapters_ = nullptr;
}
inline const ::proto::system_info::NetworkAdapters& SystemInfo::_internal_network_adapters() const {
  const ::proto::system_info::NetworkAdapters* p = _impl_.network_adapters_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::NetworkAdapters&>(
      ::proto::system_info::_NetworkAdapters_default_instance_);
}
inline const ::proto::system_info::NetworkAdapters& SystemInfo::network_adapters() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.network_adapters)
  return _internal_network_adapters();
}
inline void SystemInfo::unsafe_arena_set_allocated_network_adapters(
    ::proto::system_info::NetworkAdapters* network_adapters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_adapters_);
  }
  _impl_.network_adapters_ = network_adapters;
  if (network_adapters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.network_adapters)
}
inline ::proto::system_info::NetworkAdapters* SystemInfo::release_network_adapters() {
  
  ::proto::system_info::NetworkAdapters* temp = _impl_.network_adapters_;
  _impl_.network_adapters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::NetworkAdapters* SystemInfo::unsafe_arena_release_network_adapters() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.network_adapters)
  
  ::proto::system_info::NetworkAdapters* temp = _impl_.network_adapters_;
  _impl_.network_adapters_ = nullptr;
  return temp;
}
inline ::proto::system_info::NetworkAdapters* SystemInfo::_internal_mutable_network_adapters() {
  
  if (_impl_.network_adapters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::NetworkAdapters>(GetArenaForAllocation());
    _impl_.network_adapters_ = p;
  }
  return _impl_.network_adapters_;
}
inline ::proto::system_info::NetworkAdapters* SystemInfo::mutable_network_adapters() {
  ::proto::system_info::NetworkAdapters* _msg = _internal_mutable_network_adapters();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.network_adapters)
  return _msg;
}
inline void SystemInfo::set_allocated_network_adapters(::proto::system_info::NetworkAdapters* network_adapters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.network_adapters_;
  }
  if (network_adapters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_adapters);
    if (message_arena != submessage_arena) {
      network_adapters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_adapters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.network_adapters_ = network_adapters;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.network_adapters)
}

// .proto.system_info.NetworkShares network_shares = 10;
inline bool SystemInfo::_internal_has_network_shares() const {
  return this != internal_default_instance() && _impl_.network_shares_ != nullptr;
}
inline bool SystemInfo::has_network_shares() const {
  return _internal_has_network_shares();
}
inline void SystemInfo::clear_network_shares() {
  if (GetArenaForAllocation() == nullptr && _impl_.network_shares_ != nullptr) {
    delete _impl_.network_shares_;
  }
  _impl_.network_shares_ = nullptr;
}
inline const ::proto::system_info::NetworkShares& SystemInfo::_internal_network_shares() const {
  const ::proto::system_info::NetworkShares* p = _impl_.network_shares_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::NetworkShares&>(
      ::proto::system_info::_NetworkShares_default_instance_);
}
inline const ::proto::system_info::NetworkShares& SystemInfo::network_shares() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.network_shares)
  return _internal_network_shares();
}
inline void SystemInfo::unsafe_arena_set_allocated_network_shares(
    ::proto::system_info::NetworkShares* network_shares) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_shares_);
  }
  _impl_.network_shares_ = network_shares;
  if (network_shares) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.network_shares)
}
inline ::proto::system_info::NetworkShares* SystemInfo::release_network_shares() {
  
  ::proto::system_info::NetworkShares* temp = _impl_.network_shares_;
  _impl_.network_shares_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::NetworkShares* SystemInfo::unsafe_arena_release_network_shares() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.network_shares)
  
  ::proto::system_info::NetworkShares* temp = _impl_.network_shares_;
  _impl_.network_shares_ = nullptr;
  return temp;
}
inline ::proto::system_info::NetworkShares* SystemInfo::_internal_mutable_network_shares() {
  
  if (_impl_.network_shares_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::NetworkShares>(GetArenaForAllocation());
    _impl_.network_shares_ = p;
  }
  return _impl_.network_shares_;
}
inline ::proto::system_info::NetworkShares* SystemInfo::mutable_network_shares() {
  ::proto::system_info::NetworkShares* _msg = _internal_mutable_network_shares();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.network_shares)
  return _msg;
}
inline void SystemInfo::set_allocated_network_shares(::proto::system_info::NetworkShares* network_shares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.network_shares_;
  }
  if (network_shares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_shares);
    if (message_arena != submessage_arena) {
      network_shares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_shares, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.network_shares_ = network_shares;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.network_shares)
}

// .proto.system_info.WindowsDevices windows_devices = 11;
inline bool SystemInfo::_internal_has_windows_devices() const {
  return this != internal_default_instance() && _impl_.windows_devices_ != nullptr;
}
inline bool SystemInfo::has_windows_devices() const {
  return _internal_has_windows_devices();
}
inline void SystemInfo::clear_windows_devices() {
  if (GetArenaForAllocation() == nullptr && _impl_.windows_devices_ != nullptr) {
    delete _impl_.windows_devices_;
  }
  _impl_.windows_devices_ = nullptr;
}
inline const ::proto::system_info::WindowsDevices& SystemInfo::_internal_windows_devices() const {
  const ::proto::system_info::WindowsDevices* p = _impl_.windows_devices_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::WindowsDevices&>(
      ::proto::system_info::_WindowsDevices_default_instance_);
}
inline const ::proto::system_info::WindowsDevices& SystemInfo::windows_devices() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.windows_devices)
  return _internal_windows_devices();
}
inline void SystemInfo::unsafe_arena_set_allocated_windows_devices(
    ::proto::system_info::WindowsDevices* windows_devices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.windows_devices_);
  }
  _impl_.windows_devices_ = windows_devices;
  if (windows_devices) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.windows_devices)
}
inline ::proto::system_info::WindowsDevices* SystemInfo::release_windows_devices() {
  
  ::proto::system_info::WindowsDevices* temp = _impl_.windows_devices_;
  _impl_.windows_devices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::WindowsDevices* SystemInfo::unsafe_arena_release_windows_devices() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.windows_devices)
  
  ::proto::system_info::WindowsDevices* temp = _impl_.windows_devices_;
  _impl_.windows_devices_ = nullptr;
  return temp;
}
inline ::proto::system_info::WindowsDevices* SystemInfo::_internal_mutable_windows_devices() {
  
  if (_impl_.windows_devices_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::WindowsDevices>(GetArenaForAllocation());
    _impl_.windows_devices_ = p;
  }
  return _impl_.windows_devices_;
}
inline ::proto::system_info::WindowsDevices* SystemInfo::mutable_windows_devices() {
  ::proto::system_info::WindowsDevices* _msg = _internal_mutable_windows_devices();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.windows_devices)
  return _msg;
}
inline void SystemInfo::set_allocated_windows_devices(::proto::system_info::WindowsDevices* windows_devices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.windows_devices_;
  }
  if (windows_devices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(windows_devices);
    if (message_arena != submessage_arena) {
      windows_devices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, windows_devices, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.windows_devices_ = windows_devices;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.windows_devices)
}

// .proto.system_info.VideoAdapters video_adapters = 12;
inline bool SystemInfo::_internal_has_video_adapters() const {
  return this != internal_default_instance() && _impl_.video_adapters_ != nullptr;
}
inline bool SystemInfo::has_video_adapters() const {
  return _internal_has_video_adapters();
}
inline void SystemInfo::clear_video_adapters() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_adapters_ != nullptr) {
    delete _impl_.video_adapters_;
  }
  _impl_.video_adapters_ = nullptr;
}
inline const ::proto::system_info::VideoAdapters& SystemInfo::_internal_video_adapters() const {
  const ::proto::system_info::VideoAdapters* p = _impl_.video_adapters_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::VideoAdapters&>(
      ::proto::system_info::_VideoAdapters_default_instance_);
}
inline const ::proto::system_info::VideoAdapters& SystemInfo::video_adapters() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.video_adapters)
  return _internal_video_adapters();
}
inline void SystemInfo::unsafe_arena_set_allocated_video_adapters(
    ::proto::system_info::VideoAdapters* video_adapters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_adapters_);
  }
  _impl_.video_adapters_ = video_adapters;
  if (video_adapters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.video_adapters)
}
inline ::proto::system_info::VideoAdapters* SystemInfo::release_video_adapters() {
  
  ::proto::system_info::VideoAdapters* temp = _impl_.video_adapters_;
  _impl_.video_adapters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::VideoAdapters* SystemInfo::unsafe_arena_release_video_adapters() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.video_adapters)
  
  ::proto::system_info::VideoAdapters* temp = _impl_.video_adapters_;
  _impl_.video_adapters_ = nullptr;
  return temp;
}
inline ::proto::system_info::VideoAdapters* SystemInfo::_internal_mutable_video_adapters() {
  
  if (_impl_.video_adapters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::VideoAdapters>(GetArenaForAllocation());
    _impl_.video_adapters_ = p;
  }
  return _impl_.video_adapters_;
}
inline ::proto::system_info::VideoAdapters* SystemInfo::mutable_video_adapters() {
  ::proto::system_info::VideoAdapters* _msg = _internal_mutable_video_adapters();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.video_adapters)
  return _msg;
}
inline void SystemInfo::set_allocated_video_adapters(::proto::system_info::VideoAdapters* video_adapters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_adapters_;
  }
  if (video_adapters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_adapters);
    if (message_arena != submessage_arena) {
      video_adapters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_adapters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_adapters_ = video_adapters;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.video_adapters)
}

// .proto.system_info.Monitors monitors = 13;
inline bool SystemInfo::_internal_has_monitors() const {
  return this != internal_default_instance() && _impl_.monitors_ != nullptr;
}
inline bool SystemInfo::has_monitors() const {
  return _internal_has_monitors();
}
inline void SystemInfo::clear_monitors() {
  if (GetArenaForAllocation() == nullptr && _impl_.monitors_ != nullptr) {
    delete _impl_.monitors_;
  }
  _impl_.monitors_ = nullptr;
}
inline const ::proto::system_info::Monitors& SystemInfo::_internal_monitors() const {
  const ::proto::system_info::Monitors* p = _impl_.monitors_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Monitors&>(
      ::proto::system_info::_Monitors_default_instance_);
}
inline const ::proto::system_info::Monitors& SystemInfo::monitors() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.monitors)
  return _internal_monitors();
}
inline void SystemInfo::unsafe_arena_set_allocated_monitors(
    ::proto::system_info::Monitors* monitors) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.monitors_);
  }
  _impl_.monitors_ = monitors;
  if (monitors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.monitors)
}
inline ::proto::system_info::Monitors* SystemInfo::release_monitors() {
  
  ::proto::system_info::Monitors* temp = _impl_.monitors_;
  _impl_.monitors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Monitors* SystemInfo::unsafe_arena_release_monitors() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.monitors)
  
  ::proto::system_info::Monitors* temp = _impl_.monitors_;
  _impl_.monitors_ = nullptr;
  return temp;
}
inline ::proto::system_info::Monitors* SystemInfo::_internal_mutable_monitors() {
  
  if (_impl_.monitors_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Monitors>(GetArenaForAllocation());
    _impl_.monitors_ = p;
  }
  return _impl_.monitors_;
}
inline ::proto::system_info::Monitors* SystemInfo::mutable_monitors() {
  ::proto::system_info::Monitors* _msg = _internal_mutable_monitors();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.monitors)
  return _msg;
}
inline void SystemInfo::set_allocated_monitors(::proto::system_info::Monitors* monitors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.monitors_;
  }
  if (monitors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monitors);
    if (message_arena != submessage_arena) {
      monitors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monitors, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.monitors_ = monitors;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.monitors)
}

// .proto.system_info.PowerOptions power_options = 14;
inline bool SystemInfo::_internal_has_power_options() const {
  return this != internal_default_instance() && _impl_.power_options_ != nullptr;
}
inline bool SystemInfo::has_power_options() const {
  return _internal_has_power_options();
}
inline void SystemInfo::clear_power_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.power_options_ != nullptr) {
    delete _impl_.power_options_;
  }
  _impl_.power_options_ = nullptr;
}
inline const ::proto::system_info::PowerOptions& SystemInfo::_internal_power_options() const {
  const ::proto::system_info::PowerOptions* p = _impl_.power_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::PowerOptions&>(
      ::proto::system_info::_PowerOptions_default_instance_);
}
inline const ::proto::system_info::PowerOptions& SystemInfo::power_options() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.power_options)
  return _internal_power_options();
}
inline void SystemInfo::unsafe_arena_set_allocated_power_options(
    ::proto::system_info::PowerOptions* power_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_options_);
  }
  _impl_.power_options_ = power_options;
  if (power_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.power_options)
}
inline ::proto::system_info::PowerOptions* SystemInfo::release_power_options() {
  
  ::proto::system_info::PowerOptions* temp = _impl_.power_options_;
  _impl_.power_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::PowerOptions* SystemInfo::unsafe_arena_release_power_options() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.power_options)
  
  ::proto::system_info::PowerOptions* temp = _impl_.power_options_;
  _impl_.power_options_ = nullptr;
  return temp;
}
inline ::proto::system_info::PowerOptions* SystemInfo::_internal_mutable_power_options() {
  
  if (_impl_.power_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::PowerOptions>(GetArenaForAllocation());
    _impl_.power_options_ = p;
  }
  return _impl_.power_options_;
}
inline ::proto::system_info::PowerOptions* SystemInfo::mutable_power_options() {
  ::proto::system_info::PowerOptions* _msg = _internal_mutable_power_options();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.power_options)
  return _msg;
}
inline void SystemInfo::set_allocated_power_options(::proto::system_info::PowerOptions* power_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.power_options_;
  }
  if (power_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(power_options);
    if (message_arena != submessage_arena) {
      power_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.power_options_ = power_options;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.power_options)
}

// .proto.system_info.Drivers drivers = 15;
inline bool SystemInfo::_internal_has_drivers() const {
  return this != internal_default_instance() && _impl_.drivers_ != nullptr;
}
inline bool SystemInfo::has_drivers() const {
  return _internal_has_drivers();
}
inline void SystemInfo::clear_drivers() {
  if (GetArenaForAllocation() == nullptr && _impl_.drivers_ != nullptr) {
    delete _impl_.drivers_;
  }
  _impl_.drivers_ = nullptr;
}
inline const ::proto::system_info::Drivers& SystemInfo::_internal_drivers() const {
  const ::proto::system_info::Drivers* p = _impl_.drivers_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Drivers&>(
      ::proto::system_info::_Drivers_default_instance_);
}
inline const ::proto::system_info::Drivers& SystemInfo::drivers() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.drivers)
  return _internal_drivers();
}
inline void SystemInfo::unsafe_arena_set_allocated_drivers(
    ::proto::system_info::Drivers* drivers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drivers_);
  }
  _impl_.drivers_ = drivers;
  if (drivers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.drivers)
}
inline ::proto::system_info::Drivers* SystemInfo::release_drivers() {
  
  ::proto::system_info::Drivers* temp = _impl_.drivers_;
  _impl_.drivers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Drivers* SystemInfo::unsafe_arena_release_drivers() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.drivers)
  
  ::proto::system_info::Drivers* temp = _impl_.drivers_;
  _impl_.drivers_ = nullptr;
  return temp;
}
inline ::proto::system_info::Drivers* SystemInfo::_internal_mutable_drivers() {
  
  if (_impl_.drivers_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Drivers>(GetArenaForAllocation());
    _impl_.drivers_ = p;
  }
  return _impl_.drivers_;
}
inline ::proto::system_info::Drivers* SystemInfo::mutable_drivers() {
  ::proto::system_info::Drivers* _msg = _internal_mutable_drivers();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.drivers)
  return _msg;
}
inline void SystemInfo::set_allocated_drivers(::proto::system_info::Drivers* drivers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.drivers_;
  }
  if (drivers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drivers);
    if (message_arena != submessage_arena) {
      drivers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drivers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.drivers_ = drivers;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.drivers)
}

// .proto.system_info.Services services = 16;
inline bool SystemInfo::_internal_has_services() const {
  return this != internal_default_instance() && _impl_.services_ != nullptr;
}
inline bool SystemInfo::has_services() const {
  return _internal_has_services();
}
inline void SystemInfo::clear_services() {
  if (GetArenaForAllocation() == nullptr && _impl_.services_ != nullptr) {
    delete _impl_.services_;
  }
  _impl_.services_ = nullptr;
}
inline const ::proto::system_info::Services& SystemInfo::_internal_services() const {
  const ::proto::system_info::Services* p = _impl_.services_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Services&>(
      ::proto::system_info::_Services_default_instance_);
}
inline const ::proto::system_info::Services& SystemInfo::services() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.services)
  return _internal_services();
}
inline void SystemInfo::unsafe_arena_set_allocated_services(
    ::proto::system_info::Services* services) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.services_);
  }
  _impl_.services_ = services;
  if (services) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.services)
}
inline ::proto::system_info::Services* SystemInfo::release_services() {
  
  ::proto::system_info::Services* temp = _impl_.services_;
  _impl_.services_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Services* SystemInfo::unsafe_arena_release_services() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.services)
  
  ::proto::system_info::Services* temp = _impl_.services_;
  _impl_.services_ = nullptr;
  return temp;
}
inline ::proto::system_info::Services* SystemInfo::_internal_mutable_services() {
  
  if (_impl_.services_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Services>(GetArenaForAllocation());
    _impl_.services_ = p;
  }
  return _impl_.services_;
}
inline ::proto::system_info::Services* SystemInfo::mutable_services() {
  ::proto::system_info::Services* _msg = _internal_mutable_services();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.services)
  return _msg;
}
inline void SystemInfo::set_allocated_services(::proto::system_info::Services* services) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.services_;
  }
  if (services) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(services);
    if (message_arena != submessage_arena) {
      services = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, services, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.services_ = services;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.services)
}

// .proto.system_info.EnvironmentVariables env_vars = 17;
inline bool SystemInfo::_internal_has_env_vars() const {
  return this != internal_default_instance() && _impl_.env_vars_ != nullptr;
}
inline bool SystemInfo::has_env_vars() const {
  return _internal_has_env_vars();
}
inline void SystemInfo::clear_env_vars() {
  if (GetArenaForAllocation() == nullptr && _impl_.env_vars_ != nullptr) {
    delete _impl_.env_vars_;
  }
  _impl_.env_vars_ = nullptr;
}
inline const ::proto::system_info::EnvironmentVariables& SystemInfo::_internal_env_vars() const {
  const ::proto::system_info::EnvironmentVariables* p = _impl_.env_vars_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::EnvironmentVariables&>(
      ::proto::system_info::_EnvironmentVariables_default_instance_);
}
inline const ::proto::system_info::EnvironmentVariables& SystemInfo::env_vars() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.env_vars)
  return _internal_env_vars();
}
inline void SystemInfo::unsafe_arena_set_allocated_env_vars(
    ::proto::system_info::EnvironmentVariables* env_vars) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.env_vars_);
  }
  _impl_.env_vars_ = env_vars;
  if (env_vars) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.env_vars)
}
inline ::proto::system_info::EnvironmentVariables* SystemInfo::release_env_vars() {
  
  ::proto::system_info::EnvironmentVariables* temp = _impl_.env_vars_;
  _impl_.env_vars_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::EnvironmentVariables* SystemInfo::unsafe_arena_release_env_vars() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.env_vars)
  
  ::proto::system_info::EnvironmentVariables* temp = _impl_.env_vars_;
  _impl_.env_vars_ = nullptr;
  return temp;
}
inline ::proto::system_info::EnvironmentVariables* SystemInfo::_internal_mutable_env_vars() {
  
  if (_impl_.env_vars_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::EnvironmentVariables>(GetArenaForAllocation());
    _impl_.env_vars_ = p;
  }
  return _impl_.env_vars_;
}
inline ::proto::system_info::EnvironmentVariables* SystemInfo::mutable_env_vars() {
  ::proto::system_info::EnvironmentVariables* _msg = _internal_mutable_env_vars();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.env_vars)
  return _msg;
}
inline void SystemInfo::set_allocated_env_vars(::proto::system_info::EnvironmentVariables* env_vars) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.env_vars_;
  }
  if (env_vars) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(env_vars);
    if (message_arena != submessage_arena) {
      env_vars = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, env_vars, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.env_vars_ = env_vars;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.env_vars)
}

// .proto.system_info.EventLogs event_logs = 18;
inline bool SystemInfo::_internal_has_event_logs() const {
  return this != internal_default_instance() && _impl_.event_logs_ != nullptr;
}
inline bool SystemInfo::has_event_logs() const {
  return _internal_has_event_logs();
}
inline void SystemInfo::clear_event_logs() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_logs_ != nullptr) {
    delete _impl_.event_logs_;
  }
  _impl_.event_logs_ = nullptr;
}
inline const ::proto::system_info::EventLogs& SystemInfo::_internal_event_logs() const {
  const ::proto::system_info::EventLogs* p = _impl_.event_logs_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::EventLogs&>(
      ::proto::system_info::_EventLogs_default_instance_);
}
inline const ::proto::system_info::EventLogs& SystemInfo::event_logs() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.event_logs)
  return _internal_event_logs();
}
inline void SystemInfo::unsafe_arena_set_allocated_event_logs(
    ::proto::system_info::EventLogs* event_logs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_logs_);
  }
  _impl_.event_logs_ = event_logs;
  if (event_logs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.event_logs)
}
inline ::proto::system_info::EventLogs* SystemInfo::release_event_logs() {
  
  ::proto::system_info::EventLogs* temp = _impl_.event_logs_;
  _impl_.event_logs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::EventLogs* SystemInfo::unsafe_arena_release_event_logs() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.event_logs)
  
  ::proto::system_info::EventLogs* temp = _impl_.event_logs_;
  _impl_.event_logs_ = nullptr;
  return temp;
}
inline ::proto::system_info::EventLogs* SystemInfo::_internal_mutable_event_logs() {
  
  if (_impl_.event_logs_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::EventLogs>(GetArenaForAllocation());
    _impl_.event_logs_ = p;
  }
  return _impl_.event_logs_;
}
inline ::proto::system_info::EventLogs* SystemInfo::mutable_event_logs() {
  ::proto::system_info::EventLogs* _msg = _internal_mutable_event_logs();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.event_logs)
  return _msg;
}
inline void SystemInfo::set_allocated_event_logs(::proto::system_info::EventLogs* event_logs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_logs_;
  }
  if (event_logs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event_logs);
    if (message_arena != submessage_arena) {
      event_logs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_logs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_logs_ = event_logs;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.event_logs)
}

// .proto.system_info.Routes routes = 19;
inline bool SystemInfo::_internal_has_routes() const {
  return this != internal_default_instance() && _impl_.routes_ != nullptr;
}
inline bool SystemInfo::has_routes() const {
  return _internal_has_routes();
}
inline void SystemInfo::clear_routes() {
  if (GetArenaForAllocation() == nullptr && _impl_.routes_ != nullptr) {
    delete _impl_.routes_;
  }
  _impl_.routes_ = nullptr;
}
inline const ::proto::system_info::Routes& SystemInfo::_internal_routes() const {
  const ::proto::system_info::Routes* p = _impl_.routes_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Routes&>(
      ::proto::system_info::_Routes_default_instance_);
}
inline const ::proto::system_info::Routes& SystemInfo::routes() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.routes)
  return _internal_routes();
}
inline void SystemInfo::unsafe_arena_set_allocated_routes(
    ::proto::system_info::Routes* routes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routes_);
  }
  _impl_.routes_ = routes;
  if (routes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.routes)
}
inline ::proto::system_info::Routes* SystemInfo::release_routes() {
  
  ::proto::system_info::Routes* temp = _impl_.routes_;
  _impl_.routes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Routes* SystemInfo::unsafe_arena_release_routes() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.routes)
  
  ::proto::system_info::Routes* temp = _impl_.routes_;
  _impl_.routes_ = nullptr;
  return temp;
}
inline ::proto::system_info::Routes* SystemInfo::_internal_mutable_routes() {
  
  if (_impl_.routes_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Routes>(GetArenaForAllocation());
    _impl_.routes_ = p;
  }
  return _impl_.routes_;
}
inline ::proto::system_info::Routes* SystemInfo::mutable_routes() {
  ::proto::system_info::Routes* _msg = _internal_mutable_routes();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.routes)
  return _msg;
}
inline void SystemInfo::set_allocated_routes(::proto::system_info::Routes* routes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.routes_;
  }
  if (routes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routes);
    if (message_arena != submessage_arena) {
      routes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.routes_ = routes;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.routes)
}

// .proto.system_info.Connections connections = 20;
inline bool SystemInfo::_internal_has_connections() const {
  return this != internal_default_instance() && _impl_.connections_ != nullptr;
}
inline bool SystemInfo::has_connections() const {
  return _internal_has_connections();
}
inline void SystemInfo::clear_connections() {
  if (GetArenaForAllocation() == nullptr && _impl_.connections_ != nullptr) {
    delete _impl_.connections_;
  }
  _impl_.connections_ = nullptr;
}
inline const ::proto::system_info::Connections& SystemInfo::_internal_connections() const {
  const ::proto::system_info::Connections* p = _impl_.connections_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Connections&>(
      ::proto::system_info::_Connections_default_instance_);
}
inline const ::proto::system_info::Connections& SystemInfo::connections() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.connections)
  return _internal_connections();
}
inline void SystemInfo::unsafe_arena_set_allocated_connections(
    ::proto::system_info::Connections* connections) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connections_);
  }
  _impl_.connections_ = connections;
  if (connections) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.connections)
}
inline ::proto::system_info::Connections* SystemInfo::release_connections() {
  
  ::proto::system_info::Connections* temp = _impl_.connections_;
  _impl_.connections_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Connections* SystemInfo::unsafe_arena_release_connections() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.connections)
  
  ::proto::system_info::Connections* temp = _impl_.connections_;
  _impl_.connections_ = nullptr;
  return temp;
}
inline ::proto::system_info::Connections* SystemInfo::_internal_mutable_connections() {
  
  if (_impl_.connections_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Connections>(GetArenaForAllocation());
    _impl_.connections_ = p;
  }
  return _impl_.connections_;
}
inline ::proto::system_info::Connections* SystemInfo::mutable_connections() {
  ::proto::system_info::Connections* _msg = _internal_mutable_connections();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.connections)
  return _msg;
}
inline void SystemInfo::set_allocated_connections(::proto::system_info::Connections* connections) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connections_;
  }
  if (connections) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connections);
    if (message_arena != submessage_arena) {
      connections = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connections, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.connections_ = connections;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.connections)
}

// .proto.system_info.Licenses licenses = 21;
inline bool SystemInfo::_internal_has_licenses() const {
  return this != internal_default_instance() && _impl_.licenses_ != nullptr;
}
inline bool SystemInfo::has_licenses() const {
  return _internal_has_licenses();
}
inline void SystemInfo::clear_licenses() {
  if (GetArenaForAllocation() == nullptr && _impl_.licenses_ != nullptr) {
    delete _impl_.licenses_;
  }
  _impl_.licenses_ = nullptr;
}
inline const ::proto::system_info::Licenses& SystemInfo::_internal_licenses() const {
  const ::proto::system_info::Licenses* p = _impl_.licenses_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Licenses&>(
      ::proto::system_info::_Licenses_default_instance_);
}
inline const ::proto::system_info::Licenses& SystemInfo::licenses() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.licenses)
  return _internal_licenses();
}
inline void SystemInfo::unsafe_arena_set_allocated_licenses(
    ::proto::system_info::Licenses* licenses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.licenses_);
  }
  _impl_.licenses_ = licenses;
  if (licenses) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.licenses)
}
inline ::proto::system_info::Licenses* SystemInfo::release_licenses() {
  
  ::proto::system_info::Licenses* temp = _impl_.licenses_;
  _impl_.licenses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Licenses* SystemInfo::unsafe_arena_release_licenses() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.licenses)
  
  ::proto::system_info::Licenses* temp = _impl_.licenses_;
  _impl_.licenses_ = nullptr;
  return temp;
}
inline ::proto::system_info::Licenses* SystemInfo::_internal_mutable_licenses() {
  
  if (_impl_.licenses_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Licenses>(GetArenaForAllocation());
    _impl_.licenses_ = p;
  }
  return _impl_.licenses_;
}
inline ::proto::system_info::Licenses* SystemInfo::mutable_licenses() {
  ::proto::system_info::Licenses* _msg = _internal_mutable_licenses();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.licenses)
  return _msg;
}
inline void SystemInfo::set_allocated_licenses(::proto::system_info::Licenses* licenses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.licenses_;
  }
  if (licenses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(licenses);
    if (message_arena != submessage_arena) {
      licenses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, licenses, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.licenses_ = licenses;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.licenses)
}

// .proto.system_info.Applications applications = 22;
inline bool SystemInfo::_internal_has_applications() const {
  return this != internal_default_instance() && _impl_.applications_ != nullptr;
}
inline bool SystemInfo::has_applications() const {
  return _internal_has_applications();
}
inline void SystemInfo::clear_applications() {
  if (GetArenaForAllocation() == nullptr && _impl_.applications_ != nullptr) {
    delete _impl_.applications_;
  }
  _impl_.applications_ = nullptr;
}
inline const ::proto::system_info::Applications& SystemInfo::_internal_applications() const {
  const ::proto::system_info::Applications* p = _impl_.applications_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Applications&>(
      ::proto::system_info::_Applications_default_instance_);
}
inline const ::proto::system_info::Applications& SystemInfo::applications() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.applications)
  return _internal_applications();
}
inline void SystemInfo::unsafe_arena_set_allocated_applications(
    ::proto::system_info::Applications* applications) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applications_);
  }
  _impl_.applications_ = applications;
  if (applications) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.applications)
}
inline ::proto::system_info::Applications* SystemInfo::release_applications() {
  
  ::proto::system_info::Applications* temp = _impl_.applications_;
  _impl_.applications_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Applications* SystemInfo::unsafe_arena_release_applications() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.applications)
  
  ::proto::system_info::Applications* temp = _impl_.applications_;
  _impl_.applications_ = nullptr;
  return temp;
}
inline ::proto::system_info::Applications* SystemInfo::_internal_mutable_applications() {
  
  if (_impl_.applications_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Applications>(GetArenaForAllocation());
    _impl_.applications_ = p;
  }
  return _impl_.applications_;
}
inline ::proto::system_info::Applications* SystemInfo::mutable_applications() {
  ::proto::system_info::Applications* _msg = _internal_mutable_applications();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.applications)
  return _msg;
}
inline void SystemInfo::set_allocated_applications(::proto::system_info::Applications* applications) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.applications_;
  }
  if (applications) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(applications);
    if (message_arena != submessage_arena) {
      applications = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applications, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.applications_ = applications;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.applications)
}

// .proto.system_info.OpenFiles open_files = 23;
inline bool SystemInfo::_internal_has_open_files() const {
  return this != internal_default_instance() && _impl_.open_files_ != nullptr;
}
inline bool SystemInfo::has_open_files() const {
  return _internal_has_open_files();
}
inline void SystemInfo::clear_open_files() {
  if (GetArenaForAllocation() == nullptr && _impl_.open_files_ != nullptr) {
    delete _impl_.open_files_;
  }
  _impl_.open_files_ = nullptr;
}
inline const ::proto::system_info::OpenFiles& SystemInfo::_internal_open_files() const {
  const ::proto::system_info::OpenFiles* p = _impl_.open_files_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::OpenFiles&>(
      ::proto::system_info::_OpenFiles_default_instance_);
}
inline const ::proto::system_info::OpenFiles& SystemInfo::open_files() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.open_files)
  return _internal_open_files();
}
inline void SystemInfo::unsafe_arena_set_allocated_open_files(
    ::proto::system_info::OpenFiles* open_files) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.open_files_);
  }
  _impl_.open_files_ = open_files;
  if (open_files) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.open_files)
}
inline ::proto::system_info::OpenFiles* SystemInfo::release_open_files() {
  
  ::proto::system_info::OpenFiles* temp = _impl_.open_files_;
  _impl_.open_files_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::OpenFiles* SystemInfo::unsafe_arena_release_open_files() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.open_files)
  
  ::proto::system_info::OpenFiles* temp = _impl_.open_files_;
  _impl_.open_files_ = nullptr;
  return temp;
}
inline ::proto::system_info::OpenFiles* SystemInfo::_internal_mutable_open_files() {
  
  if (_impl_.open_files_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::OpenFiles>(GetArenaForAllocation());
    _impl_.open_files_ = p;
  }
  return _impl_.open_files_;
}
inline ::proto::system_info::OpenFiles* SystemInfo::mutable_open_files() {
  ::proto::system_info::OpenFiles* _msg = _internal_mutable_open_files();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.open_files)
  return _msg;
}
inline void SystemInfo::set_allocated_open_files(::proto::system_info::OpenFiles* open_files) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.open_files_;
  }
  if (open_files) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(open_files);
    if (message_arena != submessage_arena) {
      open_files = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open_files, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.open_files_ = open_files;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.open_files)
}

// .proto.system_info.LocalUsers local_users = 24;
inline bool SystemInfo::_internal_has_local_users() const {
  return this != internal_default_instance() && _impl_.local_users_ != nullptr;
}
inline bool SystemInfo::has_local_users() const {
  return _internal_has_local_users();
}
inline void SystemInfo::clear_local_users() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_users_ != nullptr) {
    delete _impl_.local_users_;
  }
  _impl_.local_users_ = nullptr;
}
inline const ::proto::system_info::LocalUsers& SystemInfo::_internal_local_users() const {
  const ::proto::system_info::LocalUsers* p = _impl_.local_users_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::LocalUsers&>(
      ::proto::system_info::_LocalUsers_default_instance_);
}
inline const ::proto::system_info::LocalUsers& SystemInfo::local_users() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.local_users)
  return _internal_local_users();
}
inline void SystemInfo::unsafe_arena_set_allocated_local_users(
    ::proto::system_info::LocalUsers* local_users) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_users_);
  }
  _impl_.local_users_ = local_users;
  if (local_users) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.local_users)
}
inline ::proto::system_info::LocalUsers* SystemInfo::release_local_users() {
  
  ::proto::system_info::LocalUsers* temp = _impl_.local_users_;
  _impl_.local_users_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::LocalUsers* SystemInfo::unsafe_arena_release_local_users() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.local_users)
  
  ::proto::system_info::LocalUsers* temp = _impl_.local_users_;
  _impl_.local_users_ = nullptr;
  return temp;
}
inline ::proto::system_info::LocalUsers* SystemInfo::_internal_mutable_local_users() {
  
  if (_impl_.local_users_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::LocalUsers>(GetArenaForAllocation());
    _impl_.local_users_ = p;
  }
  return _impl_.local_users_;
}
inline ::proto::system_info::LocalUsers* SystemInfo::mutable_local_users() {
  ::proto::system_info::LocalUsers* _msg = _internal_mutable_local_users();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.local_users)
  return _msg;
}
inline void SystemInfo::set_allocated_local_users(::proto::system_info::LocalUsers* local_users) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_users_;
  }
  if (local_users) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_users);
    if (message_arena != submessage_arena) {
      local_users = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_users, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_users_ = local_users;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.local_users)
}

// .proto.system_info.LocalUserGroups local_user_groups = 25;
inline bool SystemInfo::_internal_has_local_user_groups() const {
  return this != internal_default_instance() && _impl_.local_user_groups_ != nullptr;
}
inline bool SystemInfo::has_local_user_groups() const {
  return _internal_has_local_user_groups();
}
inline void SystemInfo::clear_local_user_groups() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_user_groups_ != nullptr) {
    delete _impl_.local_user_groups_;
  }
  _impl_.local_user_groups_ = nullptr;
}
inline const ::proto::system_info::LocalUserGroups& SystemInfo::_internal_local_user_groups() const {
  const ::proto::system_info::LocalUserGroups* p = _impl_.local_user_groups_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::LocalUserGroups&>(
      ::proto::system_info::_LocalUserGroups_default_instance_);
}
inline const ::proto::system_info::LocalUserGroups& SystemInfo::local_user_groups() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.local_user_groups)
  return _internal_local_user_groups();
}
inline void SystemInfo::unsafe_arena_set_allocated_local_user_groups(
    ::proto::system_info::LocalUserGroups* local_user_groups) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_user_groups_);
  }
  _impl_.local_user_groups_ = local_user_groups;
  if (local_user_groups) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.local_user_groups)
}
inline ::proto::system_info::LocalUserGroups* SystemInfo::release_local_user_groups() {
  
  ::proto::system_info::LocalUserGroups* temp = _impl_.local_user_groups_;
  _impl_.local_user_groups_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::LocalUserGroups* SystemInfo::unsafe_arena_release_local_user_groups() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.local_user_groups)
  
  ::proto::system_info::LocalUserGroups* temp = _impl_.local_user_groups_;
  _impl_.local_user_groups_ = nullptr;
  return temp;
}
inline ::proto::system_info::LocalUserGroups* SystemInfo::_internal_mutable_local_user_groups() {
  
  if (_impl_.local_user_groups_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::LocalUserGroups>(GetArenaForAllocation());
    _impl_.local_user_groups_ = p;
  }
  return _impl_.local_user_groups_;
}
inline ::proto::system_info::LocalUserGroups* SystemInfo::mutable_local_user_groups() {
  ::proto::system_info::LocalUserGroups* _msg = _internal_mutable_local_user_groups();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.local_user_groups)
  return _msg;
}
inline void SystemInfo::set_allocated_local_user_groups(::proto::system_info::LocalUserGroups* local_user_groups) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_user_groups_;
  }
  if (local_user_groups) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_user_groups);
    if (message_arena != submessage_arena) {
      local_user_groups = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_user_groups, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_user_groups_ = local_user_groups;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.local_user_groups)
}

// .proto.system_info.Processes processes = 26;
inline bool SystemInfo::_internal_has_processes() const {
  return this != internal_default_instance() && _impl_.processes_ != nullptr;
}
inline bool SystemInfo::has_processes() const {
  return _internal_has_processes();
}
inline void SystemInfo::clear_processes() {
  if (GetArenaForAllocation() == nullptr && _impl_.processes_ != nullptr) {
    delete _impl_.processes_;
  }
  _impl_.processes_ = nullptr;
}
inline const ::proto::system_info::Processes& SystemInfo::_internal_processes() const {
  const ::proto::system_info::Processes* p = _impl_.processes_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::Processes&>(
      ::proto::system_info::_Processes_default_instance_);
}
inline const ::proto::system_info::Processes& SystemInfo::processes() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.processes)
  return _internal_processes();
}
inline void SystemInfo::unsafe_arena_set_allocated_processes(
    ::proto::system_info::Processes* processes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processes_);
  }
  _impl_.processes_ = processes;
  if (processes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.processes)
}
inline ::proto::system_info::Processes* SystemInfo::release_processes() {
  
  ::proto::system_info::Processes* temp = _impl_.processes_;
  _impl_.processes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::Processes* SystemInfo::unsafe_arena_release_processes() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.processes)
  
  ::proto::system_info::Processes* temp = _impl_.processes_;
  _impl_.processes_ = nullptr;
  return temp;
}
inline ::proto::system_info::Processes* SystemInfo::_internal_mutable_processes() {
  
  if (_impl_.processes_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::Processes>(GetArenaForAllocation());
    _impl_.processes_ = p;
  }
  return _impl_.processes_;
}
inline ::proto::system_info::Processes* SystemInfo::mutable_processes() {
  ::proto::system_info::Processes* _msg = _internal_mutable_processes();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.processes)
  return _msg;
}
inline void SystemInfo::set_allocated_processes(::proto::system_info::Processes* processes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.processes_;
  }
  if (processes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(processes);
    if (message_arena != submessage_arena) {
      processes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processes_ = processes;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.processes)
}

// .proto.system_info.SystemInfoFooter footer = 128000;
inline bool SystemInfo::_internal_has_footer() const {
  return this != internal_default_instance() && _impl_.footer_ != nullptr;
}
inline bool SystemInfo::has_footer() const {
  return _internal_has_footer();
}
inline void SystemInfo::clear_footer() {
  if (GetArenaForAllocation() == nullptr && _impl_.footer_ != nullptr) {
    delete _impl_.footer_;
  }
  _impl_.footer_ = nullptr;
}
inline const ::proto::system_info::SystemInfoFooter& SystemInfo::_internal_footer() const {
  const ::proto::system_info::SystemInfoFooter* p = _impl_.footer_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::system_info::SystemInfoFooter&>(
      ::proto::system_info::_SystemInfoFooter_default_instance_);
}
inline const ::proto::system_info::SystemInfoFooter& SystemInfo::footer() const {
  // @@protoc_insertion_point(field_get:proto.system_info.SystemInfo.footer)
  return _internal_footer();
}
inline void SystemInfo::unsafe_arena_set_allocated_footer(
    ::proto::system_info::SystemInfoFooter* footer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_);
  }
  _impl_.footer_ = footer;
  if (footer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.system_info.SystemInfo.footer)
}
inline ::proto::system_info::SystemInfoFooter* SystemInfo::release_footer() {
  
  ::proto::system_info::SystemInfoFooter* temp = _impl_.footer_;
  _impl_.footer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::system_info::SystemInfoFooter* SystemInfo::unsafe_arena_release_footer() {
  // @@protoc_insertion_point(field_release:proto.system_info.SystemInfo.footer)
  
  ::proto::system_info::SystemInfoFooter* temp = _impl_.footer_;
  _impl_.footer_ = nullptr;
  return temp;
}
inline ::proto::system_info::SystemInfoFooter* SystemInfo::_internal_mutable_footer() {
  
  if (_impl_.footer_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::system_info::SystemInfoFooter>(GetArenaForAllocation());
    _impl_.footer_ = p;
  }
  return _impl_.footer_;
}
inline ::proto::system_info::SystemInfoFooter* SystemInfo::mutable_footer() {
  ::proto::system_info::SystemInfoFooter* _msg = _internal_mutable_footer();
  // @@protoc_insertion_point(field_mutable:proto.system_info.SystemInfo.footer)
  return _msg;
}
inline void SystemInfo::set_allocated_footer(::proto::system_info::SystemInfoFooter* footer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.footer_;
  }
  if (footer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(footer);
    if (message_arena != submessage_arena) {
      footer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.footer_ = footer;
  // @@protoc_insertion_point(field_set_allocated:proto.system_info.SystemInfo.footer)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace system_info
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::system_info::Monitors_Monitor_InputSignalType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::PowerOptions_Battery_State> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::PowerOptions_PowerSource> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::PowerOptions_BatteryStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::Drivers_Driver_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::Drivers_Driver_StartupType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::Services_Service_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::Services_Service_StartupType> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::EventLogs_Event_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::EventLogs_Event_Level> : ::std::true_type {};
template <> struct is_proto_enum< ::proto::system_info::Licenses_License_Field_Type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_system_5finfo_2eproto
